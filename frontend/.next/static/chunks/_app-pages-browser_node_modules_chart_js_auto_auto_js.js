"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_chart_js_auto_auto_js"],{

/***/ "(app-pages-browser)/./node_modules/@kurkle/color/dist/color.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/@kurkle/color/dist/color.esm.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Color: function() { return /* binding */ Color; },\n/* harmony export */   b2n: function() { return /* binding */ b2n; },\n/* harmony export */   b2p: function() { return /* binding */ b2p; },\n/* harmony export */   \"default\": function() { return /* binding */ index_esm; },\n/* harmony export */   hexParse: function() { return /* binding */ hexParse; },\n/* harmony export */   hexString: function() { return /* binding */ hexString; },\n/* harmony export */   hsl2rgb: function() { return /* binding */ hsl2rgb; },\n/* harmony export */   hslString: function() { return /* binding */ hslString; },\n/* harmony export */   hsv2rgb: function() { return /* binding */ hsv2rgb; },\n/* harmony export */   hueParse: function() { return /* binding */ hueParse; },\n/* harmony export */   hwb2rgb: function() { return /* binding */ hwb2rgb; },\n/* harmony export */   lim: function() { return /* binding */ lim; },\n/* harmony export */   n2b: function() { return /* binding */ n2b; },\n/* harmony export */   n2p: function() { return /* binding */ n2p; },\n/* harmony export */   nameParse: function() { return /* binding */ nameParse; },\n/* harmony export */   p2b: function() { return /* binding */ p2b; },\n/* harmony export */   rgb2hsl: function() { return /* binding */ rgb2hsl; },\n/* harmony export */   rgbParse: function() { return /* binding */ rgbParse; },\n/* harmony export */   rgbString: function() { return /* binding */ rgbString; },\n/* harmony export */   rotate: function() { return /* binding */ rotate; },\n/* harmony export */   round: function() { return /* binding */ round; }\n/* harmony export */ });\n/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names$1 = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aa3Vya2xlL2NvbG9yL2Rpc3QvY29sb3IuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLLFNBQVM7QUFDM0MsYUFBYSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLFNBQVM7QUFDakQsZUFBZSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWtNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aa3Vya2xlL2NvbG9yL2Rpc3QvY29sb3IuZXNtLmpzP2IzZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjMuNFxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDI0IEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiByb3VuZCh2KSB7XG4gIHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpLCAwLCAxMDApO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuICByZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuICBsZXQgaTtcbiAgaWYgKHcgKyBiID4gMSkge1xuICAgIGkgPSAxIC8gKHcgKyBiKTtcbiAgICB3ICo9IGk7XG4gICAgYiAqPSBpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByZ2JbaV0gKj0gMSAtIHcgLSBiO1xuICAgIHJnYltpXSArPSB3O1xuICB9XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpIHtcbiAgaWYgKHIgPT09IG1heCkge1xuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xuICB9XG4gIGlmIChnID09PSBtYXgpIHtcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xuICB9XG4gIHJldHVybiAociAtIGcpIC8gZCArIDQ7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcbiAgY29uc3QgcmFuZ2UgPSAyNTU7XG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcbiAgY29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuICBjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgbGV0IGgsIHMsIGQ7XG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIGggPSBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpO1xuICAgIGggPSBoICogNjAgKyAwLjU7XG4gIH1cbiAgcmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGEpXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcbiAgICAgIDogZihhLCBiLCBjKVxuICApLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG4gIHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcbiAgcmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuICByZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcbiAgcmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuICBjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCB2O1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bNV0gIT09IHYpIHtcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuICB9XG4gIGNvbnN0IGggPSBodWUoK21bMl0pO1xuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuICBjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuICBpZiAobVsxXSA9PT0gJ2h3YicpIHtcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG4gICAgdiA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICB2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcjogdlswXSxcbiAgICBnOiB2WzFdLFxuICAgIGI6IHZbMl0sXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuICB2YXIgaCA9IHJnYjJoc2wodik7XG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG4gIGggPSBoc2wycmdiKGgpO1xuICB2LnIgPSBoWzBdO1xuICB2LmcgPSBoWzFdO1xuICB2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcbiAgaWYgKCF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuICBjb25zdCBoID0gYVswXTtcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcbiAgY29uc3QgbCA9IG4ycChhWzJdKTtcbiAgcmV0dXJuIHYuYSA8IDI1NVxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG4gICAgOiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuXG5jb25zdCBtYXAgPSB7XG5cdHg6ICdkYXJrJyxcblx0WjogJ2xpZ2h0Jyxcblx0WTogJ3JlJyxcblx0WDogJ2JsdScsXG5cdFc6ICdncicsXG5cdFY6ICdtZWRpdW0nLFxuXHRVOiAnc2xhdGUnLFxuXHRBOiAnZWUnLFxuXHRUOiAnb2wnLFxuXHRTOiAnb3InLFxuXHRCOiAncmEnLFxuXHRDOiAnbGF0ZWcnLFxuXHREOiAnaWdodHMnLFxuXHRSOiAnaW4nLFxuXHRROiAndHVycXVvaXMnLFxuXHRFOiAnaGknLFxuXHRQOiAncm8nLFxuXHRPOiAnYWwnLFxuXHROOiAnbGUnLFxuXHRNOiAnZGUnLFxuXHRMOiAneWVsbG8nLFxuXHRGOiAnZW4nLFxuXHRLOiAnY2gnLFxuXHRHOiAnYXJrcycsXG5cdEg6ICdlYScsXG5cdEk6ICdpZ2h0ZycsXG5cdEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuXHRPaWNlWGU6ICdmMGY4ZmYnLFxuXHRhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG5cdGFxdWE6ICdmZmZmJyxcblx0YXF1YW1hclJlOiAnN2ZmZmQ0Jyxcblx0YXp1WTogJ2YwZmZmZicsXG5cdGJlaWdlOiAnZjVmNWRjJyxcblx0YmlzcXVlOiAnZmZlNGM0Jyxcblx0YmxhY2s6ICcwJyxcblx0YmxhbktlZE9tb25kOiAnZmZlYmNkJyxcblx0WGU6ICdmZicsXG5cdFhldmlUZXQ6ICc4YTJiZTInLFxuXHRiUHduOiAnYTUyYTJhJyxcblx0YnVybHl3b29kOiAnZGViODg3Jyxcblx0Y2FNdFhlOiAnNWY5ZWEwJyxcblx0S2FydFl1c2U6ICc3ZmZmMDAnLFxuXHRLb2NUYXRlOiAnZDI2OTFlJyxcblx0Y1NPOiAnZmY3ZjUwJyxcblx0Y1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuXHRjU25zaWxrOiAnZmZmOGRjJyxcblx0Y3JpbXNvbjogJ2RjMTQzYycsXG5cdGN5YW46ICdmZmZmJyxcblx0eFhlOiAnOGInLFxuXHR4Y3lhbjogJzhiOGInLFxuXHR4Z1RNblBkOiAnYjg4NjBiJyxcblx0eFdheTogJ2E5YTlhOScsXG5cdHhnWUY6ICc2NDAwJyxcblx0eGdZeTogJ2E5YTlhOScsXG5cdHhraGFraTogJ2JkYjc2YicsXG5cdHhtYWdGdGE6ICc4YjAwOGInLFxuXHR4VGl2ZWdZRjogJzU1NmIyZicsXG5cdHhTYW5nZTogJ2ZmOGMwMCcsXG5cdHhTY0VkOiAnOTkzMmNjJyxcblx0eFlkOiAnOGIwMDAwJyxcblx0eHNPbW9uOiAnZTk5NjdhJyxcblx0eHNIZ1lGOiAnOGZiYzhmJyxcblx0eFVYZTogJzQ4M2Q4YicsXG5cdHhVV2F5OiAnMmY0ZjRmJyxcblx0eFVnWXk6ICcyZjRmNGYnLFxuXHR4UWU6ICdjZWQxJyxcblx0eHZpVGV0OiAnOTQwMGQzJyxcblx0ZEFwcFJrOiAnZmYxNDkzJyxcblx0ZEFwc2t5WGU6ICdiZmZmJyxcblx0ZGltV2F5OiAnNjk2OTY5Jyxcblx0ZGltZ1l5OiAnNjk2OTY5Jyxcblx0ZG9kZ2VyWGU6ICcxZTkwZmYnLFxuXHRmaVlicmljazogJ2IyMjIyMicsXG5cdGZsU093RXRlOiAnZmZmYWYwJyxcblx0Zm9Zc3RXQW46ICcyMjhiMjInLFxuXHRmdUtzaWE6ICdmZjAwZmYnLFxuXHRnYVJzYlNvOiAnZGNkY2RjJyxcblx0Z2hvc3R3RXRlOiAnZjhmOGZmJyxcblx0Z1RkOiAnZmZkNzAwJyxcblx0Z1RNblBkOiAnZGFhNTIwJyxcblx0V2F5OiAnODA4MDgwJyxcblx0Z1lGOiAnODAwMCcsXG5cdGdZRkx3OiAnYWRmZjJmJyxcblx0Z1l5OiAnODA4MDgwJyxcblx0aG9uZXlNdzogJ2YwZmZmMCcsXG5cdGhvdHBSazogJ2ZmNjliNCcsXG5cdFJkaWFuWWQ6ICdjZDVjNWMnLFxuXHRSZGlnbzogJzRiMDA4MicsXG5cdGl2U3k6ICdmZmZmZjAnLFxuXHRraGFraTogJ2YwZTY4YycsXG5cdGxhdkZNcjogJ2U2ZTZmYScsXG5cdGxhdkZNclhzaDogJ2ZmZjBmNScsXG5cdGxhd25nWUY6ICc3Y2ZjMDAnLFxuXHRObW9uY0VmZm9uOiAnZmZmYWNkJyxcblx0WlhlOiAnYWRkOGU2Jyxcblx0WmNTTzogJ2YwODA4MCcsXG5cdFpjeWFuOiAnZTBmZmZmJyxcblx0WmdUTW5QZEx3OiAnZmFmYWQyJyxcblx0WldheTogJ2QzZDNkMycsXG5cdFpnWUY6ICc5MGVlOTAnLFxuXHRaZ1l5OiAnZDNkM2QzJyxcblx0WnBSazogJ2ZmYjZjMScsXG5cdFpzT21vbjogJ2ZmYTA3YScsXG5cdFpzSGdZRjogJzIwYjJhYScsXG5cdFpza3lYZTogJzg3Y2VmYScsXG5cdFpVV2F5OiAnNzc4ODk5Jyxcblx0WlVnWXk6ICc3Nzg4OTknLFxuXHRac3RBbFhlOiAnYjBjNGRlJyxcblx0Wkx3OiAnZmZmZmUwJyxcblx0bGltZTogJ2ZmMDAnLFxuXHRsaW1lZ1lGOiAnMzJjZDMyJyxcblx0bFJGOiAnZmFmMGU2Jyxcblx0bWFnRnRhOiAnZmYwMGZmJyxcblx0bWFQb246ICc4MDAwMDAnLFxuXHRWYXF1YW1hclJlOiAnNjZjZGFhJyxcblx0VlhlOiAnY2QnLFxuXHRWU2NFZDogJ2JhNTVkMycsXG5cdFZwdXJwTjogJzkzNzBkYicsXG5cdFZzSGdZRjogJzNjYjM3MScsXG5cdFZVWGU6ICc3YjY4ZWUnLFxuXHRWc3ByUmdnWUY6ICdmYTlhJyxcblx0VlFlOiAnNDhkMWNjJyxcblx0VnZpVGV0WWQ6ICdjNzE1ODUnLFxuXHRtaWRuaWdodFhlOiAnMTkxOTcwJyxcblx0bVJ0Y1lhbTogJ2Y1ZmZmYScsXG5cdG1pc3R5UHNlOiAnZmZlNGUxJyxcblx0bW9jY2FzUjogJ2ZmZTRiNScsXG5cdG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuXHRuYXZ5OiAnODAnLFxuXHRUZGxhY2U6ICdmZGY1ZTYnLFxuXHRUaXZlOiAnODA4MDAwJyxcblx0VGl2ZWRCYjogJzZiOGUyMycsXG5cdFNhbmdlOiAnZmZhNTAwJyxcblx0U2FuZ2VZZDogJ2ZmNDUwMCcsXG5cdFNjRWQ6ICdkYTcwZDYnLFxuXHRwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuXHRwT2VnWUY6ICc5OGZiOTgnLFxuXHRwT2VRZTogJ2FmZWVlZScsXG5cdHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuXHRwYXBheWF3RXA6ICdmZmVmZDUnLFxuXHRwSEtwdWZmOiAnZmZkYWI5Jyxcblx0cGVydTogJ2NkODUzZicsXG5cdHBSazogJ2ZmYzBjYicsXG5cdHBsdW06ICdkZGEwZGQnLFxuXHRwb3dNclhlOiAnYjBlMGU2Jyxcblx0cHVycE46ICc4MDAwODAnLFxuXHRZYmVjY2FwdXJwTjogJzY2MzM5OScsXG5cdFlkOiAnZmYwMDAwJyxcblx0UHN5YnJvd246ICdiYzhmOGYnLFxuXHRQeU9YZTogJzQxNjllMScsXG5cdHNhZGROYlB3bjogJzhiNDUxMycsXG5cdHNPbW9uOiAnZmE4MDcyJyxcblx0c2FuZHliUHduOiAnZjRhNDYwJyxcblx0c0hnWUY6ICcyZThiNTcnLFxuXHRzSHNoZWxsOiAnZmZmNWVlJyxcblx0c2lGbmE6ICdhMDUyMmQnLFxuXHRzaWx2ZXI6ICdjMGMwYzAnLFxuXHRza3lYZTogJzg3Y2VlYicsXG5cdFVYZTogJzZhNWFjZCcsXG5cdFVXYXk6ICc3MDgwOTAnLFxuXHRVZ1l5OiAnNzA4MDkwJyxcblx0c25vdzogJ2ZmZmFmYScsXG5cdHNwclJnZ1lGOiAnZmY3ZicsXG5cdHN0QWxYZTogJzQ2ODJiNCcsXG5cdHRhbjogJ2QyYjQ4YycsXG5cdHRlTzogJzgwODAnLFxuXHR0RXN0TjogJ2Q4YmZkOCcsXG5cdHRvbWF0bzogJ2ZmNjM0NycsXG5cdFFlOiAnNDBlMGQwJyxcblx0dmlUZXQ6ICdlZTgyZWUnLFxuXHRKSHQ6ICdmNWRlYjMnLFxuXHR3RXRlOiAnZmZmZmZmJyxcblx0d0V0ZXNtb2tlOiAnZjVmNWY1Jyxcblx0THc6ICdmZmZmMDAnLFxuXHRMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cblxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs3XSAhPT0gcikge1xuICAgIGNvbnN0IHYgPSArbVs3XTtcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xuICB9XG4gIHIgPSArbVsxXTtcbiAgZyA9ICttWzNdO1xuICBiID0gK21bNV07XG4gIHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IGxpbShyLCAwLCAyNTUpKTtcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xuICBiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBsaW0oYiwgMCwgMjU1KSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHYgJiYgKFxuICAgIHYuYSA8IDI1NVxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG4gICAgICA6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG4gICk7XG59XG5cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5leHBvcnQgeyBDb2xvciwgYjJuLCBiMnAsIGluZGV4X2VzbSBhcyBkZWZhdWx0LCBoZXhQYXJzZSwgaGV4U3RyaW5nLCBoc2wycmdiLCBoc2xTdHJpbmcsIGhzdjJyZ2IsIGh1ZVBhcnNlLCBod2IycmdiLCBsaW0sIG4yYiwgbjJwLCBuYW1lUGFyc2UsIHAyYiwgcmdiMmhzbCwgcmdiUGFyc2UsIHJnYlN0cmluZywgcm90YXRlLCByb3VuZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@kurkle/color/dist/color.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/chart.js/auto/auto.js":
/*!********************************************!*\
  !*** ./node_modules/chart.js/auto/auto.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Animation; },\n/* harmony export */   Animations: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Animations; },\n/* harmony export */   ArcElement: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.ArcElement; },\n/* harmony export */   BarController: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BarController; },\n/* harmony export */   BarElement: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BarElement; },\n/* harmony export */   BasePlatform: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BasePlatform; },\n/* harmony export */   BasicPlatform: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BasicPlatform; },\n/* harmony export */   BubbleController: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BubbleController; },\n/* harmony export */   CategoryScale: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.CategoryScale; },\n/* harmony export */   Chart: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart; },\n/* harmony export */   Colors: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Colors; },\n/* harmony export */   DatasetController: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.DatasetController; },\n/* harmony export */   Decimation: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Decimation; },\n/* harmony export */   DomPlatform: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.DomPlatform; },\n/* harmony export */   DoughnutController: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.DoughnutController; },\n/* harmony export */   Element: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Element; },\n/* harmony export */   Filler: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Filler; },\n/* harmony export */   Interaction: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Interaction; },\n/* harmony export */   Legend: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Legend; },\n/* harmony export */   LineController: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LineController; },\n/* harmony export */   LineElement: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LineElement; },\n/* harmony export */   LinearScale: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LinearScale; },\n/* harmony export */   LogarithmicScale: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LogarithmicScale; },\n/* harmony export */   PieController: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.PieController; },\n/* harmony export */   PointElement: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.PointElement; },\n/* harmony export */   PolarAreaController: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.PolarAreaController; },\n/* harmony export */   RadarController: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.RadarController; },\n/* harmony export */   RadialLinearScale: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.RadialLinearScale; },\n/* harmony export */   Scale: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Scale; },\n/* harmony export */   ScatterController: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.ScatterController; },\n/* harmony export */   SubTitle: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.SubTitle; },\n/* harmony export */   Ticks: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Ticks; },\n/* harmony export */   TimeScale: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.TimeScale; },\n/* harmony export */   TimeSeriesScale: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.TimeSeriesScale; },\n/* harmony export */   Title: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Title; },\n/* harmony export */   Tooltip: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Tooltip; },\n/* harmony export */   _adapters: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__._adapters; },\n/* harmony export */   _detectPlatform: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__._detectPlatform; },\n/* harmony export */   animator: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.animator; },\n/* harmony export */   controllers: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.controllers; },\n/* harmony export */   defaults: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.defaults; },\n/* harmony export */   elements: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.elements; },\n/* harmony export */   layouts: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.layouts; },\n/* harmony export */   plugins: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.plugins; },\n/* harmony export */   registerables: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables; },\n/* harmony export */   registry: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.registry; },\n/* harmony export */   scales: function() { return /* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.scales; }\n/* harmony export */ });\n/* harmony import */ var _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/chart.js */ \"(app-pages-browser)/./node_modules/chart.js/dist/chart.js\");\n\n_dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart.register(..._dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9hdXRvL2F1dG8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBRXREQSxpREFBS0EsQ0FBQ0UsUUFBUSxJQUFJRCx5REFBYUE7QUFFRTtBQUNqQywrREFBZUQsaURBQUtBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2F1dG8vYXV0by5qcz8xMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q2hhcnQsIHJlZ2lzdGVyYWJsZXN9IGZyb20gJy4uL2Rpc3QvY2hhcnQuanMnO1xuXG5DaGFydC5yZWdpc3RlciguLi5yZWdpc3RlcmFibGVzKTtcblxuZXhwb3J0ICogZnJvbSAnLi4vZGlzdC9jaGFydC5qcyc7XG5leHBvcnQgZGVmYXVsdCBDaGFydDtcbiJdLCJuYW1lcyI6WyJDaGFydCIsInJlZ2lzdGVyYWJsZXMiLCJyZWdpc3RlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/chart.js/auto/auto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/chart.js/dist/chart.js":
/*!*********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: function() { return /* binding */ Animation; },\n/* harmony export */   Animations: function() { return /* binding */ Animations; },\n/* harmony export */   ArcElement: function() { return /* binding */ ArcElement; },\n/* harmony export */   BarController: function() { return /* binding */ BarController; },\n/* harmony export */   BarElement: function() { return /* binding */ BarElement; },\n/* harmony export */   BasePlatform: function() { return /* binding */ BasePlatform; },\n/* harmony export */   BasicPlatform: function() { return /* binding */ BasicPlatform; },\n/* harmony export */   BubbleController: function() { return /* binding */ BubbleController; },\n/* harmony export */   CategoryScale: function() { return /* binding */ CategoryScale; },\n/* harmony export */   Chart: function() { return /* binding */ Chart; },\n/* harmony export */   Colors: function() { return /* binding */ plugin_colors; },\n/* harmony export */   DatasetController: function() { return /* binding */ DatasetController; },\n/* harmony export */   Decimation: function() { return /* binding */ plugin_decimation; },\n/* harmony export */   DomPlatform: function() { return /* binding */ DomPlatform; },\n/* harmony export */   DoughnutController: function() { return /* binding */ DoughnutController; },\n/* harmony export */   Element: function() { return /* binding */ Element; },\n/* harmony export */   Filler: function() { return /* binding */ index; },\n/* harmony export */   Interaction: function() { return /* binding */ Interaction; },\n/* harmony export */   Legend: function() { return /* binding */ plugin_legend; },\n/* harmony export */   LineController: function() { return /* binding */ LineController; },\n/* harmony export */   LineElement: function() { return /* binding */ LineElement; },\n/* harmony export */   LinearScale: function() { return /* binding */ LinearScale; },\n/* harmony export */   LogarithmicScale: function() { return /* binding */ LogarithmicScale; },\n/* harmony export */   PieController: function() { return /* binding */ PieController; },\n/* harmony export */   PointElement: function() { return /* binding */ PointElement; },\n/* harmony export */   PolarAreaController: function() { return /* binding */ PolarAreaController; },\n/* harmony export */   RadarController: function() { return /* binding */ RadarController; },\n/* harmony export */   RadialLinearScale: function() { return /* binding */ RadialLinearScale; },\n/* harmony export */   Scale: function() { return /* binding */ Scale; },\n/* harmony export */   ScatterController: function() { return /* binding */ ScatterController; },\n/* harmony export */   SubTitle: function() { return /* binding */ plugin_subtitle; },\n/* harmony export */   Ticks: function() { return /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM; },\n/* harmony export */   TimeScale: function() { return /* binding */ TimeScale; },\n/* harmony export */   TimeSeriesScale: function() { return /* binding */ TimeSeriesScale; },\n/* harmony export */   Title: function() { return /* binding */ plugin_title; },\n/* harmony export */   Tooltip: function() { return /* binding */ plugin_tooltip; },\n/* harmony export */   _adapters: function() { return /* binding */ adapters; },\n/* harmony export */   _detectPlatform: function() { return /* binding */ _detectPlatform; },\n/* harmony export */   animator: function() { return /* binding */ animator; },\n/* harmony export */   controllers: function() { return /* binding */ controllers; },\n/* harmony export */   defaults: function() { return /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d; },\n/* harmony export */   elements: function() { return /* binding */ elements; },\n/* harmony export */   layouts: function() { return /* binding */ layouts; },\n/* harmony export */   plugins: function() { return /* binding */ plugins; },\n/* harmony export */   registerables: function() { return /* binding */ registerables; },\n/* harmony export */   registry: function() { return /* binding */ registry; },\n/* harmony export */   scales: function() { return /* binding */ scales; }\n/* harmony export */ });\n/* harmony import */ var _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.dataset.js */ \"(app-pages-browser)/./node_modules/chart.js/dist/chunks/helpers.dataset.js\");\n/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */ \n\nclass Animator {\n    _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n    _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.r.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n    _update() {\n        let date = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Date.now();\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, \"progress\");\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, \"complete\");\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n    _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n    listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n    add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n    has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n    start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n    stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), \"complete\");\n    }\n    remove(chart) {\n        return this._charts.delete(chart);\n    }\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n}\nvar animator = /* #__PURE__ */ new Animator();\nconst transparent = \"transparent\";\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n    color (from, to, factor) {\n        const c0 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c)(from || transparent);\n        const c1 = c0.valid && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c)(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? \"res\" : \"rej\";\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e[cfg.easing] || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n}\nclass Animations {\n    configure(config) {\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(config)) {\n            return;\n        }\n        const animationOptions = Object.keys(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.animation);\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n    _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{});\n        }\n        return animations;\n    }\n    _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === \"$\") {\n                continue;\n            }\n            if (prop === \"options\") {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n    update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex) {\n    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    const keys = stack.keys;\n    const singleMode = options.mode === \"single\";\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    let found = false;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            found = true;\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(otherValue) && (singleMode || value === 0 || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) === (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(otherValue))) {\n            value += otherValue;\n        }\n    }\n    if (!found && !options.all) {\n        return 0;\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data, meta) {\n    const { iScale, vScale } = meta;\n    const iAxisKey = iScale.axis === \"x\" ? \"x\" : \"y\";\n    const vAxisKey = vScale.axis === \"x\" ? \"x\" : \"y\";\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            [iAxisKey]: key,\n            [vAxisKey]: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return \"\".concat(indexScale.id, \".\").concat(valueScale.id, \".\").concat(meta.stack || meta.type);\n}\nfunction getUserBounds(scale) {\n    const { min, max, minDefined, maxDefined } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart, _cachedMeta: meta } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale, vScale, index: datasetIndex } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index, [vAxis]: value } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n        const visualValues = stack._visualValues || (stack._visualValues = {});\n        visualValues[datasetIndex] = value;\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: \"default\",\n        type: \"dataset\"\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: \"default\",\n        type: \"data\"\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n            delete stacks[axis]._visualValues[datasetIndex];\n        }\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === \"reset\" || mode === \"none\";\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n        if (this.options.fill && !this.chart.isPluginEnabled(\"filler\")) {\n            console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === \"x\" ? x : axis === \"r\" ? r : y;\n        const xid = meta.xAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.xAxisID, getFirstScaleId(chart, \"x\"));\n        const yid = meta.yAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.yAxisID, getFirstScaleId(chart, \"y\"));\n        const rid = meta.rAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.rAxisID, getFirstScaleId(chart, \"r\"));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n    getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n    _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update(\"reset\");\n    }\n    _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u)(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n    _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            const meta = this._cachedMeta;\n            this._data = convertObjectDataToArray(data, meta);\n        } else if (_data !== data) {\n            if (_data) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u)(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.l)(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n            meta._stacked = isStacked(meta.vScale, meta);\n        }\n    }\n    configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n    parse(start, count) {\n        const { _cachedMeta: meta, _data: data } = this;\n        const { iScale, _stacked } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const { xAxisKey = \"x\", yAxisKey = \"y\" } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, xAxisKey), index),\n                y: yScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n    getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n    getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n    applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]._visualValues\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n    getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin, max: otherMax } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n    getMaxOverflow() {\n        return false;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? \"\" + iScale.getLabelForValue(parsed[iScale.axis]) : \"\",\n            value: vScale ? \"\" + vScale.getLabelForValue(parsed[vScale.axis]) : \"\"\n        };\n    }\n    _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || \"default\");\n        meta._clip = toClip((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n    update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n    getStyle(index, active) {\n        const mode = active ? \"active\" : \"default\";\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n    getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n    resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n    resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n    _resolveElementOptions(elementType) {\n        let mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"default\", index = arguments.length > 2 ? arguments[2] : void 0;\n        const active = mode === \"active\";\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + \"-\" + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            \"\".concat(elementType, \"Hover\"),\n            \"hover\",\n            elementType,\n            \"\"\n        ] : [\n            elementType,\n            \"\"\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.elements[elementType]);\n        const context = ()=>this.getContext(index, active, mode);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n    _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = \"animation-\".concat(transition);\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n    includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n    _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n    updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n    updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n    _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, \"active\", false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, \"active\", true);\n    }\n    _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, \"active\", false);\n        }\n    }\n    _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, \"active\", true);\n        }\n    }\n    _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n    _insertElements(start, count) {\n        let resetNewElements = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, \"reset\");\n        }\n    }\n    updateElements(element, start, count, mode) {}\n    _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n    _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            \"_insertElements\",\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            \"_removeElements\",\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            \"_removeElements\",\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                \"_removeElements\",\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                \"_insertElements\",\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            \"_insertElements\",\n            0,\n            arguments.length\n        ]);\n    }\n    constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n        this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.datasetElementType = new.target.datasetElementType;\n        this.dataElementType = new.target.dataElementType;\n        this.initialize();\n    }\n}\nDatasetController.defaults = {};\nDatasetController.datasetElementType = null;\nDatasetController.dataElementType = null;\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = \"left\";\n        end = \"right\";\n    } else {\n        reverse = properties.base < properties.y;\n        start = \"bottom\";\n        end = \"top\";\n    }\n    if (reverse) {\n        top = \"end\";\n        bottom = \"start\";\n    } else {\n        top = \"start\";\n        bottom = \"end\";\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start, end, reverse, top, bottom } = borderProps(properties);\n    if (edge === \"middle\" && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === \"start\" ? start : v === \"end\" ? end : v;\n}\nfunction setInflateAmount(properties, param, ratio) {\n    let { inflateAmount } = param;\n    properties.inflateAmount = inflateAmount === \"auto\" ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseObjectData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const { xAxisKey = \"x\", yAxisKey = \"y\" } = this._parsing;\n        const iAxisKey = iScale.axis === \"x\" ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === \"x\" ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, iAxisKey), i);\n            parsed.push(parseValue((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n    getMaxOverflow() {\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale, vScale } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? \"[\" + custom.start + \", \" + custom.end + \"]\" : \"\" + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: \"\" + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { index, _cachedMeta: { vScale } } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? \"active\" : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n    _getStacks(last, dataIndex) {\n        const { iScale } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n        const iScaleValue = currentParsed && currentParsed[iScale.axis];\n        const skipNull = (meta)=>{\n            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);\n            const val = parsed && parsed[meta.vScale.axis];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n    _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n    _getAxisCount() {\n        return this._getAxis().length;\n    }\n    getFirstScaleIdForIndexAxis() {\n        const scales = this.chart.scales;\n        const indexScaleId = this.chart.options.indexAxis;\n        return Object.keys(scales).filter((key)=>scales[key].axis === indexScaleId).shift();\n    }\n    _getAxis() {\n        const axis = {};\n        const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();\n        for (const dataset of this.chart.data.datasets){\n            axis[(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.options.indexAxis === \"x\" ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;\n        }\n        return Object.keys(axis);\n    }\n    _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n    _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n    _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) !== (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n            if (_stacked && !floating) {\n                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n            }\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n    _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.maxBarThickness, Infinity);\n        let center, size;\n        const axisCount = this._getAxisCount();\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === \"flex\" ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount) : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);\n            const axisID = this.chart.options.indexAxis === \"x\" ? this.getDataset().xAxisID : this.getDataset().yAxisID;\n            const axisNumber = this._getAxis().indexOf((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(axisID, this.getFirstScaleIdForIndexAxis()));\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\nBarController.id = \"bar\";\nBarController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"bar\",\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"base\",\n                \"width\",\n                \"height\"\n            ]\n        }\n    }\n};\nBarController.overrides = {\n    scales: {\n        _index_: {\n            type: \"category\",\n            offset: true,\n            grid: {\n                offset: true\n            }\n        },\n        _value_: {\n            type: \"linear\",\n            beginAtZero: true\n        }\n    }\n};\nclass BubbleController extends DatasetController {\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale, yScale } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: labels[index] || \"\",\n            value: \"(\" + x + \", \" + y + (r ? \", \" + r : \"\") + \")\"\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n    resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== \"active\") {\n            values.radius = 0;\n        }\n        values.radius += (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(parsed && parsed._custom, radius);\n        return values;\n    }\n}\nBubbleController.id = \"bubble\";\nBubbleController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"borderWidth\",\n                \"radius\"\n            ]\n        }\n    }\n};\nBubbleController.overrides = {\n    scales: {\n        x: {\n            type: \"linear\"\n        },\n        y: {\n            type: \"linear\"\n        }\n    }\n};\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        const minX = calcMin(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P, startX, endX);\n        const minY = calcMin(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    linkScales() {}\n    parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                const { key = \"value\" } = this._parsing;\n                getter = (i)=>+(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n    _getRotation() {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.rotation - 90);\n    }\n    _getCircumference() {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.circumference);\n    }\n    _getRotationExtents() {\n        let min = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T;\n        let max = -_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n    update(mode) {\n        const chart = this.chart;\n        const { chartArea } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.m)(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference, rotation } = this._getRotationExtents();\n        const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.n)(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === \"reset\";\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? \"active\" : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || \"\",\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== \"inner\") {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n    _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n    _getRingWeight(datasetIndex) {\n        return Math.max((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n    _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n}\nDoughnutController.id = \"doughnut\";\nDoughnutController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"arc\",\n    animation: {\n        animateRotate: true,\n        animateScale: false\n    },\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"circumference\",\n                \"endAngle\",\n                \"innerRadius\",\n                \"outerRadius\",\n                \"startAngle\",\n                \"x\",\n                \"y\",\n                \"offset\",\n                \"borderWidth\",\n                \"spacing\"\n            ]\n        }\n    },\n    cutout: \"50%\",\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\",\n    spacing: 0,\n    indexAxis: \"r\"\n};\nDoughnutController.descriptors = {\n    _scriptable: (name)=>name !== \"spacing\",\n    _indexable: (name)=>name !== \"spacing\" && !name.startsWith(\"borderDash\") && !name.startsWith(\"hoverBorderDash\")\n};\nDoughnutController.overrides = {\n    aspectRatio: 1,\n    plugins: {\n        legend: {\n            labels: {\n                generateLabels (chart) {\n                    const data = chart.data;\n                    const { labels: { pointStyle, textAlign, color, useBorderRadius, borderRadius } } = chart.legend.options;\n                    if (data.labels.length && data.datasets.length) {\n                        return data.labels.map((label, i)=>{\n                            const meta = chart.getDatasetMeta(0);\n                            const style = meta.controller.getStyle(i);\n                            return {\n                                text: label,\n                                fillStyle: style.backgroundColor,\n                                fontColor: color,\n                                hidden: !chart.getDataVisibility(i),\n                                lineDash: style.borderDash,\n                                lineDashOffset: style.borderDashOffset,\n                                lineJoin: style.borderJoinStyle,\n                                lineWidth: style.borderWidth,\n                                strokeStyle: style.borderColor,\n                                textAlign: textAlign,\n                                pointStyle: pointStyle,\n                                borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                                index: i\n                            };\n                        });\n                    }\n                    return [];\n                }\n            },\n            onClick (e, legendItem, legend) {\n                legend.chart.toggleDataVisibility(legendItem.index);\n                legend.chart.update();\n            }\n        }\n    }\n};\nclass LineController extends DatasetController {\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line, data: points = [], _dataset } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n        const end = start + count;\n        const pointsCount = points.length;\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = 0; i < pointsCount; ++i){\n            const point = points[i];\n            const properties = directUpdate ? point : {};\n            if (i < start || i >= end) {\n                properties.skip = true;\n                continue;\n            }\n            const parsed = this.getParsed(i);\n            const nullData = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\nLineController.id = \"line\";\nLineController.defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    showLine: true,\n    spanGaps: false\n};\nLineController.overrides = {\n    scales: {\n        _index_: {\n            type: \"category\"\n        },\n        _value_: {\n            type: \"linear\"\n        }\n    }\n};\nclass PolarAreaController extends DatasetController {\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || \"\",\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n    _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === \"reset\";\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? \"active\" : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n    _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n}\nPolarAreaController.id = \"polarArea\";\nPolarAreaController.defaults = {\n    dataElementType: \"arc\",\n    animation: {\n        animateRotate: true,\n        animateScale: true\n    },\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"startAngle\",\n                \"endAngle\",\n                \"innerRadius\",\n                \"outerRadius\"\n            ]\n        }\n    },\n    indexAxis: \"r\",\n    startAngle: 0\n};\nPolarAreaController.overrides = {\n    aspectRatio: 1,\n    plugins: {\n        legend: {\n            labels: {\n                generateLabels (chart) {\n                    const data = chart.data;\n                    if (data.labels.length && data.datasets.length) {\n                        const { labels: { pointStyle, color } } = chart.legend.options;\n                        return data.labels.map((label, i)=>{\n                            const meta = chart.getDatasetMeta(0);\n                            const style = meta.controller.getStyle(i);\n                            return {\n                                text: label,\n                                fillStyle: style.backgroundColor,\n                                strokeStyle: style.borderColor,\n                                fontColor: color,\n                                lineWidth: style.borderWidth,\n                                pointStyle: pointStyle,\n                                hidden: !chart.getDataVisibility(i),\n                                index: i\n                            };\n                        });\n                    }\n                    return [];\n                }\n            },\n            onClick (e, legendItem, legend) {\n                legend.chart.toggleDataVisibility(legendItem.index);\n                legend.chart.update();\n            }\n        }\n    },\n    scales: {\n        r: {\n            type: \"radialLinear\",\n            angleLines: {\n                display: false\n            },\n            beginAtZero: true,\n            grid: {\n                circular: true\n            },\n            pointLabels: {\n                display: false\n            },\n            startAngle: 0\n        }\n    }\n};\nclass PieController extends DoughnutController {\n}\nPieController.id = \"pie\";\nPieController.defaults = {\n    cutout: 0,\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\"\n};\nclass RadarController extends DatasetController {\n    getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: \"\" + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== \"resize\") {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === \"reset\";\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\nRadarController.id = \"radar\";\nRadarController.defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    indexAxis: \"r\",\n    showLine: true,\n    elements: {\n        line: {\n            fill: \"start\"\n        }\n    }\n};\nRadarController.overrides = {\n    aspectRatio: 1,\n    scales: {\n        r: {\n            type: \"radialLinear\"\n        }\n    }\n};\nclass ScatterController extends DatasetController {\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale, yScale } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        return {\n            label: labels[index] || \"\",\n            value: \"(\" + x + \", \" + y + \")\"\n        };\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = [] } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            if (!this.datasetElementType) {\n                this.addElements();\n            }\n            const { dataset: line, _dataset } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        } else if (this.datasetElementType) {\n            delete meta.dataset;\n            this.datasetElementType = false;\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = this.chart.registry.getElement(\"line\");\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\nScatterController.id = \"scatter\";\nScatterController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    showLine: false,\n    fill: false\n};\nScatterController.overrides = {\n    interaction: {\n        mode: \"point\"\n    },\n    scales: {\n        x: {\n            type: \"linear\"\n        },\n        y: {\n            type: \"linear\"\n        }\n    }\n};\nvar controllers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BarController: BarController,\n    BubbleController: BubbleController,\n    DoughnutController: DoughnutController,\n    LineController: LineController,\n    PieController: PieController,\n    PolarAreaController: PolarAreaController,\n    RadarController: RadarController,\n    ScatterController: ScatterController\n});\n/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */ function abstract() {\n    throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */ class DateAdapterBase {\n    /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */ static override(members) {\n        Object.assign(DateAdapterBase.prototype, members);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    init() {}\n    formats() {\n        return abstract();\n    }\n    parse() {\n        return abstract();\n    }\n    format() {\n        return abstract();\n    }\n    add() {\n        return abstract();\n    }\n    diff() {\n        return abstract();\n    }\n    startOf() {\n        return abstract();\n    }\n    endOf() {\n        return abstract();\n    }\n    constructor(options){\n        this.options = options || {};\n    }\n}\nvar adapters = {\n    _date: DateAdapterBase\n};\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller, data, _sorted } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n    if (iScale && axis === iScale.axis && axis !== \"r\" && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.A : _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B;\n        if (!intersect) {\n            const result = lookupMethod(data, axis, value);\n            if (spanGaps) {\n                const { vScale } = controller._cachedMeta;\n                const { _parsed } = metaset;\n                const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point)=>!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(point[vScale.axis]));\n                result.lo -= Math.max(0, distanceToDefinedLo);\n                const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point)=>!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(point[vScale.axis]));\n                result.hi += Math.max(0, distanceToDefinedHi);\n            }\n            return result;\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === \"function\" && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index, data } = metasets[i];\n        const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\nfunction getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf(\"x\") !== -1;\n    const useY = axis.indexOf(\"y\") !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle, endAngle } = element.getProps([\n            \"startAngle\",\n            \"endAngle\"\n        ], useFinalPosition);\n        const { angle } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D)(element, {\n            x: position.x,\n            y: position.y\n        });\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === \"r\" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === \"x\" ? \"inXRange\" : \"inYRange\";\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\nvar Interaction = {\n    evaluateInteractionItems,\n    modes: {\n        index (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || \"x\";\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n        dataset (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n        point (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n        nearest (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n        x (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            return getAxisItems(chart, position, \"x\", options.intersect, useFinalPosition);\n        },\n        y (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            return getAxisItems(chart, position, \"y\", options.intersect, useFinalPosition);\n        }\n    }\n};\nconst STATIC_POSITIONS = [\n    \"left\",\n    \"top\",\n    \"right\",\n    \"bottom\"\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos, options: { stack, stackWeight = 1 } } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack, pos, stackWeight } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth, hBoxMaxHeight } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, \"left\"), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, \"right\"));\n    const top = sortByWeight(filterByPosition(layoutBoxes, \"top\"), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, \"bottom\"));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, \"x\");\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, \"y\");\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, \"chartArea\"),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos, box } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, \"left\", \"right\"));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, \"top\", \"bottom\"));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos(\"top\");\n    chartArea.x += updatePos(\"left\");\n    updatePos(\"right\");\n    updatePos(\"bottom\");\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        \"left\",\n        \"right\"\n    ]) : marginForPositions([\n        \"top\",\n        \"bottom\"\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same, other } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x, y } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\nvar layouts = {\n    addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || \"top\";\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n    removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n    configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n    update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === \"function\") {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\nclass BasePlatform {\n    acquireContext(canvas, aspectRatio) {}\n    releaseContext(context) {\n        return false;\n    }\n    addEventListener(chart, type, listener) {}\n    removeEventListener(chart, type, listener) {}\n    getDevicePixelRatio() {\n        return 1;\n    }\n    getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n    isAttached(canvas) {\n        return true;\n    }\n    updateConfig(config) {}\n}\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext(\"2d\") || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\nconst EXPANDO_KEY = \"$chartjs\";\nconst EVENT_TYPES = {\n    touchstart: \"mousedown\",\n    touchmove: \"mousemove\",\n    touchend: \"mouseup\",\n    pointerenter: \"mouseenter\",\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointerleave: \"mouseout\",\n    pointerout: \"mouseout\"\n};\nconst isNullOrEmpty = (value)=>value === null || value === \"\";\nfunction initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute(\"height\");\n    const renderWidth = canvas.getAttribute(\"width\");\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || \"block\";\n    style.boxSizing = style.boxSizing || \"border-box\";\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J)(canvas, \"width\");\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === \"\") {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J)(canvas, \"height\");\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.K ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    if (node) {\n        node.addEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction removeListener(chart, type, listener) {\n    if (chart && chart.canvas) {\n        chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x, y } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener(\"resize\", onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener(\"resize\", onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I)(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L)((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === \"resize\") {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L)((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart);\n    addListener(canvas, type, proxy);\n    return proxy;\n}\nclass DomPlatform extends BasePlatform {\n    acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext(\"2d\");\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n    releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            \"height\",\n            \"width\"\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n    addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n    removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n    getMaximumSize(canvas, width, height, aspectRatio) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.G)(canvas, width, height, aspectRatio);\n    }\n    isAttached(canvas) {\n        const container = canvas && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I)(canvas);\n        return !!(container && container.isConnected);\n    }\n}\nfunction _detectPlatform(canvas) {\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M)() || typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\nclass Element {\n    tooltipPosition(useFinalPosition) {\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.x) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            // let's not create an object, if not needed\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n    constructor(){\n        this.active = false;\n    }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const determinedMaxTicks = determineMaxTicks(scale);\n    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.N)(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorStart, 0);\n    const end = Math.min((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\nfunction getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\nconst reverseAlign = (align)=>align === \"left\" ? \"right\" : align === \"right\" ? \"left\" : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === \"top\" || edge === \"left\" ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);\nfunction sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\nfunction garbageCollect(caches, length) {\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\nfunction getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.font, fallback);\n    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n    const lines = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        scale,\n        type: \"scale\"\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        tick,\n        index,\n        type: \"tick\"\n    });\n}\nfunction titleAlign(align, position, reverse) {\n    let ret = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(align);\n    if (reverse && position !== \"right\" || !reverse && position === \"right\") {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top, left, bottom, right, chart } = scale;\n    const { chartArea, scales } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, left, right);\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === \"center\") {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === \"center\") {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, bottom, top);\n        rotation = position === \"left\" ? -_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H : _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n    parse(raw, index) {\n        return raw;\n    }\n    getUserBounds() {\n        let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;\n        _userMin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMin, _suggestedMin),\n            max: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMax, _suggestedMax),\n            minDefined: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMin),\n            maxDefined: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMax)\n        };\n    }\n    getMinMax(canStack) {\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(min, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(max, min)),\n            max: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(max, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(min, max))\n        };\n    }\n    getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n    getTicks() {\n        return this.ticks;\n    }\n    getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n    getLabelItems() {\n        let chartArea = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.chart.chartArea;\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        return items;\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n    update(maxWidth, maxHeight, margins) {\n        const { beginAtZero, grace, ticks: tickOpts } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.R)(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === \"auto\")) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n    configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks(\"beforeDataLimits\");\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks(\"afterDataLimits\");\n    }\n    beforeBuildTicks() {\n        this._callHooks(\"beforeBuildTicks\");\n    }\n    buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks(\"afterBuildTicks\");\n    }\n    beforeTickToLabelConversion() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n    generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(Math.min(Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first, last, widest, highest } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align, padding }, position } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== \"top\" && this.axis === \"x\";\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === \"start\") {\n                paddingRight = last.width;\n            } else if (align === \"end\") {\n                paddingLeft = first.width;\n            } else if (align !== \"inner\") {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === \"start\") {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === \"end\") {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n    _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterFit, [\n            this\n        ]);\n    }\n    isHorizontal() {\n        const { axis, position } = this.options;\n        return position === \"top\" || position === \"bottom\" || axis === \"x\";\n    }\n    isFullSize() {\n        return this.options.fullSize;\n    }\n    _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n    _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n        }\n        return labelSizes;\n    }\n    _computeLabelSizes(ticks, length, maxTicksLimit) {\n        const { ctx, _longestTextCache: caches } = this;\n        const widths = [];\n        const heights = [];\n        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; i += increment){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(label) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                width = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel = label[j];\n                    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(nestedLabel) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(nestedLabel)) {\n                        width = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n    getLabelForValue(value) {\n        return value;\n    }\n    getPixelForValue(value, index) {\n        return NaN;\n    }\n    getValueForPixel(pixel) {}\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.W)(this._alignToPixels ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(this.chart, pixel, 0) : pixel);\n    }\n    getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n    getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n    getBaseValue() {\n        const { min, max } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n    getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n    _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n    _isVisible() {\n        const display = this.options.display;\n        if (display !== \"auto\") {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n    _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid, position, border } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = borderOpts.display ? borderOpts.width : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === \"top\") {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === \"bottom\") {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === \"left\") {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === \"right\") {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === \"x\") {\n            if (position === \"center\") {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === \"y\") {\n            if (position === \"center\") {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const context = this.getContext(i);\n            const optsAtIndex = grid.setContext(context);\n            const optsAtIndexBorder = border.setContext(context);\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndexBorder.dash || [];\n            const borderDashOffset = optsAtIndexBorder.dashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n    _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position, ticks: optionTicks } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align, crossAlign, padding, mirror } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = \"middle\";\n        if (position === \"top\") {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === \"bottom\") {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === \"left\") {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === \"right\") {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === \"x\") {\n            if (position === \"center\") {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === \"y\") {\n            if (position === \"center\") {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === \"y\") {\n            if (align === \"start\") {\n                textBaseline = \"top\";\n            } else if (align === \"end\") {\n                textBaseline = \"bottom\";\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === \"inner\") {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? \"right\" : \"left\";\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? \"left\" : \"right\";\n                    } else {\n                        tickTextAlign = \"center\";\n                    }\n                }\n                if (position === \"top\") {\n                    if (crossAlign === \"near\" || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === \"center\") {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === \"near\" || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === \"center\") {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n                    x += lineHeight / 2 * Math.sin(rotation);\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = textOffset - labelPadding.top;\n                let left = 0 - labelPadding.left;\n                switch(textBaseline){\n                    case \"middle\":\n                        top -= height / 2;\n                        break;\n                    case \"bottom\":\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case \"center\":\n                        left -= width / 2;\n                        break;\n                    case \"right\":\n                        left -= width;\n                        break;\n                    case \"inner\":\n                        if (i === ilen - 1) {\n                            left -= width;\n                        } else if (i > 0) {\n                            left -= width / 2;\n                        }\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                label,\n                font,\n                textOffset,\n                options: {\n                    rotation,\n                    color,\n                    strokeColor,\n                    strokeWidth,\n                    textAlign: tickTextAlign,\n                    textBaseline,\n                    translation: [\n                        x,\n                        y\n                    ],\n                    backdrop\n                }\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position, ticks } = this.options;\n        const rotation = -(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        if (rotation) {\n            return position === \"top\" ? \"left\" : \"right\";\n        }\n        let align = \"center\";\n        if (ticks.align === \"start\") {\n            align = \"left\";\n        } else if (ticks.align === \"end\") {\n            align = \"right\";\n        } else if (ticks.align === \"inner\") {\n            align = \"inner\";\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position, ticks: { crossAlign, mirror, padding } } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === \"left\") {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"left\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x += widest / 2;\n                } else {\n                    textAlign = \"right\";\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"right\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x -= widest / 2;\n                } else {\n                    textAlign = \"left\";\n                    x = this.left;\n                }\n            }\n        } else if (position === \"right\") {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"right\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x -= widest / 2;\n                } else {\n                    textAlign = \"left\";\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"left\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x += widest / 2;\n                } else {\n                    textAlign = \"right\";\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = \"right\";\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n    _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === \"left\" || position === \"right\") {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === \"top\" || position === \"bottom\") {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n    drawBackground() {\n        const { ctx, options: { backgroundColor }, left, top, width, height } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n    drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n    drawBorder() {\n        const { chart, ctx, options: { border, grid } } = this;\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = border.display ? borderOpts.width : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.width;\n        ctx.strokeStyle = borderOpts.color;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n    drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, area);\n        }\n        const items = this.getLabelItems(chartArea);\n        for (const item of items){\n            const renderTextOptions = item.options;\n            const tickFont = item.font;\n            const label = item.label;\n            const y = item.textOffset;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, label, 0, y, tickFont, renderTextOptions);\n        }\n        if (area) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n        }\n    }\n    drawTitle() {\n        const { ctx, options: { position, title, reverse } } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(title.font);\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === \"bottom\" || position === \"center\" || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            offset += padding.bottom;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: \"middle\",\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n    _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(opts.grid && opts.grid.z, -1);\n        const bz = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(opts.border && opts.border.z, 0);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: bz,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n    getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + \"AxisID\";\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);\n    }\n    _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n    constructor(cfg){\n        super();\n        this.id = cfg.id;\n        this.type = cfg.type;\n        this.options = undefined;\n        this.ctx = cfg.ctx;\n        this.chart = cfg.chart;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n        this.maxWidth = undefined;\n        this.maxHeight = undefined;\n        this.paddingTop = undefined;\n        this.paddingBottom = undefined;\n        this.paddingLeft = undefined;\n        this.paddingRight = undefined;\n        this.axis = undefined;\n        this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n        this.ticks = [];\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n        this._startPixel = undefined;\n        this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n}\nclass TypedRegistry {\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n    register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + \".\" + id;\n        if (!id) {\n            throw new Error(\"class does not have id: \" + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n    get(id) {\n        return this.items[id];\n    }\n    unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d[scope]) {\n            delete _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d[scope][id];\n            if (this.override) {\n                delete _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[id];\n            }\n        }\n    }\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a4)(Object.create(null), [\n        parentScope ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.get(parentScope) : {},\n        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.get(scope),\n        item.defaults\n    ]);\n    _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split(\".\");\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join(\".\");\n        const parts = routes[property].split(\".\");\n        const targetName = parts.pop();\n        const targetScope = parts.join(\".\");\n        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return \"id\" in proto && \"defaults\" in proto;\n}\nclass Registry {\n    add() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"register\", args);\n    }\n    remove() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"unregister\", args);\n    }\n    addControllers() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"register\", args, this.controllers);\n    }\n    addElements() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"register\", args, this.elements);\n    }\n    addPlugins() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"register\", args, this.plugins);\n    }\n    addScales() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"register\", args, this.scales);\n    }\n    getController(id) {\n        return this._get(id, this.controllers, \"controller\");\n    }\n    getElement(id) {\n        return this._get(id, this.elements, \"element\");\n    }\n    getPlugin(id) {\n        return this._get(id, this.plugins, \"plugin\");\n    }\n    getScale(id) {\n        return this._get(id, this.scales, \"scale\");\n    }\n    removeControllers() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"unregister\", args, this.controllers);\n    }\n    removeElements() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"unregister\", args, this.elements);\n    }\n    removePlugins() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"unregister\", args, this.plugins);\n    }\n    removeScales() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"unregister\", args, this.scales);\n    }\n    _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n    _exec(method, registry, component) {\n        const camelMethod = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a5)(method);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(component[\"before\" + camelMethod], [], component);\n        registry[method](component);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(component[\"after\" + camelMethod], [], component);\n    }\n    _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n    _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + \".\");\n        }\n        return item;\n    }\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, \"datasets\", true);\n        this.elements = new TypedRegistry(Element, \"elements\");\n        this.plugins = new TypedRegistry(Object, \"plugins\");\n        this.scales = new TypedRegistry(Scale, \"scales\");\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n}\nvar registry = /* #__PURE__ */ new Registry();\nclass PluginService {\n    notify(chart, hook, args, filter) {\n        if (hook === \"beforeInit\") {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, \"install\");\n        }\n        if (this._init === undefined) {\n            return;\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === \"afterDestroy\") {\n            this._notify(descriptors, chart, \"stop\");\n            this._notify(this._init, chart, \"uninstall\");\n            this._init = undefined;\n        }\n        return result;\n    }\n    _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n    _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n    _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, \"stop\");\n        this._notify(diff(descriptors, previousDescriptors), chart, \"start\");\n    }\n    constructor(){\n        this._init = undefined;\n    }\n}\nfunction allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, param, options, all) {\n    let { plugins, localIds } = param;\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, param, opts, context) {\n    let { plugin, local } = param;\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        \"\"\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || \"x\";\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === \"_index_\") {\n        axis = indexAxis;\n    } else if (id === \"_value_\") {\n        axis = indexAxis === \"x\" ? \"y\" : \"x\";\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? \"_index_\" : \"_value_\";\n}\nfunction idMatchesAxis(id) {\n    if (id === \"x\" || id === \"y\" || id === \"r\") {\n        return id;\n    }\n}\nfunction axisFromPosition(position) {\n    if (position === \"top\" || position === \"bottom\") {\n        return \"x\";\n    }\n    if (position === \"left\" || position === \"right\") {\n        return \"y\";\n    }\n}\nfunction determineAxis(id) {\n    for(var _len = arguments.length, scaleOptions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        scaleOptions[_key - 1] = arguments[_key];\n    }\n    if (idMatchesAxis(id)) {\n        return id;\n    }\n    for (const opts of scaleOptions){\n        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n        if (axis) {\n            return axis;\n        }\n    }\n    throw new Error(\"Cannot determine type of '\".concat(id, \"' axis. Please provide 'axis' or 'position' option.\"));\n}\nfunction getAxisFromDataset(id, axis, dataset) {\n    if (dataset[axis + \"AxisID\"] === id) {\n        return {\n            axis\n        };\n    }\n}\nfunction retrieveAxisFromDatasets(id, config) {\n    if (config.data && config.data.datasets) {\n        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);\n        if (boundDs.length) {\n            return getAxisFromDataset(id, \"x\", boundDs[0]) || getAxisFromDataset(id, \"y\", boundDs[0]);\n        }\n    }\n    return {};\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(scaleConf)) {\n            return console.error(\"Invalid scale configuration for scale: \".concat(id));\n        }\n        if (scaleConf._proxy) {\n            return console.warn(\"Ignoring resolver passed as options for scale: \".concat(id));\n        }\n        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[scaleConf.type]);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        scales[id] = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + \"AxisID\"] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(scale, [\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[scale.type],\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n    datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    \"datasets.\".concat(datasetType),\n                    \"\"\n                ]\n            ]);\n    }\n    datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(\"\".concat(datasetType, \".transition.\").concat(transition), ()=>[\n                [\n                    \"datasets.\".concat(datasetType, \".transitions.\").concat(transition),\n                    \"transitions.\".concat(transition)\n                ],\n                [\n                    \"datasets.\".concat(datasetType),\n                    \"\"\n                ]\n            ]);\n    }\n    datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(\"\".concat(datasetType, \"-\").concat(elementType), ()=>[\n                [\n                    \"datasets.\".concat(datasetType, \".elements.\").concat(elementType),\n                    \"datasets.\".concat(datasetType),\n                    \"elements.\".concat(elementType),\n                    \"\"\n                ]\n            ]);\n    }\n    pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(\"\".concat(type, \"-plugin-\").concat(id), ()=>[\n                [\n                    \"plugins.\".concat(id),\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n    _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n    getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options, type } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a6, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n    chartOptionScopes() {\n        const { options, type } = this;\n        return [\n            options,\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {},\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {},\n            {\n                type\n            },\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d,\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a6\n        ];\n    }\n    resolveNamedOptions(scopes, names, context) {\n        let prefixes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [\n            \"\"\n        ];\n        const result = {\n            $shared: true\n        };\n        const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8)(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n    createResolver(scopes, context) {\n        let prefixes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [\n            \"\"\n        ], descriptorDefaults = arguments.length > 3 ? arguments[3] : void 0;\n        const { resolver } = getResolver(this._resolverCache, scopes, prefixes);\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(context) ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8)(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a9)(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes(\"hover\"))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value) && Object.getOwnPropertyNames(value).some((key)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(value[key]));\nfunction needContext(proxy, names) {\n    const { isScriptable, isIndexable } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aa)(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(value) || hasFunction(value)) || indexable && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(value)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar version = \"4.5.1\";\nconst KNOWN_POSITIONS = [\n    \"top\",\n    \"bottom\",\n    \"left\",\n    \"right\",\n    \"chartArea\"\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === \"top\" || position === \"bottom\" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === \"x\";\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins(\"afterRender\");\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\nfunction getCanvas(item) {\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M)() && typeof item === \"string\") {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === \"mouseout\") {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nclass Chart {\n    static register() {\n        for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){\n            items[_key] = arguments[_key];\n        }\n        registry.add(...items);\n        invalidatePlugins();\n    }\n    static unregister() {\n        for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){\n            items[_key] = arguments[_key];\n        }\n        registry.remove(...items);\n        invalidatePlugins();\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    get registry() {\n        return registry;\n    }\n    _initialize() {\n        this.notifyPlugins(\"beforeInit\");\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins(\"afterInit\");\n        return this;\n    }\n    clear() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af)(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n    resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? \"resize\" : \"attach\";\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins(\"resize\", {\n            size: newSize\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n    buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === \"r\";\n                const isHorizontal = axis === \"x\";\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? \"chartArea\" : isHorizontal ? \"bottom\" : \"left\",\n                    dtype: isRadial ? \"radialLinear\" : isHorizontal ? \"category\" : \"linear\"\n                };\n            }));\n        }\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n    _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level(\"order\", \"index\"));\n    }\n    _removeUnreferencedMetasets() {\n        const { _metasets: metasets, data: { datasets } } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = \"\" + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType, dataElementType } = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type];\n                Object.assign(ControllerClass, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n    _resetElements() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n    reset() {\n        this._resetElements();\n        this.notifyPlugins(\"reset\");\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins(\"beforeUpdate\", {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins(\"beforeElementsUpdate\");\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins(\"afterUpdate\", {\n            mode\n        });\n        this._layers.sort(compare2Level(\"z\", \"_idx\"));\n        const { _active, _lastEvent } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n    _updateScales() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n    _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n    _updateHiddenIndices() {\n        const { _hiddenIndices } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method, start, count } of changes){\n            const move = method === \"_removeElements\" ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n    _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + \",\" + c.splice(1).join(\",\")));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag)(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(\",\")).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n    _updateLayout(minPadding) {\n        if (this.notifyPlugins(\"beforeLayout\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.boxes, (box)=>{\n            if (noArea && box.position === \"chartArea\") {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins(\"afterLayout\");\n    }\n    _updateDatasets(mode) {\n        if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins(\"afterDatasetsUpdate\", {\n            mode\n        });\n    }\n    _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins(\"beforeDatasetUpdate\", args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins(\"afterDatasetUpdate\", args);\n    }\n    render() {\n        if (this.notifyPlugins(\"beforeRender\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width, height } = this._resizeBeforeDraw;\n            this._resizeBeforeDraw = null;\n            this._resize(width, height);\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins(\"beforeDraw\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins(\"afterDraw\");\n    }\n    _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n    _drawDatasets() {\n        if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins(\"afterDatasetsDraw\");\n    }\n    _drawDataset(meta) {\n        const ctx = this.ctx;\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        const clip = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah)(this, meta);\n        if (this.notifyPlugins(\"beforeDatasetDraw\", args) === false) {\n            return;\n        }\n        if (clip) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, clip);\n        }\n        meta.controller.draw();\n        if (clip) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins(\"afterDatasetDraw\", args);\n    }\n    isPointInArea(point) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === \"function\") {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(null, {\n            chart: this,\n            type: \"chart\"\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === \"boolean\" ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n    _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? \"show\" : \"hide\";\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n    _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins(\"beforeDestroy\");\n        const { canvas, ctx } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af)(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        delete instances[this.id];\n        this.notifyPlugins(\"afterDestroy\");\n    }\n    toBase64Image() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return this.canvas.toDataURL(...args);\n    }\n    bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n    bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.options.events, (type)=>_add(type, listener));\n    }\n    bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove(\"attach\", attached);\n            this.attached = true;\n            this.resize();\n            _add(\"resize\", listener);\n            _add(\"detach\", detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove(\"resize\", listener);\n            this._stop();\n            this._resize(0, 0);\n            _add(\"attach\", attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n    unbindEvents() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? \"set\" : \"remove\";\n        let meta, item, i, ilen;\n        if (mode === \"dataset\") {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller[\"_\" + prefix + \"DatasetHoverStyle\"]();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + \"HoverStyle\"](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map((param)=>{\n            let { datasetIndex, index } = param;\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error(\"No dataset found at index \" + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n    notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n    isPluginEnabled(pluginId) {\n        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;\n    }\n    _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n    _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins(\"beforeEvent\", args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins(\"afterEvent\", args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n    _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [], options } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aj)(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === \"mouseout\") {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error(\"Canvas is already in use. Chart with ID '\" + existingChart.id + \"'\" + \" must be destroyed before the canvas with ID '\" + existingChart.canvas.id + \"' can be reused.\");\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ac)();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n        this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ad)((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, \"complete\", onAnimationsComplete);\n        animator.listen(this, \"progress\", onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n}\nChart.defaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d;\nChart.instances = instances;\nChart.overrides = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3;\nChart.registry = registry;\nChart.version = version;\nChart.getChart = getChart;\nfunction invalidatePlugins() {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(Chart.instances, (chart)=>chart._plugins.invalidate());\n}\nfunction clipSelf(ctx, element, endAngle) {\n    const { startAngle, x, y, outerRadius, innerRadius, options } = element;\n    const { borderWidth, borderJoinStyle } = options;\n    const outerAngleClip = Math.min(borderWidth / outerRadius, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);\n    if (innerRadius > 0) {\n        const innerAngleClip = Math.min(borderWidth / innerRadius, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));\n        ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);\n    } else {\n        const clipWidth = Math.min(borderWidth / 2, outerRadius * (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));\n        if (borderJoinStyle === \"round\") {\n            ctx.arc(x, y, clipWidth, endAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2, startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2, true);\n        } else if (borderJoinStyle === \"bevel\") {\n            const r = 2 * clipWidth * clipWidth;\n            const endX = -r * Math.cos(endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + x;\n            const endY = -r * Math.sin(endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + y;\n            const startX = r * Math.cos(startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + x;\n            const startY = r * Math.sin(startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + y;\n            ctx.lineTo(endX, endY);\n            ctx.lineTo(startX, startY);\n        }\n    }\n    ctx.closePath();\n    ctx.moveTo(0, 0);\n    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.clip(\"evenodd\");\n}\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    // Draw an inner border by clipping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.am)(value, [\n        \"outerStart\",\n        \"outerEnd\",\n        \"innerStart\",\n        \"innerEnd\"\n    ]);\n}\n/**\n * Parse border radius from the provided options\n */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    // Outer limits are complicated. We want to compute the available angular distance at\n    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n    //\n    // If the borderRadius is large, that value can become negative.\n    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n    // we know that the thickness term will dominate and compute the limits at that point\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(o.innerStart, 0, innerLimit),\n        innerEnd: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(o.innerEnd, 0, innerLimit)\n    };\n}\n/**\n * Convert (r, ) to (x, y)\n */ function rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */ function pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        // When spacing is present, it is the same for all items\n        // So we adjust the start and end angle of the arc such that\n        // the distance is the same as it would be without the spacing\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        // The first arc segments from point 1 to point a to point 2\n        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n        // The corner segment from point 2 to point 3\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        // The line from point 3 to point 4\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        // The corner segment from point 4 to point 5\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, innerEndAdjustedAngle + Math.PI);\n        }\n        // The inner arc from point 5 to point b to point 6\n        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\n        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\n        // The corner segment from point 6 to point 7\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        // The line from point 7 to point 8\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        // The corner segment from point 8 to point 1\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles, startAngle, circumference } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawBorder(ctx, element, offset, spacing, circular) {\n    const { fullCircles, startAngle, circumference, options } = element;\n    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset, borderRadius } = options;\n    const inner = options.borderAlign === \"inner\";\n    if (!borderWidth) {\n        return;\n    }\n    ctx.setLineDash(borderDash || []);\n    ctx.lineDashOffset = borderDashOffset;\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || \"round\";\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || \"bevel\";\n    }\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.stroke();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n        }\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    if (options.selfJoin && endAngle - startAngle >= _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P && borderRadius === 0 && borderJoinStyle !== \"miter\") {\n        clipSelf(ctx, element, endAngle);\n    }\n    if (!fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        ctx.stroke();\n    }\n}\nclass ArcElement extends Element {\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        const { angle, distance } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D)(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([\n            \"startAngle\",\n            \"endAngle\",\n            \"innerRadius\",\n            \"outerRadius\",\n            \"circumference\"\n        ], useFinalPosition);\n        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n        const _circumference = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(circumference, endAngle - startAngle);\n        const nonZeroBetween = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle) && startAngle !== endAngle;\n        const betweenAngles = _circumference >= _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || nonZeroBetween;\n        const withinRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([\n            \"x\",\n            \"y\",\n            \"startAngle\",\n            \"endAngle\",\n            \"innerRadius\",\n            \"outerRadius\"\n        ], useFinalPosition);\n        const { offset, spacing } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options, circumference } = this;\n        const offset = (options.offset || 0) / 4;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === \"inner\" ? 0.33 : 0;\n        this.fullCircles = circumference > _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T ? Math.floor(circumference / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        const halfAngle = (this.startAngle + this.endAngle) / 2;\n        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n        const fix = 1 - Math.sin(Math.min(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P, circumference || 0));\n        const radiusOffset = offset * fix;\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, circular);\n        ctx.restore();\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n}\nArcElement.id = \"arc\";\nArcElement.defaults = {\n    borderAlign: \"center\",\n    borderColor: \"#fff\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true,\n    selfJoin: false\n};\nArcElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\"\n};\nArcElement.descriptors = {\n    _scriptable: true,\n    _indexable: (name)=>name !== \"borderDash\"\n};\nfunction setStyle(ctx, options) {\n    let style = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : options;\n    ctx.lineCap = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.at;\n    }\n    if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.au;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment) {\n    let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const count = points.length;\n    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;\n    const { start: segmentStart, end: segmentEnd } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\nfunction pathSegment(ctx, line, segment, params) {\n    const { points, options } = line;\n    const { count, start, loop, ilen } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move = true, reverse } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count, start, ilen } = pathVars(points, segment, params);\n    const { move = true, reverse } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\nfunction _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== \"monotone\" && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aq;\n    }\n    if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ar;\n    }\n    return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.as;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments, options } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === \"function\";\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === \"monotone\") && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.an)(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ao)(this, this.options.segment));\n    }\n    first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n    last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n    interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ap)(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start, end } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n    path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n    draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n}\nLineElement.id = \"line\";\nLineElement.defaults = {\n    borderCapStyle: \"butt\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: \"default\",\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0\n};\nLineElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nLineElement.descriptors = {\n    _scriptable: true,\n    _indexable: (name)=>name !== \"borderDash\" && name !== \"fill\"\n};\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, \"x\", useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, \"y\", useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        // @ts-expect-error Fallbacks should never be hit in practice\n        return options.radius + options.hitRadius;\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n}\nPointElement.id = \"point\";\n/**\n   * @type {any}\n   */ PointElement.defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: \"circle\",\n    radius: 3,\n    rotation: 0\n};\n/**\n   * @type {any}\n   */ PointElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x, y, base, width, height } = bar.getProps([\n        \"x\",\n        \"y\",\n        \"base\",\n        \"width\",\n        \"height\"\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius } = bar.getProps([\n        \"enableBorderRadius\"\n    ]);\n    const value = bar.options.borderRadius;\n    const o = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, bounds.left, bounds.right)) && (skipY || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount) {\n    let refRect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    draw(ctx) {\n        const { inflateAmount, options: { borderColor, backgroundColor } } = this;\n        const { inner, outer } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill(\"evenodd\");\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, base, horizontal } = this.getProps([\n            \"x\",\n            \"y\",\n            \"base\",\n            \"horizontal\"\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === \"x\" ? this.width / 2 : this.height / 2;\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n}\nBarElement.id = \"bar\";\nBarElement.defaults = {\n    borderSkipped: \"start\",\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: \"auto\",\n    pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nvar elements = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ArcElement: ArcElement,\n    BarElement: BarElement,\n    LineElement: LineElement,\n    PointElement: PointElement\n});\nconst BORDER_COLORS = [\n    \"rgb(54, 162, 235)\",\n    \"rgb(255, 99, 132)\",\n    \"rgb(255, 159, 64)\",\n    \"rgb(255, 205, 86)\",\n    \"rgb(75, 192, 192)\",\n    \"rgb(153, 102, 255)\",\n    \"rgb(201, 203, 207)\" // grey\n];\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map(_c = (color)=>color.replace(\"rgb(\", \"rgba(\").replace(\")\", \", 0.5)\"));\n_c1 = BACKGROUND_COLORS;\nfunction getBorderColor(i) {\n    return BORDER_COLORS[i % BORDER_COLORS.length];\n}\nfunction getBackgroundColor(i) {\n    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\nfunction colorizeDefaultDataset(dataset, i) {\n    dataset.borderColor = getBorderColor(i);\n    dataset.backgroundColor = getBackgroundColor(i);\n    return ++i;\n}\nfunction colorizeDoughnutDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));\n    return i;\n}\nfunction colorizePolarAreaDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));\n    return i;\n}\nfunction getColorizer(chart) {\n    let i = 0;\n    return (dataset, datasetIndex)=>{\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\n        if (controller instanceof DoughnutController) {\n            i = colorizeDoughnutDataset(dataset, i);\n        } else if (controller instanceof PolarAreaController) {\n            i = colorizePolarAreaDataset(dataset, i);\n        } else if (controller) {\n            i = colorizeDefaultDataset(dataset, i);\n        }\n    };\n}\nfunction containsColorsDefinitions(descriptors) {\n    let k;\n    for(k in descriptors){\n        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction containsColorsDefinition(descriptor) {\n    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\nfunction containsDefaultColorsDefenitions() {\n    return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.borderColor !== \"rgba(0,0,0,0.1)\" || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.backgroundColor !== \"rgba(0,0,0,0.1)\";\n}\nvar plugin_colors = {\n    id: \"colors\",\n    defaults: {\n        enabled: true,\n        forceOverride: false\n    },\n    beforeLayout (chart, _args, options) {\n        if (!options.enabled) {\n            return;\n        }\n        const { data: { datasets }, options: chartOptions } = chart.config;\n        const { elements } = chartOptions;\n        const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();\n        if (!options.forceOverride && containsColorDefenition) {\n            return;\n        }\n        const colorizer = getColorizer(chart);\n        datasets.forEach(colorizer);\n    }\n};\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n    const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx, y: pointAy } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(minIndex) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, \"data\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale } = meta;\n    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n    if (minDefined) {\n        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: \"decimation\",\n    defaults: {\n        algorithm: \"min-max\",\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data, indexAxis } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === \"y\") {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== \"linear\" && xAxis.type !== \"time\") {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, \"data\", {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case \"lttb\":\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case \"min-max\":\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(\"Unsupported decimation algorithm '\".concat(options.algorithm, \"'\"));\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start, end } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ap)(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.az)(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, \"start\", Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, \"end\", Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === \"angle\") {\n        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(start);\n        end = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x = null, y = null } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach((param)=>{\n        let { start, end } = param;\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\nfunction _decodeFill(line, index, count) {\n    const fill = parseFillOption(line);\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        \"origin\",\n        \"start\",\n        \"end\",\n        \"stack\",\n        \"shape\"\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === \"-\" || firstCh === \"+\") {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\nfunction _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === \"start\") {\n        pixel = scale.bottom;\n    } else if (fill === \"end\") {\n        pixel = scale.top;\n    } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === \"start\") {\n        value = startValue;\n    } else if (fill === \"end\") {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\nfunction parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return \"origin\";\n    }\n    return fill;\n}\nfunction _buildStackLine(source) {\n    const { scale, index, line } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\nfunction getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas(\"line\");\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first, last, point } = findPoint(line, sourcePoint, \"x\");\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\nclass simpleArc {\n    pathSegment(ctx, bounds, opts) {\n        const { x, y, radius } = this;\n        bounds = bounds || {\n            start: 0,\n            end: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x, y, radius } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n}\nfunction _getTarget(source) {\n    const { chart, fill, line } = source;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === \"stack\") {\n        return _buildStackLine(source);\n    }\n    if (fill === \"shape\") {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale = {}, fill } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale, fill } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { chart, index, line, scale, axis } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above = color, below = color } = fillOption || {};\n    const meta = chart.getDatasetMeta(index);\n    const clip = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah)(chart, meta);\n    if (target && line.points.length) {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis,\n            clip\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line, target, above, below, area, scale, clip } = cfg;\n    const property = line._loop ? \"angle\" : cfg.axis;\n    ctx.save();\n    let fillColor = below;\n    if (below !== above) {\n        if (property === \"x\") {\n            clipVertical(ctx, target, area.top);\n            fill(ctx, {\n                line,\n                target,\n                color: above,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipVertical(ctx, target, area.bottom);\n        } else if (property === \"y\") {\n            clipHorizontal(ctx, target, area.left);\n            fill(ctx, {\n                line,\n                target,\n                color: below,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipHorizontal(ctx, target, area.right);\n            fillColor = above;\n        }\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: fillColor,\n        scale,\n        property,\n        clip\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments, points } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start, end } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction clipHorizontal(ctx, target, clipX) {\n    const { segments, points } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start, end } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(clipX, firstPoint.y);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(clipX, lastPoint.y);\n        }\n    }\n    ctx.lineTo(clipX, target.first().y);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line, target, property, color, scale, clip } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src, target: tgt, start, end } of segments){\n        const { style: { backgroundColor = color } = {} } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? \"evenodd\" : \"nonzero\");\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, clip, bounds) {\n    const chartArea = scale.chart.chartArea;\n    const { property, start, end } = bounds || {};\n    if (property === \"x\" || property === \"y\") {\n        let left, top, right, bottom;\n        if (property === \"x\") {\n            left = start;\n            top = chartArea.top;\n            right = end;\n            bottom = chartArea.bottom;\n        } else {\n            left = chartArea.left;\n            top = start;\n            right = chartArea.right;\n            bottom = end;\n        }\n        ctx.beginPath();\n        if (clip) {\n            left = Math.max(left, clip.left);\n            right = Math.min(right, clip.right);\n            top = Math.max(top, clip.top);\n            bottom = Math.min(bottom, clip.bottom);\n        }\n        ctx.rect(left, top, right - left, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\nvar index = {\n    id: \"filler\",\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === \"beforeDraw\";\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== \"beforeDatasetsDraw\") {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== \"beforeDatasetDraw\") {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: \"beforeDatasetDraw\"\n    }\n};\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options, ctx } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx, maxWidth, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = \"left\";\n        ctx.textBaseline = \"middle\";\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n        const { ctx, maxHeight, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === \"top\" || this.options.position === \"bottom\";\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, this);\n            this._draw();\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n        }\n    }\n    _draw() {\n        const { options: opts, columnSizes, lineWidths, ctx } = this;\n        const { align, labels: labelOpts } = opts;\n        const defaultColor = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.color;\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const labelFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(labelOpts.font);\n        const { padding } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign(\"left\");\n        ctx.textBaseline = \"middle\";\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineWidth, 1);\n            ctx.fillStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineCap, \"butt\");\n            ctx.lineDashOffset = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineJoin, \"miter\");\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aE)(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB)(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor;\n            ctx.fillStyle = legendItem.fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aC)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else if (typeof legendItem.text !== \"string\") {\n                const fontLineHeight = labelFont.lineHeight;\n                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD)(this.ctx, opts.textDirection);\n    }\n    drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(position));\n        ctx.textBaseline = \"middle\";\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, titleOpts.text, x, y, titleFont);\n    }\n    _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n    _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, this.left, this.right) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, hitBox.left, hitBox.left + hitBox.width) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n    handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === \"mousemove\" || e.type === \"mouseout\") {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n    constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n        this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n}\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n    return {\n        itemWidth,\n        itemHeight\n    };\n}\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n    let legendItemText = legendItem.text;\n    if (legendItemText && typeof legendItemText !== \"string\") {\n        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);\n    }\n    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\n}\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n    let itemHeight = _itemHeight;\n    if (typeof legendItem.text !== \"string\") {\n        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n    }\n    return itemHeight;\n}\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n    const labelHeight = legendItem.text ? legendItem.text.length : 0;\n    return fontLineHeight * labelHeight;\n}\nfunction isListened(type, opts) {\n    if ((type === \"mousemove\" || type === \"mouseout\") && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === \"click\" || type === \"mouseup\")) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: \"legend\",\n    _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: \"top\",\n        align: \"center\",\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius } } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: \"center\",\n            text: \"\"\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith(\"on\"),\n        labels: {\n            _scriptable: (name)=>![\n                    \"generateLabels\",\n                    \"filter\",\n                    \"sort\"\n                ].includes(name)\n        }\n    }\n};\nclass Title extends Element {\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(opts.text) ? opts.text.length : 1;\n        this._padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(opts.padding);\n        const textSize = lineCount * (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === \"top\" || pos === \"bottom\";\n    }\n    _drawArgs(offset) {\n        const { top, left, bottom, right, options } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === \"left\") {\n                titleX = left + offset;\n                titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, bottom, top);\n                rotation = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, top, bottom);\n                rotation = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(opts.align),\n            textBaseline: \"middle\",\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: \"title\",\n    _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: \"center\",\n        display: false,\n        font: {\n            weight: \"bold\"\n        },\n        fullSize: true,\n        padding: 10,\n        position: \"top\",\n        text: \"\",\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: \"color\"\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: \"subtitle\",\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: \"center\",\n        display: false,\n        font: {\n            weight: \"normal\"\n        },\n        fullSize: true,\n        padding: 0,\n        position: \"top\",\n        text: \"\",\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: \"color\"\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst positioners = {\n    average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let xSet = new Set();\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                xSet.add(pos.x);\n                y += pos.y;\n                ++count;\n            }\n        }\n        if (count === 0 || xSet.size === 0) {\n            return false;\n        }\n        const xAverage = [\n            ...xSet\n        ].reduce((a, b)=>a + b) / xSet.size;\n        return {\n            x: xAverage,\n            y: y / count\n        };\n    },\n    nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aF)(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\nfunction splitNewlines(str) {\n    if ((typeof str === \"string\" || str instanceof String) && str.indexOf(\"\\n\") > -1) {\n        return str.split(\"\\n\");\n    }\n    return str;\n}\nfunction createTooltipItem(chart, item) {\n    const { element, datasetIndex, index } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label, value } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\nfunction getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body, footer, title } = tooltip;\n    const { boxWidth, boxHeight } = options;\n    const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);\n    const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.titleFont);\n    const footerFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(body, (bodyItem)=>{\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.before, maxLineWidth);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.lines, maxLineWidth);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y, height } = size;\n    if (y < height / 2) {\n        return \"top\";\n    } else if (y > chart.height - height / 2) {\n        return \"bottom\";\n    }\n    return \"center\";\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x, width } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === \"left\" && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === \"right\" && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x, width } = size;\n    const { width: chartWidth, chartArea: { left, right } } = chart;\n    let xAlign = \"center\";\n    if (yAlign === \"center\") {\n        xAlign = x <= (left + right) / 2 ? \"left\" : \"right\";\n    } else if (x <= width / 2) {\n        xAlign = \"left\";\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = \"right\";\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = \"center\";\n    }\n    return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x, width } = size;\n    if (xAlign === \"right\") {\n        x -= width;\n    } else if (xAlign === \"center\") {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y, height } = size;\n    if (yAlign === \"top\") {\n        y += paddingAndSize;\n    } else if (yAlign === \"bottom\") {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize, caretPadding, cornerRadius } = options;\n    const { xAlign, yAlign } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === \"center\") {\n        if (xAlign === \"left\") {\n            x += paddingAndSize;\n        } else if (xAlign === \"right\") {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === \"left\") {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === \"right\") {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(x, 0, chart.width - size.width),\n        y: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n    return align === \"center\" ? tooltip.x + tooltip.width / 2 : align === \"right\" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        tooltip,\n        tooltipItems,\n        type: \"tooltip\"\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nconst defaultCallbacks = {\n    beforeTitle: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    title (tooltipItems) {\n        if (tooltipItems.length > 0) {\n            const item = tooltipItems[0];\n            const labels = item.chart.data.labels;\n            const labelCount = labels ? labels.length : 0;\n            if (this && this.options && this.options.mode === \"dataset\") {\n                return item.dataset.label || \"\";\n            } else if (item.label) {\n                return item.label;\n            } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                return labels[item.dataIndex];\n            }\n        }\n        return \"\";\n    },\n    afterTitle: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    beforeBody: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    beforeLabel: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    label (tooltipItem) {\n        if (this && this.options && this.options.mode === \"dataset\") {\n            return tooltipItem.label + \": \" + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || \"\";\n        if (label) {\n            label += \": \";\n        }\n        const value = tooltipItem.formattedValue;\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n            label += value;\n        }\n        return label;\n    },\n    labelColor (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            borderColor: options.borderColor,\n            backgroundColor: options.backgroundColor,\n            borderWidth: options.borderWidth,\n            borderDash: options.borderDash,\n            borderDashOffset: options.borderDashOffset,\n            borderRadius: 0\n        };\n    },\n    labelTextColor () {\n        return this.options.bodyColor;\n    },\n    labelPointStyle (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            pointStyle: options.pointStyle,\n            rotation: options.rotation\n        };\n    },\n    afterLabel: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    afterBody: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    beforeFooter: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    footer: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    afterFooter: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG\n};\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n    const result = callbacks[name].call(ctx, arg);\n    if (typeof result === \"undefined\") {\n        return defaultCallbacks[name].call(ctx, arg);\n    }\n    return result;\n}\nclass Tooltip extends Element {\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n    _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks } = options;\n        const beforeTitle = invokeCallbackWithFallback(callbacks, \"beforeTitle\", this, context);\n        const title = invokeCallbackWithFallback(callbacks, \"title\", this, context);\n        const afterTitle = invokeCallbackWithFallback(callbacks, \"afterTitle\", this, context);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, \"beforeBody\", this, tooltipItems));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks } = options;\n        const bodyItems = [];\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, \"beforeLabel\", this, context)));\n            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, \"label\", this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, \"afterLabel\", this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, \"afterBody\", this, tooltipItems));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks } = options;\n        const beforeFooter = invokeCallbackWithFallback(callbacks, \"beforeFooter\", this, tooltipItems);\n        const footer = invokeCallbackWithFallback(callbacks, \"footer\", this, tooltipItems);\n        const afterFooter = invokeCallbackWithFallback(callbacks, \"afterFooter\", this, tooltipItems);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n    _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(invokeCallbackWithFallback(scoped, \"labelColor\", this, context));\n            labelPointStyles.push(invokeCallbackWithFallback(scoped, \"labelPointStyle\", this, context));\n            labelTextColors.push(invokeCallbackWithFallback(scoped, \"labelTextColor\", this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign, yAlign } = this;\n        const { caretSize, cornerRadius } = options;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(cornerRadius);\n        const { x: ptX, y: ptY } = tooltipPoint;\n        const { width, height } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === \"center\") {\n            y2 = ptY + height / 2;\n            if (xAlign === \"left\") {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === \"left\") {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === \"right\") {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === \"top\") {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = \"middle\";\n            titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n    _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColor = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight, boxWidth } = options;\n        const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);\n        const colorX = getAlignedX(this, \"left\", options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.fillStyle = labelColor.backgroundColor;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.setLineDash(labelColor.borderDash || []);\n            ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n            const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(labelColor.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.beginPath();\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body } = this;\n        const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;\n        const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = \"middle\";\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== \"right\" ? bodyAlign === \"center\" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = \"middle\";\n            footerFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign, yAlign } = this;\n        const { x, y } = pt;\n        const { width, height } = tooltipSize;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === \"top\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === \"center\" && xAlign === \"right\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === \"bottom\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === \"center\" && xAlign === \"left\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n    _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n    _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB)(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD)(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map((param)=>{\n            let { datasetIndex, index } = param;\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error(\"Cannot find a dataset at index \" + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n    handleEvent(e, replay) {\n        let inChartArea = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n    _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === \"mouseout\") {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n    _positionChanged(active, e) {\n        const { caretX, caretY, options } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n    id: \"tooltip\",\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins(\"beforeTooltipDraw\", {\n                ...args,\n                cancelable: true\n            }) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins(\"afterTooltipDraw\", args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: \"average\",\n        backgroundColor: \"rgba(0,0,0,0.8)\",\n        titleColor: \"#fff\",\n        titleFont: {\n            weight: \"bold\"\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: \"left\",\n        bodyColor: \"#fff\",\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: \"left\",\n        footerColor: \"#fff\",\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: \"bold\"\n        },\n        footerAlign: \"left\",\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: \"#fff\",\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: \"rgba(0,0,0,0)\",\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: \"easeOutQuart\"\n        },\n        animations: {\n            numbers: {\n                type: \"number\",\n                properties: [\n                    \"x\",\n                    \"y\",\n                    \"width\",\n                    \"height\",\n                    \"caretX\",\n                    \"caretY\"\n                ]\n            },\n            opacity: {\n                easing: \"linear\",\n                duration: 200\n            }\n        },\n        callbacks: defaultCallbacks\n    },\n    defaultRoutes: {\n        bodyFont: \"font\",\n        footerFont: \"font\",\n        titleFont: \"font\"\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== \"filter\" && name !== \"itemSort\" && name !== \"external\",\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: \"animation\"\n        }\n    },\n    additionalOptionScopes: [\n        \"interaction\"\n    ]\n};\nvar plugins = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Colors: plugin_colors,\n    Decimation: plugin_decimation,\n    Filler: index,\n    Legend: plugin_legend,\n    SubTitle: plugin_subtitle,\n    Title: plugin_title,\n    Tooltip: plugin_tooltip\n});\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === \"string\") {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(Math.round(index), 0, max);\nfunction _getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n        return labels[value];\n    }\n    return value;\n}\nclass CategoryScale extends Scale {\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index, label } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this.getMinMax(true);\n        if (this.options.bounds === \"ticks\") {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return _getLabelForValue.call(this, value);\n    }\n    configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== \"number\") {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n    constructor(cfg){\n        super(cfg);\n        this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n}\nCategoryScale.id = \"category\";\nCategoryScale.defaults = {\n    ticks: {\n        callback: _getLabelForValue\n    }\n};\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin, max: rmax } = dataRange;\n    const minDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(min);\n    const maxDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(max);\n    const countDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI)((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI)(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === \"ticks\") {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aJ)((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL)(spacing), (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL)(niceMin));\n    factor = Math.pow(10, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n        if (maxDefined && tickValue > max) {\n            break;\n        }\n        ticks.push({\n            value: tickValue\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, param) {\n    let { horizontal, minRotation } = param;\n    const rad = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * (\"\" + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    parse(raw, index) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        if ((typeof raw === \"number\" || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero } = this.options;\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(min);\n            const maxSign = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit, stepSize } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(\"scales.\".concat(this.id, \".ticks.stepSize: \").concat(stepSize, \" would result generating up to \").concat(maxTicks, \" ticks. Limiting to 1000.\"));\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n    computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === \"ticks\") {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, \"value\");\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._endValue = undefined;\n        this._valueRange = 0;\n    }\n}\nclass LinearScale extends LinearScaleBase {\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? min : 0;\n        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\nLinearScale.id = \"linear\";\nLinearScale.defaults = {\n    ticks: {\n        callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.numeric\n    }\n};\nconst log10Floor = (v)=>Math.floor((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(v));\nconst changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, log10Floor(tickVal));\n    return remain === 1;\n}\nfunction steps(min, max, rangeExp) {\n    const rangeStep = Math.pow(10, rangeExp);\n    const start = Math.floor(min / rangeStep);\n    const end = Math.ceil(max / rangeStep);\n    return end - start;\n}\nfunction startExp(min, max) {\n    const range = max - min;\n    let rangeExp = log10Floor(range);\n    while(steps(min, max, rangeExp) > 10){\n        rangeExp++;\n    }\n    while(steps(min, max, rangeExp) < 10){\n        rangeExp--;\n    }\n    return Math.min(rangeExp, log10Floor(min));\n}\nfunction generateTicks(generationOptions, param) {\n    let { min, max } = param;\n    min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.min, min);\n    const ticks = [];\n    const minExp = log10Floor(min);\n    let exp = startExp(min, max);\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    const stepSize = Math.pow(10, exp);\n    const base = minExp > exp ? Math.pow(10, minExp) : 0;\n    const start = Math.round((min - base) * precision) / precision;\n    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n    let significand = Math.floor((start - offset) / Math.pow(10, exp));\n    let value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n    while(value < max){\n        ticks.push({\n            value,\n            major: isMajor(value),\n            significand\n        });\n        if (significand >= 10) {\n            significand = significand < 15 ? 15 : 20;\n        } else {\n            significand++;\n        }\n        if (significand >= 20) {\n            exp++;\n            significand = 2;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n    }\n    const lastTick = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.max, value);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(lastTick),\n        significand\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? Math.max(0, min) : null;\n        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        if (this._zero && this.min !== this._suggestedMin && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(this._userMin)) {\n            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(changeExponent(min, -1));\n                setMax(changeExponent(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(changeExponent(max, -1));\n        }\n        if (max <= 0) {\n            setMax(changeExponent(min, +1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === \"ticks\") {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, \"value\");\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return value === undefined ? \"0\" : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n    configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(start);\n        this._valueRange = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(this.max) - (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._valueRange = 0;\n    }\n}\nLogarithmicScale.id = \"logarithmic\";\nLogarithmicScale.defaults = {\n    ticks: {\n        callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.logarithmic,\n        major: {\n            enabled: true\n        }\n    }\n};\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(tickOpts.backdropPadding);\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(tickOpts.font && tickOpts.font.size, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label : [\n        label\n    ];\n    return {\n        w: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aO)(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\nfunction fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction createPointLabelItem(scale, index, itemOpts) {\n    const outerDistance = scale.drawingArea;\n    const { extra, additionalAngle, padding, size } = itemOpts;\n    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n    const angle = Math.round((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(pointLabelPosition.angle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H)));\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    return {\n        visible: true,\n        x: pointLabelPosition.x,\n        y,\n        textAlign,\n        left,\n        top: y,\n        right: left + size.w,\n        bottom: y + size.h\n    };\n}\nfunction isNotOverlapped(item, area) {\n    if (!area) {\n        return true;\n    }\n    const { left, top, right, bottom } = item;\n    const apexesInArea = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: left,\n        y: top\n    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: left,\n        y: bottom\n    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: right,\n        y: top\n    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: right,\n        y: bottom\n    }, area);\n    return !apexesInArea;\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const { centerPointLabels, display } = opts.pointLabels;\n    const itemOpts = {\n        extra: getTickBackdropHeight(opts) / 2,\n        additionalAngle: centerPointLabels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0\n    };\n    let area;\n    for(let i = 0; i < valueCount; i++){\n        itemOpts.padding = padding[i];\n        itemOpts.size = labelSizes[i];\n        const item = createPointLabelItem(scale, i, itemOpts);\n        items.push(item);\n        if (display === \"auto\") {\n            item.visible = isNotOverlapped(item, area);\n            if (item.visible) {\n                area = item;\n            }\n        }\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return \"center\";\n    } else if (angle < 180) {\n        return \"left\";\n    }\n    return \"right\";\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === \"right\") {\n        x -= w;\n    } else if (align === \"center\") {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabelBox(ctx, opts, item) {\n    const { left, top, right, bottom } = item;\n    const { backdropColor } = opts;\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(backdropColor)) {\n        const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(opts.borderRadius);\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(opts.backdropPadding);\n        ctx.fillStyle = backdropColor;\n        const backdropLeft = left - padding.left;\n        const backdropTop = top - padding.top;\n        const backdropWidth = right - left + padding.width;\n        const backdropHeight = bottom - top + padding.height;\n        if (Object.values(borderRadius).some((v)=>v !== 0)) {\n            ctx.beginPath();\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                x: backdropLeft,\n                y: backdropTop,\n                w: backdropWidth,\n                h: backdropHeight,\n                radius: borderRadius\n            });\n            ctx.fill();\n        } else {\n            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n        }\n    }\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx, options: { pointLabels } } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const item = scale._pointLabelItems[i];\n        if (!item.visible) {\n            continue;\n        }\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        drawPointLabelBox(ctx, optsAtIndex, item);\n        const plFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(optsAtIndex.font);\n        const { x, y, textAlign } = item;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: \"middle\"\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color, lineWidth } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(borderOpts.dash || []);\n    ctx.lineDashOffset = borderOpts.dashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        label,\n        index,\n        type: \"pointLabel\"\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    setDimensions() {\n        const padding = this._padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(false);\n        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : 0;\n        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : \"\";\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(index * angleMultiplier + (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter) {\n        let additionalAngle = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const angle = this.getIndexAngle(index) - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left, top, right, bottom } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n    drawBackground() {\n        const { backgroundColor, grid: { circular } } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n    drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines, grid, border } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0 || index === 0 && this.min < 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const context = this.getContext(index);\n                    const optsAtIndex = grid.setContext(context);\n                    const optsAtIndexBorder = border.setContext(context);\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color, lineWidth } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n    drawBorder() {}\n    drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && this.min >= 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color,\n                strokeColor: optsAtIndex.textStrokeColor,\n                strokeWidth: optsAtIndex.textStrokeWidth\n            });\n        });\n        ctx.restore();\n    }\n    drawTitle() {}\n    constructor(cfg){\n        super(cfg);\n        this.xCenter = undefined;\n        this.yCenter = undefined;\n        this.drawingArea = undefined;\n        this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n}\nRadialLinearScale.id = \"radialLinear\";\nRadialLinearScale.defaults = {\n    display: true,\n    animate: true,\n    position: \"chartArea\",\n    angleLines: {\n        display: true,\n        lineWidth: 1,\n        borderDash: [],\n        borderDashOffset: 0.0\n    },\n    grid: {\n        circular: false\n    },\n    startAngle: 0,\n    ticks: {\n        showLabelBackdrop: true,\n        callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.numeric\n    },\n    pointLabels: {\n        backdropColor: undefined,\n        backdropPadding: 2,\n        display: true,\n        font: {\n            size: 10\n        },\n        callback (label) {\n            return label;\n        },\n        padding: 5,\n        centerPointLabels: false\n    }\n};\nRadialLinearScale.defaultRoutes = {\n    \"angleLines.color\": \"borderColor\",\n    \"pointLabels.color\": \"color\",\n    \"ticks.color\": \"color\"\n};\nRadialLinearScale.descriptors = {\n    angleLines: {\n        _fallback: \"grid\"\n    }\n};\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\nconst UNITS = /* #__PURE__ */ Object.keys(INTERVALS);\n_c2 = UNITS;\nfunction sorter(a, b) {\n    return a - b;\n}\nfunction parse(scale, input) {\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser, round, isoWeekday } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === \"function\") {\n        value = parser(value);\n    }\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n        value = typeof parser === \"string\" ? adapter.parse(value, parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === \"week\" && ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, \"isoWeek\", isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\nfunction addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo, hi } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aQ)(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n    const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    init(scaleOpts) {\n        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const time = scaleOpts.time || (scaleOpts.time = {});\n        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n    parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || \"day\";\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== \"ticks\" || options.ticks.source !== \"labels\") {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n    _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n    buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === \"ticks\" && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aP)(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === \"year\" ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n    initOffsets() {\n        let timestamps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(start, 0, limit);\n        end = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n    _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.stepSize, 1);\n        const weekday = minor === \"week\" ? timeOpts.isoWeekday : false;\n        const hasWeekday = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, \"isoWeek\", weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? \"day\" : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + \" and \" + max + \" are too far apart with stepSize of \" + stepSize + \" \" + minor);\n        }\n        const timestamps = options.ticks.source === \"data\" && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === \"ticks\" || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort(sorter).map((x)=>+x);\n    }\n    getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n    format(value, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const fmt = format || formats[unit];\n        return this._adapter.format(value, fmt);\n    }\n    _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formatter = options.ticks.callback;\n        if (formatter) {\n            return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(formatter, [\n                time,\n                index,\n                ticks\n            ], this);\n        }\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    }\n    generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n    getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n    getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n    _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n    _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n    getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n    getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n    normalize(values) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort(sorter));\n    }\n    constructor(props){\n        super(props);\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n        this._unit = \"day\";\n        this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n}\nTimeScale.id = \"time\";\nTimeScale.defaults = {\n    bounds: \"data\",\n    adapters: {},\n    time: {\n        parser: false,\n        unit: false,\n        round: false,\n        isoWeekday: false,\n        minUnit: \"millisecond\",\n        displayFormats: {}\n    },\n    ticks: {\n        source: \"auto\",\n        callback: false,\n        major: {\n            enabled: false\n        }\n    }\n};\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo, hi } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(table, \"pos\", val));\n        }\n        ({ pos: prevSource, time: prevTarget } = table[lo]);\n        ({ pos: nextSource, time: nextTarget } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo, hi } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(table, \"time\", val));\n        }\n        ({ time: prevSource, pos: prevTarget } = table[lo]);\n        ({ time: nextSource, pos: nextTarget } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n    buildLookupTable(timestamps) {\n        const { min, max } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n    _generate() {\n        const min = this.min;\n        const max = this.max;\n        let timestamps = super.getDataTimestamps();\n        if (!timestamps.includes(min) || !timestamps.length) {\n            timestamps.splice(0, 0, min);\n        }\n        if (!timestamps.includes(max) || timestamps.length === 1) {\n            timestamps.push(max);\n        }\n        return timestamps.sort((a, b)=>a - b);\n    }\n    _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n    getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n    constructor(props){\n        super(props);\n        this._table = [];\n        this._minPos = undefined;\n        this._tableRange = undefined;\n    }\n}\nTimeSeriesScale.id = \"timeseries\";\nTimeSeriesScale.defaults = TimeScale.defaults;\nvar scales = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    CategoryScale: CategoryScale,\n    LinearScale: LinearScale,\n    LogarithmicScale: LogarithmicScale,\n    RadialLinearScale: RadialLinearScale,\n    TimeScale: TimeScale,\n    TimeSeriesScale: TimeSeriesScale\n});\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n //# sourceMappingURL=chart.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"BACKGROUND_COLORS$BORDER_COLORS.map\");\n$RefreshReg$(_c1, \"BACKGROUND_COLORS\");\n$RefreshReg$(_c2, \"UNITS\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXTyxNQUFNQTtJQVdYQyxRQUFRQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUU7UUFDaEMsTUFBTUMsWUFBWUgsTUFBTUksU0FBUyxDQUFDRixLQUFLO1FBQ3ZDLE1BQU1HLFdBQVdMLE1BQU1NLFFBQVE7UUFFL0JILFVBQVVJLE9BQU8sQ0FBQ0MsQ0FBQUEsS0FBTUEsR0FBRztnQkFDekJUO2dCQUNBVSxTQUFTVCxNQUFNUyxPQUFPO2dCQUN0Qko7Z0JBQ0FLLGFBQWFDLEtBQUtDLEdBQUcsQ0FBQ1gsT0FBT0QsTUFBTWEsS0FBSyxFQUFFUjtZQUM1QztJQUNGO0lBS0FTLFdBQVc7UUFDVCxJQUFJLElBQUksQ0FBQ0MsUUFBUSxFQUFFO1lBQ2pCOztRQUVGLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBRWhCLElBQUksQ0FBQ0QsUUFBUSxHQUFHRSx5REFBZ0JBLENBQUNDLElBQUksQ0FBQ0MsUUFBUTtZQUM1QyxJQUFJLENBQUNDLE9BQU87WUFDWixJQUFJLENBQUNMLFFBQVEsR0FBRztZQUVoQixJQUFJLElBQUksQ0FBQ0MsUUFBUSxFQUFFO2dCQUNqQixJQUFJLENBQUNGLFFBQVE7O1FBRWpCO0lBQ0Y7SUFLQU0sVUFBMkI7WUFBbkJuQixPQUFBQSxpRUFBT29CLEtBQUtDLEdBQUc7UUFDckIsSUFBSUMsWUFBWTtRQUVoQixJQUFJLENBQUNDLE9BQU8sQ0FBQ2pCLE9BQU8sQ0FBQyxDQUFDUCxPQUFPRDtZQUMzQixJQUFJLENBQUNDLE1BQU15QixPQUFPLElBQUksQ0FBQ3pCLE1BQU0wQixLQUFLLENBQUNDLE1BQU0sRUFBRTtnQkFDekM7O1lBRUYsTUFBTUQsUUFBUTFCLE1BQU0wQixLQUFLO1lB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Z0JBT0d2L0QsV0FBVzI4RCxVQUFVMzhELFFBQVE7Ozs7Ozs7Ozs7TUNyQnpCNi9ELGdCQUFnQjtJQUMzQnA4QjtJQUNBLzFCO0lBQ0F5UTtJQUNBdlgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9jb3JlL2NvcmUuYW5pbWF0b3IuanM/MWJmMSIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9uLmpzPzkxZjAiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbnMuanM/MzdiZCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanM/ZDA1YiIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJhci5qcz84ZGMxIiwid2VicGFjazovL19OX0UvLi4vc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuYnViYmxlLmpzPzE2YTIiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5kb3VnaG51dC5qcz9jYWJhIiwid2VicGFjazovL19OX0UvLi4vc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIubGluZS5qcz85NzU2Iiwid2VicGFjazovL19OX0UvLi4vc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucG9sYXJBcmVhLmpzPzE5Y2EiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5waWUuanM/MDY5OCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnJhZGFyLmpzP2QwMWEiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5zY2F0dGVyLmpzPzk0MGEiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvY29yZS9jb3JlLmFkYXB0ZXJzLnRzP2ZiYjkiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvY29yZS9jb3JlLmludGVyYWN0aW9uLmpzPzNiNWEiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvY29yZS9jb3JlLmxheW91dHMuanM/YzRlMCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzP2M0ZWEiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzaWMuanM/OTA3ZiIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5kb20uanM/NjI2NCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wbGF0Zm9ybS9pbmRleC5qcz81NmI1Iiwid2VicGFjazovL19OX0UvLi4vc3JjL2NvcmUvY29yZS5lbGVtZW50LnRzP2I3MWUiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvY29yZS9jb3JlLnNjYWxlLmF1dG9za2lwLmpzP2QxMzUiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvY29yZS9jb3JlLnNjYWxlLmpzPzg4OGIiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvY29yZS9jb3JlLnR5cGVkUmVnaXN0cnkuanM/N2Y5OSIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9jb3JlL2NvcmUucmVnaXN0cnkuanM/MjAxOSIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9jb3JlL2NvcmUucGx1Z2lucy5qcz83YzNlIiwid2VicGFjazovL19OX0UvLi4vc3JjL2NvcmUvY29yZS5jb25maWcuanM/NTIzZiIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9jb3JlL2NvcmUuY29udHJvbGxlci5qcz83NzI3Iiwid2VicGFjazovL19OX0UvLi4vc3JjL2VsZW1lbnRzL2VsZW1lbnQuYXJjLnRzP2QxZWIiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvZWxlbWVudHMvZWxlbWVudC5saW5lLmpzPzVmNmUiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvZWxlbWVudHMvZWxlbWVudC5wb2ludC50cz81ZTZjIiwid2VicGFjazovL19OX0UvLi4vc3JjL2VsZW1lbnRzL2VsZW1lbnQuYmFyLmpzPzA3YjMiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvcGx1Z2lucy9wbHVnaW4uY29sb3JzLnRzPzVkNDgiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvcGx1Z2lucy9wbHVnaW4uZGVjaW1hdGlvbi5qcz9kODY0Iiwid2VicGFjazovL19OX0UvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuc2VnbWVudC5qcz9hNjU1Iiwid2VicGFjazovL19OX0UvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuaGVscGVyLmpzPzg4YWQiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5vcHRpb25zLmpzP2JjZTAiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuc3RhY2suanM/MjFlYSIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvc2ltcGxlQXJjLmpzPzg3ZmEiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuanM/OGM2NiIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmRyYXdpbmcuanM/MWEzNCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvaW5kZXguanM/NzEzZCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wbHVnaW5zL3BsdWdpbi5sZWdlbmQuanM/MjhiMyIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wbHVnaW5zL3BsdWdpbi50aXRsZS5qcz9hYjE2Iiwid2VicGFjazovL19OX0UvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLnN1YnRpdGxlLmpzP2MyM2EiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvcGx1Z2lucy9wbHVnaW4udG9vbHRpcC5qcz9kZjFkIiwid2VicGFjazovL19OX0UvLi4vc3JjL3NjYWxlcy9zY2FsZS5jYXRlZ29yeS5qcz9iZDg0Iiwid2VicGFjazovL19OX0UvLi4vc3JjL3NjYWxlcy9zY2FsZS5saW5lYXJiYXNlLmpzPzMyNTUiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhci5qcz9hMDEyIiwid2VicGFjazovL19OX0UvLi4vc3JjL3NjYWxlcy9zY2FsZS5sb2dhcml0aG1pYy5qcz81YTU1Iiwid2VicGFjazovL19OX0UvLi4vc3JjL3NjYWxlcy9zY2FsZS5yYWRpYWxMaW5lYXIuanM/ZjRhNyIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zY2FsZXMvc2NhbGUudGltZS5qcz85ZTUxIiwid2VicGFjazovL19OX0UvLi4vc3JjL3NjYWxlcy9zY2FsZS50aW1lc2VyaWVzLmpzPzQwZjAiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvaW5kZXgudHM/NTJkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3JlcXVlc3RBbmltRnJhbWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuYW5pbWF0aW9uLmpzJykuZGVmYXVsdCB9IEFuaW1hdGlvblxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuLyoqXG4gKiBQbGVhc2UgdXNlIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydCB3aGljaCBwcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuICogTm90ZTogY2xhc3MgaXMgZXhwb3J0IGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG5cbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG5cbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuXG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChpdGVtLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFuZCBpdHMgZHVyYXRpb24gcHJvbG9uZ2VkLFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRvdGFsIGR1cmF0aW9uIG9mIGN1cnJlbnQgYW5pbWF0aW9ucyBydW4gKGZvciBwcm9ncmVzcyBldmVudClcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW0gYnkgcmVwbGFjaW5nIGl0IHdpdGggbGFzdCBpdGVtIGFuZCByZW1vdmluZyB0aGUgbGFzdFxuICAgICAgICAgIC8vIEEgbG90IGZhc3RlciB0aGFuIHNwbGljZS5cbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNoYXJ0LmRyYXcoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFuaW1zLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcblxuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrXG5cdCAqL1xuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZCBhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uW119IGl0ZW1zIC0gYW5pbWF0aW9uc1xuXHQgKi9cbiAgYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gIH1cblxuICAvKipcblx0ICogQ291bnRzIG51bWJlciBvZiBhY3RpdmUgYW5pbWF0aW9ucyBmb3IgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcblx0ICogU3RhcnQgYW5pbWF0aW5nIChhbGwgY2hhcnRzKVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG5cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdG9wIGFsbCBhbmltYXRpb25zIGZvciB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcblx0ICogUmVtb3ZlIGNoYXJ0IGZyb20gQW5pbWF0b3Jcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHJlbW92ZShjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgQW5pbWF0b3IoKTtcbiIsImltcG9ydCBlZmZlY3RzIGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5lYXNpbmcuanMnO1xuaW1wb3J0IHtyZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2NvbG9yIGFzIGhlbHBlcnNDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yXG4gICAqL1xuICBjb2xvcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc3QgYzAgPSBoZWxwZXJzQ29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBoZWxwZXJzQ29sb3IodG8gfHwgdHJhbnNwYXJlbnQpO1xuICAgIHJldHVybiBjMSAmJiBjMS52YWxpZFxuICAgICAgPyBjMS5taXgoYzAsIGZhY3RvcikuaGV4U3RyaW5nKClcbiAgICAgIDogdG87XG4gIH0sXG4gIG51bWJlcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgY29uc3QgZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2ZuID0gY2ZnLmZuIHx8IGludGVycG9sYXRvcnNbY2ZnLnR5cGUgfHwgdHlwZW9mIGZyb21dO1xuICAgIHRoaXMuX2Vhc2luZyA9IGVmZmVjdHNbY2ZnLmVhc2luZ10gfHwgZWZmZWN0cy5saW5lYXI7XG4gICAgdGhpcy5fc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgKyAoY2ZnLmRlbGF5IHx8IDApKTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcihjZmcuZHVyYXRpb24pO1xuICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9wcm9wID0gcHJvcDtcbiAgICB0aGlzLl9mcm9tID0gZnJvbTtcbiAgICB0aGlzLl90byA9IHRvO1xuICAgIHRoaXMuX3Byb21pc2VzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wXTtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICBjb25zdCByZW1haW4gPSB0aGlzLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XG4gICAgICB0aGlzLl9zdGFydCA9IGRhdGU7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgocmVtYWluLCBjZmcuZHVyYXRpb24pKTtcbiAgICAgIHRoaXMuX3RvdGFsICs9IGVsYXBzZWQ7XG4gICAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICAgIHRoaXMuX3RvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgICAgdGhpcy5fZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IGV2YWx1YXRlZCB2YWx1ZSwgZm9yIHNtb290aGVyIGFuaW1hdGlvbnNcbiAgICAgIHRoaXMudGljayhEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICB0aWNrKGRhdGUpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuX3Byb3A7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgY29uc3QgdG8gPSB0aGlzLl90bztcbiAgICBsZXQgZmFjdG9yO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gZnJvbSAhPT0gdG8gJiYgKGxvb3AgfHwgKGVsYXBzZWQgPCBkdXJhdGlvbikpO1xuXG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgdGhpcy5fbm90aWZ5KHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGFwc2VkIDwgMCkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gZnJvbTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWN0b3IgPSAoZWxhcHNlZCAvIGR1cmF0aW9uKSAlIDI7XG4gICAgZmFjdG9yID0gbG9vcCAmJiBmYWN0b3IgPiAxID8gMiAtIGZhY3RvciA6IGZhY3RvcjtcbiAgICBmYWN0b3IgPSB0aGlzLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZmFjdG9yKSkpO1xuXG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cblxuICB3YWl0KCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goe3JlcywgcmVqfSk7XG4gICAgfSk7XG4gIH1cblxuICBfbm90aWZ5KHJlc29sdmVkKSB7XG4gICAgY29uc3QgbWV0aG9kID0gcmVzb2x2ZWQgPyAncmVzJyA6ICdyZWonO1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZXNbaV1bbWV0aG9kXSgpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IGFuaW1hdG9yIGZyb20gJy4vY29yZS5hbmltYXRvci5qcyc7XG5pbXBvcnQgQW5pbWF0aW9uIGZyb20gJy4vY29yZS5hbmltYXRpb24uanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgY29uZmlnKSB7XG4gICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XG4gIH1cblxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGNmZyA9IGNvbmZpZ1trZXldO1xuICAgICAgaWYgKCFpc09iamVjdChjZmcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBhbmltYXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJlc29sdmVkW29wdGlvbl0gPSBjZmdbb3B0aW9uXTtcbiAgICAgIH1cblxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IHRvIGhhbmRsZSBhbmltYXRpb24gb2YgYG9wdGlvbnNgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IHZhbHVlcy5vcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIC8vIEdvaW5nIHRvIHNoYXJlZCBvcHRpb25zOlxuICAgICAgLy8gQWZ0ZXIgYWxsIGFuaW1hdGlvbnMgYXJlIGRvbmUsIGFzc2lnbiB0aGUgc2hhcmVkIG9wdGlvbnMgb2JqZWN0IHRvIHRoZSBlbGVtZW50XG4gICAgICAvLyBTbyBhbnkgbmV3IHVwZGF0ZXMgdG8gdGhlIHNoYXJlZCBvcHRpb25zIGFyZSBvYnNlcnZlZFxuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIC8vIHJlamVjdGVkLCBub29wXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgcnVubmluZyA9IHRhcmdldC4kYW5pbWF0aW9ucyB8fCAodGFyZ2V0LiRhbmltYXRpb25zID0ge30pO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IHByb3BzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAocHJvcC5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBhbiBleGlzdGluZyBhY3RpdmUgYW5pbWF0aW9uLCBsZXQncyB1cGRhdGUgdGhhdFxuICAgICAgICAgIGFuaW1hdGlvbi51cGRhdGUoY2ZnLCB2YWx1ZSwgZGF0ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNmZyB8fCAhY2ZnLmR1cmF0aW9uKSB7XG4gICAgICAgIC8vIG5vdCBhbmltYXRlZCwgc2V0IGRpcmVjdGx5IHRvIG5ldyB2YWx1ZVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJ1bm5pbmdbcHJvcF0gPSBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGNmZywgdGFyZ2V0LCBwcm9wLCB2YWx1ZSk7XG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgYHRhcmdldGAgcHJvcGVydGllcyB0byBuZXcgdmFsdWVzLCB1c2luZyBjb25maWd1cmVkIGFuaW1hdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIG9iamVjdCB0byB1cGRhdGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAtIG5ldyB0YXJnZXQgcHJvcGVydGllc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbnx1bmRlZmluZWR9IC0gYHRydWVgIGlmIGFuaW1hdGlvbnMgd2VyZSBzdGFydGVkXG5cdCAqKi9cbiAgdXBkYXRlKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgLy8gTm90aGluZyBpcyBhbmltYXRlZCwganVzdCBhcHBseSB0aGUgbmV3IHZhbHVlcy5cbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKTtcblxuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHJ1bm5pbmcgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhbmltID0gYW5pbWF0aW9uc1trZXlzW2ldXTtcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgIH1cbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBQcm9taXNlLmFsbChydW5uaW5nKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAvLyBHb2luZyBmcm9tIHNoYXJlZCBvcHRpb25zIHRvIGRpc3RpbmN0IG9uZTpcbiAgICAvLyBDcmVhdGUgbmV3IG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9sZCBzaGFyZWQgdmFsdWVzIGFuZCBzdGFydCB1cGRhdGluZyB0aGF0LlxuICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHskc2hhcmVkOiBmYWxzZSwgJGFuaW1hdGlvbnM6IHt9fSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG4iLCJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNGaW5pdGUsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdCwgcmVzb2x2ZU9iamVjdEtleSwgZGVmaW5lZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtsaXN0ZW5BcnJheUV2ZW50cywgdW5saXN0ZW5BcnJheUV2ZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBzaWdufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqL1xuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcblxuICByZXR1cm4ge1xuICAgIHRvcDogeS5lbmQsXG4gICAgcmlnaHQ6IHguZW5kLFxuICAgIGJvdHRvbTogeS5zdGFydCxcbiAgICBsZWZ0OiB4LnN0YXJ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcblxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogcixcbiAgICBib3R0b206IGIsXG4gICAgbGVmdDogbCxcbiAgICBkaXNhYmxlZDogdmFsdWUgPT09IGZhbHNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIGRzSW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XG4gIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRhdGFzZXRJbmRleCA9ICtrZXlzW2ldO1xuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKGlzRmluaXRlKG90aGVyVmFsdWUpICYmIChzaW5nbGVNb2RlIHx8ICh2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpKSB7XG4gICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghZm91bmQgJiYgIW9wdGlvbnMuYWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhLCBtZXRhKSB7XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyAneCcgOiAneSc7XG4gIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/ICd4JyA6ICd5JztcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICBjb25zdCBhZGF0YSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gIGxldCBpLCBpbGVuLCBrZXk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgYWRhdGFbaV0gPSB7XG4gICAgICBbaUF4aXNLZXldOiBrZXksXG4gICAgICBbdkF4aXNLZXldOiBkYXRhW2tleV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhZGF0YTtcbn1cblxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICByZXR1cm4gYCR7aW5kZXhTY2FsZS5pZH0uJHt2YWx1ZVNjYWxlLmlkfS4ke21ldGEuc3RhY2sgfHwgbWV0YS50eXBlfWA7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbkRlZmluZWQgPyBtaW4gOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgcG9zaXRpdmUsIHR5cGUpIHtcbiAgZm9yIChjb25zdCBtZXRhIG9mIHZTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xuICAgIGlmICgocG9zaXRpdmUgJiYgdmFsdWUgPiAwKSB8fCAoIXBvc2l0aXZlICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgIHJldHVybiBtZXRhLmluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGFja3MoY29udHJvbGxlciwgcGFyc2VkKSB7XG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcbiAgY29uc3Qgc3RhY2tzID0gY2hhcnQuX3N0YWNrcyB8fCAoY2hhcnQuX3N0YWNrcyA9IHt9KTsgLy8gbWFwIHN0cnVjdHVyZSBpcyB7c3RhY2tLZXk6IHtkYXRhc2V0SW5kZXg6IHZhbHVlfX1cbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBpbmRleDogZGF0YXNldEluZGV4fSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gIGNvbnN0IGtleSA9IGdldFN0YWNrS2V5KGlTY2FsZSwgdlNjYWxlLCBtZXRhKTtcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBzdGFjaztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBwYXJzZWRbaV07XG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xuICAgIGNvbnN0IGl0ZW1TdGFja3MgPSBpdGVtLl9zdGFja3MgfHwgKGl0ZW0uX3N0YWNrcyA9IHt9KTtcbiAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcblxuICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XG4gICAgc3RhY2suX2JvdHRvbSA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgZmFsc2UsIG1ldGEudHlwZSk7XG5cbiAgICBjb25zdCB2aXN1YWxWYWx1ZXMgPSBzdGFjay5fdmlzdWFsVmFsdWVzIHx8IChzdGFjay5fdmlzdWFsVmFsdWVzID0ge30pO1xuICAgIHZpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCxcbiAgICB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgZGF0YXNldDogdW5kZWZpbmVkLFxuICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgIGluZGV4LFxuICAgICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBwYXJzZWQ6IHVuZGVmaW5lZCxcbiAgICByYXc6IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50LFxuICAgIGluZGV4LFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICB0eXBlOiAnZGF0YSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIC8vIE5vdCB1c2luZyBtZXRhLmluZGV4IGhlcmUsIGJlY2F1c2UgaXQgbWlnaHQgYmUgYWxyZWFkeSB1cGRhdGVkIGlmIHRoZSBkYXRhc2V0IGNoYW5nZWQgbG9jYXRpb25cbiAgY29uc3QgZGF0YXNldEluZGV4ID0gbWV0YS5jb250cm9sbGVyLmluZGV4O1xuICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaXRlbXMgPSBpdGVtcyB8fCBtZXRhLl9wYXJzZWQ7XG4gIGZvciAoY29uc3QgcGFyc2VkIG9mIGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gcGFyc2VkLl9zdGFja3M7XG4gICAgaWYgKCFzdGFja3MgfHwgc3RhY2tzW2F4aXNdID09PSB1bmRlZmluZWQgfHwgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzICE9PSB1bmRlZmluZWQgJiYgc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcbiAgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge307XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhc2V0IChlLmcuIENoYXJ0LmVsZW1lbnQuTGluZUVsZW1lbnQpLlxuICAgKi9cbiAgc3RhdGljIGRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhIChlLmcuIENoYXJ0LmVsZW1lbnQuUG9pbnRFbGVtZW50KS5cbiAgICovXG4gIHN0YXRpYyBkYXRhRWxlbWVudFR5cGUgPSBudWxsO1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGF0YXNldEluZGV4XG5cdCAqL1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX2N0eCA9IGNoYXJ0LmN0eDtcbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gICAgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IG9iamVjdH0gKi9cbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YXNldEVsZW1lbnRUeXBlO1xuICAgIHRoaXMuZGF0YUVsZW1lbnRUeXBlID0gbmV3LnRhcmdldC5kYXRhRWxlbWVudFR5cGU7XG5cbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmxpbmtTY2FsZXMoKTtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmZpbGwgJiYgIXRoaXMuY2hhcnQuaXNQbHVnaW5FbmFibGVkKCdmaWxsZXInKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gdXNlIHRoZSAnZmlsbCcgb3B0aW9uIHdpdGhvdXQgdGhlICdGaWxsZXInIHBsdWdpbiBlbmFibGVkLiBQbGVhc2UgaW1wb3J0IGFuZCByZWdpc3RlciB0aGUgJ0ZpbGxlcicgcGx1Z2luIGFuZCBtYWtlIHN1cmUgaXQgaXMgbm90IGRpc2FibGVkIGluIHRoZSBvcHRpb25zXCIpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSBkYXRhc2V0SW5kZXgpIHtcbiAgICAgIGNsZWFyU3RhY2tzKHRoaXMuX2NhY2hlZE1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICB9XG5cbiAgbGlua1NjYWxlcygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuXG4gICAgY29uc3QgeGlkID0gbWV0YS54QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC54QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd4JykpO1xuICAgIGNvbnN0IHlpZCA9IG1ldGEueUF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueUF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneScpKTtcbiAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gbWV0YS5pbmRleEF4aXM7XG4gICAgY29uc3QgaWlkID0gbWV0YS5pQXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB4aWQsIHlpZCwgcmlkKTtcbiAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgIG1ldGEueFNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHhpZCk7XG4gICAgbWV0YS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeWlkKTtcbiAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgIG1ldGEuaVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGlpZCk7XG4gICAgbWV0YS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQodmlkKTtcbiAgfVxuXG4gIGdldERhdGFzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNjYWxlSURcblx0ICogQHJldHVybiB7U2NhbGV9XG5cdCAqL1xuICBnZXRTY2FsZUZvcklkKHNjYWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kYXRhQ2hlY2soKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICBjb25zdCBfZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAvLyBJbiBvcmRlciB0byBjb3JyZWN0bHkgaGFuZGxlIGRhdGEgYWRkaXRpb24vZGVsZXRpb24gYW5pbWF0aW9uIChhbmQgdGh1cyBzaW11bGF0ZVxuICAgIC8vIHJlYWwtdGltZSBjaGFydHMpLCB3ZSBuZWVkIHRvIG1vbml0b3IgdGhlc2UgZGF0YSBtb2RpZmljYXRpb25zIGFuZCBzeW5jaHJvbml6ZVxuICAgIC8vIHRoZSBpbnRlcm5hbCBtZXRhZGF0YSBhY2NvcmRpbmdseS5cblxuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEsIG1ldGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcbiAgICAgICAgLy8gRGlzY2FyZCBvbGQgcGFyc2VkIGRhdGEgYW5kIHN0YWNrc1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuXG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cblxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIC8vIG1ha2Ugc3VyZSBjYWNoZWQgX3N0YWNrZWQgc3RhdHVzIGlzIGN1cnJlbnRcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcblxuICAgIC8vIGRldGVjdCBjaGFuZ2UgaW4gc3RhY2sgb3B0aW9uXG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICAvLyByZW1vdmUgdmFsdWVzIGZyb20gb2xkIHN0YWNrXG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cblxuICAgIC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG4gICAgLy8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcblxuICAgIC8vIGlmIHN0YWNrIGNoYW5nZWQsIHVwZGF0ZSBzdGFjayB2YWx1ZXMgZm9yIHRoZSB3aG9sZSBkYXRhc2V0XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBNZXJnZXMgdXNlci1zdXBwbGllZCBhbmQgZGVmYXVsdCBkYXRhc2V0LWxldmVsIG9wdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldFNjb3BlS2V5cyh0aGlzLl90eXBlKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMsIHRydWUpO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLl9wYXJzaW5nID0gdGhpcy5vcHRpb25zLnBhcnNpbmc7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG5cdCAqL1xuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IG1ldGEsIF9kYXRhOiBkYXRhfSA9IHRoaXM7XG4gICAgY29uc3Qge2lTY2FsZSwgX3N0YWNrZWR9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuXG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYgPSAoKSA9PiBjdXJbaUF4aXNdID09PSBudWxsIHx8IChwcmV2ICYmIGN1cltpQXhpc10gPCBwcmV2W2lBeGlzXSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaSArIHN0YXJ0XSA9IGN1ciA9IHBhcnNlZFtpXTtcbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgIGlmIChpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldigpKSB7XG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWV0YS5fc29ydGVkID0gc29ydGVkO1xuICAgIH1cblxuICAgIGlmIChfc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgWzEsMyw0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eFNjYWxlMDogMCwgeVNjYWxlMDogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIFtpQXhpc106IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaW5kZXhdLCBpbmRleCksXG4gICAgICAgIFt2QXhpc106IHZTY2FsZS5wYXJzZShkYXRhW2luZGV4XSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIGFycmF5c1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbWzEsMl0sWzMsNF1dXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuXG5cdCAqIEV4YW1wbGU6IHt4OiAwLCB5OiAxfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShpdGVtWzBdLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShpdGVtWzFdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbe3g6MSwgeTo1fSwge3g6MiwgeToxMH1dXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuIF9jdXN0b20gaXMgb3B0aW9uYWxcblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDEsIF9jdXN0b206IHtyOiAxMCwgZm9vOiAnYmFyJ319XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB4QXhpc0tleSksIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0UGFyc2VkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YUVsZW1lbnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBhcHBseVN0YWNrKHNjYWxlLCBwYXJzZWQsIG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICB2YWx1ZXM6IHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNcbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICB9XG4gICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWluTWF4KHNjYWxlLCBjYW5TdGFjaykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgIGNvbnN0IHN0YWNrID0gY3JlYXRlU3RhY2soY2FuU3RhY2ssIG1ldGEsIHRoaXMuY2hhcnQpO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICBsZXQgaSwgcGFyc2VkO1xuXG4gICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgcmV0dXJuICFpc0Zpbml0ZShwYXJzZWRbc2NhbGUuYXhpc10pIHx8IG90aGVyTWluID4gb3RoZXJWYWx1ZSB8fCBvdGhlck1heCA8IG90aGVyVmFsdWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAvLyBpZiB0aGUgZGF0YSBpcyBzb3J0ZWQsIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZnVydGhlciBmcm9tIHRoaXMgZW5kIG9mIGFycmF5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICAvLyBpbiB0aGUgc29ydGVkIGNhc2UsIGZpbmQgZmlyc3Qgbm9uLXNraXBwZWQgdmFsdWUgZnJvbSBvdGhlciBlbmQgb2YgYXJyYXlcbiAgICAgIGZvciAoaSA9IGlsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBnZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWQ7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGksIGlsZW4sIHZhbHVlO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogaVNjYWxlID8gJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSA6ICcnLFxuICAgICAgdmFsdWU6IHZTY2FsZSA/ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSkgOiAnJ1xuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KHRoaXMub3B0aW9ucy5jbGlwLCBkZWZhdWx0Q2xpcChtZXRhLnhTY2FsZSwgbWV0YS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuXHQgKi9cbiAgdXBkYXRlKG1vZGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhY3RpdmUgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2RyYXdTdGFydCB8fCAwO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZHJhd0NvdW50IHx8IChlbGVtZW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgY29uc3QgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0aGlzLm9wdGlvbnMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3A7XG4gICAgbGV0IGk7XG5cbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSAmJiBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCkge1xuICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuZHJhdyhjdHgsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFjdGl2ZVtpXS5kcmF3KGN0eCwgYXJlYSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSBzZXQgb2YgcHJlZGVmaW5lZCBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBkYXRhc2V0XG5cdCAqIG9yIHRoZSBkYXRhIGlmIHRoZSBpbmRleCBpcyBzcGVjaWZpZWRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gZGF0YSBpbmRleFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthY3RpdmVdIC0gdHJ1ZSBpZiBob3ZlclxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IHN0eWxlIG9iamVjdFxuXHQgKi9cbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXRcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXG4gICAgICA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gdGhpcy4kY29udGV4dCB8fFxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG5cbiAgICBjb250ZXh0LmFjdGl2ZSA9ICEhYWN0aXZlO1xuICAgIGNvbnRleHQubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgbW9kZSwgaW5kZXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGVsZW1lbnRUeXBlLCBtb2RlID0gJ2RlZmF1bHQnLCBpbmRleCkge1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGNvbnN0IHNoYXJpbmcgPSB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgJiYgZGVmaW5lZChpbmRleCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNsb25lSWZOb3RTaGFyZWQoY2FjaGVkLCBzaGFyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuZWxlbWVudHNbZWxlbWVudFR5cGVdKTtcbiAgICAvLyBjb250ZXh0IGlzIHByb3ZpZGVkIGFzIGEgZnVuY3Rpb24sIGFuZCBpcyBjYWxsZWQgb25seSBpZiBuZWVkZWQsXG4gICAgLy8gc28gd2UgZG9uJ3QgY3JlYXRlIGEgY29udGV4dCBmb3IgZWFjaCBlbGVtZW50IGlmIG5vdCBuZWVkZWQuXG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG5cbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIC8vIGAkc2hhcmVkYCBpbmRpY2F0ZXMgdGhpcyBzZXQgb2Ygb3B0aW9ucyBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgZWxlbWVudHMuXG4gICAgICAvLyBTaGFyaW5nIGlzIHVzZWQgdG8gcmVkdWNlIG51bWJlciBvZiBwcm9wZXJ0aWVzIHRvIGNoYW5nZSBkdXJpbmcgYW5pbWF0aW9uLlxuICAgICAgdmFsdWVzLiRzaGFyZWQgPSBzaGFyaW5nO1xuXG4gICAgICAvLyBXZSBjYWNoZSBvcHRpb25zIGJ5IGBtb2RlYCwgd2hpY2ggY2FuIGJlICdhY3RpdmUnIGZvciBleGFtcGxlLiBUaGlzIGVuYWJsZXMgdXNcbiAgICAgIC8vIHRvIGhhdmUgdGhlICdhY3RpdmUnIGVsZW1lbnQgb3B0aW9ucyBhbmQgJ2RlZmF1bHQnIG9wdGlvbnMgdG8gc3dpdGNoIGJldHdlZW5cbiAgICAgIC8vIHdoZW4gaW50ZXJhY3RpbmcuXG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIHRyYW5zaXRpb24sIGFjdGl2ZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFuaW1hdGlvbi0ke3RyYW5zaXRpb259YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCB0cmFuc2l0aW9uKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBzaGFyZWQgYmV0d2VlbiBlbGVtZW50c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBkZXRlcm1pbmluZyBpZiBgb3B0aW9uc2Agc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSB1cGRhdGVkIHByb3BlcnRpZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0b2RvIHY0LCByZW5hbWUgdG8gZ2V0U2hhcmVkT3B0aW9ucyBhbmQgcmVtb3ZlIGV4Y2VzcyBmdW5jdGlvbnNcbiAgICovXG4gIF9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKSB7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyA9IHRoaXMuX3NoYXJlZE9wdGlvbnM7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB8fCAoc2hhcmVkT3B0aW9ucyAhPT0gcHJldmlvdXNseVNoYXJlZE9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIHJldHVybiB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIHVwZGF0aW5nIGFuIGVsZW1lbnQgd2l0aCBuZXcgcHJvcGVydGllcywgdXNpbmcgYW5pbWF0aW9ucyB3aGVuIGFwcHJvcHJpYXRlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCBwcm9wZXJ0aWVzLCBtb2RlKSB7XG4gICAgaWYgKGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUpLnVwZGF0ZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSB0byBhbmltYXRlIHRoZSBzaGFyZWQgb3B0aW9ucywgdGhhdCBhcmUgcG90ZW50aWFsbHkgYWZmZWN0aW5nIG11bHRpcGxlIGVsZW1lbnRzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgbW9kZSwgYWN0aXZlKSB7XG4gICAgZWxlbWVudC5hY3RpdmUgPSBhY3RpdmU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSk7XG4gICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUsIGFjdGl2ZSkudXBkYXRlKGVsZW1lbnQsIHtcbiAgICAgIC8vIFdoZW4gZ29pbmcgZnJvbSBhY3RpdmUgdG8gaW5hY3RpdmUsIHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBzaGFyZWQgb3B0aW9ucy5cbiAgICAgIC8vIFRoaXMgd2F5IHRoZSBvbmNlIGhvdmVyZWQgZWxlbWVudCB3aWxsIGVuZCB1cCB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNoYXJlZCBvcHRpb25zIGluc3RhbmNlLCBhZnRlciBhbmltYXRpb24uXG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgZmFsc2UpO1xuICB9XG5cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3NldERhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgLy8gQXBwbHkgY2hhbmdlcyBkZXRlY3RlZCB0aHJvdWdoIGFycmF5IGxpc3RlbmVyc1xuICAgIGZvciAoY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gb2YgdGhpcy5fc3luY0xpc3QpIHtcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcblxuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIC8vIFRPRE86IEl0IGlzIG5vdCBvcHRpbWFsIHRvIGFsd2F5cyBwYXJzZSB0aGUgb2xkIGRhdGFcbiAgICAgIC8vIFRoaXMgaXMgZG9uZSBiZWNhdXNlIHdlIGFyZSBub3QgZGV0ZWN0aW5nIGRpcmVjdCBhc3NpZ25tZW50czpcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XSA9IDEwO1xuICAgICAgLy8gY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhWzVdLnkgPSAxMDtcbiAgICAgIHRoaXMucGFyc2UoMCwgY291bnQpO1xuICAgIH1cblxuICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuICAgICAgdGhpcy5faW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEsIHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIH0gZWxzZSBpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGxldCBpO1xuXG4gICAgY29uc3QgbW92ZSA9IChhcnIpID0+IHtcbiAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XG4gICAgICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSBlbmQ7IGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaSAtIGNvdW50XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vdmUoZGF0YSk7XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIG1vdmUobWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZShzdGFydCwgY291bnQpO1xuXG4gICAgaWYgKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZGF0YSwgc3RhcnQsIGNvdW50LCAncmVzZXQnKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcbiAgICovXG4gIF9zeW5jKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgdGhpcy5fc3luY0xpc3QucHVzaChhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gPSBhcmdzO1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFt0aGlzLmluZGV4LCAuLi5hcmdzXSk7XG4gIH1cblxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50XSk7XG4gIH1cblxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCAwLCAxXSk7XG4gIH1cblxuICBfb25EYXRhU3BsaWNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBuZXdDb3VudF0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gIH1cbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtcbiAgX2FycmF5VW5pcXVlLCBpc0FycmF5LCBpc051bGxPclVuZGVmLFxuICB2YWx1ZU9yRGVmYXVsdCwgcmVzb2x2ZU9iamVjdEtleSwgc2lnbiwgZGVmaW5lZFxufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIHR5cGUpIHtcbiAgaWYgKCFzY2FsZS5fY2FjaGUuJGJhcikge1xuICAgIGNvbnN0IHZpc2libGVNZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpO1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdmlzaWJsZU1ldGFzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh2aXNpYmxlTWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpKTtcbiAgICB9XG4gICAgc2NhbGUuX2NhY2hlLiRiYXIgPSBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlLl9jYWNoZS4kYmFyO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBcIm9wdGltYWxcIiBzYW1wbGUgc2l6ZSB0byBtYWludGFpbiBiYXJzIGVxdWFsbHkgc2l6ZWQgd2hpbGUgcHJldmVudGluZyBvdmVybGFwLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSkge1xuICBjb25zdCBzY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2YWx1ZXMgPSBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgbWV0YS50eXBlKTtcbiAgbGV0IG1pbiA9IHNjYWxlLl9sZW5ndGg7XG4gIGxldCBpLCBpbGVuLCBjdXJyLCBwcmV2O1xuICBjb25zdCB1cGRhdGVNaW5BbmRQcmV2ID0gKCkgPT4ge1xuICAgIGlmIChjdXJyID09PSAzMjc2NyB8fCBjdXJyID09PSAtMzI3NjgpIHtcbiAgICAgIC8vIElnbm9yZSB0cnVuY2F0ZWQgcGl4ZWxzXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKHByZXYpKSB7XG4gICAgICAvLyBjdXJyIC0gcHJldiA9PT0gMCBpcyBpZ25vcmVkXG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xuICAgIH1cbiAgICBwcmV2ID0gY3VycjtcbiAgfTtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlc1tpXSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG5cbiAgcHJldiA9IHVuZGVmaW5lZDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHNjYWxlLnRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG5cbiAgcmV0dXJuIG1pbjtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBcImlkZWFsXCIgY2F0ZWdvcnkgYmFzZWQgb24gdGhlIGFic29sdXRlIGJhciB0aGlja25lc3Mgb3IsIGlmIHVuZGVmaW5lZCBvciBudWxsLFxuICogdXNlcyB0aGUgc21hbGxlc3QgaW50ZXJ2YWwgKHNlZSBjb21wdXRlTWluU2FtcGxlU2l6ZSkgdGhhdCBwcmV2ZW50cyBiYXIgb3ZlcmxhcHBpbmcuIFRoaXNcbiAqIG1vZGUgY3VycmVudGx5IGFsd2F5cyBnZW5lcmF0ZXMgYmFycyBlcXVhbGx5IHNpemVkICh1bnRpbCB3ZSBpbnRyb2R1Y2Ugc2NyaXB0YWJsZSBvcHRpb25zPykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHRoaWNrbmVzcyA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xuICBsZXQgc2l6ZSwgcmF0aW87XG5cbiAgaWYgKGlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xuICAgIHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICByYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIGJhciB0aGlja25lc3MgaXMgZW5mb3JjZWQsIGNhdGVnb3J5IGFuZCBiYXIgcGVyY2VudGFnZXMgYXJlIGlnbm9yZWQuXG4gICAgLy8gTm90ZShTQik6IHdlIGNvdWxkIGFkZCBzdXBwb3J0IGZvciByZWxhdGl2ZSBiYXIgdGhpY2tuZXNzIChlLmcuIGJhclRoaWNrbmVzczogJzUwJScpXG4gICAgLy8gYW5kIGRlcHJlY2F0ZSBiYXJQZXJjZW50YWdlIHNpbmNlIHRoaXMgdmFsdWUgaXMgaWdub3JlZCB3aGVuIHRoaWNrbmVzcyBpcyBhYnNvbHV0ZS5cbiAgICBzaXplID0gdGhpY2tuZXNzICogc3RhY2tDb3VudDtcbiAgICByYXRpbyA9IDE7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbyxcbiAgICBzdGFydDogcnVsZXIucGl4ZWxzW2luZGV4XSAtIChzaXplIC8gMilcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBcIm9wdGltYWxcIiBjYXRlZ29yeSB0aGF0IGdsb2JhbGx5IGFycmFuZ2VzIGJhcnMgc2lkZSBieSBzaWRlIChubyBnYXAgd2hlblxuICogcGVyY2VudGFnZSBvcHRpb25zIGFyZSAxKSwgYmFzZWQgb24gdGhlIHByZXZpb3VzIGFuZCBmb2xsb3dpbmcgY2F0ZWdvcmllcy4gVGhpcyBtb2RlXG4gKiBnZW5lcmF0ZXMgYmFycyB3aXRoIGRpZmZlcmVudCB3aWR0aHMgd2hlbiBkYXRhIGFyZSBub3QgZXZlbmx5IHNwYWNlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHBpeGVscyA9IHJ1bGVyLnBpeGVscztcbiAgY29uc3QgY3VyciA9IHBpeGVsc1tpbmRleF07XG4gIGxldCBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xuICBsZXQgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG4gIGNvbnN0IHBlcmNlbnQgPSBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcblxuICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgIC8vIGZpcnN0IGRhdGE6IGl0cyBzaXplIGlzIGRvdWJsZSBiYXNlZCBvbiB0aGUgbmV4dCBwb2ludCBvcixcbiAgICAvLyBpZiBpdCdzIGFsc28gdGhlIGxhc3QgZGF0YSwgd2UgdXNlIHRoZSBzY2FsZSBzaXplLlxuICAgIHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gbGFzdCBkYXRhOiBpdHMgc2l6ZSBpcyBhbHNvIGRvdWJsZSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcG9pbnQuXG4gICAgbmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG4gIGNvbnN0IHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcblxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxuICAgIHN0YXJ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBjb25zdCBzdGFydFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzBdLCBpKTtcbiAgY29uc3QgZW5kVmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMV0sIGkpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgbGV0IGJhclN0YXJ0ID0gbWluO1xuICBsZXQgYmFyRW5kID0gbWF4O1xuXG4gIGlmIChNYXRoLmFicyhtaW4pID4gTWF0aC5hYnMobWF4KSkge1xuICAgIGJhclN0YXJ0ID0gbWF4O1xuICAgIGJhckVuZCA9IG1pbjtcbiAgfVxuXG4gIC8vIFN0b3JlIGBiYXJFbmRgIChmdXJ0aGVzdCBhd2F5IGZyb20gb3JpZ2luKSBhcyBwYXJzZWQgdmFsdWUsXG4gIC8vIHRvIG1ha2Ugc3RhY2tpbmcgc3RyYWlnaHQgZm9yd2FyZFxuICBpdGVtW3ZTY2FsZS5heGlzXSA9IGJhckVuZDtcblxuICBpdGVtLl9jdXN0b20gPSB7XG4gICAgYmFyU3RhcnQsXG4gICAgYmFyRW5kLFxuICAgIHN0YXJ0OiBzdGFydFZhbHVlLFxuICAgIGVuZDogZW5kVmFsdWUsXG4gICAgbWluLFxuICAgIG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgaWYgKGlzQXJyYXkoZW50cnkpKSB7XG4gICAgcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtW3ZTY2FsZS5heGlzXSA9IHZTY2FsZS5wYXJzZShlbnRyeSwgaSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xuICBsZXQgaSwgaWxlbiwgaXRlbSwgZW50cnk7XG5cbiAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZW50cnkgPSBkYXRhW2ldO1xuICAgIGl0ZW0gPSB7fTtcbiAgICBpdGVtW2lTY2FsZS5heGlzXSA9IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaV0sIGkpO1xuICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXRCYXIoY3VzdG9tKSB7XG4gIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkge1xuICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgIHJldHVybiBzaWduKHNpemUpO1xuICB9XG4gIHJldHVybiAodlNjYWxlLmlzSG9yaXpvbnRhbCgpID8gMSA6IC0xKSAqICh2U2NhbGUubWluID49IGFjdHVhbEJhc2UgPyAxIDogLTEpO1xufVxuXG5mdW5jdGlvbiBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKSB7XG4gIGxldCByZXZlcnNlLCBzdGFydCwgZW5kLCB0b3AsIGJvdHRvbTtcbiAgaWYgKHByb3BlcnRpZXMuaG9yaXpvbnRhbCkge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPiBwcm9wZXJ0aWVzLng7XG4gICAgc3RhcnQgPSAnbGVmdCc7XG4gICAgZW5kID0gJ3JpZ2h0JztcbiAgfSBlbHNlIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlIDwgcHJvcGVydGllcy55O1xuICAgIHN0YXJ0ID0gJ2JvdHRvbSc7XG4gICAgZW5kID0gJ3RvcCc7XG4gIH1cbiAgaWYgKHJldmVyc2UpIHtcbiAgICB0b3AgPSAnZW5kJztcbiAgICBib3R0b20gPSAnc3RhcnQnO1xuICB9IGVsc2Uge1xuICAgIHRvcCA9ICdzdGFydCc7XG4gICAgYm90dG9tID0gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX07XG59XG5cbmZ1bmN0aW9uIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KSB7XG4gIGxldCBlZGdlID0gb3B0aW9ucy5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCByZXMgPSB7fTtcblxuICBpZiAoIWVkZ2UpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVkZ2UgPT09IHRydWUpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSB7dG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlLCBsZWZ0OiB0cnVlfTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219ID0gYm9yZGVyUHJvcHMocHJvcGVydGllcyk7XG5cbiAgaWYgKGVkZ2UgPT09ICdtaWRkbGUnICYmIHN0YWNrKSB7XG4gICAgcHJvcGVydGllcy5lbmFibGVCb3JkZXJSYWRpdXMgPSB0cnVlO1xuICAgIGlmICgoc3RhY2suX3RvcCB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfSBlbHNlIGlmICgoc3RhY2suX2JvdHRvbSB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSBib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1twYXJzZUVkZ2UoYm90dG9tLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9XG4gIH1cblxuICByZXNbcGFyc2VFZGdlKGVkZ2UsIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VFZGdlKGVkZ2UsIGEsIGIsIHJldmVyc2UpIHtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBlZGdlID0gc3dhcChlZGdlLCBhLCBiKTtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYiwgYSk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGEsIGIpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuXG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuICByZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuXG5mdW5jdGlvbiBzdGFydEVuZCh2LCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB2ID09PSAnc3RhcnQnID8gc3RhcnQgOiB2ID09PSAnZW5kJyA/IGVuZCA6IHY7XG59XG5cbmZ1bmN0aW9uIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywge2luZmxhdGVBbW91bnR9LCByYXRpbykge1xuICBwcm9wZXJ0aWVzLmluZmxhdGVBbW91bnQgPSBpbmZsYXRlQW1vdW50ID09PSAnYXV0bydcbiAgICA/IHJhdGlvID09PSAxID8gMC4zMyA6IDBcbiAgICA6IGluZmxhdGVBbW91bnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2Jhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxuXG4gICAgY2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG4gICAgYmFyUGVyY2VudGFnZTogMC45LFxuICAgIGdyb3VwZWQ6IHRydWUsXG5cbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBzY2FsZXM6IHtcbiAgICAgIF9pbmRleF86IHtcbiAgICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgICAgb2Zmc2V0OiB0cnVlLFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgb2Zmc2V0OiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdmFsdWVfOiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBwcmltaXRpdmUgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIGFycmF5IGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIG9iamVjdCBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogdmFsdWUtc2NhbGUgZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgaXRlbSwgb2JqO1xuICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb2JqID0gZGF0YVtpXTtcbiAgICAgIGl0ZW0gPSB7fTtcbiAgICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkob2JqLCBpQXhpc0tleSksIGkpO1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgdkF4aXNLZXkpLCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgaWYgKGN1c3RvbSAmJiBzY2FsZSA9PT0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUpIHtcbiAgICAgIC8vIGZsb2F0IGJhcjogb25seSBvbmUgZW5kIG9mIHRoZSBiYXIgaXMgY29uc2lkZXJlZCBieSBgc3VwZXJgXG4gICAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIGN1c3RvbS5taW4pO1xuICAgICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCBjdXN0b20ubWF4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgdmFsdWUgPSBpc0Zsb2F0QmFyKGN1c3RvbSlcbiAgICAgID8gJ1snICsgY3VzdG9tLnN0YXJ0ICsgJywgJyArIGN1c3RvbS5lbmQgKyAnXSdcbiAgICAgIDogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcblxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcblxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuc3RhY2sgPSB0aGlzLmdldERhdGFzZXQoKS5zdGFjaztcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhtZXRhLmRhdGEsIDAsIG1ldGEuZGF0YS5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYmFycywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpbmRleCwgX2NhY2hlZE1ldGE6IHt2U2NhbGV9fSA9IHRoaXM7XG4gICAgY29uc3QgYmFzZSA9IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdlNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHJ1bGVyID0gdGhpcy5fZ2V0UnVsZXIoKTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgdnBpeGVscyA9IHJlc2V0IHx8IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZTY2FsZS5heGlzXSkgPyB7YmFzZSwgaGVhZDogYmFzZX0gOiB0aGlzLl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpKTtcbiAgICAgIGNvbnN0IGlwaXhlbHMgPSB0aGlzLl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpLCBydWxlcik7XG4gICAgICBjb25zdCBzdGFjayA9IChwYXJzZWQuX3N0YWNrcyB8fCB7fSlbdlNjYWxlLmF4aXNdO1xuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICBiYXNlOiB2cGl4ZWxzLmJhc2UsXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIXN0YWNrIHx8IGlzRmxvYXRCYXIocGFyc2VkLl9jdXN0b20pIHx8IChpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSksXG4gICAgICAgIHg6IGhvcml6b250YWwgPyB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcixcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogdnBpeGVscy5oZWFkLFxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxuICAgICAgICB3aWR0aDogaG9yaXpvbnRhbCA/IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSkgOiBpcGl4ZWxzLnNpemVcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBiYXJzW2ldLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zIHx8IGJhcnNbaV0ub3B0aW9ucztcbiAgICAgIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KTtcbiAgICAgIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywgb3B0aW9ucywgcnVsZXIucmF0aW8pO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGJhcnNbaV0sIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtsYXN0XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XSAtIFRoZSBkYXRhIGluZGV4IG9mIHRoZSBydWxlclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBsaXN0IG9mIHN0YWNrIElEc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFN0YWNrcyhsYXN0LCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCB7aVNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YXNldHMgPSBpU2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModGhpcy5fdHlwZSlcbiAgICAgIC5maWx0ZXIobWV0YSA9PiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKTtcbiAgICBjb25zdCBzdGFja2VkID0gaVNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICBjb25zdCBzdGFja3MgPSBbXTtcbiAgICBjb25zdCBjdXJyZW50UGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpO1xuICAgIGNvbnN0IGlTY2FsZVZhbHVlID0gY3VycmVudFBhcnNlZCAmJiBjdXJyZW50UGFyc2VkW2lTY2FsZS5heGlzXTtcblxuICAgIGNvbnN0IHNraXBOdWxsID0gKG1ldGEpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IG1ldGEuX3BhcnNlZC5maW5kKGl0ZW0gPT4gaXRlbVtpU2NhbGUuYXhpc10gPT09IGlTY2FsZVZhbHVlKTtcbiAgICAgIGNvbnN0IHZhbCA9IHBhcnNlZCAmJiBwYXJzZWRbbWV0YS52U2NhbGUuYXhpc107XG5cbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbCkgfHwgaXNOYU4odmFsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBtZXRhIG9mIG1ldGFzZXRzKSB7XG4gICAgICBpZiAoZGF0YUluZGV4ICE9PSB1bmRlZmluZWQgJiYgc2tpcE51bGwobWV0YSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YWNrZWQgICB8IG1ldGEuc3RhY2tcbiAgICAgIC8vICAgICAgICAgICB8IGZvdW5kIHwgbm90IGZvdW5kIHwgdW5kZWZpbmVkXG4gICAgICAvLyBmYWxzZSAgICAgfCAgIHggICB8ICAgICB4ICAgICB8ICAgICB4XG4gICAgICAvLyB0cnVlICAgICAgfCAgICAgICB8ICAgICB4ICAgICB8XG4gICAgICAvLyB1bmRlZmluZWQgfCAgICAgICB8ICAgICB4ICAgICB8ICAgICB4XG4gICAgICBpZiAoc3RhY2tlZCA9PT0gZmFsc2UgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhLmluZGV4ID09PSBsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHN0YWNrcz8gdGhhdCBtZWFucyB0aGVyZSBpcyBubyB2aXNpYmxlIGRhdGEuIExldCdzIHN0aWxsIGluaXRpYWxpemUgYW4gYHVuZGVmaW5lZGBcbiAgICAvLyBzdGFjayB3aGVyZSBwb3NzaWJsZSBpbnZpc2libGUgYmFycyB3aWxsIGJlIGxvY2F0ZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzYzNjhcbiAgICBpZiAoIXN0YWNrcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgbnVtYmVyIG9mIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFN0YWNrQ291bnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKHVuZGVmaW5lZCwgaW5kZXgpLmxlbmd0aDtcbiAgfVxuXG4gIF9nZXRBeGlzQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEF4aXMoKS5sZW5ndGg7XG4gIH1cblxuICBnZXRGaXJzdFNjYWxlSWRGb3JJbmRleEF4aXMoKSB7XG4gICAgY29uc3Qgc2NhbGVzID0gdGhpcy5jaGFydC5zY2FsZXM7XG4gICAgY29uc3QgaW5kZXhTY2FsZUlkID0gdGhpcy5jaGFydC5vcHRpb25zLmluZGV4QXhpcztcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoa2V5ID0+IHNjYWxlc1trZXldLmF4aXMgPT09IGluZGV4U2NhbGVJZCkuc2hpZnQoKTtcbiAgfVxuXG4gIF9nZXRBeGlzKCkge1xuICAgIGNvbnN0IGF4aXMgPSB7fTtcbiAgICBjb25zdCBmaXJzdFNjYWxlQXhpc0lkID0gdGhpcy5nZXRGaXJzdFNjYWxlSWRGb3JJbmRleEF4aXMoKTtcbiAgICBmb3IgKGNvbnN0IGRhdGFzZXQgb2YgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzKSB7XG4gICAgICBheGlzW3ZhbHVlT3JEZWZhdWx0KFxuICAgICAgICB0aGlzLmNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzID09PSAneCcgPyBkYXRhc2V0LnhBeGlzSUQgOiBkYXRhc2V0LnlBeGlzSUQsIGZpcnN0U2NhbGVBeGlzSWRcbiAgICAgICldID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGF4aXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgLy8gYmFyIHRoaWNrbmVzcyByYXRpbyB1c2VkIGZvciBub24tZ3JvdXBlZCBiYXJzXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZCwgaW5kZXg6IGRhdGFzZXRJbmRleH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIC8vIGJhcnMgY3Jvc3Npbmcgb3JpZ2luIGFyZSBub3Qgc3RhY2tlZFxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG5cbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gbm90IHZpc2libGUsIG5vIGhlaWdodFxuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuXG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuXG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuXG4gICAgICBpZiAoX3N0YWNrZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgIC8vIHZpc3VhbCBkYXRhIGNvb3JkaW5hdGVzIGFmdGVyIGFwcGx5aW5nIG1pbkJhckxlbmd0aFxuICAgICAgICBwYXJzZWQuX3N0YWNrc1t2U2NhbGUuYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoaGVhZCkgLSB2U2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChiYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgY29uc3QgYXhpc0NvdW50ID0gdGhpcy5fZ2V0QXhpc0NvdW50KCk7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50ICogYXhpc0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQgKiBheGlzQ291bnQpO1xuICAgICAgY29uc3QgYXhpc0lEID0gdGhpcy5jaGFydC5vcHRpb25zLmluZGV4QXhpcyA9PT0gJ3gnID8gdGhpcy5nZXREYXRhc2V0KCkueEF4aXNJRCA6IHRoaXMuZ2V0RGF0YXNldCgpLnlBeGlzSUQ7XG4gICAgICBjb25zdCBheGlzTnVtYmVyID0gdGhpcy5fZ2V0QXhpcygpLmluZGV4T2YodmFsdWVPckRlZmF1bHQoYXhpc0lELCB0aGlzLmdldEZpcnN0U2NhbGVJZEZvckluZGV4QXhpcygpKSk7XG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKSArIGF4aXNOdW1iZXI7XG4gICAgICBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCByYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIG5vbi1ncm91cGVkIGJhciBjaGFydHMsIGV4YWN0IHBpeGVsIHZhbHVlcyBhcmUgdXNlZFxuICAgICAgY2VudGVyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpbmRleClbc2NhbGUuYXhpc10sIGluZGV4KTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJ1bGVyLm1pbiAqIHJ1bGVyLnJhdGlvKTtcbiAgICB9XG5cblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwgJiYgIXJlY3RzW2ldLmhpZGRlbikge1xuICAgICAgICByZWN0c1tpXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWJibGVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdidWJibGUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJ11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgeDoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgYXJyYXlzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW1bMl0sIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW0gJiYgaXRlbS5yICYmICtpdGVtLnIsIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAociA/ICcsICcgKyByIDogJycpICsgJyknXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gIXJlc2V0ICYmIHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSByZXNldCA/IGlTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10pO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFt2QXhpc10pO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuXG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21vZGVdXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xuXG4gICAgLy8gSW4gY2FzZSB2YWx1ZXMgd2VyZSBjYWNoZWQgKGFuZCB0aHVzIGZyb3plbiksIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHZhbHVlc1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7JHNoYXJlZDogZmFsc2V9KTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cbiAgICBjb25zdCByYWRpdXMgPSB2YWx1ZXMucmFkaXVzO1xuICAgIGlmIChtb2RlICE9PSAnYWN0aXZlJykge1xuICAgICAgdmFsdWVzLnJhZGl1cyA9IDA7XG4gICAgfVxuICAgIHZhbHVlcy5yYWRpdXMgKz0gdmFsdWVPckRlZmF1bHQocGFyc2VkICYmIHBhcnNlZC5fY3VzdG9tLCByYWRpdXMpO1xuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuIiwiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCByZXNvbHZlT2JqZWN0S2V5LCB0b1BlcmNlbnRhZ2UsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgVEFVLCBIQUxGX1BJLCBfYW5nbGVCZXR3ZWVufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuZnVuY3Rpb24gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCkge1xuICBsZXQgcmF0aW9YID0gMTtcbiAgbGV0IHJhdGlvWSA9IDE7XG4gIGxldCBvZmZzZXRYID0gMDtcbiAgbGV0IG9mZnNldFkgPSAwO1xuICAvLyBJZiB0aGUgY2hhcnQncyBjaXJjdW1mZXJlbmNlIGlzbid0IGEgZnVsbCBjaXJjbGUsIGNhbGN1bGF0ZSBzaXplIGFzIGEgcmF0aW8gb2YgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYXJjXG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2RvdWdobnV0JztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgRG91Z2hudXRcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuICAgICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG4gICAgY3V0b3V0OiAnNTAlJyxcblxuICAgIC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG4gICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuXG4gICAgLy8gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY2hhcnRcbiAgICByYWRpdXM6ICcxMDAlJyxcblxuICAgIC8vIFNwYWNpbmcgYmV0d2VlbiBhcmNzXG4gICAgc3BhY2luZzogMCxcblxuICAgIGluZGV4QXhpczogJ3InLFxuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2JvcmRlckRhc2gnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdob3ZlckJvcmRlckRhc2gnKSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICAvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcbiAgICBwbHVnaW5zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGUsIHRleHRBbGlnbiwgY29sb3IsIHVzZUJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogdXNlQm9yZGVyUmFkaXVzICYmIChib3JkZXJSYWRpdXMgfHwgc3R5bGUuYm9yZGVyUmFkaXVzKSxcbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcblxuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsaW5rU2NhbGVzKCkge31cblxuICAvKipcblx0ICogT3ZlcnJpZGUgZGF0YSBwYXJzaW5nLCBzaW5jZSB3ZSBhcmUgbm90IHVzaW5nIHNjYWxlc1xuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG5cbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZXR0ZXIgPSAoaSkgPT4gK2RhdGFbaV07XG5cbiAgICAgIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgY29uc3Qge2tleSA9ICd2YWx1ZSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgZ2V0dGVyID0gKGkpID0+ICtyZXNvbHZlT2JqZWN0S2V5KGRhdGFbaV0sIGtleSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpXSA9IGdldHRlcihpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5yb3RhdGlvbiAtIDkwKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBtYXhpbWFsIHJvdGF0aW9uICYgY2lyY3VtZmVyZW5jZSBleHRlbnRzXG5cdCAqIGFjcm9zcyBhbGwgdmlzaWJsZSBkYXRhc2V0cy5cblx0ICovXG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkudHlwZSA9PT0gdGhpcy5fdHlwZSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG5cbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3RhdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm90YXRpb24gKyBjaXJjdW1mZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IG1pbixcbiAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pbixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlXG5cdCAqL1xuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KChNYXRoLm1pbihjaGFydEFyZWEud2lkdGgsIGNoYXJ0QXJlYS5oZWlnaHQpIC0gc3BhY2luZykgLyAyLCAwKTtcbiAgICBjb25zdCBjdXRvdXQgPSBNYXRoLm1pbih0b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gdGhpcy5fZ2V0UmluZ1dlaWdodCh0aGlzLmluZGV4KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1heGltYWwgcm90YXRpb24gJiBjaXJjdW1mZXJlbmNlIGxpbWl0cy5cbiAgICAvLyBJZiB3ZSBvbmx5IGNvbnNpZGVyIG91ciBkYXRhc2V0LCB0aGlzIGNhbiBjYXVzZSBwcm9ibGVtcyB3aGVuIHR3byBkYXRhc2V0c1xuICAgIC8vIGFyZSBib3RoIGxlc3MgdGhhbiBhIGNpcmNsZSB3aXRoIGRpZmZlcmVudCByb3RhdGlvbnMgKHN0YXJ0aW5nIGFuZ2xlcylcbiAgICBjb25zdCB7Y2lyY3VtZmVyZW5jZSwgcm90YXRpb259ID0gdGhpcy5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgY29uc3Qge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfSA9IGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gdGhpcy5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG5cbiAgICBtZXRhLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpO1xuXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcblxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5vdXRlclJhZGl1cztcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlVG90YWwoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodmFsdWUpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgaWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gVEFVICogKE1hdGguYWJzKHZhbHVlKSAvIHRvdGFsKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBnZXRNYXhCb3JkZXJXaWR0aChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxldCBpLCBpbGVuLCBtZXRhLCBjb250cm9sbGVyLCBvcHRpb25zO1xuXG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICAvLyBGaW5kIHRoZSBvdXRtb3N0IHZpc2libGUgZGF0YXNldFxuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgIGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvcHRpb25zID0gY29udHJvbGxlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuXG4gIGdldE1heE9mZnNldChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgcmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmluZ1dlaWdodChkYXRhc2V0SW5kZXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmxlIGRhdGEgc2V0IHdlaWdodHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICB9XG59XG4iLCJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCBfc2NhbGVSYW5nZXNDaGFuZ2VkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcblxuICAgIHNob3dMaW5lOiB0cnVlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICBfaW5kZXhfOiB7XG4gICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICB9LFxuICAgICAgX3ZhbHVlXzoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgIH0sXG4gICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG5cbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcblxuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIExpbmVcbiAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgY29uc3QgcG9pbnRzQ291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG5cbiAgICAgIGlmIChpIDwgc3RhcnQgfHwgaSA+PSBlbmQpIHtcbiAgICAgICAgcHJvcGVydGllcy5za2lwID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIFBJLCBmb3JtYXROdW1iZXIsIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3BvbGFyQXJlYSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICBhbmltYXRlU2NhbGU6IHRydWVcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxuICAgICAgfSxcbiAgICB9LFxuICAgIGluZGV4QXhpczogJ3InLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgcGx1Z2luczoge1xuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGUsIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcblxuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG5cbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNjYWxlczoge1xuICAgICAgcjoge1xuICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY2lyY3VsYXI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzdGFydEFuZ2xlOiAwXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcblxuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XS5yLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0TWluTWF4KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG5cbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yO1xuXG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgaWYgKHBhcnNlZCA8IHJhbmdlLm1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IHBhcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZWQgPiByYW5nZS5tYXgpIHtcbiAgICAgICAgICByYW5nZS5tYXggPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuXG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG5cbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAocmFkaXVzTGVuZ3RoICogdGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuXG4gICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIGFuZ2xlICs9IHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICBsZXQgZW5kQW5nbGUgPSBhbmdsZSArIHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgICAgbGV0IG91dGVyUmFkaXVzID0gY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgPyBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKS5yKSA6IDA7XG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuXG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlKSB7XG4gICAgICAgICAgb3V0ZXJSYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNOYU4odGhpcy5nZXRQYXJzZWQoaW5kZXgpLnIpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxuICAgICAgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpXG4gICAgICA6IDA7XG4gIH1cbn1cbiIsImltcG9ydCBEb3VnaG51dENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyLmRvdWdobnV0LmpzJztcblxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpZUNvbnRyb2xsZXIgZXh0ZW5kcyBEb3VnaG51dENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdwaWUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cbiAgICBjdXRvdXQ6IDAsXG5cbiAgICAvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLy8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcblxuICAgIC8vIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNoYXJ0XG4gICAgcmFkaXVzOiAnMTAwJSdcbiAgfTtcbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3JhZGFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgaW5kZXhBeGlzOiAncicsXG4gICAgc2hvd0xpbmU6IHRydWUsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgZmlsbDogJ3N0YXJ0J1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICByOiB7XG4gICAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBVcGRhdGUgTGluZVxuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIC8vIEluIHJlc2l6ZSBtb2RlIG9ubHkgcG9pbnQgbG9jYXRpb25zIGNoYW5nZSwgc28gbm8gbmVlZCB0byBzZXQgdGhlIHBvaW50cyBvciBvcHRpb25zLlxuICAgIGlmIChtb2RlICE9PSAncmVzaXplJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHRoaXMuZ2V0UGFyc2VkKGkpLnIpO1xuXG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYW5nbGU6IHBvaW50UG9zaXRpb24uYW5nbGUsXG4gICAgICAgIHNraXA6IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgX3NjYWxlUmFuZ2VzQ2hhbmdlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdzY2F0dGVyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICBzaG93TGluZTogZmFsc2UsXG4gICAgZmlsbDogZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG5cbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgbW9kZTogJ3BvaW50J1xuICAgIH0sXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArICcpJ1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhOiBwb2ludHMgPSBbXX0gPSBtZXRhO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuXG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG5cbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzExMzMzXG4gICAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBfZGF0YXNldH0gPSBtZXRhO1xuXG4gICAgICAvLyBVcGRhdGUgTGluZVxuICAgICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBtb2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMTEzMzNcbiAgICAgIGRlbGV0ZSBtZXRhLmRhdGFzZXQ7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuXG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHtzaG93TGluZX0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHNob3dMaW5lKSB7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IHRoaXMuY2hhcnQucmVnaXN0cnkuZ2V0RWxlbWVudCgnbGluZScpO1xuICAgIH1cblxuICAgIHN1cGVyLmFkZEVsZW1lbnRzKCk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGxldCBtYXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuXG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG59XG4iLCIvKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAc2luY2UgMi44LjBcbiAqIEBwcml2YXRlXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0T3B0aW9uc30gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5leHBvcnQgdHlwZSBUaW1lVW5pdCA9ICdtaWxsaXNlY29uZCcgfCAnc2Vjb25kJyB8ICdtaW51dGUnIHwgJ2hvdXInIHwgJ2RheScgfCAnd2VlaycgfCAnbW9udGgnIHwgJ3F1YXJ0ZXInIHwgJ3llYXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVBZGFwdGVyPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+IHtcbiAgcmVhZG9ubHkgb3B0aW9uczogVDtcbiAgLyoqXG4gICAqIFdpbGwgY2FsbGVkIHdpdGggY2hhcnQgb3B0aW9ucyBhZnRlciBhZGFwdGVyIGNyZWF0aW9uLlxuICAgKi9cbiAgaW5pdCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgY2hhcnRPcHRpb25zOiBDaGFydE9wdGlvbnMpOiB2b2lkO1xuICAvKipcbiAgICogUmV0dXJucyBhIG1hcCBvZiB0aW1lIGZvcm1hdHMgZm9yIHRoZSBzdXBwb3J0ZWQgZm9ybWF0dGluZyB1bml0cyBkZWZpbmVkXG4gICAqIGluIFVuaXQgYXMgd2VsbCBhcyAnZGF0ZXRpbWUnIHJlcHJlc2VudGluZyBhIGRldGFpbGVkIGRhdGUvdGltZSBzdHJpbmcuXG4gICAqL1xuICBmb3JtYXRzKHRoaXM6IERhdGVBZGFwdGVyPFQ+KTogUmVjb3JkPFRpbWVVbml0IHwgJ2RhdGV0aW1lJywgc3RyaW5nPjtcbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gYHZhbHVlYCBhbmQgcmV0dXJuIHRoZSBhc3NvY2lhdGVkIHRpbWVzdGFtcC5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHBhcnNlICh1c3VhbGx5IGNvbWVzIGZyb20gdGhlIGRhdGEpXG4gICAqIEBwYXJhbSBbZm9ybWF0XSAtIHRoZSBleHBlY3RlZCBkYXRhIGZvcm1hdFxuICAgKi9cbiAgcGFyc2UodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHZhbHVlOiB1bmtub3duLCBmb3JtYXQ/OiBzdHJpbmcpOiBudW1iZXIgfCBudWxsO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZm9ybWF0dGVkIGRhdGUgaW4gdGhlIHNwZWNpZmllZCBgZm9ybWF0YCBmb3IgYSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSB0aW1lc3RhbXAgdG8gZm9ybWF0XG4gICAqIEBwYXJhbSBmb3JtYXQgLSB0aGUgZGF0ZS90aW1lIHRva2VuXG4gICAqL1xuICBmb3JtYXQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCBmb3JtYXQ6IHN0cmluZyk6IHN0cmluZztcbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGFkZCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIGFtb3VudDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBgdW5pdGAgYmV0d2VlbiB0aGUgZ2l2ZW4gdGltZXN0YW1wcy5cbiAgICogQHBhcmFtIGEgLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG4gICAqIEBwYXJhbSBiIC0gdGhlIHRpbWVzdGFtcCB0byBzdWJ0cmFjdFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgZGlmZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgYTogbnVtYmVyLCBiOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyBzdGFydCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICogQHBhcmFtIFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcbiAgICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cbiAgICovXG4gIHN0YXJ0T2YodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCB8ICdpc29XZWVrJywgd2Vla2RheT86IG51bWJlciB8IGJvb2xlYW4pOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGVuZCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGVuZE9mKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgdW5pdDogVGltZVVuaXQpOiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIGFic3RyYWN0PFQgPSB2b2lkPigpOiBUIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IENoZWNrIHRoYXQgYSBjb21wbGV0ZSBkYXRlIGFkYXB0ZXIgaXMgcHJvdmlkZWQuJyk7XG59XG5cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRGF0ZUFkYXB0ZXJCYXNlIGltcGxlbWVudHMgRGF0ZUFkYXB0ZXIge1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBkZWZhdWx0IGRhdGUgYWRhcHRlciBtZXRob2RzLlxuICAgKiBBY2NlcHRzIHR5cGUgcGFyYW1ldGVyIHRvIGRlZmluZSBvcHRpb25zIHR5cGUuXG4gICAqIEBleGFtcGxlXG4gICAqIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZS5vdmVycmlkZTx7bXlBZGFwdGVyT3B0aW9uOiBzdHJpbmd9Pih7XG4gICAqICAgaW5pdCgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKHRoaXMub3B0aW9ucy5teUFkYXB0ZXJPcHRpb24pO1xuICAgKiAgIH1cbiAgICogfSlcbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZTxUIGV4dGVuZHMgQW55T2JqZWN0ID0gQW55T2JqZWN0PihcbiAgICBtZW1iZXJzOiBQYXJ0aWFsPE9taXQ8RGF0ZUFkYXB0ZXI8VD4sICdvcHRpb25zJz4+XG4gICkge1xuICAgIE9iamVjdC5hc3NpZ24oRGF0ZUFkYXB0ZXJCYXNlLnByb3RvdHlwZSwgbWVtYmVycyk7XG4gIH1cblxuICByZWFkb25seSBvcHRpb25zOiBBbnlPYmplY3Q7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IEFueU9iamVjdCkge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGluaXQoKSB7fVxuXG4gIGZvcm1hdHMoKTogUmVjb3JkPFRpbWVVbml0IHwgJ2RhdGV0aW1lJywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBwYXJzZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGZvcm1hdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgYWRkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBkaWZmKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBzdGFydE9mKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBlbmRPZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX2RhdGU6IERhdGVBZGFwdGVyQmFzZSBhcyB7XG4gICAgbmV3IChvcHRpb25zPzogQW55T2JqZWN0KTogRGF0ZUFkYXB0ZXI7XG4gICAgb3ZlcnJpZGU8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4oXG4gICAgICBtZW1iZXJzOiBQYXJ0aWFsPE9taXQ8RGF0ZUFkYXB0ZXI8VD4sICdvcHRpb25zJz4+XG4gICAgKTogdm9pZDtcbiAgfVxufTtcbiIsImltcG9ydCB7X2xvb2t1cEJ5S2V5LCBfcmxvb2t1cEJ5S2V5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2dldFJlbGF0aXZlUG9zaXRpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfaXNQb2ludEluQXJlYSwgaXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYge3theGlzPzogc3RyaW5nLCBpbnRlcnNlY3Q/OiBib29sZWFuLCBpbmNsdWRlSW52aXNpYmxlPzogYm9vbGVhbn19IEludGVyYWN0aW9uT3B0aW9uc1xuICogQHR5cGVkZWYge3tkYXRhc2V0SW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlciwgZWxlbWVudDogaW1wb3J0KCcuL2NvcmUuZWxlbWVudC5qcycpLmRlZmF1bHR9fSBJbnRlcmFjdGlvbkl0ZW1cbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLlBvaW50IH0gUG9pbnRcbiAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBkbyBiaW5hcnkgc2VhcmNoIHdoZW4gcG9zc2libGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhc2V0IC0gdGhlIGRhdGFzZXQgbWV0YVxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBzaG91bGQgdGhlIGVsZW1lbnQgaW50ZXJzZWN0XG4gKiBAcmV0dXJucyB7e2xvOm51bWJlciwgaGk6bnVtYmVyfX0gaW5kaWNlcyB0byBzZWFyY2ggZGF0YSBhcnJheSBiZXR3ZWVuXG4gKi9cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChtZXRhc2V0LCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IHtjb250cm9sbGVyLCBkYXRhLCBfc29ydGVkfSA9IG1ldGFzZXQ7XG4gIGNvbnN0IGlTY2FsZSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGEuaVNjYWxlO1xuICBjb25zdCBzcGFuR2FwcyA9IG1ldGFzZXQuZGF0YXNldCA/IG1ldGFzZXQuZGF0YXNldC5vcHRpb25zID8gbWV0YXNldC5kYXRhc2V0Lm9wdGlvbnMuc3BhbkdhcHMgOiBudWxsIDogbnVsbDtcblxuICBpZiAoaVNjYWxlICYmIGF4aXMgPT09IGlTY2FsZS5heGlzICYmIGF4aXMgIT09ICdyJyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgbG9va3VwTWV0aG9kID0gaVNjYWxlLl9yZXZlcnNlUGl4ZWxzID8gX3Jsb29rdXBCeUtleSA6IF9sb29rdXBCeUtleTtcbiAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlKTtcbiAgICAgIGlmIChzcGFuR2Fwcykge1xuICAgICAgICBjb25zdCB7dlNjYWxlfSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IHtfcGFyc2VkfSA9IG1ldGFzZXQ7XG5cbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRMbyA9IChfcGFyc2VkXG4gICAgICAgICAgLnNsaWNlKDAsIHJlc3VsdC5sbyArIDEpXG4gICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIHJlc3VsdC5sbyAtPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZExvKTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZEhpID0gKF9wYXJzZWRcbiAgICAgICAgICAuc2xpY2UocmVzdWx0LmhpKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIHJlc3VsdC5oaSArPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZEhpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICAvLyBfc2hhcmVkT3B0aW9ucyBpbmRpY2F0ZXMgdGhhdCBlYWNoIGVsZW1lbnQgaGFzIGVxdWFsIG9wdGlvbnMgLT4gZXF1YWwgcHJvcG9ydGlvbnNcbiAgICAgIC8vIFNvIHdlIGNhbiBkbyBhIHJhbmdlZCBiaW5hcnkgc2VhcmNoIGJhc2VkIG9uIHRoZSByYW5nZSBvZiBmaXJzdCBlbGVtZW50IGFuZFxuICAgICAgLy8gYmUgY29uZmlkZW50IHRvIGdldCB0aGUgZnVsbCByYW5nZSBvZiBpbmRpY2VzIHRoYXQgY2FuIGludGVyc2VjdCB3aXRoIHRoZSB2YWx1ZS5cbiAgICAgIGNvbnN0IGVsID0gZGF0YVswXTtcbiAgICAgIGNvbnN0IHJhbmdlID0gdHlwZW9mIGVsLmdldFJhbmdlID09PSAnZnVuY3Rpb24nICYmIGVsLmdldFJhbmdlKGF4aXMpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlIC0gcmFuZ2UpO1xuICAgICAgICBjb25zdCBlbmQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgKyByYW5nZSk7XG4gICAgICAgIHJldHVybiB7bG86IHN0YXJ0LmxvLCBoaTogZW5kLmhpfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRGVmYXVsdCB0byBhbGwgZWxlbWVudHMsIHdoZW4gYmluYXJ5IHNlYXJjaCBjYW4gbm90IGJlIHVzZWQuXG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBzZWxlY3QgY2FuZGlkYXRlIGVsZW1lbnRzIGZvciBpbnRlcmFjdGlvblxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gY29uc2lkZXIgaW50ZXJzZWN0aW5nIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCB7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV07XG4gICAgY29uc3Qge2xvLCBoaX0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICBjb25zdCBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBldmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhX2lzUG9pbnRJbkFyZWEoZWxlbWVudCwgY2hhcnQuY2hhcnRBcmVhLCAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jLCB0cnVlKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGZvciBhIHJhZGlhbCBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBsZXQgaXRlbXMgPSBbXTtcblxuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlfSA9IGVsZW1lbnQuZ2V0UHJvcHMoWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZX0gPSBnZXRBbmdsZUZyb21Qb2ludChlbGVtZW50LCB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX0pO1xuXG4gICAgaWYgKF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGZvciBhIGNhcnRlc2lhbiBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGNvbnN0IGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpO1xuICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IGluUmFuZ2UgPSBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgaWYgKGludGVyc2VjdCAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgcG9pbnRJbkFyZWEgPSAhIWluY2x1ZGVJbnZpc2libGUgfHwgY2hhcnQuaXNQb2ludEluQXJlYShjZW50ZXIpO1xuICAgIGlmICghcG9pbnRJbkFyZWEgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcyA9IFt7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH1dO1xuICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgLy8gQ2FuIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgaW4gd2hpY2ggY2FzZSB3ZSBzb3J0IGJ5IHNpemVcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBjb25zaWRlcmluZyBhbGwgdmlzaWJsZSBpdGVtcyBpbiB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gYXhpcyA9PT0gJ3InICYmICFpbnRlcnNlY3RcbiAgICA/IGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXG4gICAgOiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG1hdGNoaW5nIGFsb25nIHRoZSBnaXZlbiBYIG9yIFkgYXhpc1xuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyB0byBtYXRjaFxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHJhbmdlTWV0aG9kID0gYXhpcyA9PT0gJ3gnID8gJ2luWFJhbmdlJyA6ICdpbllSYW5nZSc7XG4gIGxldCBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XG4gICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdICYmIGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSBpbnRlcnNlY3RzSXRlbSB8fCBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuICAvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG4gIGlmIChpbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBDb250YWlucyBpbnRlcmFjdGlvbiByZWxhdGVkIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8vIFBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgdG8gZmFjaWxpdGF0ZSBkZXZlbG9wZXJzIGNyZWF0aW5nIHRoZWlyIG93biBtb2Rlc1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMsXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcbiAgbW9kZXM6IHtcbiAgICAvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgbW9kZSBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4IGFzIHRoYXQgaXRlbVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgaW5kZXgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICAvLyBEZWZhdWx0IGF4aXMgZm9yIGluZGV4IG1vZGUgaXMgJ3gnIHRvIG1hdGNoIG9sZCBiZWhhdmlvdXJcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpXG4gICAgICAgIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcblxuICAgICAgICAvLyBkb24ndCBjb3VudCBpdGVtcyB0aGF0IGFyZSBza2lwcGVkIChudWxsIGRhdGEpXG4gICAgICAgIGlmIChlbGVtZW50ICYmICFlbGVtZW50LnNraXApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXgsIGluZGV4fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgaW4gdGhlIHNhbWUgZGF0YXNldC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgaW4gdGhhdCBkYXRhc2V0XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgZGF0YXNldChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkgOlxuICAgICAgICBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IGl0ZW1zWzBdLmRhdGFzZXRJbmRleDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuZGF0YTtcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudDogZGF0YVtpXSwgZGF0YXNldEluZGV4LCBpbmRleDogaX0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIG9mIHRoZSBldmVudFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgcG9pbnQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIHggbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHggY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3gnLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIHkgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHkgY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy55XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3knLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHtkZWZpbmVkLCBlYWNoLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1BhZGRpbmd9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcblxuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG4vKipcbiAqIHN0b3JlIGRpbWVuc2lvbnMgdXNlZCBpbnN0ZWFkIG9mIGF2YWlsYWJsZSBjaGFydEFyZWEgaW4gZml0Qm94ZXNcbiAqKi9cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgLy8gZHluYW1pY2FsbHkgcGxhY2VkIGJveGVzIHNpemUgaXMgbm90IGNvbnNpZGVyZWRcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICAvLyB0aGlzIGxheW91dCB3YXMgYWxyZWFkeSBjb3VudGVkIGZvciwgbGV0cyBmaXJzdCByZWR1Y2Ugb2xkIHNpemVcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cblxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG5cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuXG4gIC8vIHJldHVybiBib29sZWFucyBvbiB0aGUgY2hhbmdlcyBwZXIgZGlyZWN0aW9uXG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG5cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuXG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuXG4gICAgLy8gRGltZW5zaW9ucyBjaGFuZ2VkIGFuZCB0aGVyZSB3ZXJlIG5vbiBmdWxsIHdpZHRoIGJveGVzIGJlZm9yZSB0aGlzXG4gICAgLy8gLT4gd2UgaGF2ZSB0byByZWZpdCB0aG9zZVxuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG5cbiAgICAvLyBDaGFydCBhcmVhIGNoYW5nZWQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuXG4gICAgaWYgKCFib3guZnVsbFNpemUpIHsgLy8gZnVsbFNpemUgYm94ZXMgZG9uJ3QgbmVlZCB0byBiZSByZS1maXR0ZWQgaW4gYW55IGNhc2VcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuXG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cblxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuXG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTGF5b3V0SXRlbVxuICogQHR5cGVkZWYge29iamVjdH0gTGF5b3V0SXRlbVxuICogQHByb3Age3N0cmluZ30gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNoYXJ0IGxheW91dC4gUG9zc2libGUgdmFsdWVzIGFyZVxuICogJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsIGFuZCAnY2hhcnRBcmVhJ1xuICogQHByb3Age251bWJlcn0gd2VpZ2h0IC0gVGhlIHdlaWdodCB1c2VkIHRvIHNvcnQgdGhlIGl0ZW0uIEhpZ2hlciB3ZWlnaHRzIGFyZSBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuICogQHByb3Age2Jvb2xlYW59IGZ1bGxTaXplIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBkcmF3IC0gRHJhd3MgdGhlIGVsZW1lbnRcbiAqIEBwcm9wIHtmdW5jdGlvbn0gW2dldFBhZGRpbmddIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGFkZCB0byBiZSBsYWlkIG91dFxuXHQgKi9cbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH07XG5cbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuXG4gIC8qKlxuXHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0ICovXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG5cdCAqIFNldHMgKG9yIHVwZGF0ZXMpIG9wdGlvbnMgb24gdGhlIGdpdmVuIGBpdGVtYC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXG5cdCAqL1xuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblBhZGRpbmcgLSBtaW5pbXVtIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGVhY2ggc2lkZSBvZiBjaGFydCBhcmVhXG5cdCAqL1xuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG5cbiAgICAvLyBCZWZvcmUgYW55IGNoYW5nZXMgYXJlIG1hZGUsIG5vdGlmeSBib3hlcyB0aGF0IGFuIHVwZGF0ZSBpcyBhYm91dCB0byBiZWluZ1xuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBjbGVhciBhbnkgY2FjaGVkIGRhdGEgKGUuZy4gc2NhbGUgbGltaXRzKVxuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxuICAgIC8vIE91ciBjYW52YXMgbG9va3MgbGlrZSB0aGUgZm9sbG93aW5nLlxuICAgIC8vIFRoZSBhcmVhcyBMMSBhbmQgTDIgYXJlIHRoZSBsZWZ0IGF4ZXMuIFIxIGlzIHRoZSByaWdodCBheGlzLCBUMSBpcyB0aGUgdG9wIGF4aXMgYW5kXG4gICAgLy8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXG4gICAgLy8gVGhlcmUgYXJlIGFsc28gNCBxdWFkcmFudC1saWtlIGxvY2F0aW9ucyAobGVmdCB0byByaWdodCBpbnN0ZWFkIG9mIGNsb2Nrd2lzZSkgcmVzZXJ2ZWQgZm9yIGNoYXJ0IG92ZXJsYXlzXG4gICAgLy8gVGhlc2UgbG9jYXRpb25zIGFyZSBzaW5nbGUtYm94IGxvY2F0aW9ucyBvbmx5LCB3aGVuIHRyeWluZyB0byByZWdpc3RlciBhIGNoYXJ0QXJlYSBsb2NhdGlvbiB0aGF0IGlzIGFscmVhZHkgdGFrZW4sXG4gICAgLy8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgLy9cbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgVDIgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCBDMSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDMiB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8IEwxIHwgTDIgfCAgICAgICAgICAgQ2hhcnRBcmVhIChDMCkgICAgICAgICAgICB8IFIxIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCBDMyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDNCB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgQjIgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvL1xuXG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgb3V0ZXJXaWR0aDogd2lkdGgsXG4gICAgICBvdXRlckhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZyxcbiAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCB0b1BhZGRpbmcobWluUGFkZGluZykpO1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4UGFkZGluZyxcbiAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgeTogcGFkZGluZy50b3BcbiAgICB9LCBwYWRkaW5nKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcblxuICAgIC8vIEZpcnN0IGZpdCB0aGUgZnVsbFNpemUgYm94ZXMsIHRvIHJlZHVjZSBwcm9iYWJpbGl0eSBvZiByZS1maXR0aW5nLlxuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIFRoZW4gZml0IHZlcnRpY2FsIGJveGVzXG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCBob3Jpem9udGFsIGJveGVzXG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIC8vIGlmIHRoZSBhcmVhIGNoYW5nZWQsIHJlLWZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuXG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuXG4gICAgLy8gRmluYWxseSBwbGFjZSB0aGUgYm94ZXMgdG8gY29ycmVjdCBjb29yZGluYXRlc1xuICAgIHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBNb3ZlIHRvIG9wcG9zaXRlIHNpZGUgb2YgY2hhcnRcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcblxuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgIHdpZHRoOiBjaGFydEFyZWEudyxcbiAgICB9O1xuXG4gICAgLy8gRmluYWxseSB1cGRhdGUgYm94ZXMgaW4gY2hhcnRBcmVhIChyYWRpYWwgc2NhbGUgZm9yIGV4YW1wbGUpXG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IGFsbG93cyBhYnN0cmFjdGluZyBwbGF0Zm9ybSBkZXBlbmRlbmNpZXMgYXdheSBmcm9tIHRoZSBjaGFydC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiAgLyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcblx0ICogdGhlIFtXM0MgQ2FudmFzIDJEIENvbnRleHQgQVBJIHN0YW5kYXJkXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L30uXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgZnJvbSB3aGljaCB0byBhY3F1aXJlIGNvbnRleHQgKHBsYXRmb3JtIHNwZWNpZmljKVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIFRoZSBjaGFydCBvcHRpb25zXG5cdCAqL1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBkZXN0cnVjdGlvbiB0aW1lLCByZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFzc29jaWF0ZWQgdG8gdGhlIGNvbnRleHRcblx0ICogcHJldmlvdXNseSByZXR1cm5lZCBieSB0aGUgYWNxdWlyZUNvbnRleHQoKSBtZXRob2QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNvbnRleHQyZCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWV0aG9kIHN1Y2NlZWRlZCwgZWxzZSBmYWxzZVxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIG9uIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIGxpc3RlbiBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBDaGFydEV2ZW50fSkgdHlwZSB0byBsaXN0ZW4gZm9yXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gUmVjZWl2ZXMgYSBub3RpZmljYXRpb24gKGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHNcblx0ICogdGhlIHtAbGluayBDaGFydEV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cblx0ICovXG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIENoYXJ0RXZlbnR9KSB0eXBlIHRvIHJlbW92ZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQHJldHVybnMge251bWJlcn0gdGhlIGN1cnJlbnQgZGV2aWNlUGl4ZWxSYXRpbyBvZiB0aGUgZGV2aWNlIHRoaXMgcGxhdGZvcm0gaXMgY29ubmVjdGVkIHRvLlxuXHQgKi9cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHNpemUgaW4gcGl4ZWxzIG9mIGdpdmVuIGNhbnZhcyBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIC0gY29udGVudCB3aWR0aCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gLSBjb250ZW50IGhlaWdodCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIGFzcGVjdCByYXRpbyB0byBtYWludGFpblxuXHQgKi9cbiAgZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIGlzIGF0dGFjaGVkIHRvIHRoZSBwbGF0Zm9ybSwgZmFsc2UgaWYgbm90LlxuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY29uZmlnIHdpdGggcGxhdGZvcm0gc3BlY2lmaWMgcmVxdWlyZW1lbnRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb3JlL2NvcmUuY29uZmlnLmpzJykuZGVmYXVsdH0gY29uZmlnXG4gICAqL1xuICB1cGRhdGVDb25maWcoY29uZmlnKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyBuby1vcFxuICB9XG59XG4iLCIvKipcbiAqIFBsYXRmb3JtIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIChtaW5pbWFsKS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTkxI2lzc3VlY29tbWVudC0zMTk1NzU5MzlcbiAqL1xuXG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5cbi8qKlxuICogUGxhdGZvcm0gY2xhc3MgZm9yIGNoYXJ0cyB3aXRob3V0IGFjY2VzcyB0byB0aGUgRE9NIG9yIHRvIG1hbnkgZWxlbWVudCBwcm9wZXJ0aWVzXG4gKiBUaGlzIHBsYXRmb3JtIGlzIHVzZWQgYnkgZGVmYXVsdCBmb3IgYW55IGNoYXJ0IHBhc3NlZCBhbiBPZmZzY3JlZW5DYW52YXMuXG4gKiBAZXh0ZW5kcyBCYXNlUGxhdGZvcm1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGl0ZW0pIHtcbiAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG4gICAgLy8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgIHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnLm9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG4gIH1cbn1cbiIsIi8qKlxuICogQ2hhcnQuUGxhdGZvcm0gaW1wbGVtZW50YXRpb24gZm9yIHRhcmdldGluZyBhIHdlYiBicm93c2VyXG4gKi9cblxuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuaW1wb3J0IHtfZ2V0UGFyZW50Tm9kZSwgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgcmVhZFVzZWRTaXplLCBnZXRNYXhpbXVtU2l6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge3Rocm90dGxlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5cbi8qKlxuICogRE9NIGV2ZW50IHR5cGVzIC0+IENoYXJ0LmpzIGV2ZW50IHR5cGVzLlxuICogTm90ZTogb25seSBldmVudHMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgYXJlIG1hcHBlZC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXG4gKi9cbmNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG4gIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb11cbiAqL1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG4gIC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcbiAgLy8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cbiAgY29uc3QgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcblxuICAvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBGb3JjZSBjYW52YXMgdG8gZGlzcGxheSBhcyBibG9jayB0byBhdm9pZCBleHRyYSBzcGFjZSBjYXVzZWQgYnkgaW5saW5lXG4gIC8vIGVsZW1lbnRzLCB3aGljaCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgcmVzcG9uc2l2ZSByZXNpemUgcHJvY2Vzcy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1MzhcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgLy8gSW5jbHVkZSBwb3NzaWJsZSBib3JkZXJzIGluIHRoZSBzaXplXG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgLy8gSWYgbm8gZXhwbGljaXQgcmVuZGVyIGhlaWdodCBhbmQgc3R5bGUgaGVpZ2h0LCBsZXQncyBhcHBseSB0aGUgYXNwZWN0IHJhdGlvLFxuICAgICAgLy8gd2hpY2ggb25lIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgYnV0IGFsc28gYnkgY2hhcnRzIGFzIGRlZmF1bHQgb3B0aW9uXG4gICAgICAvLyAoaS5lLiBvcHRpb25zLmFzcGVjdFJhdGlvKS4gSWYgbm90IHNwZWNpZmllZCwgdXNlIGNhbnZhcyBhc3BlY3QgcmF0aW8gb2YgMi5cbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYW52YXM7XG59XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKGNoYXJ0ICYmIGNoYXJ0LmNhbnZhcykge1xuICAgIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgY2hhcnQsXG4gICAgbmF0aXZlOiBldmVudCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuXG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuXG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzaXplIHNocmFuayBkdXJpbmcgY2hhcnQgcmVzaXplLCBsZXQncyBhc3N1bWVcbiAgICAgIC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cbiAgICAgIC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cbiAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIGluc2lkZSBgdGhyb3R0bGVkYCwgYW5kIGN1cnJlbnRseSBgdGlja2luZ2AsIHNjcm9sbFxuICAgICAgLy8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXG4gICAgICAvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG4gICAgICAvLyB0d2ljZSBpbiBhIGZyYW1lIChwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaXNzdWUpXG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcblxuICAvLyBAdHMtaWdub3JlIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzc4NjEgaW1wbGVtZW50ZWRcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIC8vIFdoZW4gaXRzIGNvbnRhaW5lcidzIGRpc3BsYXkgaXMgc2V0IHRvICdub25lJyB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gICAgLy8gc2l6ZSBvZiAoMCwgMCksIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGNoYXJ0IHRvIGxvc2UgaXRzIG9yaWdpbmFsIGhlaWdodCwgc28gc2tpcFxuICAgIC8vIHJlc2l6aW5nIGluIHN1Y2ggY2FzZS5cbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG5cbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGNhc2UgY2FuIG9jY3VyIGlmIHRoZSBjaGFydCBpcyBkZXN0cm95ZWQgd2hpbGUgd2FpdGluZ1xuICAgIC8vIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHRvIG9jY3VyLiBXZSBwcmV2ZW50IGNyYXNoZXMgYnkgY2hlY2tpbmdcbiAgICAvLyBmb3IgYSBkZXN0cm95ZWQgY2hhcnRcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCk7XG5cbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vKipcbiAqIFBsYXRmb3JtIGNsYXNzIGZvciBjaGFydHMgdGhhdCBjYW4gYWNjZXNzIHRoZSBET00gYW5kIGdsb2JhbCB3aW5kb3cvZG9jdW1lbnQgcHJvcGVydGllc1xuICogQGV4dGVuZHMgQmFzZVBsYXRmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG5cdCAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfVxuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIGBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50L0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgZmFpbHMgd2hlbiB0aGUgY2FudmFzIGlzXG4gICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciB3aGVuIHJ1bm5pbmcgaW4gYSBwcm90ZWN0ZWQgZW52aXJvbm1lbnQuIFdlIGNvdWxkIGd1ZXNzIHRoZVxuICAgIC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXG4gICAgLy8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgY2FudmFzIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgY2FudmFzIGFzIGBjYW52YXNgLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE1MlxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvXG4gICAgICAvLyBpbXBvcnQgdGhlIGxpYnJhcnkgYmVmb3JlIHNldHRpbmcgcGxhdGZvcm0gb3B0aW9ucy5cbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxuICAgIC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuICAgIC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxuXHQgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBDYW4gaGF2ZSBvbmx5IG9uZSBsaXN0ZW5lciBwZXIgdHlwZSwgc28gbWFrZSBzdXJlIHByZXZpb3VzIGlzIHJlbW92ZWRcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuXG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuXG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gLSBjb250ZW50IHdpZHRoIG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSAtIGNvbnRlbnQgaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gYXNwZWN0IHJhdGlvIHRvIG1haW50YWluXG5cdCAqL1xuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICByZXR1cm4gISEoY29udGFpbmVyICYmIGNvbnRhaW5lci5pc0Nvbm5lY3RlZCk7XG4gIH1cbn1cbiIsImltcG9ydCB7X2lzRG9tU3VwcG9ydGVkfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCBCYXNpY1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzaWMuanMnO1xuaW1wb3J0IERvbVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uZG9tLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuZXhwb3J0IHtCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIERvbVBsYXRmb3JtfTtcbiIsImltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcbmltcG9ydCB0eXBlIHtBbmltYXRpb259IGZyb20gJy4uL3R5cGVzL2FuaW1hdGlvbi5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnQ8VCA9IEFueU9iamVjdCwgTyA9IEFueU9iamVjdD4ge1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHt9O1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHVuZGVmaW5lZDtcblxuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgYWN0aXZlID0gZmFsc2U7XG4gIG9wdGlvbnM6IE87XG4gICRhbmltYXRpb25zOiBSZWNvcmQ8a2V5b2YgVCwgQW5pbWF0aW9uPjtcblxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbik6IFBvaW50IHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX0gYXMgUG9pbnQ7XG4gIH1cblxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGhpcy54KSAmJiBpc051bWJlcih0aGlzLnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgb3IgZmluYWwgdmFsdWUgb2YgZWFjaCBwcm9wLiBDYW4gcmV0dXJuIGV4dHJhIHByb3BlcnRpZXMgKHdob2xlIG9iamVjdCkuXG4gICAqIEBwYXJhbSBwcm9wcyAtIHByb3BlcnRpZXMgdG8gZ2V0XG4gICAqIEBwYXJhbSBbZmluYWxdIC0gZ2V0IHRoZSBmaW5hbCB2YWx1ZSAoYW5pbWF0aW9uIHRhcmdldClcbiAgICovXG4gIGdldFByb3BzPFAgZXh0ZW5kcyAoa2V5b2YgVClbXT4ocHJvcHM6IFAsIGZpbmFsPzogYm9vbGVhbik6IFBpY2s8VCwgUFtudW1iZXJdPjtcbiAgZ2V0UHJvcHM8UCBleHRlbmRzIHN0cmluZz4ocHJvcHM6IFBbXSwgZmluYWw/OiBib29sZWFuKTogUGFydGlhbDxSZWNvcmQ8UCwgdW5rbm93bj4+O1xuICBnZXRQcm9wcyhwcm9wczogc3RyaW5nW10sIGZpbmFsPzogYm9vbGVhbik6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+IHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgaWYgKCFmaW5hbCB8fCAhYW5pbXMpIHtcbiAgICAgIC8vIGxldCdzIG5vdCBjcmVhdGUgYW4gb2JqZWN0LCBpZiBub3QgbmVlZGVkXG4gICAgICByZXR1cm4gdGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICB9XG4gICAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIHJldFtwcm9wXSA9IGFuaW1zW3Byb3BdICYmIGFuaW1zW3Byb3BdLmFjdGl2ZSgpID8gYW5pbXNbcHJvcF0uX3RvIDogdGhpc1twcm9wIGFzIHN0cmluZ107XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuIiwiaW1wb3J0IHtpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtfZmFjdG9yaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHt7dmFsdWU6bnVtYmVyIHwgc3RyaW5nLCBsYWJlbD86c3RyaW5nLCBtYWpvcj86Ym9vbGVhbiwgJGNvbnRleHQ/OmFueX19IFRpY2tcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGlja3MgdG8gYmUgcGxvdHRlZCB0byBhdm9pZCBvdmVybGFwcGluZyBsYWJlbHMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdH0gc2NhbGVcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHJldHVybiB7VGlja1tdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9Ta2lwKHNjYWxlLCB0aWNrcykge1xuICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XG4gIGNvbnN0IGRldGVybWluZWRNYXhUaWNrcyA9IGRldGVybWluZU1heFRpY2tzKHNjYWxlKTtcbiAgY29uc3QgdGlja3NMaW1pdCA9IE1hdGgubWluKHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lZE1heFRpY2tzLCBkZXRlcm1pbmVkTWF4VGlja3MpO1xuICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcbiAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgY29uc3QgbmV3VGlja3MgPSBbXTtcblxuICAvLyBJZiB0aGVyZSBhcmUgdG9vIG1hbnkgbWFqb3IgdGlja3MgdG8gZGlzcGxheSB0aGVtIGFsbFxuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuXG4gIGNvbnN0IHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpO1xuXG4gIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgcmV0dXJuIG5ld1RpY2tzO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgY29uc3QgdGlja0xlbmd0aCA9IHNjYWxlLl90aWNrU2l6ZSgpO1xuICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4obWF4U2NhbGUsIG1heENoYXJ0KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gbWFqb3JJbmRpY2VzXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrc0xpbWl0XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCkge1xuICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcbiAgY29uc3Qgc3BhY2luZyA9IHRpY2tzLmxlbmd0aCAvIHRpY2tzTGltaXQ7XG5cbiAgLy8gSWYgdGhlIG1ham9yIHRpY2tzIGFyZSBldmVubHkgc3BhY2VkIGFwYXJ0LCBwbGFjZSB0aGUgbWlub3IgdGlja3NcbiAgLy8gc28gdGhhdCB0aGV5IGRpdmlkZSB0aGUgbWFqb3IgdGlja3MgaW50byBldmVuIGNodW5rc1xuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gIH1cblxuICBjb25zdCBmYWN0b3JzID0gX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSBmYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XG4gICAgICByZXR1cm4gZmFjdG9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKi9cbmZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubWFqb3IpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtUaWNrW119IG5ld1RpY2tzXG4gKiBAcGFyYW0ge251bWJlcltdfSBtYWpvckluZGljZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGFjaW5nXG4gKi9cbmZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IG5leHQgPSBtYWpvckluZGljZXNbMF07XG4gIGxldCBpO1xuXG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge1RpY2tbXX0gbmV3VGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGFjaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gW21ham9yU3RhcnRdXG4gKiBAcGFyYW0ge251bWJlcn0gW21ham9yRW5kXVxuICovXG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZU9yRGVmYXVsdChtYWpvclN0YXJ0LCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBsZW5ndGgsIGksIG5leHQ7XG5cbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgaWYgKG1ham9yRW5kKSB7XG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xuICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICB9XG5cbiAgbmV4dCA9IHN0YXJ0O1xuXG4gIHdoaWxlIChuZXh0IDwgMCkge1xuICAgIGNvdW50Kys7XG4gICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICB9XG5cbiAgZm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSwgZGlmZjtcblxuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuIiwiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYWxpZ25QaXhlbCwgX21lYXN1cmVUZXh0LCByZW5kZXJUZXh0LCBjbGlwQXJlYSwgdW5jbGlwQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGVhY2gsIGZpbml0ZU9yRGVmYXVsdCwgaXNBcnJheSwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0RlZ3JlZXMsIHRvUmFkaWFucywgX2ludDE2UmFuZ2UsIF9saW1pdFZhbHVlLCBIQUxGX1BJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCB0b0ZvbnQsIHRvUGFkZGluZywgX2FkZEdyYWNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2F1dG9Ta2lwfSBmcm9tICcuL2NvcmUuc2NhbGUuYXV0b3NraXAuanMnO1xuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5jb25zdCBnZXRUaWNrc0xpbWl0ID0gKHRpY2tzTGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSA9PiBNYXRoLm1pbihtYXhUaWNrc0xpbWl0IHx8IHRpY2tzTGVuZ3RoLCB0aWNrc0xlbmd0aCk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIG51bUl0ZW1zIGZyb20gYXJyXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1JdGVtc1xuICovXG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb2Zmc2V0R3JpZExpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuXG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuXG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjYWNoZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuXG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIC8qKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqL1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG5cbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovXG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIC8qKiBAdHlwZSB7Q2hhcnR9ICovXG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcblxuICAgIC8vIGltcGxlbWVudHMgYm94XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHNjYWxlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyPX0gKi9cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtUaWNrW119ICovXG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0W118bnVsbH0gKi9cbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3R8bnVsbH0gKi9cbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gb3B0aW9uc1xuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzO1xuXG4gICAgLy8gcGFyc2UgbWluL21heCB2YWx1ZSwgc28gd2UgY2FuIHByb3Blcmx5IGRldGVybWluZSBtaW4vbWF4IGZvciBvdGhlciBzY2FsZXNcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGEgc3VwcG9ydGVkIGlucHV0IHZhbHVlIHRvIGludGVybmFsIHJlcHJlc2VudGF0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhd1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gcmF3O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXIsIG1pbkRlZmluZWQ6IGJvb2xlYW4sIG1heERlZmluZWQ6IGJvb2xlYW59fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuU3RhY2tcblx0ICogQHJldHVybiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgcmFuZ2U7XG5cbiAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcmFuZ2UgPSBtZXRhc1tpXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCBjYW5TdGFjayk7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByYW5nZS5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgbWluIDw9IG1heCB3aGVuIG9ubHkgbWluIG9yIG1heCBpcyBkZWZpbmVkIGJ5IHVzZXIgYW5kIHRoZSBkYXRhIGlzIG91dHNpZGUgdGhhdCByYW5nZVxuICAgIG1pbiA9IG1heERlZmluZWQgJiYgbWluID4gbWF4ID8gbWF4IDogbWluO1xuICAgIG1heCA9IG1pbkRlZmluZWQgJiYgbWluID4gbWF4ID8gbWluIDogbWF4O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KG1pbiwgZmluaXRlT3JEZWZhdWx0KG1heCwgbWluKSksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChtYXgsIGZpbml0ZU9yRGVmYXVsdChtaW4sIG1heCkpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgdGhlIHBhZGRpbmcgbmVlZGVkIGZvciB0aGUgc2NhbGVcblx0ICogQHJldHVybiB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCByaWdodDogbnVtYmVyfX0gdGhlIG5lY2Vzc2FyeSBwYWRkaW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnBhZGRpbmdMZWZ0IHx8IDAsXG4gICAgICB0b3A6IHRoaXMucGFkZGluZ1RvcCB8fCAwLFxuICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICBib3R0b206IHRoaXMucGFkZGluZ0JvdHRvbSB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzY2FsZSB0aWNrIG9iamVjdHNcblx0ICogQHJldHVybiB7VGlja1tdfVxuXHQgKiBAc2luY2UgMi43XG5cdCAqL1xuICBnZXRUaWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtzdHJpbmdbXX1cblx0ICovXG4gIGdldExhYmVscygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuTGFiZWxJdGVtW119XG4gICAqL1xuICBnZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSA9IHRoaXMuY2hhcnQuY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgLy8gV2hlbiBhIG5ldyBsYXlvdXQgaXMgY3JlYXRlZCwgcmVzZXQgdGhlIGRhdGEgbGltaXRzIGNhY2hlXG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5Y2xlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG4gIC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBzY2FsZSB0eXBlcy5cbiAgLy8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxuXG4gIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFdpZHRoIC0gdGhlIG1heCB3aWR0aCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIHRoZSBtYXggaGVpZ2h0IGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IG1hcmdpbnMgLSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgZWRnZSBvZiB0aGUgb3RoZXIgc2NhbGVzIGFuZCBlZGdlIG9mIHRoZSBjaGFydFxuXHQgKiAgIFRoaXMgc3BhY2UgY29tZXMgZnJvbSB0d28gc291cmNlczpcblx0ICogICAgIC0gcGFkZGluZyAtIHNwYWNlIHRoYXQncyByZXF1aXJlZCB0byBzaG93IHRoZSBsYWJlbHMgYXQgdGhlIGVkZ2VzIG9mIHRoZSBzY2FsZVxuXHQgKiAgICAgLSB0aGlja25lc3Mgb2Ygc2NhbGVzIG9yIGxlZ2VuZHMgaW4gYW5vdGhlciBvcmllbnRhdGlvblxuXHQgKi9cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm8sIGdyYWNlLCB0aWNrczogdGlja09wdHN9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xuXG4gICAgLy8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgLy8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCBtYXJnaW5zKTtcblxuICAgIHRoaXMudGlja3MgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuXG4gICAgLy8gRGltZW5zaW9uc1xuICAgIHRoaXMuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cbiAgICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IHRoaXMud2lkdGggKyBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0XG4gICAgICA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcblxuICAgIC8vIERhdGEgbWluL21heFxuICAgIGlmICghdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCkge1xuICAgICAgdGhpcy5iZWZvcmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmRldGVybWluZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLl9yYW5nZSA9IF9hZGRHcmFjZSh0aGlzLCBncmFjZSwgYmVnaW5BdFplcm8pO1xuICAgICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5iZWZvcmVCdWlsZFRpY2tzKCk7XG5cbiAgICB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW107XG5cbiAgICAvLyBBbGxvdyBtb2RpZmljYXRpb24gb2YgdGlja3MgaW4gY2FsbGJhY2suXG4gICAgdGhpcy5hZnRlckJ1aWxkVGlja3MoKTtcblxuICAgIC8vIENvbXB1dGUgdGljayByb3RhdGlvbiBhbmQgZml0IHVzaW5nIGEgc2FtcGxlZCBzdWJzZXQgb2YgbGFiZWxzXG4gICAgLy8gV2UgZ2VuZXJhbGx5IGRvbid0IG5lZWQgdG8gY29tcHV0ZSB0aGUgc2l6ZSBvZiBldmVyeSBzaW5nbGUgbGFiZWwgZm9yIGRldGVybWluaW5nIHNjYWxlIHNpemVcbiAgICBjb25zdCBzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKHRoaXMudGlja3MsIHNhbXBsZVNpemUpIDogdGhpcy50aWNrcyk7XG5cbiAgICAvLyBjb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGhlcmUsIG9uY2UgZnJvbSBjb3JlLmNvbnRyb2xsZXIudXBkYXRlTGF5b3V0LlxuICAgIC8vIEhlcmUgd2UgaGF2ZW4ndCBiZWVuIHBvc2l0aW9uZWQgeWV0LCBidXQgZGltZW5zaW9ucyBhcmUgY29ycmVjdC5cbiAgICAvLyBWYXJpYWJsZXMgc2V0IGluIGNvbmZpZ3VyZSBhcmUgbmVlZGVkIGZvciBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBhbmRcbiAgICAvLyBpdCdzIG9rIHRoYXQgY29vcmRpbmF0ZXMgYXJlIG5vdCBjb3JyZWN0IHRoZXJlLCBvbmx5IGRpbWVuc2lvbnMgbWF0dGVyLlxuICAgIHRoaXMuY29uZmlndXJlKCk7XG5cbiAgICAvLyBUaWNrIFJvdGF0aW9uXG4gICAgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7IC8vIFByZWNvbmRpdGlvbnM6IG51bWJlciBvZiB0aWNrcyBhbmQgc2l6ZXMgb2YgbGFyZ2VzdCBsYWJlbHMgbXVzdCBiZSBjYWxjdWxhdGVkIGJlZm9yZWhhbmRcbiAgICB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuXG4gICAgLy8gQXV0by1za2lwXG4gICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgKHRpY2tPcHRzLmF1dG9Ta2lwIHx8IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2F1dG8nKSkge1xuICAgICAgdGhpcy50aWNrcyA9IGF1dG9Ta2lwKHRoaXMsIHRoaXMudGlja3MpO1xuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgICB0aGlzLmFmdGVyQXV0b1NraXAoKTtcbiAgICB9XG5cbiAgICBpZiAoc2FtcGxpbmdFbmFibGVkKSB7XG4gICAgICAvLyBHZW5lcmF0ZSBsYWJlbHMgdXNpbmcgYWxsIG5vbi1za2lwcGVkIHRpY2tzXG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKTtcbiAgICB9XG5cbiAgICB0aGlzLmJlZm9yZUZpdCgpO1xuICAgIHRoaXMuZml0KCk7IC8vIFByZWNvbmRpdGlvbnM6IGxhYmVsIHJvdGF0aW9uIGFuZCBsYWJlbCBzaXplcyBtdXN0IGJlIGNhbGN1bGF0ZWQgYmVmb3JlaGFuZFxuICAgIHRoaXMuYWZ0ZXJGaXQoKTtcblxuICAgIC8vIElNUE9SVEFOVDogYWZ0ZXIgdGhpcyBwb2ludCwgd2UgY29uc2lkZXIgdGhhdCBgdGhpcy50aWNrc2Agd2lsbCBORVZFUiBjaGFuZ2UhXG5cbiAgICB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGxldCByZXZlcnNlUGl4ZWxzID0gdGhpcy5vcHRpb25zLnJldmVyc2U7XG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLmxlZnQ7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLnRvcDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5ib3R0b207XG4gICAgICAvLyBieSBkZWZhdWx0IHZlcnRpY2FsIHNjYWxlcyBhcmUgZnJvbSBib3R0b20gdG8gdG9wLCBzbyBwaXhlbHMgYXJlIHJldmVyc2VkXG4gICAgICByZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gZW5kUGl4ZWw7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IHJldmVyc2VQaXhlbHM7XG4gICAgdGhpcy5fbGVuZ3RoID0gZW5kUGl4ZWwgLSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2FsaWduVG9QaXhlbHMgPSB0aGlzLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcbiAgfVxuXG4gIGFmdGVyVXBkYXRlKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG5cbiAgLy9cblxuICBiZWZvcmVTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICAvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuXG4gICAgICAvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cbiAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgcGFkZGluZ1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSAwO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSAwO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gIH1cbiAgYWZ0ZXJTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuXG4gIF9jYWxsSG9va3MobmFtZSkge1xuICAgIHRoaXMuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnNbbmFtZV0sIFt0aGlzXSk7XG4gIH1cblxuICAvLyBEYXRhIGxpbWl0c1xuICBiZWZvcmVEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlRGF0YUxpbWl0cycpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7fVxuICBhZnRlckRhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckRhdGFMaW1pdHMnKTtcbiAgfVxuXG4gIC8vXG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gIH1cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfSB0aGUgdGlja3Ncblx0ICovXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGFmdGVyQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyQnVpbGRUaWNrcycpO1xuICB9XG5cbiAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICAvKipcblx0ICogQ29udmVydCB0aWNrcyB0byBsYWJlbCBzdHJpbmdzXG5cdCAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuXHQgKi9cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IGNhbGwodGlja09wdHMuY2FsbGJhY2ssIFt0aWNrLnZhbHVlLCBpLCB0aWNrc10sIHRoaXMpO1xuICAgIH1cbiAgfVxuICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vXG5cbiAgYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgbnVtVGlja3MgPSBnZXRUaWNrc0xpbWl0KHRoaXMudGlja3MubGVuZ3RoLCBvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgIGxldCBsYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhdGlja09wdHMuZGlzcGxheSB8fCBtaW5Sb3RhdGlvbiA+PSBtYXhSb3RhdGlvbiB8fCBudW1UaWNrcyA8PSAxIHx8ICF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQ7XG5cbiAgICAvLyBFc3RpbWF0ZSB0aGUgd2lkdGggb2YgZWFjaCBncmlkIGJhc2VkIG9uIHRoZSBjYW52YXMgd2lkdGgsIHRoZSBtYXhpbXVtXG4gICAgLy8gbGFiZWwgd2lkdGggYW5kIHRoZSBudW1iZXIgb2YgdGljayBpbnRlcnZhbHNcbiAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKHRoaXMuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG5cbiAgICAvLyBBbGxvdyAzIHBpeGVscyB4MiBwYWRkaW5nIGVpdGhlciBzaWRlIGZvciBsYWJlbCByZWFkYWJpbGl0eVxuICAgIGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuICAgICAgdGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG4gICAgICBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZClcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucy50aXRsZSwgdGhpcy5jaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgbWF4TGFiZWxEaWFnb25hbCA9IE1hdGguc3FydChtYXhMYWJlbFdpZHRoICogbWF4TGFiZWxXaWR0aCArIG1heExhYmVsSGVpZ2h0ICogbWF4TGFiZWxIZWlnaHQpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IHRvRGVncmVlcyhNYXRoLm1pbihcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKChsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyB0aWNrV2lkdGgsIC0xLCAxKSksXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpIC0gTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heExhYmVsSGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKVxuICAgICAgKSk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7fVxuXG4gIC8vXG5cbiAgYmVmb3JlRml0KCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgLy8gUmVzZXRcbiAgICBjb25zdCBtaW5TaXplID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuXG4gICAgY29uc3Qge2NoYXJ0LCBvcHRpb25zOiB7dGlja3M6IHRpY2tPcHRzLCB0aXRsZTogdGl0bGVPcHRzLCBncmlkOiBncmlkT3B0c319ID0gdGhpcztcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5faXNWaXNpYmxlKCk7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcblxuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICBjb25zdCB0aXRsZUhlaWdodCA9IGdldFRpdGxlSGVpZ2h0KHRpdGxlT3B0cywgY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG4gICAgICAgIG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgYm90aGVyIGZpdHRpbmcgdGhlIHRpY2tzIGlmIHdlIGFyZSBub3Qgc2hvd2luZyB0aGUgbGFiZWxzXG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdH0gPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgLy8gQSBob3Jpem9udGFsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgaGVpZ2h0LlxuICAgICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja09wdHMubWlycm9yID8gMCA6IHNpbiAqIHdpZGVzdC53aWR0aCArIGNvcyAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgdmVydGljYWwgYXhpcyBpcyBtb3JlIGNvbnN0cmFpbmVkIGJ5IHRoZSB3aWR0aC4gTGFiZWxzIGFyZSB0aGVcbiAgICAgICAgLy8gZG9taW5hbnQgZmFjdG9yIGhlcmUsIHNvIGdldCB0aGF0IGxlbmd0aCBmaXJzdCBhbmQgYWNjb3VudCBmb3IgcGFkZGluZ1xuICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogY29zICogd2lkZXN0LndpZHRoICsgc2luICogaGlnaGVzdC5oZWlnaHQ7XG5cbiAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGggKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2hhbmRsZU1hcmdpbnMoKTtcblxuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9sZW5ndGggPSBjaGFydC53aWR0aCAtIHRoaXMuX21hcmdpbnMubGVmdCAtIHRoaXMuX21hcmdpbnMucmlnaHQ7XG4gICAgICB0aGlzLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gbWluU2l6ZS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQuaGVpZ2h0IC0gdGhpcy5fbWFyZ2lucy50b3AgLSB0aGlzLl9tYXJnaW5zLmJvdHRvbTtcbiAgICB9XG4gIH1cblxuICBfY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpIHtcbiAgICBjb25zdCB7dGlja3M6IHthbGlnbiwgcGFkZGluZ30sIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLmxhYmVsUm90YXRpb24gIT09IDA7XG4gICAgY29uc3QgbGFiZWxzQmVsb3dUaWNrcyA9IHBvc2l0aW9uICE9PSAndG9wJyAmJiB0aGlzLmF4aXMgPT09ICd4JztcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuXG4gICAgICAvLyBFbnN1cmUgdGhhdCBvdXIgdGlja3MgYXJlIGFsd2F5cyBpbnNpZGUgdGhlIGNhbnZhcy4gV2hlbiByb3RhdGVkLCB0aWNrcyBhcmUgcmlnaHQgYWxpZ25lZFxuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XG4gICAgICBpZiAoaXNSb3RhdGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNCZWxvd1RpY2tzKSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBjb3MgKiBmaXJzdC53aWR0aDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBzaW4gKiBsYXN0LmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IHNpbiAqIGZpcnN0LmhlaWdodDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBjb3MgKiBsYXN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoIC8gMjtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aCAvIDI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkanVzdCBwYWRkaW5nIHRha2luZyBpbnRvIGFjY291bnQgY2hhbmdlcyBpbiBvZmZzZXRzXG4gICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApO1xuICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldFJpZ2h0KSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQgLyAyO1xuICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQgLyAyO1xuXG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wICsgcGFkZGluZztcbiAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgbWFyZ2lucyBhbmQgcGFkZGluZyBpbnRlcmFjdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9oYW5kbGVNYXJnaW5zKCkge1xuICAgIGlmICh0aGlzLl9tYXJnaW5zKSB7XG4gICAgICB0aGlzLl9tYXJnaW5zLmxlZnQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdMZWZ0LCB0aGlzLl9tYXJnaW5zLmxlZnQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy50b3AgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdUb3AsIHRoaXMuX21hcmdpbnMudG9wKTtcbiAgICAgIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0JvdHRvbSwgdGhpcy5fbWFyZ2lucy5ib3R0b20pO1xuICAgIH1cbiAgfVxuXG4gIGFmdGVyRml0KCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuICB9XG5cbiAgLy8gU2hhcmVkIE1ldGhvZHNcbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3Qge2F4aXMsIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBheGlzID09PSAneCc7XG4gIH1cbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBpc0Z1bGxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHtcbiAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG4gICAgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpO1xuXG4gICAgLy8gVGlja3Mgc2hvdWxkIGJlIHNraXBwZWQgd2hlbiBjYWxsYmFjayByZXR1cm5zIG51bGwgb3IgdW5kZWYsIHNvIGxldHMgcmVtb3ZlIHRob3NlLlxuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHRpY2tzW2ldLmxhYmVsKSkge1xuICAgICAgICB0aWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlsZW4tLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHt7IGZpcnN0OiBvYmplY3QsIGxhc3Q6IG9iamVjdCwgd2lkZXN0OiBvYmplY3QsIGhpZ2hlc3Q6IG9iamVjdCwgd2lkdGhzOiBBcnJheSwgaGVpZ2h0czogYXJyYXkgfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbFNpemVzKCkge1xuICAgIGxldCBsYWJlbFNpemVzID0gdGhpcy5fbGFiZWxTaXplcztcblxuICAgIGlmICghbGFiZWxTaXplcykge1xuICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IGxhYmVsU2l6ZXMgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgdGlja3MubGVuZ3RoLCB0aGlzLm9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsU2l6ZXM7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB7d2lkdGgsIGhlaWdodCwgb2Zmc2V0fSBvYmplY3RzIGZvciB0aGUgZmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdCB0aWNrXG5cdCAqIGxhYmVscyB3aGVyZSBvZmZzZXQgaW5kaWNhdGVzIHRoZSBhbmNob3IgcG9pbnQgb2Zmc2V0IGZyb20gdGhlIHRvcCBpbiBwaXhlbHMuXG5cdCAqIEByZXR1cm4ge3sgZmlyc3Q6IG9iamVjdCwgbGFzdDogb2JqZWN0LCB3aWRlc3Q6IG9iamVjdCwgaGlnaGVzdDogb2JqZWN0LCB3aWR0aHM6IEFycmF5LCBoZWlnaHRzOiBhcnJheSB9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCBsZW5ndGgsIG1heFRpY2tzTGltaXQpIHtcbiAgICBjb25zdCB7Y3R4LCBfbG9uZ2VzdFRleHRDYWNoZTogY2FjaGVzfSA9IHRoaXM7XG4gICAgY29uc3Qgd2lkdGhzID0gW107XG4gICAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICAgIGNvbnN0IGluY3JlbWVudCA9IE1hdGguZmxvb3IobGVuZ3RoIC8gZ2V0VGlja3NMaW1pdChsZW5ndGgsIG1heFRpY2tzTGltaXQpKTtcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICAgIGxhYmVsID0gdGlja3NbaV0ubGFiZWw7XG4gICAgICB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICBjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7ZGF0YToge30sIGdjOiBbXX07XG4gICAgICBsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ID0gMDtcbiAgICAgIC8vIFVuZGVmaW5lZCBsYWJlbHMgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xuICAgICAgICBoZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICAvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXQncyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbmVzdGVkTGFiZWwgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGxhYmVsW2pdKTtcbiAgICAgICAgICAvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aWR0aHMucHVzaCh3aWR0aCk7XG4gICAgICBoZWlnaHRzLnB1c2goaGVpZ2h0KTtcbiAgICAgIHdpZGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCB3aWRlc3RMYWJlbFNpemUpO1xuICAgICAgaGlnaGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KGhlaWdodCwgaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgfVxuICAgIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKTtcblxuICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgaGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcblxuICAgIGNvbnN0IHZhbHVlQXQgPSAoaWR4KSA9PiAoe3dpZHRoOiB3aWR0aHNbaWR4XSB8fCAwLCBoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3Q6IHZhbHVlQXQoMCksXG4gICAgICBsYXN0OiB2YWx1ZUF0KGxlbmd0aCAtIDEpLFxuICAgICAgd2lkZXN0OiB2YWx1ZUF0KHdpZGVzdCksXG4gICAgICBoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpLFxuICAgICAgd2lkdGhzLFxuICAgICAgaGVpZ2h0cyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBsYWJlbCB0byBkaXNwbGF5IGluIHRoZSB0b29sdGlwIGZvciB0aGUgZ2l2ZW4gdmFsdWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHBvaW50LiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBkYXRhIHZhbHVlIGZyb20gYSBnaXZlbiBwaXhlbC4gVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBnZXRQaXhlbEZvclZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIHRpY2sgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIGEgcGVyY2VudGFnZSBvZiBzY2FsZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpIHtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZVBpeGVscykge1xuICAgICAgZGVjaW1hbCA9IDEgLSBkZWNpbWFsO1xuICAgIH1cblxuICAgIGNvbnN0IHBpeGVsID0gdGhpcy5fc3RhcnRQaXhlbCArIGRlY2ltYWwgKiB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIF9pbnQxNlJhbmdlKHRoaXMuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbCh0aGlzLmNoYXJ0LCBwaXhlbCwgMCkgOiBwaXhlbCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZVBpeGVscyA/IDEgLSBkZWNpbWFsIDogZGVjaW1hbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwaXhlbCBmb3IgdGhlIG1pbmltdW0gY2hhcnQgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldEJhc2VWYWx1ZSgpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcblxuICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuICAgICAgbWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcbiAgICAgIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcblxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRpY2suJGNvbnRleHQgfHxcblx0XHRcdFx0KHRpY2suJGNvbnRleHQgPSBjcmVhdGVUaWNrQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHRpY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlU2NhbGVDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3RpY2tTaXplKCkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBieSBsYWJlbCBpbiBheGlzIGRpcmVjdGlvbi5cbiAgICBjb25zdCByb3QgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcblxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuICAgIGNvbnN0IHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcbiAgICBjb25zdCBoID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcblxuICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgZm9yIDEgdGljayBpbiBheGlzIGRpcmVjdGlvbi5cbiAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG4gICAgICA6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuXG4gICAgaWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuICEhZGlzcGxheTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtncmlkLCBwb3NpdGlvbiwgYm9yZGVyfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZ3JpZC5vZmZzZXQ7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgdGlja3NMZW5ndGggPSB0aWNrcy5sZW5ndGggKyAob2Zmc2V0ID8gMSA6IDApO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZCk7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcblxuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyT3B0cy5kaXNwbGF5ID8gYm9yZGVyT3B0cy53aWR0aCA6IDA7XG4gICAgY29uc3QgYXhpc0hhbGZXaWR0aCA9IGF4aXNXaWR0aCAvIDI7XG4gICAgY29uc3QgYWxpZ25Cb3JkZXJWYWx1ZSA9IGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICByZXR1cm4gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCBheGlzV2lkdGgpO1xuICAgIH07XG4gICAgbGV0IGJvcmRlclZhbHVlLCBpLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XG4gICAgbGV0IHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTI7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5ib3R0b20pO1xuICAgICAgdHkxID0gdGhpcy5ib3R0b20gLSB0bDtcbiAgICAgIHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEudG9wKSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnRvcCk7XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmJvdHRvbSkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdGhpcy50b3AgKyB0bDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnJpZ2h0KTtcbiAgICAgIHR4MSA9IHRoaXMucmlnaHQgLSB0bDtcbiAgICAgIHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMubGVmdCk7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdGhpcy5sZWZ0ICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyICsgMC41KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHR5MSArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0eDEgLSB0bDtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9XG5cbiAgICBjb25zdCBsaW1pdCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCwgdGlja3NMZW5ndGgpO1xuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGkpO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleEJvcmRlciA9IGJvcmRlci5zZXRDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoIHx8IFtdO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4Qm9yZGVyLmRhc2hPZmZzZXQ7XG5cbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcbiAgICAgIGNvbnN0IHRpY2tDb2xvciA9IG9wdHNBdEluZGV4LnRpY2tDb2xvcjtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKHRoaXMsIGksIG9mZnNldCk7XG5cbiAgICAgIC8vIFNraXAgaWYgdGhlIHBpeGVsIGlzIG91dCBvZiB0aGUgcmFuZ2VcbiAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgdHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHR4MSxcbiAgICAgICAgdHkxLFxuICAgICAgICB0eDIsXG4gICAgICAgIHR5MixcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTIsXG4gICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgIGJvcmRlckRhc2gsXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgIHRpY2tXaWR0aCxcbiAgICAgICAgdGlja0NvbG9yLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IHRpY2tzTGVuZ3RoO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczogb3B0aW9uVGlja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB7YWxpZ24sIGNyb3NzQWxpZ24sIHBhZGRpbmcsIG1pcnJvcn0gPSBvcHRpb25UaWNrcztcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3QgaFRpY2tBbmRQYWRkaW5nID0gbWlycm9yID8gLXBhZGRpbmcgOiB0aWNrQW5kUGFkZGluZztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHkgPSB0aGlzLmJvdHRvbSAtIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgeSA9IHRoaXMudG9wICsgaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB5ID0gKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB5ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeCA9ICgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMikgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeCA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpLnRleHRBbGlnbjtcbiAgICB9XG5cbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIGxhYmVsID0gdGljay5sYWJlbDtcblxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBvcHRpb25UaWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBwaXhlbCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKGkpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG4gICAgICBmb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XG4gICAgICBsaW5lQ291bnQgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBoYWxmQ291bnQgPSBsaW5lQ291bnQgLyAyO1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICBsZXQgdGlja1RleHRBbGlnbiA9IHRleHRBbGlnbjtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB4ID0gcGl4ZWw7XG5cbiAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZWx5LWlmXG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgIHRleHRPZmZzZXQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdGF0aW9uICE9PSAwICYmICFvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICAgIHggKz0gKGxpbmVIZWlnaHQgLyAyKSAqIE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHBpeGVsO1xuICAgICAgICB0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XG4gICAgICB9XG5cbiAgICAgIGxldCBiYWNrZHJvcDtcblxuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsYWJlbFNpemVzLmhlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XG5cbiAgICAgICAgbGV0IHRvcCA9IHRleHRPZmZzZXQgLSBsYWJlbFBhZGRpbmcudG9wO1xuICAgICAgICBsZXQgbGVmdCA9IDAgLSBsYWJlbFBhZGRpbmcubGVmdDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5uZXInOlxuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBiYWNrZHJvcCA9IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyBsYWJlbFBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuXG4gICAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3IsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgZm9udCxcbiAgICAgICAgdGV4dE9mZnNldCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIHRleHRBbGlnbjogdGlja1RleHRBbGlnbixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgdHJhbnNsYXRpb246IFt4LCB5XSxcbiAgICAgICAgICBiYWNrZHJvcCxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrc30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG5cbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cblxuICAgIGxldCBhbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgaWYgKHRpY2tzLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnZW5kJykge1xuICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgIGFsaWduID0gJ2lubmVyJztcbiAgICB9XG5cbiAgICByZXR1cm4gYWxpZ247XG4gIH1cblxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IHtjcm9zc0FsaWduLCBtaXJyb3IsIHBhZGRpbmd9fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuXG4gICAgbGV0IHRleHRBbGlnbjtcbiAgICBsZXQgeDtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0ICsgcGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ICs9IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4ID0gdGhpcy5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgcGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4IC09IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHRpY2tBbmRQYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9IHdpZGVzdCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ID0gdGhpcy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIH1cblxuICAgIHJldHVybiB7dGV4dEFsaWduLCB4fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IHRoaXMubGVmdCwgYm90dG9tOiBjaGFydC5oZWlnaHQsIHJpZ2h0OiB0aGlzLnJpZ2h0fTtcbiAgICB9IGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4ge3RvcDogdGhpcy50b3AsIGxlZnQ6IDAsIGJvdHRvbTogdGhpcy5ib3R0b20sIHJpZ2h0OiBjaGFydC53aWR0aH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtiYWNrZ3JvdW5kQ29sb3J9LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFncmlkLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgaW5kZXggPSB0aWNrcy5maW5kSW5kZXgodCA9PiB0LnZhbHVlID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGNvbnN0IGRyYXdMaW5lID0gKHAxLCBwMiwgc3R5bGUpID0+IHtcbiAgICAgIGlmICghc3R5bGUud2lkdGggfHwgIXN0eWxlLmNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgaWYgKGdyaWQuZHJhd09uQ2hhcnRBcmVhKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS54MSwgeTogaXRlbS55MX0sXG4gICAgICAgICAgICB7eDogaXRlbS54MiwgeTogaXRlbS55Mn0sXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmlkLmRyYXdUaWNrcykge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0udHgxLCB5OiBpdGVtLnR5MX0sXG4gICAgICAgICAgICB7eDogaXRlbS50eDIsIHk6IGl0ZW0udHkyfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29sb3I6IGl0ZW0udGlja0NvbG9yLFxuICAgICAgICAgICAgICB3aWR0aDogaXRlbS50aWNrV2lkdGgsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2g6IGl0ZW0udGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IGl0ZW0udGlja0JvcmRlckRhc2hPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCb3JkZXIoKSB7XG4gICAgY29uc3Qge2NoYXJ0LCBjdHgsIG9wdGlvbnM6IHtib3JkZXIsIGdyaWR9fSA9IHRoaXM7XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGJvcmRlci5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXIuZGlzcGxheSA/IGJvcmRlck9wdHMud2lkdGggOiAwO1xuICAgIGlmICghYXhpc1dpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMaW5lV2lkdGggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KDApKS5saW5lV2lkdGg7XG4gICAgY29uc3QgYm9yZGVyVmFsdWUgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICBsZXQgeDEsIHgyLCB5MSwgeTI7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMudG9wLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHkyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLndpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlck9wdHMuY29sb3I7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdMYWJlbHMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cbiAgICBpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcblxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmdldExhYmVsSXRlbXMoY2hhcnRBcmVhKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRleHRPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSBpdGVtLmZvbnQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGl0ZW0ubGFiZWw7XG4gICAgICBjb25zdCB5ID0gaXRlbS50ZXh0T2Zmc2V0O1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxhYmVsLCAwLCB5LCB0aWNrRm9udCwgcmVuZGVyVGV4dE9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChhcmVhKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9zaXRpb24sIHRpdGxlLCByZXZlcnNlfX0gPSB0aGlzO1xuXG4gICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlLnBhZGRpbmcpO1xuICAgIGNvbnN0IGFsaWduID0gdGl0bGUuYWxpZ247XG4gICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nIHx8IHBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLmJvdHRvbTtcbiAgICAgIGlmIChpc0FycmF5KHRpdGxlLnRleHQpKSB7XG4gICAgICAgIG9mZnNldCArPSBmb250LmxpbmVIZWlnaHQgKiAodGl0bGUudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcudG9wO1xuICAgIH1cblxuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRpdGxlQXJncyh0aGlzLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbik7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGUudGV4dCwgMCwgMCwgZm9udCwge1xuICAgICAgY29sb3I6IHRpdGxlLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG5cbiAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2xheWVycygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcbiAgICBjb25zdCBneiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZ3JpZCAmJiBvcHRzLmdyaWQueiwgLTEpO1xuICAgIGNvbnN0IGJ6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ib3JkZXIgJiYgb3B0cy5ib3JkZXIueiwgMCk7XG5cbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8IHRoaXMuZHJhdyAhPT0gU2NhbGUucHJvdG90eXBlLmRyYXcpIHtcbiAgICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGRyYXcgaGFzIGJlZW4gb3ZlcnJpZGRlbiBieSBjdXN0b20gc2NhbGVcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiB0eixcbiAgICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICAgIHRoaXMuZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3tcbiAgICAgIHo6IGd6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiBieixcbiAgICAgIGRyYXc6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogdHosXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1dO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdmlzaWJsZSBkYXRhc2V0IG1ldGFzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIHRoaXMgc2NhbGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIGlmIHNwZWNpZmllZCwgYWxzbyBmaWx0ZXIgYnkgZGF0YXNldCB0eXBlXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5jaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXhpc0lEID0gdGhpcy5heGlzICsgJ0F4aXNJRCc7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgICBpZiAobWV0YVtheGlzSURdID09PSB0aGlzLmlkICYmICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuICBfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpbmRleCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICByZXR1cm4gdG9Gb250KG9wdHMuZm9udCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX21heERpZ2l0cygpIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICByZXR1cm4gKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQpIC8gZm9udFNpemU7XG4gIH1cbn1cbiIsImltcG9ydCB7bWVyZ2V9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7aWQ6IHN0cmluZywgZGVmYXVsdHM6IGFueSwgb3ZlcnJpZGVzPzogYW55LCBkZWZhdWx0Um91dGVzOiBhbnl9fSBJQ2hhcnRDb21wb25lbnRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeXBlZFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgaXNGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SUNoYXJ0Q29tcG9uZW50fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzY29wZSB3aGVyZSBpdGVtcyBkZWZhdWx0cyB3ZXJlIHJlZ2lzdGVyZWQgdG8uXG5cdCAqL1xuICByZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaXRlbSk7XG4gICAgbGV0IHBhcmVudFNjb3BlO1xuXG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXJlbnQgaXMgcmVnaXN0ZXJlZCBhbmQgbm90ZSB0aGUgc2NvcGUgd2hlcmUgaXRzIGRlZmF1bHRzIGFyZS5cbiAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcblxuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogJyArIGl0ZW0pO1xuICAgIH1cblxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuXG4gICAgaXRlbXNbaWRdID0gaXRlbTtcbiAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgIGRlZmF1bHRzLm92ZXJyaWRlKGl0ZW0uaWQsIGl0ZW0ub3ZlcnJpZGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHtvYmplY3Q/fVxuXHQgKi9cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SUNoYXJ0Q29tcG9uZW50fSBpdGVtXG5cdCAqL1xuICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgZGVsZXRlIGl0ZW1zW2lkXTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkZWZhdWx0cyBhbmQga2VlcCBleGlzdGluZyBkZWZhdWx0c1xuICBjb25zdCBpdGVtRGVmYXVsdHMgPSBtZXJnZShPYmplY3QuY3JlYXRlKG51bGwpLCBbXG4gICAgcGFyZW50U2NvcGUgPyBkZWZhdWx0cy5nZXQocGFyZW50U2NvcGUpIDoge30sXG4gICAgZGVmYXVsdHMuZ2V0KHNjb3BlKSxcbiAgICBpdGVtLmRlZmF1bHRzXG4gIF0pO1xuXG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcblxuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuXG4gIGlmIChpdGVtLmRlc2NyaXB0b3JzKSB7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoc2NvcGUsIGl0ZW0uZGVzY3JpcHRvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJvdXRlRGVmYXVsdHMoc2NvcGUsIHJvdXRlcykge1xuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5UGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBwcm9wZXJ0eVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgIGNvbnN0IHBhcnRzID0gcm91dGVzW3Byb3BlcnR5XS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICBkZWZhdWx0cy5yb3V0ZShzb3VyY2VTY29wZSwgc291cmNlTmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4vY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgVHlwZWRSZWdpc3RyeSBmcm9tICcuL2NvcmUudHlwZWRSZWdpc3RyeS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGwsIF9jYXBpdGFsaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KE9iamVjdCwgJ3BsdWdpbnMnKTtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBTY2FsZSBoYXMgRWxlbWVudCBpbiBwcm90b3R5cGUgY2hhaW4sXG4gICAgLy8gc28gU2NhbGVzIG11c3QgYmUgYmVmb3JlIEVsZW1lbnRzLiBQbHVnaW5zIGFyZSBhIGZhbGxiYWNrLCBzbyBub3QgbGlzdGVkIGhlcmUuXG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgYWRkQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIEVsZW1lbnR9IGFyZ3Ncblx0ICovXG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn1cblx0ICovXG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIEVsZW1lbnR9XG5cdCAqL1xuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIFNjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIERhdGFzZXRDb250cm9sbGVyfSBhcmdzXG5cdCAqL1xuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICByZW1vdmVFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIFNjYWxlfSBhcmdzXG5cdCAqL1xuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgbG9vcGFibGUgYXJnc1xuICAgICAgICAvLyBVc2UgY2FzZTpcbiAgICAgICAgLy8gIGltcG9ydCAqIGFzIHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zLmpzJztcbiAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHBsdWdpbnMpO1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1peGVkIHR5cGVzIGluIHRoZSBsb29wYWJsZSwgbWFrZSBzdXJlIHRob3NlIGFyZVxuICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgaW4gY29ycmVjdCByZWdpc3RyeVxuICAgICAgICAgIC8vIFVzZSBjYXNlOiAodHJlZW1hcCBleHBvcnRpbmcgY29udHJvbGxlciwgZWxlbWVudHMgZXRjKVxuICAgICAgICAgIC8vICBpbXBvcnQgKiBhcyB0cmVlbWFwIGZyb20gJ2NoYXJ0anMtY2hhcnQtdHJlZW1hcC5qcyc7XG4gICAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHRyZWVtYXApO1xuXG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGJlZm9yZVJlZ2lzdGVyIC8gYmVmb3JlVW5yZWdpc3RlclxuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTsgLy8gYWZ0ZXJSZWdpc3RlciAvIGFmdGVyVW5yZWdpc3RlclxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcGx1Z2lucyBpcyB0aGUgZmFsbGJhY2sgcmVnaXN0cnlcbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBSZWdpc3RyeSgpO1xuIiwiaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgaXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vcGx1Z2lucy9wbHVnaW4udG9vbHRpcC5qcycpLmRlZmF1bHQgfSBUb29sdGlwXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZmlsdGVyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7e3BsdWdpbjogb2JqZWN0LCBvcHRpb25zOiBvYmplY3R9fSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAqIEBwYXJhbSB7YXJyYXl9IFthcnJheV1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ11cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbHVnaW5TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5pdCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgZm9yIGBjaGFydGAgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UgZm9yIHdoaWNoIHBsdWdpbnMgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuICAgKiBAcGFyYW0ge2ZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbml0ID09PSB1bmRlZmluZWQpIHsgLy8gRG8gbm90IHRyaWdnZXIgZXZlbnRzIGJlZm9yZSBpbnN0YWxsXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWx0ZXIgPyB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCkuZmlsdGVyKGZpbHRlcikgOiB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncyk7XG5cbiAgICBpZiAoaG9vayA9PT0gJ2FmdGVyRGVzdHJveScpIHtcbiAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICAgIHRoaXMuX2luaXQgPSB1bmRlZmluZWQ7IC8vIERvIG5vdCB0cmlnZ2VyIGV2ZW50cyBhZnRlciB1bmluc3RhbGxcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpIHtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuICAgICAgY29uc3QgbWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuICAgICAgY29uc3QgcGFyYW1zID0gW2NoYXJ0LCBhcmdzLCBkZXNjcmlwdG9yLm9wdGlvbnNdO1xuICAgICAgaWYgKGNhbGxDYWxsYmFjayhtZXRob2QsIHBhcmFtcywgcGx1Z2luKSA9PT0gZmFsc2UgJiYgYXJncy5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGludmFsaWRhdGUoKSB7XG4gICAgLy8gV2hlbiBwbHVnaW5zIGFyZSByZWdpc3RlcmVkLCB0aGVyZSBpcyB0aGUgcG9zc2liaWxpdHkgb2YgYSBkb3VibGVcbiAgICAvLyBpbnZhbGlkYXRlIHNpdHVhdGlvbi4gSW4gdGhpcyBjYXNlLCB3ZSBvbmx5IHdhbnQgdG8gaW52YWxpZGF0ZSBvbmNlLlxuICAgIC8vIElmIHdlIGludmFsaWRhdGUgbXVsdGlwbGUgdGltZXMsIHRoZSBgX29sZENhY2hlYCBpcyBsb3N0IGFuZCBhbGwgb2YgdGhlXG4gICAgLy8gcGx1Z2lucyBhcmUgcmVzdGFydGVkIHdpdGhvdXQgYmVpbmcgY29ycmVjdGx5IHN0b3BwZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy84MTQ3XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xuICAgICAgdGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc2NyaXB0b3JzKGNoYXJ0KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcblxuICAgIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH1cblxuICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgLy8gb3B0aW9ucyA9PT0gZmFsc2UgPT4gYWxsIHBsdWdpbnMgYXJlIGRpc2FibGVkXG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IGZhbHNlICYmICFhbGwgPyBbXSA6IGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KSB7XG4gICAgY29uc3QgcHJldmlvdXNEZXNjcmlwdG9ycyA9IHRoaXMuX29sZENhY2hlIHx8IFtdO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGU7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LnBsdWdpbi5pZCA9PT0geS5wbHVnaW4uaWQpKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihwcmV2aW91c0Rlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RvcCcpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKGRlc2NyaXB0b3JzLCBwcmV2aW91c0Rlc2NyaXB0b3JzKSwgY2hhcnQsICdzdGFydCcpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5jb25maWcuanMnKS5kZWZhdWx0fSBjb25maWdcbiAqL1xuZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgY29uc3QgbG9jYWxJZHMgPSB7fTtcbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHBsdWdpbnMucHVzaChyZWdpc3RyeS5nZXRQbHVnaW4oa2V5c1tpXSkpO1xuICB9XG5cbiAgY29uc3QgbG9jYWwgPSBjb25maWcucGx1Z2lucyB8fCBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsdWdpbiA9IGxvY2FsW2ldO1xuXG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICBsb2NhbElkc1twbHVnaW4uaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3BsdWdpbnMsIGxvY2FsSWRzfTtcbn1cblxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcbiAgaWYgKCFhbGwgJiYgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHtwbHVnaW5zLCBsb2NhbElkc30sIG9wdGlvbnMsIGFsbCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGNoYXJ0LmdldENvbnRleHQoKTtcblxuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBwbHVnaW4sXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywge3BsdWdpbiwgbG9jYWw6IGxvY2FsSWRzW2lkXX0sIG9wdHMsIGNvbnRleHQpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwbHVnaW5PcHRzKGNvbmZpZywge3BsdWdpbiwgbG9jYWx9LCBvcHRzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XG4gIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXMob3B0cywga2V5cyk7XG4gIGlmIChsb2NhbCAmJiBwbHVnaW4uZGVmYXVsdHMpIHtcbiAgICAvLyBtYWtlIHN1cmUgcGx1Z2luIGRlZmF1bHRzIGFyZSBpbiBzY29wZXMgZm9yIGxvY2FsIChub3QgcmVnaXN0ZXJlZCkgcGx1Z2luc1xuICAgIHNjb3Blcy5wdXNoKHBsdWdpbi5kZWZhdWx0cyk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFsnJ10sIHtcbiAgICAvLyBUaGVzZSBhcmUganVzdCBkZWZhdWx0cyB0aGF0IHBsdWdpbnMgY2FuIG92ZXJyaWRlXG4gICAgc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBhbGxLZXlzOiB0cnVlXG4gIH0pO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzLCBkZXNjcmlwdG9yc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7bWVyZ2VJZiwgcmVzb2x2ZU9iamVjdEtleSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgdmFsdWVPckRlZmF1bHQsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge19hdHRhY2hDb250ZXh0LCBfY3JlYXRlUmVzb2x2ZXIsIF9kZXNjcmlwdG9yc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbmZpZy5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fTtcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gIHJldHVybiBkYXRhc2V0T3B0aW9ucy5pbmRleEF4aXMgfHwgb3B0aW9ucy5pbmRleEF4aXMgfHwgZGF0YXNldERlZmF1bHRzLmluZGV4QXhpcyB8fCAneCc7XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoaWQsIGluZGV4QXhpcykge1xuICBsZXQgYXhpcyA9IGlkO1xuICBpZiAoaWQgPT09ICdfaW5kZXhfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXM7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICdfdmFsdWVfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgfVxuICByZXR1cm4gYXhpcztcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cblxuZnVuY3Rpb24gaWRNYXRjaGVzQXhpcyhpZCkge1xuICBpZiAoaWQgPT09ICd4JyB8fCBpZCA9PT0gJ3knIHx8IGlkID09PSAncicpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVBeGlzKGlkLCAuLi5zY2FsZU9wdGlvbnMpIHtcbiAgaWYgKGlkTWF0Y2hlc0F4aXMoaWQpKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGZvciAoY29uc3Qgb3B0cyBvZiBzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBheGlzID0gb3B0cy5heGlzXG4gICAgICB8fCBheGlzRnJvbVBvc2l0aW9uKG9wdHMucG9zaXRpb24pXG4gICAgICB8fCBpZC5sZW5ndGggPiAxICYmIGlkTWF0Y2hlc0F4aXMoaWRbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKGF4aXMpIHtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkZXRlcm1pbmUgdHlwZSBvZiAnJHtpZH0nIGF4aXMuIFBsZWFzZSBwcm92aWRlICdheGlzJyBvciAncG9zaXRpb24nIG9wdGlvbi5gKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCBheGlzLCBkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gPT09IGlkKSB7XG4gICAgcmV0dXJuIHtheGlzfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMoaWQsIGNvbmZpZykge1xuICBpZiAoY29uZmlnLmRhdGEgJiYgY29uZmlnLmRhdGEuZGF0YXNldHMpIHtcbiAgICBjb25zdCBib3VuZERzID0gY29uZmlnLmRhdGEuZGF0YXNldHMuZmlsdGVyKChkKSA9PiBkLnhBeGlzSUQgPT09IGlkIHx8IGQueUF4aXNJRCA9PT0gaWQpO1xuICAgIGlmIChib3VuZERzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGdldEF4aXNGcm9tRGF0YXNldChpZCwgJ3gnLCBib3VuZERzWzBdKSB8fCBnZXRBeGlzRnJvbURhdGFzZXQoaWQsICd5JywgYm91bmREc1swXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xuICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgY29uc3QgY2hhcnRJbmRleEF4aXMgPSBnZXRJbmRleEF4aXMoY29uZmlnLnR5cGUsIG9wdGlvbnMpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIEZpcnN0IGZpZ3VyZSBvdXQgZmlyc3Qgc2NhbGUgaWQncyBwZXIgYXhpcy5cbiAgT2JqZWN0LmtleXMoY29uZmlnU2NhbGVzKS5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBzY2FsZUNvbmYgPSBjb25maWdTY2FsZXNbaWRdO1xuICAgIGlmICghaXNPYmplY3Qoc2NhbGVDb25mKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2NhbGUgY29uZmlndXJhdGlvbiBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZUNvbmYsIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSwgZGVmYXVsdHMuc2NhbGVzW3NjYWxlQ29uZi50eXBlXSk7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIHNjYWxlc1tpZF0gPSBtZXJnZUlmKE9iamVjdC5jcmVhdGUobnVsbCksIFt7YXhpc30sIHNjYWxlQ29uZiwgZGVmYXVsdFNjYWxlT3B0aW9uc1theGlzXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SWRdXSk7XG4gIH0pO1xuXG4gIC8vIFRoZW4gbWVyZ2UgZGF0YXNldCBkZWZhdWx0cyB0byBzY2FsZSBjb25maWdzXG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYXBwbHkgc2NhbGUgZGVmYXVsdHMsIGlmIG5vdCBvdmVycmlkZGVuIGJ5IGRhdGFzZXQgZGVmYXVsdHNcbiAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xuICB9KTtcblxuICByZXR1cm4gc2NhbGVzO1xufVxuXG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcblxuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgb3B0aW9ucy5zY2FsZXMgPSBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhKGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEgfHwge307XG4gIGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuICBkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcblxuICBpbml0T3B0aW9ucyhjb25maWcpO1xuXG4gIHJldHVybiBjb25maWc7XG59XG5cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gY2FjaGVkS2V5cyhjYWNoZUtleSwgZ2VuZXJhdGUpIHtcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gZ2VuZXJhdGUoKTtcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xuICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5jb25zdCBhZGRJZkZvdW5kID0gKHNldCwgb2JqLCBrZXkpID0+IHtcbiAgY29uc3Qgb3B0cyA9IHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpO1xuICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0LmFkZChvcHRzKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGdldCBwbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICB9XG5cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgfVxuXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9jb25maWcuZGF0YSA9IGluaXREYXRhKGRhdGEpO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuXG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGRhdGFzZXQgb3B0aW9ucy5cbiAgICogVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXQgaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGRhdGFzZXQgYW5pbWF0aW9uIG9wdGlvbnMuXG4gICAqIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0IGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zaXRpb25cbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbi4ke3RyYW5zaXRpb259YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgICBgdHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlIHVzZWQgZm9yIGxvb2tpbmcgdXAgdGhlIGBhbmltYXRpb25zYCBhbmQgYGFuaW1hdGlvbmAga2V5c1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBlbGVtZW50IG9wdGlvbnMgdGhhdCBiZWxvbmdcbiAgICogdG8gYW4gZGF0YXNldC4gVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXRcbiAgICogaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudFR5cGVcbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKGRhdGFzZXRUeXBlLCBlbGVtZW50VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS0ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0uZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIHBsdWdpbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3tpZDogc3RyaW5nLCBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzPzogc3RyaW5nW119fSBwbHVnaW5cbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdLFxuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIG9iamVjdHMgZnJvbSBvcHRpb25zIGFuZCBkZWZhdWx0cyBmb3Igb3B0aW9uIHZhbHVlIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYWluU2NvcGUgLSBUaGUgbWFpbiBzY29wZSBvYmplY3QgZm9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmdbXVtdfSBrZXlMaXN0cyAtIFRoZSBhcnJheXMgb2Yga2V5cyBpbiByZXNvbHV0aW9uIG9yZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0Q2FjaGVdIC0gcmVzZXQgdGhlIGNhY2hlIGZvciB0aGlzIG1haW5TY29wZVxuICAgKi9cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBTZXQoKTtcblxuICAgIGtleUxpc3RzLmZvckVhY2goa2V5cyA9PiB7XG4gICAgICBpZiAobWFpblNjb3BlKSB7XG4gICAgICAgIHNjb3Blcy5hZGQobWFpblNjb3BlKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgbWFpblNjb3BlLCBrZXkpKTtcbiAgICAgIH1cbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG9wdGlvbnMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlZmF1bHRzLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlc2NyaXB0b3JzLCBrZXkpKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlcyBmb3IgcmVzb2x2aW5nIGNoYXJ0IG9wdGlvbnNcbiAgICogQHJldHVybiB7b2JqZWN0W119XG4gICAqL1xuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvdmVycmlkZXNbdHlwZV0gfHwge30sXG4gICAgICBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fSwgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzg1MzFcbiAgICAgIHt0eXBlfSxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgZGVzY3JpcHRvcnNcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjb3Blc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBuYW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdH0gY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbcHJlZml4ZXNdXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG4gIHJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyRzaGFyZWQ6IHRydWV9O1xuICAgIGNvbnN0IHtyZXNvbHZlciwgc3ViUHJlZml4ZXN9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgbGV0IG9wdGlvbnMgPSByZXNvbHZlcjtcbiAgICBpZiAobmVlZENvbnRleHQocmVzb2x2ZXIsIG5hbWVzKSkge1xuICAgICAgcmVzdWx0LiRzaGFyZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQgPSBpc0Z1bmN0aW9uKGNvbnRleHQpID8gY29udGV4dCgpIDogY29udGV4dDtcbiAgICAgIC8vIHN1YlJlc29sdmVyIGlzIHBhc3NlZCB0byBzY3JpcHRhYmxlIG9wdGlvbnMuIEl0IHNob3VsZCBub3QgcmVzb2x2ZSB0byBob3ZlciBvcHRpb25zLlxuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjb3Blc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtwcmVmaXhlc11cbiAgICogQHBhcmFtIHt7c2NyaXB0YWJsZTogYm9vbGVhbiwgaW5kZXhhYmxlOiBib29sZWFuLCBhbGxLZXlzPzogYm9vbGVhbn19IFtkZXNjcmlwdG9yRGVmYXVsdHNdXG4gICAqL1xuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHJlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpIHtcbiAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJlc29sdmVyQ2FjaGUuc2V0KHNjb3BlcywgY2FjaGUpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJlZml4ZXMuam9pbigpO1xuICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFjYWNoZWQpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzKTtcbiAgICBjYWNoZWQgPSB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1YlByZWZpeGVzOiBwcmVmaXhlcy5maWx0ZXIocCA9PiAhcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdob3ZlcicpKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5cbmNvbnN0IGhhc0Z1bmN0aW9uID0gdmFsdWUgPT4gaXNPYmplY3QodmFsdWUpXG4gICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5zb21lKChrZXkpID0+IGlzRnVuY3Rpb24odmFsdWVba2V5XSkpO1xuXG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICBjb25zdCBzY3JpcHRhYmxlID0gaXNTY3JpcHRhYmxlKHByb3ApO1xuICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgIGNvbnN0IHZhbHVlID0gKGluZGV4YWJsZSB8fCBzY3JpcHRhYmxlKSAmJiBwcm94eVtwcm9wXTtcbiAgICBpZiAoKHNjcmlwdGFibGUgJiYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGhhc0Z1bmN0aW9uKHZhbHVlKSkpXG4gICAgICB8fCAoaW5kZXhhYmxlICYmIGlzQXJyYXkodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vY29yZS5pbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge19kZXRlY3RQbGF0Zm9ybX0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IFBsdWdpblNlcnZpY2UgZnJvbSAnLi9jb3JlLnBsdWdpbnMuanMnO1xuaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQgQ29uZmlnLCB7ZGV0ZXJtaW5lQXhpcywgZ2V0SW5kZXhBeGlzfSBmcm9tICcuL2NvcmUuY29uZmlnLmpzJztcbmltcG9ydCB7ZWFjaCwgY2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCB1aWQsIHZhbHVlT3JEZWZhdWx0LCBfZWxlbWVudHNFcXVhbCwgaXNOdWxsT3JVbmRlZiwgc2V0c0VxdWFsLCBkZWZpbmVkLCBpc0Z1bmN0aW9uLCBfaXNDbGlja0V2ZW50fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2NsZWFyQ2FudmFzLCBjbGlwQXJlYSwgY3JlYXRlQ29udGV4dCwgdW5jbGlwQXJlYSwgX2lzUG9pbnRJbkFyZWEsIF9pc0RvbVN1cHBvcnRlZCwgcmV0aW5hU2NhbGUsIGdldERhdGFzZXRDbGlwQXJlYX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge3ZlcnNpb259IGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQge2RlYm91bmNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuUG9pbnQgfSBQb2ludFxuICovXG5cbmNvbnN0IEtOT1dOX1BPU0lUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NoYXJ0QXJlYSddO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZTJMZXZlbChsMSwgbDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYVtsMV0gPT09IGJbbDFdXG4gICAgICA/IGFbbDJdIC0gYltsMl1cbiAgICAgIDogYVtsMV0gLSBiW2wxXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BbmltYXRpb25zQ29tcGxldGUoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcblxuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICBjYWxsQ2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuXG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNhbGxDYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcywgW2NvbnRleHRdLCBjaGFydCk7XG59XG5cbi8qKlxuICogQ2hhcnQuanMgY2FuIHRha2UgYSBzdHJpbmcgaWQgb2YgYSBjYW52YXMgZWxlbWVudCwgYSAyZCBjb250ZXh0LCBvciBhIGNhbnZhcyBlbGVtZW50IGl0c2VsZi5cbiAqIEF0dGVtcHQgdG8gdW53cmFwIHRoZSBpdGVtIHBhc3NlZCBpbnRvIHRoZSBjaGFydCBjb25zdHJ1Y3RvciBzbyB0aGF0IGl0IGlzIGEgY2FudmFzIGVsZW1lbnQgKGlmIHBvc3NpYmxlKS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpICYmIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0ubGVuZ3RoKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG4gICAgaXRlbSA9IGl0ZW1bMF07XG4gIH1cblxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuICAgIC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxuICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuY29uc3QgaW5zdGFuY2VzID0ge307XG5jb25zdCBnZXRDaGFydCA9IChrZXkpID0+IHtcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZmlsdGVyKChjKSA9PiBjLmNhbnZhcyA9PT0gY2FudmFzKS5wb3AoKTtcbn07XG5cbmZ1bmN0aW9uIG1vdmVOdW1lcmljS2V5cyhvYmosIHN0YXJ0LCBtb3ZlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgaW50S2V5ID0gK2tleTtcbiAgICBpZiAoaW50S2V5ID49IHN0YXJ0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgaWYgKG1vdmUgPiAwIHx8IGludEtleSA+IHN0YXJ0KSB7XG4gICAgICAgIG9ialtpbnRLZXkgKyBtb3ZlXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZVxuICogQHBhcmFtIHtDaGFydEV2ZW50fG51bGx9IGxhc3RFdmVudFxuICogQHBhcmFtIHtib29sZWFufSBpbkNoYXJ0QXJlYVxuICogQHBhcmFtIHtib29sZWFufSBpc0NsaWNrXG4gKiBAcmV0dXJucyB7Q2hhcnRFdmVudHxudWxsfVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICBpZiAoIWluQ2hhcnRBcmVhIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0NsaWNrKSB7XG4gICAgcmV0dXJuIGxhc3RFdmVudDtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuY2xhc3MgQ2hhcnQge1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IGRlZmF1bHRzO1xuICBzdGF0aWMgaW5zdGFuY2VzID0gaW5zdGFuY2VzO1xuICBzdGF0aWMgb3ZlcnJpZGVzID0gb3ZlcnJpZGVzO1xuICBzdGF0aWMgcmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgc3RhdGljIHZlcnNpb24gPSB2ZXJzaW9uO1xuICBzdGF0aWMgZ2V0Q2hhcnQgPSBnZXRDaGFydDtcblxuICBzdGF0aWMgcmVnaXN0ZXIoLi4uaXRlbXMpIHtcbiAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xuICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gIH1cblxuICBzdGF0aWMgdW5yZWdpc3RlciguLi5pdGVtcykge1xuICAgIHJlZ2lzdHJ5LnJlbW92ZSguLi5pdGVtcyk7XG4gICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihpdGVtLCB1c2VyQ29uZmlnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IGluaXRpYWxDYW52YXMgPSBnZXRDYW52YXMoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdDaGFydCA9IGdldENoYXJ0KGluaXRpYWxDYW52YXMpO1xuICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW52YXMgaXMgYWxyZWFkeSBpbiB1c2UuIENoYXJ0IHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuaWQgKyAnXFwnJyArXG5cdFx0XHRcdCcgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5jYW52YXMuaWQgKyAnXFwnIGNhbiBiZSByZXVzZWQuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG5cbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IChjb25maWcucGxhdGZvcm0gfHwgX2RldGVjdFBsYXRmb3JtKGluaXRpYWxDYW52YXMpKSgpO1xuICAgIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKGNvbmZpZyk7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpbml0aWFsQ2FudmFzLCBvcHRpb25zLmFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcblxuICAgIHRoaXMuaWQgPSB1aWQoKTtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIFN0b3JlIHRoZSBwcmV2aW91c2x5IHVzZWQgYXNwZWN0IHJhdGlvIHRvIGRldGVybWluZSBpZiBhIHJlc2l6ZVxuICAgIC8vIGlzIG5lZWRlZCBkdXJpbmcgdXBkYXRlcy4gRG8gdGhpcyBhZnRlciBfb3B0aW9ucyBpcyBzZXQgc2luY2VcbiAgICAvLyBhc3BlY3RSYXRpbyB1c2VzIGEgZ2V0dGVyXG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIHRoaXMuX21ldGFzZXRzID0gW107XG4gICAgdGhpcy5fc3RhY2tzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm94ZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnRBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAvKiogQHR5cGUgez97YXR0YWNoPzogZnVuY3Rpb24sIGRldGFjaD86IGZ1bmN0aW9uLCByZXNpemU/OiBmdW5jdGlvbn19ICovXG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5fcGx1Z2lucyA9IG5ldyBQbHVnaW5TZXJ2aWNlKCk7XG4gICAgdGhpcy4kcHJveGllcyA9IHt9O1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXMgPSB7fTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9SZXNpemUgPSBkZWJvdW5jZShtb2RlID0+IHRoaXMudXBkYXRlKG1vZGUpLCBvcHRpb25zLnJlc2l6ZURlbGF5IHx8IDApO1xuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG5cbiAgICAvLyBBZGQgdGhlIGNoYXJ0IGluc3RhbmNlIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG4gICAgaW5zdGFuY2VzW3RoaXMuaWRdID0gdGhpcztcblxuICAgIGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG4gICAgICAvLyBUaGUgZ2l2ZW4gaXRlbSBpcyBub3QgYSBjb21wYXRpYmxlIGNvbnRleHQyZCBlbGVtZW50LCBsZXQncyByZXR1cm4gYmVmb3JlIGZpbmFsaXppbmdcbiAgICAgIC8vIHRoZSBjaGFydCBpbml0aWFsaXphdGlvbiBidXQgYWZ0ZXIgc2V0dGluZyBiYXNpYyBjaGFydCAvIGNvbnRyb2xsZXIgcHJvcGVydGllcyB0aGF0XG4gICAgICAvLyBjYW4gaGVscCB0byBmaWd1cmUgb3V0IHRoYXQgdGhlIGNoYXJ0IGlzIG5vdCB2YWxpZCAoZS5nIGNoYXJ0LmNhbnZhcyAhPT0gbnVsbCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAnY29tcGxldGUnLCBvbkFuaW1hdGlvbnNDb21wbGV0ZSk7XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdwcm9ncmVzcycsIG9uQW5pbWF0aW9uUHJvZ3Jlc3MpO1xuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICBjb25zdCB7b3B0aW9uczoge2FzcGVjdFJhdGlvLCBtYWludGFpbkFzcGVjdFJhdGlvfSwgd2lkdGgsIGhlaWdodCwgX2FzcGVjdFJhdGlvfSA9IHRoaXM7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xuICAgICAgLy8gSWYgYXNwZWN0UmF0aW8gaXMgZGVmaW5lZCBpbiBvcHRpb25zLCB1c2UgdGhhdC5cbiAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcbiAgICAgIC8vIElmIG1haW50YWluQXNwZWN0UmF0aW8gaXMgdHJ1dGhseSBhbmQgd2UgaGFkIHByZXZpb3VzbHkgZGV0ZXJtaW5lZCBfYXNwZWN0UmF0aW8sIHVzZSB0aGF0XG4gICAgICByZXR1cm4gX2FzcGVjdFJhdGlvO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZVxuICAgIHJldHVybiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG4gIH1cblxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YTtcbiAgfVxuXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLmNvbmZpZy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZ2V0IHJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiByZWdpc3RyeTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgLy8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlSW5pdCcpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRpbmFTY2FsZSh0aGlzLCB0aGlzLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfVxuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG5cbiAgICAvLyBBZnRlciBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBjbGVhckNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBhbmltYXRvci5zdG9wKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc2l6ZSB0aGUgY2hhcnQgdG8gaXRzIGNvbnRhaW5lciBvciB0byBleHBsaWNpdCBkaW1lbnNpb25zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF1cblx0ICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7d2lkdGgsIGhlaWdodH07XG4gICAgfVxuICB9XG5cbiAgX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IG5ld1JhdGlvID0gb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvIHx8IHRoaXMucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLndpZHRoID8gJ3Jlc2l6ZScgOiAnYXR0YWNoJztcblxuICAgIHRoaXMud2lkdGggPSBuZXdTaXplLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGlmICghcmV0aW5hU2NhbGUodGhpcywgbmV3UmF0aW8sIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNpemUnLCB7c2l6ZTogbmV3U2l6ZX0pO1xuXG4gICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25SZXNpemUsIFt0aGlzLCBuZXdTaXplXSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKHRoaXMuX2RvUmVzaXplKG1vZGUpKSB7XG4gICAgICAgIC8vIFRoZSByZXNpemUgdXBkYXRlIGlzIGRlbGF5ZWQsIG9ubHkgZHJhdyB3aXRob3V0IHVwZGF0aW5nLlxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG5cbiAgICBlYWNoKHNjYWxlc09wdGlvbnMsIChheGlzT3B0aW9ucywgYXhpc0lEKSA9PiB7XG4gICAgICBheGlzT3B0aW9ucy5pZCA9IGF4aXNJRDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBCdWlsZHMgYSBtYXAgb2Ygc2NhbGUgSUQgdG8gc2NhbGUgb2JqZWN0IGZvciBmdXR1cmUgbG9va3VwLlxuXHQgKi9cbiAgYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlT3B0cyA9IG9wdGlvbnMuc2NhbGVzO1xuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZSgob2JqLCBpZCkgPT4ge1xuICAgICAgb2JqW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgbGV0IGl0ZW1zID0gW107XG5cbiAgICBpZiAoc2NhbGVPcHRzKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc2NhbGVPcHRzKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGVPcHRzW2lkXTtcbiAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICBjb25zdCBpc1JhZGlhbCA9IGF4aXMgPT09ICdyJztcbiAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRwb3NpdGlvbjogaXNSYWRpYWwgPyAnY2hhcnRBcmVhJyA6IGlzSG9yaXpvbnRhbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBlYWNoKGl0ZW1zLCAoaXRlbSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG4gICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNjYWxlVHlwZSA9IHZhbHVlT3JEZWZhdWx0KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcblxuICAgICAgaWYgKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiwgYXhpcykgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlZFtpZF0gPSB0cnVlO1xuICAgICAgbGV0IHNjYWxlID0gbnVsbDtcbiAgICAgIGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZXNbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XG4gICAgICAgIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcbiAgICAgICAgICBjdHg6IHRoaXMuY3R4LFxuICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlLmluaXQoc2NhbGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICAvLyBjbGVhciB1cCBkaXNjYXJkZWQgc2NhbGVzXG4gICAgZWFjaCh1cGRhdGVkLCAoaGFzVXBkYXRlZCwgaWQpID0+IHtcbiAgICAgIGlmICghaGFzVXBkYXRlZCkge1xuICAgICAgICBkZWxldGUgc2NhbGVzW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMuY29uZmlndXJlKHRoaXMsIHNjYWxlLCBzY2FsZS5vcHRpb25zKTtcbiAgICAgIGxheW91dHMuYWRkQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZU1ldGFzZXRzKCkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgY29uc3QgbnVtRGF0YSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtTWV0YSA9IG1ldGFzZXRzLmxlbmd0aDtcblxuICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcbiAgICBpZiAobnVtTWV0YSA+IG51bURhdGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSBudW1EYXRhOyBpIDwgbnVtTWV0YTsgKytpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGFzZXRzLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gbWV0YXNldHMuc2xpY2UoMCkuc29ydChjb21wYXJlMkxldmVsKCdvcmRlcicsICdpbmRleCcpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCkge1xuICAgIGNvbnN0IHtfbWV0YXNldHM6IG1ldGFzZXRzLCBkYXRhOiB7ZGF0YXNldHN9fSA9IHRoaXM7XG4gICAgaWYgKG1ldGFzZXRzLmxlbmd0aCA+IGRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0YWNrcztcbiAgICB9XG4gICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXRhc2V0cy5maWx0ZXIoeCA9PiB4ID09PSBtZXRhLl9kYXRhc2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpIHtcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRzID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgdGhpcy5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcbiAgICAgIGxldCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgdGhpcy5jb25maWcudHlwZTtcblxuICAgICAgaWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGEudHlwZSA9IHR5cGU7XG4gICAgICBtZXRhLmluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgbWV0YS5vcmRlciA9IGRhdGFzZXQub3JkZXIgfHwgMDtcbiAgICAgIG1ldGEuaW5kZXggPSBpO1xuICAgICAgbWV0YS5sYWJlbCA9ICcnICsgZGF0YXNldC5sYWJlbDtcbiAgICAgIG1ldGEudmlzaWJsZSA9IHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKTtcblxuICAgICAgaWYgKG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgICAgICBjb25zdCB7ZGF0YXNldEVsZW1lbnRUeXBlLCBkYXRhRWxlbWVudFR5cGV9ID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oQ29udHJvbGxlckNsYXNzLCB7XG4gICAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFFbGVtZW50VHlwZSksXG4gICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBkYXRhc2V0RWxlbWVudFR5cGUgJiYgcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhc2V0RWxlbWVudFR5cGUpXG4gICAgICAgIH0pO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMsIGkpO1xuICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlTWV0YXNldHMoKTtcbiAgICByZXR1cm4gbmV3Q29udHJvbGxlcnM7XG4gIH1cblxuICAvKipcblx0ICogUmVzZXQgdGhlIGVsZW1lbnRzIG9mIGFsbCBkYXRhc2V0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgZWFjaCh0aGlzLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICAvKipcblx0KiBSZXNldHMgdGhlIGNoYXJ0IGJhY2sgdG8gaXRzIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbCBhbmltYXRpb25cblx0Ki9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICBjb25maWcudXBkYXRlKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhbmltc0Rpc2FibGVkID0gdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gIW9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gICAgdGhpcy5fdXBkYXRlU2NhbGVzKCk7XG4gICAgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCk7XG4gICAgdGhpcy5fdXBkYXRlSGlkZGVuSW5kaWNlcygpO1xuXG4gICAgLy8gcGx1Z2lucyBvcHRpb25zIHJlZmVyZW5jZXMgbWlnaHQgaGF2ZSBjaGFuZ2UsIGxldCdzIGludmFsaWRhdGUgdGhlIGNhY2hlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUxMTEjaXNzdWVjb21tZW50LTM1NTkzNDE2N1xuICAgIHRoaXMuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgZGF0YXNldCBjb250cm9sbGVycyBhcmUgdXBkYXRlZCBhbmQgbmV3IGNvbnRyb2xsZXJzIGFyZSByZXNldFxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRWxlbWVudHNVcGRhdGUnKTtcblxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgZGF0YXNldCBjb250cm9sbGVycyBoYXZlIGNvcnJlY3QgbWV0YSBkYXRhIGNvdW50c1xuICAgIGxldCBtaW5QYWRkaW5nID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHtjb250cm9sbGVyfSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCByZXNldCA9ICFhbmltc0Rpc2FibGVkICYmIG5ld0NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPT09IC0xO1xuICAgICAgLy8gTmV3IGNvbnRyb2xsZXJzIHdpbGwgYmUgcmVzZXQgYWZ0ZXIgdGhlIGxheW91dCBwYXNzLCBzbyB3ZSBvbmx5IHdhbnQgdG8gbW9kaWZ5XG4gICAgICAvLyBlbGVtZW50cyBhZGRlZCB0byBuZXcgZGF0YXNldHNcbiAgICAgIGNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0KTtcbiAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1heCgrY29udHJvbGxlci5nZXRNYXhPdmVyZmxvdygpLCBtaW5QYWRkaW5nKTtcbiAgICB9XG4gICAgbWluUGFkZGluZyA9IHRoaXMuX21pblBhZGRpbmcgPSBvcHRpb25zLmxheW91dC5hdXRvUGFkZGluZyA/IG1pblBhZGRpbmcgOiAwO1xuICAgIHRoaXMuX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKTtcblxuICAgIC8vIE9ubHkgcmVzZXQgdGhlIGNvbnRyb2xsZXJzIGlmIHdlIGhhdmUgYW5pbWF0aW9uc1xuICAgIGlmICghYW5pbXNEaXNhYmxlZCkge1xuICAgICAgLy8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXG4gICAgICAvLyBSZXNldCBpcyBkb25lIHRvIGdldCB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBpbml0aWFsIGFuaW1hdGlvblxuICAgICAgZWFjaChuZXdDb250cm9sbGVycywgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlRGF0YXNldHMobW9kZSk7XG5cbiAgICAvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlclVwZGF0ZScsIHttb2RlfSk7XG5cbiAgICB0aGlzLl9sYXllcnMuc29ydChjb21wYXJlMkxldmVsKCd6JywgJ19pZHgnKSk7XG5cbiAgICAvLyBSZXBsYXkgbGFzdCBldmVudCBmcm9tIGJlZm9yZSB1cGRhdGUsIG9yIHNldCBob3ZlciBzdHlsZXMgb24gYWN0aXZlIGVsZW1lbnRzXG4gICAgY29uc3Qge19hY3RpdmUsIF9sYXN0RXZlbnR9ID0gdGhpcztcbiAgICBpZiAoX2xhc3RFdmVudCkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKF9sYXN0RXZlbnQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoX2FjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKF9hY3RpdmUsIF9hY3RpdmUsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgZWFjaCh0aGlzLnNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLnJlbW92ZUJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcbiAgICB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrRXZlbnRCaW5kaW5ncygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLl9saXN0ZW5lcnMpKTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBuZXcgU2V0KG9wdGlvbnMuZXZlbnRzKTtcblxuICAgIGlmICghc2V0c0VxdWFsKGV4aXN0aW5nRXZlbnRzLCBuZXdFdmVudHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gb3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICAvLyBUaGUgY29uZmlndXJlZCBldmVudHMgaGF2ZSBjaGFuZ2VkLiBSZWJpbmQuXG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICBjb25zdCB7X2hpZGRlbkluZGljZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgZm9yIChjb25zdCB7bWV0aG9kLCBzdGFydCwgY291bnR9IG9mIGNoYW5nZXMpIHtcbiAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XG4gICAgICBtb3ZlTnVtZXJpY0tleXMoX2hpZGRlbkluZGljZXMsIHN0YXJ0LCBtb3ZlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB7XG4gICAgY29uc3QgX2RhdGFDaGFuZ2VzID0gdGhpcy5fZGF0YUNoYW5nZXM7XG4gICAgaWYgKCFfZGF0YUNoYW5nZXMgfHwgIV9kYXRhQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRDb3VudCA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbWFrZVNldCA9IChpZHgpID0+IG5ldyBTZXQoXG4gICAgICBfZGF0YUNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGNbMF0gPT09IGlkeClcbiAgICAgICAgLm1hcCgoYywgaSkgPT4gaSArICcsJyArIGMuc3BsaWNlKDEpLmpvaW4oJywnKSlcbiAgICApO1xuXG4gICAgY29uc3QgY2hhbmdlU2V0ID0gbWFrZVNldCgwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGFzZXRDb3VudDsgaSsrKSB7XG4gICAgICBpZiAoIXNldHNFcXVhbChjaGFuZ2VTZXQsIG1ha2VTZXQoaSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbmdlU2V0KVxuICAgICAgLm1hcChjID0+IGMuc3BsaXQoJywnKSlcbiAgICAgIC5tYXAoYSA9PiAoe21ldGhvZDogYVsxXSwgc3RhcnQ6ICthWzJdLCBjb3VudDogK2FbM119KSk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyB0aGUgY2hhcnQgbGF5b3V0IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVMYXlvdXRgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckxheW91dGAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVMYXlvdXQnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcblxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBub0FyZWEgPSBhcmVhLndpZHRoIDw9IDAgfHwgYXJlYS5oZWlnaHQgPD0gMDtcblxuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIGVhY2godGhpcy5ib3hlcywgKGJveCkgPT4ge1xuICAgICAgaWYgKG5vQXJlYSAmJiBib3gucG9zaXRpb24gPT09ICdjaGFydEFyZWEnKSB7XG4gICAgICAgIC8vIFNraXAgZHJhd2luZyBhbmQgY29uZmlndXJpbmcgY2hhcnRBcmVhIGJveGVzIHdoZW4gY2hhcnRBcmVhIGlzIHplcm8gb3IgbmVnYXRpdmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGluIGNvcmUuc2NhbGUudXBkYXRlIGFuZCBvbmNlIGhlcmUuXG4gICAgICAvLyBIZXJlIHRoZSBib3hlcyBhcmUgZnVsbHkgdXBkYXRlZCBhbmQgYXQgdGhlaXIgZmluYWwgcG9zaXRpb25zLlxuICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2goLi4uYm94Ll9sYXllcnMoKSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGl0ZW0uX2lkeCA9IGluZGV4O1xuICAgIH0pO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckxheW91dCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEYXRhc2V0KGksIGlzRnVuY3Rpb24obW9kZSkgPyBtb2RlKHtkYXRhc2V0SW5kZXg6IGl9KSA6IG1vZGUpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0VXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0VXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVEYXRhc2V0KGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgIGNvbnN0IGFyZ3MgPSB7bWV0YSwgaW5kZXgsIG1vZGUsIGNhbmNlbGFibGU6IHRydWV9O1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1ldGEuY29udHJvbGxlci5fdXBkYXRlKG1vZGUpO1xuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRVcGRhdGUnLCBhcmdzKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRvci5oYXModGhpcykpIHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICAgIG9uQW5pbWF0aW9uc0NvbXBsZXRlKHtjaGFydDogdGhpc30pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXc7XG4gICAgICAvLyBVbnNldCBwZW5kaW5nIHJlc2l6ZSByZXF1ZXN0IG5vdyB0byBhdm9pZCBwb3NzaWJsZSByZWN1cnNpb24gd2l0aGluIF9yZXNpemVcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCZWNhdXNlIG9mIHBsdWdpbiBob29rcyAoYmVmb3JlL2FmdGVyRGF0YXNldHNEcmF3KSwgZGF0YXNldHMgY2FuJ3RcbiAgICAvLyBjdXJyZW50bHkgYmUgcGFydCBvZiBsYXllcnMuIEluc3RlYWQsIHdlIGRyYXdcbiAgICAvLyBsYXllcnMgPD0gMCBiZWZvcmUoZGVmYXVsdCwgYmFja3dhcmQgY29tcGF0KSwgYW5kIHRoZSByZXN0IGFmdGVyXG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYXdEYXRhc2V0cygpO1xuXG4gICAgLy8gUmVzdCBvZiBsYXllcnNcbiAgICBmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fc29ydGVkTWV0YXNldHM7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgdmlzaWJsZSBkYXRhc2V0IG1ldGFzIGluIGRyYXdpbmcgb3JkZXJcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogRHJhd3MgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c0RyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzRHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRoaXMuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNEcmF3Jyk7XG4gIH1cblxuICAvKipcblx0ICogRHJhd3MgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldERyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXREcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBjbGlwID0gZ2V0RGF0YXNldENsaXBBcmVhKHRoaXMsIG1ldGEpO1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBjbGlwKTtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuXG4gICAgaWYgKGNsaXApIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW4gdGhlIGNoYXJ0IGFyZWEuXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXMgKHNlZSwgZS5nLiwgZ2V0UmVsYXRpdmVQb3NpdGlvbilcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BvaW50SW5BcmVhKHBvaW50KSB7XG4gICAgcmV0dXJuIF9pc1BvaW50SW5BcmVhKHBvaW50LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XG4gIH1cblxuICBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG1vZGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcih4ID0+IHggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XG5cbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIG1ldGEgPSB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBkYXRhc2V0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgICBoaWRkZW46IG51bGwsXHRcdFx0Ly8gU2VlIGlzRGF0YXNldFZpc2libGUoKSBjb21tZW50XG4gICAgICAgIHhBeGlzSUQ6IG51bGwsXG4gICAgICAgIHlBeGlzSUQ6IG51bGwsXG4gICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcbiAgICAgICAgaW5kZXg6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgX2RhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICBfc29ydGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIG1ldGFzZXRzLnB1c2gobWV0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cblxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsLCB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KSk7XG4gIH1cblxuICBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gIH1cblxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgLy8gbWV0YS5oaWRkZW4gaXMgYSBwZXIgY2hhcnQgZGF0YXNldCBoaWRkZW4gZmxhZyBvdmVycmlkZSB3aXRoIDMgc3RhdGVzOiBpZiB0cnVlIG9yIGZhbHNlLFxuICAgIC8vIHRoZSBkYXRhc2V0LmhpZGRlbiB2YWx1ZSBpcyBpZ25vcmVkLCBlbHNlIGlmIG51bGwsIHRoZSBkYXRhc2V0IGhpZGRlbiBzdGF0ZSBpcyByZXR1cm5lZC5cbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cblxuICBzZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIG1ldGEuaGlkZGVuID0gIXZpc2libGU7XG4gIH1cblxuICB0b2dnbGVEYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG5cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1vZGUgPSB2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgY29uc3QgYW5pbXMgPSBtZXRhLmNvbnRyb2xsZXIuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSk7XG5cbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKTtcbiAgICAgIC8vIEFuaW1hdGUgdmlzaWJsZSBzdGF0ZSwgc28gaGlkZSBhbmltYXRpb24gY2FuIGJlIHNlZW4uIFRoaXMgY291bGQgYmUgaGFuZGxlZCBiZXR0ZXIgaWYgdXBkYXRlIC8gdXBkYXRlRGF0YXNldCByZXR1cm5lZCBhIFByb21pc2UuXG4gICAgICBhbmltcy51cGRhdGUobWV0YSwge3Zpc2libGV9KTtcbiAgICAgIHRoaXMudXBkYXRlKChjdHgpID0+IGN0eC5kYXRhc2V0SW5kZXggPT09IGRhdGFzZXRJbmRleCA/IG1vZGUgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cblxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gIH1cblxuICBfc3RvcCgpIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBhbmltYXRvci5yZW1vdmUodGhpcyk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XG5cbiAgICB0aGlzLl9zdG9wKCk7XG4gICAgdGhpcy5jb25maWcuY2xlYXJDYWNoZSgpO1xuXG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRlc3Ryb3knKTtcbiAgfVxuXG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5iaW5kVXNlckV2ZW50cygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5iaW5kUmVzcG9uc2l2ZUV2ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG5cbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KSA9PiB7XG4gICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcbiAgICB9O1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMuZXZlbnRzLCAodHlwZSkgPT4gX2FkZCh0eXBlLCBsaXN0ZW5lcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiaW5kUmVzcG9uc2l2ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG5cbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZSA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgZGV0YWNoZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgY29uc3QgYXR0YWNoZWQgPSAoKSA9PiB7XG4gICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG5cbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgX2FkZCgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnZGV0YWNoJywgZGV0YWNoZWQpO1xuICAgIH07XG5cbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcblxuICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBTdG9wIGFuaW1hdGluZyBhbmQgcmVtb3ZlIG1ldGFzZXRzLCBzbyB3aGVuIHJlLWF0dGFjaGVkLCB0aGUgYW5pbWF0aW9ucyBzdGFydCBmcm9tIGJlZ2lubmluZy5cbiAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZSgwLCAwKTtcblxuICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgIH07XG5cbiAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykpIHtcbiAgICAgIGF0dGFjaGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFjaGVkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgZWFjaCh0aGlzLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuICAgIGVhY2godGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGVIb3ZlclN0eWxlKGl0ZW1zLCBtb2RlLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG5cbiAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShpdGVtLmVsZW1lbnQsIGl0ZW0uZGF0YXNldEluZGV4LCBpdGVtLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogR2V0IGFjdGl2ZSAoaG92ZXJlZCkgZWxlbWVudHNcblx0ICogQHJldHVybnMgYXJyYXlcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSAoaG92ZXJlZCkgZWxlbWVudHNcblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlRWxlbWVudHMgTmV3IGFjdGl2ZSBkYXRhIHBvaW50c1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCB1c2UgdGhlIHByZXZpb3VzIG1vdXNlIGV2ZW50IHRvIG92ZXJyaWRlIHRoZSBhY3RpdmUgZWxlbWVudHMgaW4gdXBkYXRlLlxuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgYXMgc29vbiBhcyBhIHBsdWdpbiBleHBsaWNpdGx5IHJldHVybnMgZmFsc2UuIFRoZVxuXHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaG9vayAtIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gbWV0aG9kIHRvIGNhbGwgKGUuZy4gJ2JlZm9yZVVwZGF0ZScpLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUucGx1Z2lucy5qcycpLmZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5UGx1Z2lucyhob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHBsdWdpbiB3aXRoIHRoZSBzcGVjaWZpYyBJRCBpcyByZWdpc3RlcmVkIGFuZCBlbmFibGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbHVnaW5JZCAtIFRoZSBJRCBvZiB0aGUgcGx1Z2luIG9mIHdoaWNoIHRvIGNoZWNrIGlmIGl0IGlzIGVuYWJsZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BsdWdpbkVuYWJsZWQocGx1Z2luSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5fY2FjaGUuZmlsdGVyKHAgPT4gcC5wbHVnaW4uaWQgPT09IHBsdWdpbklkKS5sZW5ndGggPT09IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSkge1xuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHguZGF0YXNldEluZGV4ID09PSB5LmRhdGFzZXRJbmRleCAmJiB4LmluZGV4ID09PSB5LmluZGV4KSk7XG4gICAgY29uc3QgZGVhY3RpdmF0ZWQgPSBkaWZmKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgYWN0aXZhdGVkID0gcmVwbGF5ID8gYWN0aXZlIDogZGlmZihhY3RpdmUsIGxhc3RBY3RpdmUpO1xuXG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBldmVudDogZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBpbkNoYXJ0QXJlYTogdGhpcy5pc1BvaW50SW5BcmVhKGUpXG4gICAgfTtcbiAgICBjb25zdCBldmVudEZpbHRlciA9IChwbHVnaW4pID0+IChwbHVnaW4ub3B0aW9ucy5ldmVudHMgfHwgdGhpcy5vcHRpb25zLmV2ZW50cykuaW5jbHVkZXMoZS5uYXRpdmUudHlwZSk7XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBhcmdzLmluQ2hhcnRBcmVhKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IGFyZ3MuY2hhbmdlZCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIHRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIHRydWUgaWYgdGhlIGV2ZW50IHdhcyByZXBsYXllZCBieSBgdXBkYXRlYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSB0cnVlIGlmIHRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNoYXJ0IG5lZWRzIHRvIHJlLXJlbmRlclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCB7X2FjdGl2ZTogbGFzdEFjdGl2ZSA9IFtdLCBvcHRpb25zfSA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwbGF5ZWQgZnJvbSBgdXBkYXRlYCwgd2Ugc2hvdWxkIGV2YWx1YXRlIHdpdGggdGhlIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAvL1xuICAgIC8vIFRoZSBgcmVwbGF5YDpcbiAgICAvLyBJdCdzIHRoZSBsYXN0IGV2ZW50IChleGNsdWRpbmcgY2xpY2spIHRoYXQgaGFzIG9jY3VycmVkIGJlZm9yZSBgdXBkYXRlYC5cbiAgICAvLyBTbyBtb3VzZSBoYXMgbm90IG1vdmVkLiBJdCdzIGFsc28gb3ZlciB0aGUgY2hhcnQsIGJlY2F1c2UgdGhlcmUgaXMgYSBgcmVwbGF5YC5cbiAgICAvL1xuICAgIC8vIFRoZSB3aHk6XG4gICAgLy8gSWYgYW5pbWF0aW9ucyBhcmUgYWN0aXZlLCB0aGUgZWxlbWVudHMgaGF2ZW4ndCBtb3ZlZCB5ZXQgY29tcGFyZWQgdG8gc3RhdGUgYmVmb3JlIHVwZGF0ZS5cbiAgICAvLyBCdXQgaWYgdGhleSB3aWxsLCB3ZSBhcmUgYWN0aXZhdGluZyB0aGUgZWxlbWVudHMgdGhhdCB3b3VsZCBiZSBhY3RpdmUsIGlmIHRoaXMgY2hlY2tcbiAgICAvLyB3YXMgZG9uZSBhZnRlciB0aGUgYW5pbWF0aW9ucyBoYXZlIGNvbXBsZXRlZC4gPT4gXCJmaW5hbCBwb3NpdGlvbnNcIi5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbmltYXRpb25zLCB0aGUgXCJmaW5hbFwiIGFuZCBcImN1cnJlbnRcIiBwb3NpdGlvbnMgYXJlIGVxdWFsLlxuICAgIC8vIFRoaXMgaXMgZG9uZSBzbyB3ZSBkbyBub3QgaGF2ZSB0byBldmFsdWF0ZSB0aGUgYWN0aXZlIGVsZW1lbnRzIGVhY2ggYW5pbWF0aW9uIGZyYW1lXG4gICAgLy8gLSBpdCB3b3VsZCBiZSBleHBlbnNpdmUuXG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgaXNDbGljayA9IF9pc0NsaWNrRXZlbnQoZSk7XG4gICAgY29uc3QgbGFzdEV2ZW50ID0gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIHRoaXMuX2xhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spO1xuXG4gICAgaWYgKGluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBTZXQgX2xhc3RFdmVudCB0byBudWxsIHdoaWxlIHdlIGFyZSBwcm9jZXNzaW5nIHRoZSBldmVudCBoYW5kbGVycy5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgcmVjdXJzaW9uIGlmIHRoZSBoYW5kbGVyIGNhbGxzIGNoYXJ0LnVwZGF0ZSgpXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gICAgICAvLyBJbnZva2Ugb25Ib3ZlciBob29rXG4gICAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG5cbiAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnRbXX0gbGFzdEFjdGl2ZSAtIFByZXZpb3VzbHkgYWN0aXZlIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5DaGFydEFyZWEgLSBJcyB0aGUgZXZlbnQgaW5zaWRlIGNoYXJ0QXJlYVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUZpbmFsUG9zaXRpb24gLSBTaG91bGQgdGhlIGV2YWx1YXRpb24gYmUgZG9uZSB3aXRoIGN1cnJlbnQgb3IgZmluYWwgKGFmdGVyIGFuaW1hdGlvbikgZWxlbWVudCBwb3NpdGlvbnNcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50W119IC0gVGhlIGFjdGl2ZSBlbGVtZW50c1xuICAgKiBAcHJhdmF0ZVxuICAgKi9cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIExldCB1c2VyIGNvbnRyb2wgdGhlIGFjdGl2ZSBlbGVtZW50cyBvdXRzaWRlIGNoYXJ0QXJlYS4gRWcuIHVzaW5nIExlZ2VuZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGludmFsaWRhdGVQbHVnaW5zKCkge1xuICByZXR1cm4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCkgPT4gY2hhcnQuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iLCJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19hbmdsZUJldHdlZW4sIGdldEFuZ2xlRnJvbVBvaW50LCBUQVUsIEhBTEZfUEksIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7UEksIF9hbmdsZURpZmYsIF9ub3JtYWxpemVBbmdsZSwgX2lzQmV0d2VlbiwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X3JlYWRWYWx1ZVRvUHJvcHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB0eXBlIHtBcmNPcHRpb25zLCBQb2ludH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBjbGlwU2VsZihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZWxlbWVudDogQXJjRWxlbWVudCwgZW5kQW5nbGU6IG51bWJlcikge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBvcHRpb25zfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IHtib3JkZXJXaWR0aCwgYm9yZGVySm9pblN0eWxlfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG91dGVyQW5nbGVDbGlwID0gTWF0aC5taW4oYm9yZGVyV2lkdGggLyBvdXRlclJhZGl1cywgX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMgLSBib3JkZXJXaWR0aCAvIDIsIHN0YXJ0QW5nbGUgKyBvdXRlckFuZ2xlQ2xpcCAvIDIsIGVuZEFuZ2xlIC0gb3V0ZXJBbmdsZUNsaXAgLyAyKTtcblxuICBpZiAoaW5uZXJSYWRpdXMgPiAwKSB7XG4gICAgY29uc3QgaW5uZXJBbmdsZUNsaXAgPSBNYXRoLm1pbihib3JkZXJXaWR0aCAvIGlubmVyUmFkaXVzLCBfbm9ybWFsaXplQW5nbGUoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSk7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cyArIGJvcmRlcldpZHRoIC8gMiwgZW5kQW5nbGUgLSBpbm5lckFuZ2xlQ2xpcCAvIDIsIHN0YXJ0QW5nbGUgKyBpbm5lckFuZ2xlQ2xpcCAvIDIsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNsaXBXaWR0aCA9IE1hdGgubWluKGJvcmRlcldpZHRoIC8gMiwgb3V0ZXJSYWRpdXMgKiBfbm9ybWFsaXplQW5nbGUoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSk7XG5cbiAgICBpZiAoYm9yZGVySm9pblN0eWxlID09PSAncm91bmQnKSB7XG4gICAgICBjdHguYXJjKHgsIHksIGNsaXBXaWR0aCwgZW5kQW5nbGUgLSBQSSAvIDIsIHN0YXJ0QW5nbGUgKyBQSSAvIDIsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoYm9yZGVySm9pblN0eWxlID09PSAnYmV2ZWwnKSB7XG4gICAgICBjb25zdCByID0gMiAqIGNsaXBXaWR0aCAqIGNsaXBXaWR0aDtcbiAgICAgIGNvbnN0IGVuZFggPSAtciAqIE1hdGguY29zKGVuZEFuZ2xlICsgUEkgLyAyKSArIHg7XG4gICAgICBjb25zdCBlbmRZID0gLXIgKiBNYXRoLnNpbihlbmRBbmdsZSArIFBJIC8gMikgKyB5O1xuICAgICAgY29uc3Qgc3RhcnRYID0gciAqIE1hdGguY29zKHN0YXJ0QW5nbGUgKyBQSSAvIDIpICsgeDtcbiAgICAgIGNvbnN0IHN0YXJ0WSA9IHIgKiBNYXRoLnNpbihzdGFydEFuZ2xlICsgUEkgLyAyKSArIHk7XG4gICAgICBjdHgubGluZVRvKGVuZFgsIGVuZFkpO1xuICAgICAgY3R4LmxpbmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgfVxuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcblxuICBjdHgubW92ZVRvKDAsIDApO1xuICBjdHgucmVjdCgwLCAwLCBjdHguY2FudmFzLndpZHRoLCBjdHguY2FudmFzLmhlaWdodCk7XG5cbiAgY3R4LmNsaXAoJ2V2ZW5vZGQnKTtcbn1cblxuXG5mdW5jdGlvbiBjbGlwQXJjKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBlbGVtZW50OiBBcmNFbGVtZW50LCBlbmRBbmdsZTogbnVtYmVyKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzfSA9IGVsZW1lbnQ7XG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XG5cbiAgLy8gRHJhdyBhbiBpbm5lciBib3JkZXIgYnkgY2xpcHBpbmcgdGhlIGFyYyBhbmQgZHJhd2luZyBhIGRvdWJsZS13aWR0aCBib3JkZXJcbiAgLy8gRW5sYXJnZSB0aGUgY2xpcHBpbmcgYXJjIGJ5IDAuMzMgcGl4ZWxzIHRvIGVsaW1pbmF0ZSBnbGl0Y2hlcyBiZXR3ZWVuIGJvcmRlcnNcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4pO1xuICBpZiAoaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuICAgIGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBpbm5lclJhZGl1cztcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5hcmMoeCwgeSwgcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgSEFMRl9QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gdG9SYWRpdXNDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWydvdXRlclN0YXJ0JywgJ291dGVyRW5kJywgJ2lubmVyU3RhcnQnLCAnaW5uZXJFbmQnXSk7XG59XG5cbi8qKlxuICogUGFyc2UgYm9yZGVyIHJhZGl1cyBmcm9tIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGFyYzogQXJjRWxlbWVudCwgaW5uZXJSYWRpdXM6IG51bWJlciwgb3V0ZXJSYWRpdXM6IG51bWJlciwgYW5nbGVEZWx0YTogbnVtYmVyKSB7XG4gIGNvbnN0IG8gPSB0b1JhZGl1c0Nvcm5lcnMoYXJjLm9wdGlvbnMuYm9yZGVyUmFkaXVzKTtcbiAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XG4gIGNvbnN0IGlubmVyTGltaXQgPSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBhbmdsZURlbHRhICogaW5uZXJSYWRpdXMgLyAyKTtcblxuICAvLyBPdXRlciBsaW1pdHMgYXJlIGNvbXBsaWNhdGVkLiBXZSB3YW50IHRvIGNvbXB1dGUgdGhlIGF2YWlsYWJsZSBhbmd1bGFyIGRpc3RhbmNlIGF0XG4gIC8vIGEgcmFkaXVzIG9mIG91dGVyUmFkaXVzIC0gYm9yZGVyUmFkaXVzIGJlY2F1c2UgZm9yIHNtYWxsIGFuZ3VsYXIgZGlzdGFuY2VzLCB0aGlzIHRlcm0gbGltaXRzLlxuICAvLyBXZSBjb21wdXRlIGF0IHIgPSBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIHRoaXMgY2lyY2xlIGRlZmluZXMgdGhlIGNlbnRlciBvZiB0aGUgYm9yZGVyIGNvcm5lcnMuXG4gIC8vXG4gIC8vIElmIHRoZSBib3JkZXJSYWRpdXMgaXMgbGFyZ2UsIHRoYXQgdmFsdWUgY2FuIGJlY29tZSBuZWdhdGl2ZS5cbiAgLy8gVGhpcyBjYXVzZXMgdGhlIG91dGVyIGJvcmRlcnMgdG8gbG9zZSB0aGVpciByYWRpdXMgZW50aXJlbHksIHdoaWNoIGlzIHJhdGhlciB1bmV4cGVjdGVkLiBUbyBzb2x2ZSB0aGF0LCBpZiBib3JkZXJSYWRpdXMgPiBvdXRlclJhZGl1c1xuICAvLyB3ZSBrbm93IHRoYXQgdGhlIHRoaWNrbmVzcyB0ZXJtIHdpbGwgZG9taW5hdGUgYW5kIGNvbXB1dGUgdGhlIGxpbWl0cyBhdCB0aGF0IHBvaW50XG4gIGNvbnN0IGNvbXB1dGVPdXRlckxpbWl0ID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG91dGVyQXJjTGltaXQgPSAob3V0ZXJSYWRpdXMgLSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCB2YWwpKSAqIGFuZ2xlRGVsdGEgLyAyO1xuICAgIHJldHVybiBfbGltaXRWYWx1ZSh2YWwsIDAsIE1hdGgubWluKGhhbGZUaGlja25lc3MsIG91dGVyQXJjTGltaXQpKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG91dGVyU3RhcnQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJTdGFydCksXG4gICAgb3V0ZXJFbmQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXG4gICAgaW5uZXJFbmQ6IF9saW1pdFZhbHVlKG8uaW5uZXJFbmQsIDAsIGlubmVyTGltaXQpLFxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgKHIsIPCdnIMpIHRvICh4LCB5KVxuICovXG5mdW5jdGlvbiByVGhldGFUb1hZKHI6IG51bWJlciwgdGhldGE6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICB5OiB5ICsgciAqIE1hdGguc2luKHRoZXRhKSxcbiAgfTtcbn1cblxuXG4vKipcbiAqIFBhdGggdGhlIGFyYywgcmVzcGVjdGluZyBib3JkZXIgcmFkaXVzIGJ5IHNlcGFyYXRpbmcgaW50byBsZWZ0IGFuZCByaWdodCBoYWx2ZXMuXG4gKlxuICogICBTdGFydCAgICAgIEVuZFxuICpcbiAqICAgIDEtLS0+YS0tLT4yICAgIE91dGVyXG4gKiAgIC8gICAgICAgICAgIFxcXG4gKiAgIDggICAgICAgICAgIDNcbiAqICAgfCAgICAgICAgICAgfFxuICogICB8ICAgICAgICAgICB8XG4gKiAgIDcgICAgICAgICAgIDRcbiAqICAgXFwgICAgICAgICAgIC9cbiAqICAgIDY8LS0tYjwtLS01ICAgIElubmVyXG4gKi9cbmZ1bmN0aW9uIHBhdGhBcmMoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBlbmQ6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGU6IHN0YXJ0LCBwaXhlbE1hcmdpbiwgaW5uZXJSYWRpdXM6IGlubmVyUn0gPSBlbGVtZW50O1xuXG4gIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiArIHNwYWNpbmcgKyBvZmZzZXQgKyBwaXhlbE1hcmdpbiA6IDA7XG5cbiAgbGV0IHNwYWNpbmdPZmZzZXQgPSAwO1xuICBjb25zdCBhbHBoYSA9IGVuZCAtIHN0YXJ0O1xuXG4gIGlmIChzcGFjaW5nKSB7XG4gICAgLy8gV2hlbiBzcGFjaW5nIGlzIHByZXNlbnQsIGl0IGlzIHRoZSBzYW1lIGZvciBhbGwgaXRlbXNcbiAgICAvLyBTbyB3ZSBhZGp1c3QgdGhlIHN0YXJ0IGFuZCBlbmQgYW5nbGUgb2YgdGhlIGFyYyBzdWNoIHRoYXRcbiAgICAvLyB0aGUgZGlzdGFuY2UgaXMgdGhlIHNhbWUgYXMgaXQgd291bGQgYmUgd2l0aG91dCB0aGUgc3BhY2luZ1xuICAgIGNvbnN0IG5vU3BhY2luZ0lubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBhdk5vZ1NwYWNpbmdSYWRpdXMgPSAobm9TcGFjaW5nSW5uZXJSYWRpdXMgKyBub1NwYWNpbmdPdXRlclJhZGl1cykgLyAyO1xuICAgIGNvbnN0IGFkanVzdGVkQW5nbGUgPSBhdk5vZ1NwYWNpbmdSYWRpdXMgIT09IDAgPyAoYWxwaGEgKiBhdk5vZ1NwYWNpbmdSYWRpdXMpIC8gKGF2Tm9nU3BhY2luZ1JhZGl1cyArIHNwYWNpbmcpIDogYWxwaGE7XG4gICAgc3BhY2luZ09mZnNldCA9IChhbHBoYSAtIGFkanVzdGVkQW5nbGUpIC8gMjtcbiAgfVxuXG4gIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgY29uc3Qge291dGVyU3RhcnQsIG91dGVyRW5kLCBpbm5lclN0YXJ0LCBpbm5lckVuZH0gPSBwYXJzZUJvcmRlclJhZGl1cyhlbGVtZW50LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG5cbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XG5cbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lclN0YXJ0O1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lckVuZDtcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgaW5uZXJTdGFydCAvIGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBpbm5lckVuZCAvIGlubmVyRW5kQWRqdXN0ZWRSYWRpdXM7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIGlmIChjaXJjdWxhcikge1xuICAgIC8vIFRoZSBmaXJzdCBhcmMgc2VnbWVudHMgZnJvbSBwb2ludCAxIHRvIHBvaW50IGEgdG8gcG9pbnQgMlxuICAgIGNvbnN0IG91dGVyTWlkQWRqdXN0ZWRBbmdsZSA9IChvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSArIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgLyAyO1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlck1pZEFkanVzdGVkQW5nbGUpO1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyTWlkQWRqdXN0ZWRBbmdsZSwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDIgdG8gcG9pbnQgM1xuICAgIGlmIChvdXRlckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgMyB0byBwb2ludCA0XG4gICAgY29uc3QgcDQgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGVuZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA0LngsIHA0LnkpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNCB0byBwb2ludCA1XG4gICAgaWYgKGlubmVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBpbm5lciBhcmMgZnJvbSBwb2ludCA1IHRvIHBvaW50IGIgdG8gcG9pbnQgNlxuICAgIGNvbnN0IGlubmVyTWlkQWRqdXN0ZWRBbmdsZSA9ICgoZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cykpICsgKHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSkpIC8gMjtcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSwgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlLCB0cnVlKTtcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBpbm5lck1pZEFkanVzdGVkQW5nbGUsIHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSwgdHJ1ZSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA2IHRvIHBvaW50IDdcbiAgICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cywgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGxpbmUgZnJvbSBwb2ludCA3IHRvIHBvaW50IDhcbiAgICBjb25zdCBwOCA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBzdGFydEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA4LngsIHA4LnkpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgOCB0byBwb2ludCAxXG4gICAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG5cbiAgICBjb25zdCBvdXRlclN0YXJ0WCA9IE1hdGguY29zKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlclN0YXJ0WSA9IE1hdGguc2luKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyU3RhcnRYLCBvdXRlclN0YXJ0WSk7XG5cbiAgICBjb25zdCBvdXRlckVuZFggPSBNYXRoLmNvcyhvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyRW5kWSA9IE1hdGguc2luKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlckVuZFgsIG91dGVyRW5kWSk7XG4gIH1cblxuICBjdHguY2xvc2VQYXRoKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdBcmMoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2V9ID0gZWxlbWVudDtcbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChjaXJjdW1mZXJlbmNlICUgVEFVIHx8IFRBVSk7XG4gICAgfVxuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gIGN0eC5maWxsKCk7XG4gIHJldHVybiBlbmRBbmdsZTtcbn1cblxuZnVuY3Rpb24gZHJhd0JvcmRlcihcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGVsZW1lbnQ6IEFyY0VsZW1lbnQsXG4gIG9mZnNldDogbnVtYmVyLFxuICBzcGFjaW5nOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZSwgb3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCB7Ym9yZGVyV2lkdGgsIGJvcmRlckpvaW5TdHlsZSwgYm9yZGVyRGFzaCwgYm9yZGVyRGFzaE9mZnNldCwgYm9yZGVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlubmVyID0gb3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJztcblxuICBpZiAoIWJvcmRlcldpZHRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LnNldExpbmVEYXNoKGJvcmRlckRhc2ggfHwgW10pO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSBib3JkZXJEYXNoT2Zmc2V0O1xuXG4gIGlmIChpbm5lcikge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAqIDI7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdyb3VuZCc7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAnYmV2ZWwnO1xuICB9XG5cbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGNpcmN1bWZlcmVuY2UgJSBUQVUgfHwgVEFVKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuc2VsZkpvaW4gJiYgZW5kQW5nbGUgLSBzdGFydEFuZ2xlID49IFBJICYmIGJvcmRlclJhZGl1cyA9PT0gMCAmJiBib3JkZXJKb2luU3R5bGUgIT09ICdtaXRlcicpIHtcbiAgICBjbGlwU2VsZihjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmICghZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFyY1Byb3BzIGV4dGVuZHMgUG9pbnQge1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG4gIGVuZEFuZ2xlOiBudW1iZXI7XG4gIGlubmVyUmFkaXVzOiBudW1iZXI7XG4gIG91dGVyUmFkaXVzOiBudW1iZXI7XG4gIGNpcmN1bWZlcmVuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ8QXJjUHJvcHMsIEFyY09wdGlvbnM+IHtcblxuICBzdGF0aWMgaWQgPSAnYXJjJztcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyQWxpZ246ICdjZW50ZXInLFxuICAgIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgICBib3JkZXJKb2luU3R5bGU6IHVuZGVmaW5lZCxcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHNwYWNpbmc6IDAsXG4gICAgYW5nbGU6IHVuZGVmaW5lZCxcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBzZWxmSm9pbjogZmFsc2UsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnXG4gIH07XG5cbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBmdWxsQ2lyY2xlczogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBwaXhlbE1hcmdpbjogbnVtYmVyO1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGluUmFuZ2UoY2hhcnRYOiBudW1iZXIsIGNoYXJ0WTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9ICh0aGlzLm9wdGlvbnMuc3BhY2luZyArIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCkgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBub25aZXJvQmV0d2VlbiA9IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSAmJiBzdGFydEFuZ2xlICE9PSBlbmRBbmdsZTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IG5vblplcm9CZXR3ZWVuO1xuICAgIGNvbnN0IHdpdGhpblJhZGl1cyA9IF9pc0JldHdlZW4oZGlzdGFuY2UsIGlubmVyUmFkaXVzICsgckFkanVzdCwgb3V0ZXJSYWRpdXMgKyByQWRqdXN0KTtcblxuICAgIHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3gnLFxuICAgICAgJ3knLFxuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge29mZnNldCwgc3BhY2luZ30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xuICAgIGNvbnN0IGhhbGZSYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzXG4gICAgfTtcbiAgfVxuXG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcztcbiAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5vZmZzZXQgfHwgMCkgLyA0O1xuICAgIGNvbnN0IHNwYWNpbmcgPSAob3B0aW9ucy5zcGFjaW5nIHx8IDApIC8gMjtcbiAgICBjb25zdCBjaXJjdWxhciA9IG9wdGlvbnMuY2lyY3VsYXI7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IChvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSBjaXJjdW1mZXJlbmNlID4gVEFVID8gTWF0aC5mbG9vcihjaXJjdW1mZXJlbmNlIC8gVEFVKSA6IDA7XG5cbiAgICBpZiAoY2lyY3VtZmVyZW5jZSA9PT0gMCB8fCB0aGlzLmlubmVyUmFkaXVzIDwgMCB8fCB0aGlzLm91dGVyUmFkaXVzIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBjb25zdCBoYWxmQW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICsgdGhpcy5lbmRBbmdsZSkgLyAyO1xuICAgIGN0eC50cmFuc2xhdGUoTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIG9mZnNldCwgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIG9mZnNldCk7XG4gICAgY29uc3QgZml4ID0gMSAtIE1hdGguc2luKE1hdGgubWluKFBJLCBjaXJjdW1mZXJlbmNlIHx8IDApKTtcbiAgICBjb25zdCByYWRpdXNPZmZzZXQgPSBvZmZzZXQgKiBmaXg7XG5cbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcblxuICAgIGRyYXdBcmMoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcbiAgICBkcmF3Qm9yZGVyKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG4iLCJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19iZXppZXJJbnRlcnBvbGF0aW9uLCBfcG9pbnRJbkxpbmUsIF9zdGVwcGVkSW50ZXJwb2xhdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24uanMnO1xuaW1wb3J0IHtfY29tcHV0ZVNlZ21lbnRzLCBfYm91bmRTZWdtZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMnO1xuaW1wb3J0IHtfc3RlcHBlZExpbmVUbywgX2JlemllckN1cnZlVG99IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmN1cnZlLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cblxuZnVuY3Rpb24gbGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCkge1xuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cblxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVyQ3VydmVUbztcbiAgfVxuXG4gIHJldHVybiBsaW5lVG87XG59XG5cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBjb3VudCxcbiAgICBzdGFydCxcbiAgICBsb29wOiBzZWdtZW50Lmxvb3AsXG4gICAgaWxlbjogZW5kIDwgc3RhcnQgJiYgIW91dHNpZGUgPyBjb3VudCArIGVuZCAtIHN0YXJ0IDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGkgOiBpKSkgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBza2lwcGVkIHBvaW50IGluc2lkZSBhIHNlZ21lbnQsIHNwYW5HYXBzIG11c3QgYmUgdHJ1ZVxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuXG4gICAgcHJldiA9IHBvaW50O1xuICB9XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gOiAwKSkgJSBjb3VudF07XG4gICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICB9XG5cbiAgcmV0dXJuICEhbG9vcDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG5cbiAgY29uc3QgcG9pbnRJbmRleCA9IChpbmRleCkgPT4gKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaW5kZXggOiBpbmRleCkpICUgY291bnQ7XG4gIGNvbnN0IGRyYXdYID0gKCkgPT4ge1xuICAgIGlmIChtaW5ZICE9PSBtYXhZKSB7XG4gICAgICAvLyBEcmF3IGxpbmUgdG8gbWF4WSBhbmQgbWluWSwgdXNpbmcgdGhlIGF2ZXJhZ2UgeC1jb29yZGluYXRlXG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcbiAgICAgIC8vIExpbmUgdG8geS12YWx1ZSBvZiBsYXN0IHBvaW50IGluIGdyb3VwLiBTbyB0aGUgbGluZSBjb250aW51ZXNcbiAgICAgIC8vIGZyb20gY29ycmVjdCBwb3NpdGlvbi4gTm90IHVzaW5nIG1vdmUsIHRvIGhhdmUgc29saWQgcGF0aC5cbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbGFzdFkpO1xuICAgIH1cbiAgfTtcblxuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2tpcHBlZCBwb2ludCBpbnNpZGUgYSBzZWdtZW50LCBzcGFuR2FwcyBtdXN0IGJlIHRydWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwOyAvLyB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgLy8gRHJhdyBsaW5lIHRvIG5leHQgeC1wb3NpdGlvbiwgdXNpbmcgdGhlIGZpcnN0IChvciBvbmx5KVxuICAgICAgLy8geS12YWx1ZSBpbiB0aGF0IGdyb3VwXG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgeS12YWx1ZSBpbiBncm91cFxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmUgLSB0aGUgbGluZVxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cblxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuXG5mdW5jdGlvbiBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGxldCBwYXRoID0gbGluZS5fcGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcGF0aCA9IGxpbmUuX3BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGxpbmUucGF0aChwYXRoLCBzdGFydCwgY291bnQpKSB7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XG4gIGN0eC5zdHJva2UocGF0aCk7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICBzdGF0aWMgaWQgPSAnbGluZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgICBib3JkZXJXaWR0aDogMyxcbiAgICBjYXBCZXppZXJQb2ludHM6IHRydWUsXG4gICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICAgIGZpbGw6IGZhbHNlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgICBzdGVwcGVkOiBmYWxzZSxcbiAgICB0ZW5zaW9uOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnLFxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHBvaW50cyhwb2ludHMpIHtcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgZGVsZXRlIHRoaXMuX3NlZ21lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9wYXRoO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgfVxuXG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZpcnN0IG5vbi1za2lwcGVkIHBvaW50IG9uIHRoaXMgbGluZVxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cblxuICAvKipcblx0ICogTGFzdCBub24tc2tpcHBlZCBwb2ludCBvbiB0aGlzIGxpbmVcblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBsYXN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gY291bnQgJiYgcG9pbnRzW3NlZ21lbnRzW2NvdW50IC0gMV0uZW5kXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBJbnRlcnBvbGF0ZSBhIHBvaW50IGluIHRoaXMgbGluZSBhdCB0aGUgc2FtZSB2YWx1ZSBvbiBgcHJvcGVydHlgIGFzXG5cdCAqIHRoZSByZWZlcmVuY2UgYHBvaW50YCBwcm92aWRlZFxuXHQgKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gcG9pbnQgLSB0aGUgcmVmZXJlbmNlIHBvaW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSB0byBtYXRjaCBvblxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuXG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50c1tpXTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRzW3N0YXJ0XTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRzW2VuZF07XG4gICAgICBpZiAocDEgPT09IHAyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKHZhbHVlIC0gcDFbcHJvcGVydHldKSAvIChwMltwcm9wZXJ0eV0gLSBwMVtwcm9wZXJ0eV0pKTtcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZCA9IF9pbnRlcnBvbGF0ZShwMSwgcDIsIHQsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xuICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2xhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGEgc2VnbWVudCBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuXHQgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBzZWdtZW50IGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGFsbCBzZWdtZW50cyBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IC0gdHJ1ZSBpZiBsaW5lIGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG5cbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgY291bnQgPSBjb3VudCB8fCAodGhpcy5wb2ludHMubGVuZ3RoIC0gc3RhcnQpO1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QXJlYVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKi9cbiAgZHJhdyhjdHgsIGNoYXJ0QXJlYSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cyB8fCBbXTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoICYmIG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICAvLyBXaGVuIGxpbmUgaXMgYW5pbWF0ZWQsIHRoZSBjb250cm9sIHBvaW50cyBhbmQgcGF0aCBhcmUgbm90IGNhY2hlZC5cbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2RyYXdQb2ludCwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge1xuICBDYXJ0ZXNpYW5QYXJzZWREYXRhLFxuICBDaGFydEFyZWEsXG4gIFBvaW50LFxuICBQb2ludEhvdmVyT3B0aW9ucyxcbiAgUG9pbnRPcHRpb25zLFxufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGluUmFuZ2UoZWw6IFBvaW50RWxlbWVudCwgcG9zOiBudW1iZXIsIGF4aXM6ICd4JyB8ICd5JywgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gIGNvbnN0IHtbYXhpc106IHZhbHVlfSA9IGVsLmdldFByb3BzKFtheGlzXSwgdXNlRmluYWxQb3NpdGlvbik7XG5cbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cblxuZXhwb3J0IHR5cGUgUG9pbnRQcm9wcyA9IFBvaW50XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ8UG9pbnRQcm9wcywgUG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+IHtcblxuICBzdGF0aWMgaWQgPSAncG9pbnQnO1xuXG4gIHBhcnNlZDogQ2FydGVzaWFuUGFyc2VkRGF0YTtcbiAgc2tpcD86IGJvb2xlYW47XG4gIHN0b3A/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlcldpZHRoOiAxLFxuICAgIGhpdFJhZGl1czogMSxcbiAgICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICAgIGhvdmVyUmFkaXVzOiA0LFxuICAgIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICAgIHJhZGl1czogMyxcbiAgICByb3RhdGlvbjogMFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5za2lwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RvcCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWDogbnVtYmVyLCBtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuICgoTWF0aC5wb3cobW91c2VYIC0geCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB5LCAyKSkgPCBNYXRoLnBvdyhvcHRpb25zLmhpdFJhZGl1cyArIG9wdGlvbnMucmFkaXVzLCAyKSk7XG4gIH1cblxuICBpblhSYW5nZShtb3VzZVg6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsICd4JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpbllSYW5nZShtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVksICd5JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuXG4gIHNpemUob3B0aW9ucz86IFBhcnRpYWw8UG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFyZWE6IENoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAodGhpcy5za2lwIHx8IG9wdGlvbnMucmFkaXVzIDwgMC4xIHx8ICFfaXNQb2ludEluQXJlYSh0aGlzLCBhcmVhLCB0aGlzLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuXG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBGYWxsYmFja3Mgc2hvdWxkIG5ldmVyIGJlIGhpdCBpbiBwcmFjdGljZVxuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG4iLCJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCBfaXNCZXR3ZWVuLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge3RvVFJCTCwgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG4vKiogQHR5cGVkZWYge3sgeDogbnVtYmVyLCB5OiBudW1iZXIsIGJhc2U6IG51bWJlciwgaG9yaXpvbnRhbDogYm9vbGVhbiwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gQmFyUHJvcHMgKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIGJhciByZWdhcmRsZXNzIG9mIHRoZSBvcmllbnRhdGlvblxuICogQHBhcmFtIHtCYXJFbGVtZW50fSBiYXIgdGhlIGJhclxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl1cbiAqIEByZXR1cm4ge29iamVjdH0gYm91bmRzIG9mIHRoZSBiYXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qge3gsIHksIGJhc2UsIHdpZHRoLCBoZWlnaHR9ID0gLyoqIEB0eXBlIHtCYXJQcm9wc30gKi8gKGJhci5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddLCB1c2VGaW5hbFBvc2l0aW9uKSk7XG5cbiAgbGV0IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgaGFsZjtcblxuICBpZiAoYmFyLmhvcml6b250YWwpIHtcbiAgICBoYWxmID0gaGVpZ2h0IC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XG4gICAgcmlnaHQgPSBNYXRoLm1heCh4LCBiYXNlKTtcbiAgICB0b3AgPSB5IC0gaGFsZjtcbiAgICBib3R0b20gPSB5ICsgaGFsZjtcbiAgfSBlbHNlIHtcbiAgICBoYWxmID0gd2lkdGggLyAyO1xuICAgIGxlZnQgPSB4IC0gaGFsZjtcbiAgICByaWdodCA9IHggKyBoYWxmO1xuICAgIHRvcCA9IE1hdGgubWluKHksIGJhc2UpO1xuICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xuICB9XG5cbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219O1xufVxuXG5mdW5jdGlvbiBza2lwT3JMaW1pdChza2lwLCB2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHNraXAgPyAwIDogX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aChiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBvID0gdG9UUkJMKHZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIHQ6IHNraXBPckxpbWl0KHNraXAudG9wLCBvLnRvcCwgMCwgbWF4SCksXG4gICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXG4gICAgYjogc2tpcE9yTGltaXQoc2tpcC5ib3R0b20sIG8uYm90dG9tLCAwLCBtYXhIKSxcbiAgICBsOiBza2lwT3JMaW1pdChza2lwLmxlZnQsIG8ubGVmdCwgMCwgbWF4VylcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHtlbmFibGVCb3JkZXJSYWRpdXN9ID0gYmFyLmdldFByb3BzKFsnZW5hYmxlQm9yZGVyUmFkaXVzJ10pO1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlclJhZGl1cztcbiAgY29uc3QgbyA9IHRvVFJCTENvcm5lcnModmFsdWUpO1xuICBjb25zdCBtYXhSID0gTWF0aC5taW4obWF4VywgbWF4SCk7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcblxuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LCBhc3N1bWUgdGhlIHVzZXIga25vd3Mgd2hhdCB0aGV5IGFyZSBkb2luZ1xuICAvLyBhbmQgYXBwbHkgYXMgZGlyZWN0ZWQuXG4gIGNvbnN0IGVuYWJsZUJvcmRlciA9IGVuYWJsZUJvcmRlclJhZGl1cyB8fCBpc09iamVjdCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3BMZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAubGVmdCwgby50b3BMZWZ0LCAwLCBtYXhSKSxcbiAgICB0b3BSaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLnJpZ2h0LCBvLnRvcFJpZ2h0LCAwLCBtYXhSKSxcbiAgICBib3R0b21MZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAubGVmdCwgby5ib3R0b21MZWZ0LCAwLCBtYXhSKSxcbiAgICBib3R0b21SaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCBtYXhSKVxuICB9O1xufVxuXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKGJhcikge1xuICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcbiAgY29uc3Qgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG4gIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICBjb25zdCByYWRpdXMgPSBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICB5OiBib3VuZHMudG9wLFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHQsXG4gICAgICByYWRpdXNcbiAgICB9LFxuICAgIGlubmVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuICAgICAgeTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuICAgICAgdzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuICAgICAgaDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYixcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxuICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcFJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5yKSksXG4gICAgICAgIGJvdHRvbUxlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21MZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5sKSksXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluUmFuZ2UoYmFyLCB4LCB5LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHNraXBYID0geCA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcFkgPSB5ID09PSBudWxsO1xuICBjb25zdCBza2lwQm90aCA9IHNraXBYICYmIHNraXBZO1xuICBjb25zdCBib3VuZHMgPSBiYXIgJiYgIXNraXBCb3RoICYmIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pO1xuXG4gIHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgX2lzQmV0d2Vlbih4LCBib3VuZHMubGVmdCwgYm91bmRzLnJpZ2h0KSlcblx0XHQmJiAoc2tpcFkgfHwgX2lzQmV0d2Vlbih5LCBib3VuZHMudG9wLCBib3VuZHMuYm90dG9tKSk7XG59XG5cbmZ1bmN0aW9uIGhhc1JhZGl1cyhyYWRpdXMpIHtcbiAgcmV0dXJuIHJhZGl1cy50b3BMZWZ0IHx8IHJhZGl1cy50b3BSaWdodCB8fCByYWRpdXMuYm90dG9tTGVmdCB8fCByYWRpdXMuYm90dG9tUmlnaHQ7XG59XG5cbi8qKlxuICogQWRkIGEgcGF0aCBvZiBhIHJlY3RhbmdsZSB0byB0aGUgY3VycmVudCBzdWItcGF0aFxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0XG4gKiBAcGFyYW0geyp9IHJlY3QgQm91bmRpbmcgcmVjdFxuICovXG5mdW5jdGlvbiBhZGROb3JtYWxSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlY3QocmVjdCwgYW1vdW50LCByZWZSZWN0ID0ge30pIHtcbiAgY29uc3QgeCA9IHJlY3QueCAhPT0gcmVmUmVjdC54ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHkgPSByZWN0LnkgIT09IHJlZlJlY3QueSA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB3ID0gKHJlY3QueCArIHJlY3QudyAhPT0gcmVmUmVjdC54ICsgcmVmUmVjdC53ID8gYW1vdW50IDogMCkgLSB4O1xuICBjb25zdCBoID0gKHJlY3QueSArIHJlY3QuaCAhPT0gcmVmUmVjdC55ICsgcmVmUmVjdC5oID8gYW1vdW50IDogMCkgLSB5O1xuICByZXR1cm4ge1xuICAgIHg6IHJlY3QueCArIHgsXG4gICAgeTogcmVjdC55ICsgeSxcbiAgICB3OiByZWN0LncgKyB3LFxuICAgIGg6IHJlY3QuaCArIGgsXG4gICAgcmFkaXVzOiByZWN0LnJhZGl1c1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgc3RhdGljIGlkID0gJ2Jhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyU2tpcHBlZDogJ3N0YXJ0JyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgaW5mbGF0ZUFtb3VudDogJ2F1dG8nLFxuICAgIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5mbGF0ZUFtb3VudCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtpbmZsYXRlQW1vdW50LCBvcHRpb25zOiB7Ym9yZGVyQ29sb3IsIGJhY2tncm91bmRDb2xvcn19ID0gdGhpcztcbiAgICBjb25zdCB7aW5uZXIsIG91dGVyfSA9IGJvdW5kaW5nUmVjdHModGhpcyk7XG4gICAgY29uc3QgYWRkUmVjdFBhdGggPSBoYXNSYWRpdXMob3V0ZXIucmFkaXVzKSA/IGFkZFJvdW5kZWRSZWN0UGF0aCA6IGFkZE5vcm1hbFJlY3RQYXRoO1xuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGlmIChvdXRlci53ICE9PSBpbm5lci53IHx8IG91dGVyLmggIT09IGlubmVyLmgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3Qob3V0ZXIsIGluZmxhdGVBbW91bnQsIGlubmVyKSk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgLWluZmxhdGVBbW91bnQsIG91dGVyKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgIH1cblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCBpbmZsYXRlQW1vdW50KSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG51bGwsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgYmFzZSwgaG9yaXpvbnRhbH0gPSAvKiogQHR5cGUge0JhclByb3BzfSAqLyAodGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbikpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxuICAgICAgeTogaG9yaXpvbnRhbCA/IHkgOiAoeSArIGJhc2UpIC8gMlxuICAgIH07XG4gIH1cblxuICBnZXRSYW5nZShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG4iLCJpbXBvcnQge0RvdWdobnV0Q29udHJvbGxlciwgUG9sYXJBcmVhQ29udHJvbGxlciwgZGVmYXVsdHN9IGZyb20gJy4uL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtDaGFydCwgQ2hhcnREYXRhc2V0fSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JzUGx1Z2luT3B0aW9ucyB7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICBmb3JjZU92ZXJyaWRlPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIENvbG9yc0Rlc2NyaXB0b3Ige1xuICBiYWNrZ3JvdW5kQ29sb3I/OiB1bmtub3duO1xuICBib3JkZXJDb2xvcj86IHVua25vd247XG59XG5cbmNvbnN0IEJPUkRFUl9DT0xPUlMgPSBbXG4gICdyZ2IoNTQsIDE2MiwgMjM1KScsIC8vIGJsdWVcbiAgJ3JnYigyNTUsIDk5LCAxMzIpJywgLy8gcmVkXG4gICdyZ2IoMjU1LCAxNTksIDY0KScsIC8vIG9yYW5nZVxuICAncmdiKDI1NSwgMjA1LCA4NiknLCAvLyB5ZWxsb3dcbiAgJ3JnYig3NSwgMTkyLCAxOTIpJywgLy8gZ3JlZW5cbiAgJ3JnYigxNTMsIDEwMiwgMjU1KScsIC8vIHB1cnBsZVxuICAncmdiKDIwMSwgMjAzLCAyMDcpJyAvLyBncmV5XG5dO1xuXG4vLyBCb3JkZXIgY29sb3JzIHdpdGggNTAlIHRyYW5zcGFyZW5jeVxuY29uc3QgQkFDS0dST1VORF9DT0xPUlMgPSAvKiAjX19QVVJFX18gKi8gQk9SREVSX0NPTE9SUy5tYXAoY29sb3IgPT4gY29sb3IucmVwbGFjZSgncmdiKCcsICdyZ2JhKCcpLnJlcGxhY2UoJyknLCAnLCAwLjUpJykpO1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJDb2xvcihpOiBudW1iZXIpIHtcbiAgcmV0dXJuIEJPUkRFUl9DT0xPUlNbaSAlIEJPUkRFUl9DT0xPUlMubGVuZ3RoXTtcbn1cblxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZENvbG9yKGk6IG51bWJlcikge1xuICByZXR1cm4gQkFDS0dST1VORF9DT0xPUlNbaSAlIEJBQ0tHUk9VTkRfQ09MT1JTLmxlbmd0aF07XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplRGVmYXVsdERhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5ib3JkZXJDb2xvciA9IGdldEJvcmRlckNvbG9yKGkpO1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGdldEJhY2tncm91bmRDb2xvcihpKTtcblxuICByZXR1cm4gKytpO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZURvdWdobnV0RGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuZGF0YS5tYXAoKCkgPT4gZ2V0Qm9yZGVyQ29sb3IoaSsrKSk7XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuZGF0YS5tYXAoKCkgPT4gZ2V0QmFja2dyb3VuZENvbG9yKGkrKykpO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBnZXRDb2xvcml6ZXIoY2hhcnQ6IENoYXJ0KSB7XG4gIGxldCBpID0gMDtcblxuICByZXR1cm4gKGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgZGF0YXNldEluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBEb3VnaG51dENvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZURvdWdobnV0RGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBQb2xhckFyZWFDb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVQb2xhckFyZWFEYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplRGVmYXVsdERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKFxuICBkZXNjcmlwdG9yczogQ29sb3JzRGVzY3JpcHRvcltdIHwgUmVjb3JkPHN0cmluZywgQ29sb3JzRGVzY3JpcHRvcj5cbikge1xuICBsZXQgazogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIGZvciAoayBpbiBkZXNjcmlwdG9ycykge1xuICAgIGlmIChkZXNjcmlwdG9yc1trXS5ib3JkZXJDb2xvciB8fCBkZXNjcmlwdG9yc1trXS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKFxuICBkZXNjcmlwdG9yOiBDb2xvcnNEZXNjcmlwdG9yXG4pIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgKGRlc2NyaXB0b3IuYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvci5iYWNrZ3JvdW5kQ29sb3IpO1xufVxuXG5mdW5jdGlvbiBjb250YWluc0RlZmF1bHRDb2xvcnNEZWZlbml0aW9ucygpIHtcbiAgcmV0dXJuIGRlZmF1bHRzLmJvcmRlckNvbG9yICE9PSAncmdiYSgwLDAsMCwwLjEpJyB8fCBkZWZhdWx0cy5iYWNrZ3JvdW5kQ29sb3IgIT09ICdyZ2JhKDAsMCwwLDAuMSknO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnY29sb3JzJyxcblxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm9yY2VPdmVycmlkZTogZmFsc2VcbiAgfSBhcyBDb2xvcnNQbHVnaW5PcHRpb25zLFxuXG4gIGJlZm9yZUxheW91dChjaGFydDogQ2hhcnQsIF9hcmdzLCBvcHRpb25zOiBDb2xvcnNQbHVnaW5PcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7ZGF0YXNldHN9LFxuICAgICAgb3B0aW9uczogY2hhcnRPcHRpb25zXG4gICAgfSA9IGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCB7ZWxlbWVudHN9ID0gY2hhcnRPcHRpb25zO1xuXG4gICAgY29uc3QgY29udGFpbnNDb2xvckRlZmVuaXRpb24gPSAoXG4gICAgICBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGRhdGFzZXRzKSB8fFxuICAgICAgY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKGNoYXJ0T3B0aW9ucykgfHxcbiAgICAgIChlbGVtZW50cyAmJiBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGVsZW1lbnRzKSkgfHxcbiAgICAgIGNvbnRhaW5zRGVmYXVsdENvbG9yc0RlZmVuaXRpb25zKCkpO1xuXG4gICAgaWYgKCFvcHRpb25zLmZvcmNlT3ZlcnJpZGUgJiYgY29udGFpbnNDb2xvckRlZmVuaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb2xvcml6ZXIgPSBnZXRDb2xvcml6ZXIoY2hhcnQpO1xuXG4gICAgZGF0YXNldHMuZm9yRWFjaChjb2xvcml6ZXIpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtfbGltaXRWYWx1ZSwgX2xvb2t1cEJ5S2V5LCBpc051bGxPclVuZGVmLCByZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIExhcmdlc3QgVHJpYW5nbGUgVGhyZWUgQnVja2V0cyBhbGdvcml0aG0uXG4gICAqXG4gICAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGJ5IFN2ZWlubiBTdGVpbmFyc3NvblxuICAgKiBpbiBodHRwczovL2dpdGh1Yi5jb20vc3ZlaW5uLXN0ZWluYXJzc29uL2Zsb3QtZG93bnNhbXBsZS9ibG9iL21hc3Rlci9qcXVlcnkuZmxvdC5kb3duc2FtcGxlLmpzXG4gICAqXG4gICAqIFRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBpcyBNSVQgbGljZW5zZWQuXG4gICAqL1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICAvLyBUaGVyZSBhcmUgbGVzcyBwb2ludHMgdGhhbiB0aGUgdGhyZXNob2xkLCByZXR1cm5pbmcgdGhlIHdob2xlIGFycmF5XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG5cbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG5cbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICAvLyBTdGFydGluZyBmcm9tIG9mZnNldFxuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcblxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKykge1xuICAgIGxldCBhdmdYID0gMDtcbiAgICBsZXQgYXZnWSA9IDA7XG4gICAgbGV0IGo7XG5cbiAgICAvLyBBZGRpbmcgb2Zmc2V0XG4gICAgY29uc3QgYXZnUmFuZ2VTdGFydCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUVuZCA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAyKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xuXG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuXG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGNoYW5nZWQgZnJvbSB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIHdoaWNoIGluaXRpYWxpemVzIHRoZXNlXG4gICAgLy8gdmFsdWVzIHRvIDEuIFRoZSByZWFzb24gZm9yIHRoaXMgY2hhbmdlIGlzIHRoYXQgaWYgdGhlIGFyZWEgaXMgc21hbGwsIG5leHRBXG4gICAgLy8gd291bGQgbmV2ZXIgYmUgc2V0IGFuZCB0aHVzIGEgY3Jhc2ggd291bGQgb2NjdXIgaW4gdGhlIG5leHQgbG9vcCBhcyBgYWAgd291bGQgYmVjb21lXG4gICAgLy8gYHVuZGVmaW5lZGAuIFNpbmNlIHRoZSBhcmVhIGlzIGFsd2F5cyBwb3NpdGl2ZSwgYnV0IGNvdWxkIGJlIDAgaW4gdGhlIGNhc2Ugb2YgYSBmbGF0IHRyYWNlLFxuICAgIC8vIGluaXRpYWxpemluZyB3aXRoIGEgbmVnYXRpdmUgbnVtYmVyIGlzIHRoZSBjb3JyZWN0IHNvbHV0aW9uLlxuICAgIG1heEFyZWEgPSBhcmVhID0gLTE7XG5cbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG5cbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBtYXhBcmVhUG9pbnQ7XG4gICAgYSA9IG5leHRBO1xuICB9XG5cbiAgLy8gSW5jbHVkZSB0aGUgbGFzdCBwb2ludFxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG5cbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuXG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgcG9pbnQgPSBkYXRhW2ldO1xuICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcbiAgICB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcblxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgYG1pbllgIC8gYG1heFlgIGFuZCBgYXZnWGAgd2hpbGUgd2Ugc3RheSB3aXRoaW4gc2FtZSB4LXBvc2l0aW9uXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICAvLyBVc2UgcG9pbnQueCBoZXJlIGJlY2F1c2Ugd2UncmUgY29tcHV0aW5nIHRoZSBhdmVyYWdlIGRhdGEgYHhgIHZhbHVlXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyBwb2ludC54KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQdXNoIHVwIHRvIDQgcG9pbnRzLCAzIGZvciB0aGUgbGFzdCBpbnRlcnZhbCBhbmQgdGhlIGZpcnN0IHBvaW50IGZvciB0aGlzIGludGVydmFsXG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBpIC0gMTtcblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgLy8gVGhlIGludGVydmFsIGlzIGRlZmluZWQgYnkgNCBwb2ludHM6IHN0YXJ0LCBtaW4sIG1heCwgZW5kLlxuICAgICAgICAvLyBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgYWxyZWFkeSBjb25zaWRlcmVkIGF0IHRoaXMgcG9pbnQsIHNvIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgIC8vIG9mIHRoZSBvdGhlciBwb2ludHMgdG8gYWRkLiBXZSBuZWVkIHRvIHNvcnQgdGhlc2UgcG9pbnRzIHRvIGVuc3VyZSB0aGUgZGVjaW1hdGVkIGRhdGFcbiAgICAgICAgLy8gaXMgc3RpbGwgc29ydGVkIGFuZCB0aGVuIGVuc3VyZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlcy5cbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcblxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxhc3RJbmRleCA9PT0gc3RhcnRJbmRleCB3aWxsIG9jY3VyIHdoZW4gYSByYW5nZSBoYXMgb25seSAxIHBvaW50IHdoaWNoIGNvdWxkXG4gICAgICAvLyBoYXBwZW4gd2l0aCB2ZXJ5IHVuZXZlbiBkYXRhXG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIC8vIExhc3QgcG9pbnQgaW4gdGhlIHByZXZpb3VzIGludGVydmFsXG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IG9mIHRoZSBuZXcgaW50ZXJ2YWxcbiAgICAgIGRlY2ltYXRlZC5wdXNoKHBvaW50KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICAgIG1pbkluZGV4ID0gbWF4SW5kZXggPSBzdGFydEluZGV4ID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpIHtcbiAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcblxuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnZGVjaW1hdGlvbicsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcblxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIC8vIFRoZSBkZWNpbWF0aW9uIHBsdWdpbiBtYXkgaGF2ZSBiZWVuIHByZXZpb3VzbHkgZW5hYmxlZC4gTmVlZCB0byByZW1vdmUgb2xkIGBkYXRhc2V0Ll9kYXRhYCBoYW5kbGVyc1xuICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBc3N1bWUgdGhlIGVudGlyZSBjaGFydCBpcyBhdmFpbGFibGUgdG8gc2hvdyBhIGZldyBtb3JlIHBvaW50cyB0aGFuIG5lZWRlZFxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG5cbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qge19kYXRhLCBpbmRleEF4aXN9ID0gZGF0YXNldDtcbiAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgY29uc3QgZGF0YSA9IF9kYXRhIHx8IGRhdGFzZXQuZGF0YTtcblxuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIC8vIERlY2ltYXRpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIGxpbmVzIHRoYXQgaGF2ZSBhbiBYIGluZGV4QXhpc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0YS5jb250cm9sbGVyLnN1cHBvcnRzRGVjaW1hdGlvbikge1xuICAgICAgICAvLyBPbmx5IGxpbmUgZGF0YXNldHMgYXJlIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIC8vIE9ubHkgbGluZWFyIGludGVycG9sYXRpb24gaXMgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMucGFyc2luZykge1xuICAgICAgICAvLyBQbHVnaW4gb25seSBzdXBwb3J0cyBkYXRhIHRoYXQgZG9lcyBub3QgbmVlZCBwYXJzaW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIC8vIE5vIGRlY2ltYXRpb24gaXMgcmVxdWlyZWQgdW50aWwgd2UgYXJlIGFib3ZlIHRoaXMgdGhyZXNob2xkXG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZihfZGF0YSkpIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSBhcmUgc2VlaW5nIHRoaXMgZGF0YXNldFxuICAgICAgICAvLyBXZSBvdmVycmlkZSB0aGUgJ2RhdGEnIHByb3BlcnR5IHdpdGggYSBzZXR0ZXIgdGhhdCBzdG9yZXMgdGhlXG4gICAgICAgIC8vIHJhdyBkYXRhIGluIF9kYXRhLCBidXQgcmVhZHMgdGhlIGRlY2ltYXRlZCBkYXRhIGZyb20gX2RlY2ltYXRlZFxuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQb2ludCB0aGUgY2hhcnQgdG8gdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuXG4gICAgICBkYXRhc2V0Ll9kZWNpbWF0ZWQgPSBkZWNpbWF0ZWQ7XG4gICAgfSk7XG4gIH0sXG5cbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge19ib3VuZFNlZ21lbnQsIF9ib3VuZFNlZ21lbnRzLCBfbm9ybWFsaXplQW5nbGV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgdHBvaW50cyA9IHRhcmdldC5wb2ludHM7XG4gIGNvbnN0IHBhcnRzID0gW107XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgbGV0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyk7XG5cbiAgICBjb25zdCBib3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCBwb2ludHNbc3RhcnRdLCBwb2ludHNbZW5kXSwgc2VnbWVudC5sb29wKTtcblxuICAgIGlmICghdGFyZ2V0LnNlZ21lbnRzKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGJvdW5kYXJ5IG5vdCBzdXBwb3J0aW5nIGBzZWdtZW50c2AgKHNpbXBsZUFyYylcbiAgICAgIC8vIEJvdW5kcyBhcmUgcHJvdmlkZWQgYXMgYHRhcmdldGAgZm9yIHBhcnRpYWwgY2lyY2xlLCBvciB1bmRlZmluZWQgZm9yIGZ1bGwgY2lyY2xlXG4gICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgc291cmNlOiBzZWdtZW50LFxuICAgICAgICB0YXJnZXQ6IGJvdW5kcyxcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tzdGFydF0sXG4gICAgICAgIGVuZDogcG9pbnRzW2VuZF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gR2V0IGFsbCBzZWdtZW50cyBmcm9tIGB0YXJnZXRgIHRoYXQgaW50ZXJzZWN0IHRoZSBib3VuZHMgb2YgY3VycmVudCBzZWdtZW50IG9mIGBsaW5lYFxuICAgIGNvbnN0IHRhcmdldFNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGFyZ2V0LCBib3VuZHMpO1xuXG4gICAgZm9yIChjb25zdCB0Z3Qgb2YgdGFyZ2V0U2VnbWVudHMpIHtcbiAgICAgIGNvbnN0IHN1YkJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHRwb2ludHNbdGd0LnN0YXJ0XSwgdHBvaW50c1t0Z3QuZW5kXSwgdGd0Lmxvb3ApO1xuICAgICAgY29uc3QgZmlsbFNvdXJjZXMgPSBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgc3ViQm91bmRzKTtcblxuICAgICAgZm9yIChjb25zdCBmaWxsU291cmNlIG9mIGZpbGxTb3VyY2VzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogZmlsbFNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCb3VuZHMocHJvcGVydHksIGZpcnN0LCBsYXN0LCBsb29wKSB7XG4gIGlmIChsb29wKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcbiAgbGV0IGVuZCA9IGxhc3RbcHJvcGVydHldO1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHN0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgfVxuICByZXR1cm4ge3Byb3BlcnR5LCBzdGFydCwgZW5kfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpIHtcbiAgY29uc3Qge3ggPSBudWxsLCB5ID0gbnVsbH0gPSBib3VuZGFyeSB8fCB7fTtcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgbGluZS5zZWdtZW50cy5mb3JFYWNoKCh7c3RhcnQsIGVuZH0pID0+IHtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eDogZmlyc3QueCwgeX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGxhc3QueCwgeX0pO1xuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGZpcnN0Lnl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBsYXN0Lnl9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cykge1xuICBmb3IgKDtlbmQgPiBzdGFydDsgZW5kLS0pIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xuICAgIGlmICghaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZDtcbn1cblxuZnVuY3Rpb24gX2dldEVkZ2UoYSwgYiwgcHJvcCwgZm4pIHtcbiAgaWYgKGEgJiYgYikge1xuICAgIHJldHVybiBmbihhW3Byb3BdLCBiW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gYSA/IGFbcHJvcF0gOiBiID8gYltwcm9wXSA6IDA7XG59XG4iLCIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X3BvaW50c0Zyb21TZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXSB8IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IH19IGJvdW5kYXJ5XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudD99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG5cbiAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgX2xvb3AgPSB0cnVlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuZmlsbCAhPT0gZmFsc2U7XG59XG4iLCJpbXBvcnQge2lzT2JqZWN0LCBpc0Zpbml0ZSwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uLy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJykuZGVmYXVsdCB9IExpbmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvaW5kZXguanMnKS5GaWxsVGFyZ2V0IH0gRmlsbFRhcmdldFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuQ29tcGxleEZpbGxUYXJnZXQgfSBDb21wbGV4RmlsbFRhcmdldFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcblxuICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgIHJldHVybiBmaWxsO1xuICB9XG5cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCB7dmFsdWU6IG51bWJlcn19ICovXG4gIGNvbnN0IGZpbGwgPSBwYXJzZUZpbGxPcHRpb24obGluZSk7XG5cbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG5cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG5cbiAgaWYgKGlzRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gZGVjb2RlVGFyZ2V0SW5kZXgoZmlsbFswXSwgaW5kZXgsIHRhcmdldCwgY291bnQpO1xuICB9XG5cbiAgcmV0dXJuIFsnb3JpZ2luJywgJ3N0YXJ0JywgJ2VuZCcsICdzdGFjaycsICdzaGFwZSddLmluZGV4T2YoZmlsbCkgPj0gMCAmJiBmaWxsO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xuICBpZiAoZmlyc3RDaCA9PT0gJy0nIHx8IGZpcnN0Q2ggPT09ICcrJykge1xuICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICB9XG5cbiAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmlsbFRhcmdldCB8IENvbXBsZXhGaWxsVGFyZ2V0fSBmaWxsXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpIHtcbiAgbGV0IHBpeGVsID0gbnVsbDtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHBpeGVsID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBpeGVsID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICB9XG4gIHJldHVybiBwaXhlbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydFZhbHVlKSB7XG4gIGxldCB2YWx1ZTtcblxuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHZhbHVlID0gc2NhbGUub3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmlsbE9wdGlvbihsaW5lKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBvcHRpb25zLmZpbGw7XG4gIGxldCBmaWxsID0gdmFsdWVPckRlZmF1bHQoZmlsbE9wdGlvbiAmJiBmaWxsT3B0aW9uLnRhcmdldCwgZmlsbE9wdGlvbik7XG5cbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnb3JpZ2luJztcbiAgfVxuICByZXR1cm4gZmlsbDtcbn1cbiIsIi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5pbXBvcnQge0xpbmVFbGVtZW50fSBmcm9tICcuLi8uLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQge19pc0JldHdlZW59IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfY3JlYXRlQm91bmRhcnlMaW5lfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7eyBjaGFydDogQ2hhcnQ7IHNjYWxlOiBTY2FsZTsgaW5kZXg6IG51bWJlcjsgbGluZTogTGluZUVsZW1lbnQ7IH19IHNvdXJjZVxuICogQHJldHVybiB7TGluZUVsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgaW5kZXgsIGxpbmV9ID0gc291cmNlO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBzb3VyY2VQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgbGluZXNCZWxvdyA9IGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KTtcbiAgbGluZXNCZWxvdy5wdXNoKF9jcmVhdGVCb3VuZGFyeUxpbmUoe3g6IG51bGwsIHk6IHNjYWxlLmJvdHRvbX0sIGxpbmUpKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGZvciAobGV0IGogPSBzZWdtZW50LnN0YXJ0OyBqIDw9IHNlZ21lbnQuZW5kOyBqKyspIHtcbiAgICAgIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnRzW2pdLCBsaW5lc0JlbG93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMaW5lRWxlbWVudCh7cG9pbnRzLCBvcHRpb25zOiB7fX0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50W119XG4gKi9cbmZ1bmN0aW9uIGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KSB7XG4gIGNvbnN0IGJlbG93ID0gW107XG4gIGNvbnN0IG1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2xpbmUnKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbWV0YS5oaWRkZW4pIHtcbiAgICAgIGJlbG93LnVuc2hpZnQobWV0YS5kYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlbG93O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHNvdXJjZVBvaW50XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50W119IGxpbmVzQmVsb3dcbiAqL1xuZnVuY3Rpb24gYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludCwgbGluZXNCZWxvdykge1xuICBjb25zdCBwb3N0cG9uZWQgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lc0JlbG93Lmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzQmVsb3dbal07XG4gICAgY29uc3Qge2ZpcnN0LCBsYXN0LCBwb2ludH0gPSBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsICd4Jyk7XG5cbiAgICBpZiAoIXBvaW50IHx8IChmaXJzdCAmJiBsYXN0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmaXJzdCkge1xuICAgICAgLy8gRmlyc3QgcG9pbnQgb2YgYSBzZWdtZW50IC0+IG5lZWQgdG8gYWRkIGFub3RoZXIgcG9pbnQgYmVmb3JlIHRoaXMsXG4gICAgICBwb3N0cG9uZWQudW5zaGlmdChwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAvLyBJbiB0aGUgbWlkZGxlIG9mIGEgc2VnbWVudCwgbm8gbmVlZCB0byBhZGQgbW9yZSBwb2ludHMuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludHMucHVzaCguLi5wb3N0cG9uZWQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBzb3VyY2VQb2ludFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7e3BvaW50PzogUG9pbnRFbGVtZW50LCBmaXJzdD86IGJvb2xlYW4sIGxhc3Q/OiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwb2ludCA9IGxpbmUuaW50ZXJwb2xhdGUoc291cmNlUG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKCFwb2ludCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IHBvaW50VmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LnN0YXJ0XVtwcm9wZXJ0eV07XG4gICAgY29uc3QgbGFzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LmVuZF1bcHJvcGVydHldO1xuICAgIGlmIChfaXNCZXR3ZWVuKHBvaW50VmFsdWUsIGZpcnN0VmFsdWUsIGxhc3RWYWx1ZSkpIHtcbiAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcbiAgICAgIGxhc3QgPSBwb2ludFZhbHVlID09PSBsYXN0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtmaXJzdCwgbGFzdCwgcG9pbnR9O1xufVxuIiwiaW1wb3J0IHtUQVV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vLyBUT0RPOiB1c2UgZWxlbWVudHMuQXJjRWxlbWVudCBpbnN0ZWFkXG5leHBvcnQgY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuXG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG5cbiAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7aXNGaW5pdGV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfY3JlYXRlQm91bmRhcnlMaW5lfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuaW1wb3J0IHtfZ2V0VGFyZ2V0UGl4ZWwsIF9nZXRUYXJnZXRWYWx1ZX0gZnJvbSAnLi9maWxsZXIub3B0aW9ucy5qcyc7XG5pbXBvcnQge19idWlsZFN0YWNrTGluZX0gZnJvbSAnLi9maWxsZXIudGFyZ2V0LnN0YWNrLmpzJztcbmltcG9ydCB7c2ltcGxlQXJjfSBmcm9tICcuL3NpbXBsZUFyYy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldChzb3VyY2UpIHtcbiAgY29uc3Qge2NoYXJ0LCBmaWxsLCBsaW5lfSA9IHNvdXJjZTtcblxuICBpZiAoaXNGaW5pdGUoZmlsbCkpIHtcbiAgICByZXR1cm4gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGZpbGwpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcbiAgICByZXR1cm4gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSk7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gJ3NoYXBlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcblxuICBpZiAoYm91bmRhcnkgaW5zdGFuY2VvZiBzaW1wbGVBcmMpIHtcbiAgICByZXR1cm4gYm91bmRhcnk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5mdW5jdGlvbiBnZXRMaW5lQnlJbmRleChjaGFydCwgaW5kZXgpIHtcbiAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgY29uc3QgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XG4gIHJldHVybiB2aXNpYmxlID8gbWV0YS5kYXRhc2V0IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCBzY2FsZSA9IHNvdXJjZS5zY2FsZSB8fCB7fTtcblxuICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlID0ge30sIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBwaXhlbCA9IF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSk7XG5cbiAgaWYgKGlzRmluaXRlKHBpeGVsKSkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gcGl4ZWwgOiBudWxsLFxuICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiBwaXhlbFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICBjb25zdCB2YWx1ZSA9IF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnQpO1xuICBjb25zdCB0YXJnZXQgPSBbXTtcblxuICBpZiAob3B0aW9ucy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgY29uc3QgY2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcbiAgICByZXR1cm4gbmV3IHNpbXBsZUFyYyh7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55LFxuICAgICAgcmFkaXVzOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSlcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0YXJnZXQucHVzaChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4iLCJpbXBvcnQge2NsaXBBcmVhLCB1bmNsaXBBcmVhLCBnZXREYXRhc2V0Q2xpcEFyZWF9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfZmluZFNlZ21lbnRFbmQsIF9nZXRCb3VuZHMsIF9zZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5pbXBvcnQge19nZXRUYXJnZXR9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7Y2hhcnQsIGluZGV4LCBsaW5lLCBzY2FsZSwgYXhpc30gPSBzb3VyY2U7XG4gIGNvbnN0IGxpbmVPcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgY29uc3QgY29sb3IgPSBsaW5lT3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGNvbnN0IHthYm92ZSA9IGNvbG9yLCBiZWxvdyA9IGNvbG9yfSA9IGZpbGxPcHRpb24gfHwge307XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IGNsaXAgPSBnZXREYXRhc2V0Q2xpcEFyZWEoY2hhcnQsIG1ldGEpO1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpcywgY2xpcH0pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgY2xpcH0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcblxuICBjdHguc2F2ZSgpO1xuXG4gIGxldCBmaWxsQ29sb3IgPSBiZWxvdztcbiAgaWYgKGJlbG93ICE9PSBhYm92ZSkge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEudG9wKTtcbiAgICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eSwgY2xpcH0pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAneScpIHtcbiAgICAgIGNsaXBIb3Jpem9udGFsKGN0eCwgdGFyZ2V0LCBhcmVhLmxlZnQpO1xuICAgICAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBiZWxvdywgc2NhbGUsIHByb3BlcnR5LCBjbGlwfSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNsaXBIb3Jpem9udGFsKGN0eCwgdGFyZ2V0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIGZpbGxDb2xvciA9IGFib3ZlO1xuICAgIH1cbiAgfVxuICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGZpbGxDb2xvciwgc2NhbGUsIHByb3BlcnR5LCBjbGlwfSk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICBjb25zdCB7c2VnbWVudHMsIHBvaW50c30gPSB0YXJnZXQ7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgY2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgfVxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcbiAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhsYXN0UG9pbnQueCwgY2xpcFkpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIGNsaXBIb3Jpem9udGFsKGN0eCwgdGFyZ2V0LCBjbGlwWCkge1xuICBjb25zdCB7c2VnbWVudHMsIHBvaW50c30gPSB0YXJnZXQ7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGNsaXBYLCBmaXJzdFBvaW50LnkpO1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgfVxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcbiAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhjbGlwWCwgbGFzdFBvaW50LnkpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5saW5lVG8oY2xpcFgsIHRhcmdldC5maXJzdCgpLnkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIGZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgcHJvcGVydHksIGNvbG9yLCBzY2FsZSwgY2xpcH0gPSBjZmc7XG4gIGNvbnN0IHNlZ21lbnRzID0gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpO1xuXG4gIGZvciAoY29uc3Qge3NvdXJjZTogc3JjLCB0YXJnZXQ6IHRndCwgc3RhcnQsIGVuZH0gb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3R5bGU6IHtiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcn0gPSB7fX0gPSBzcmM7XG4gICAgY29uc3Qgbm90U2hhcGUgPSB0YXJnZXQgIT09IHRydWU7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGNsaXAsIG5vdFNoYXBlICYmIF9nZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGNvbnN0IGxpbmVMb29wID0gISFsaW5lLnBhdGhTZWdtZW50KGN0eCwgc3JjKTtcblxuICAgIGxldCBsb29wO1xuICAgIGlmIChub3RTaGFwZSkge1xuICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgZW5kLCBwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge21vdmU6IGxpbmVMb29wLCByZXZlcnNlOiB0cnVlfSk7XG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKGxvb3AgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGNsaXAsIGJvdW5kcykge1xuICBjb25zdCBjaGFydEFyZWEgPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG5cbiAgaWYgKHByb3BlcnR5ID09PSAneCcgfHwgcHJvcGVydHkgPT09ICd5Jykge1xuICAgIGxldCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b207XG5cbiAgICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgICAgbGVmdCA9IHN0YXJ0O1xuICAgICAgdG9wID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHJpZ2h0ID0gZW5kO1xuICAgICAgYm90dG9tID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgdG9wID0gc3RhcnQ7XG4gICAgICByaWdodCA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICAgIGJvdHRvbSA9IGVuZDtcbiAgICB9XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIGNsaXAubGVmdCk7XG4gICAgICByaWdodCA9IE1hdGgubWluKHJpZ2h0LCBjbGlwLnJpZ2h0KTtcbiAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgY2xpcC50b3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCBjbGlwLmJvdHRvbSk7XG4gICAgfVxuXG4gICAgY3R4LnJlY3QobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBpbnRlcnBvbGF0ZWRQb2ludCA9IHRhcmdldC5pbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpO1xuICBpZiAoaW50ZXJwb2xhdGVkUG9pbnQpIHtcbiAgICBjdHgubGluZVRvKGludGVycG9sYXRlZFBvaW50LngsIGludGVycG9sYXRlZFBvaW50LnkpO1xuICB9XG59XG5cbiIsIi8qKlxuICogUGx1Z2luIGJhc2VkIG9uIGRpc2N1c3Npb24gZnJvbSB0aGUgZm9sbG93aW5nIENoYXJ0LmpzIGlzc3VlczpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIzODAjaXNzdWVjb21tZW50LTI3OTk2MTU2OVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjQ0MCNpc3N1ZWNvbW1lbnQtMjU2NDYxODk3XG4gKi9cblxuaW1wb3J0IExpbmVFbGVtZW50IGZyb20gJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyc7XG5pbXBvcnQge19kcmF3ZmlsbH0gZnJvbSAnLi9maWxsZXIuZHJhd2luZy5qcyc7XG5pbXBvcnQge19zaG91bGRBcHBseUZpbGx9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5pbXBvcnQge19kZWNvZGVGaWxsLCBfcmVzb2x2ZVRhcmdldH0gZnJvbSAnLi9maWxsZXIub3B0aW9ucy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdmaWxsZXInLFxuXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuXG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IF9kZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UuZmlsbCA9IF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcgJiYgc291cmNlLmZpbGwpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcblxuICAgICAgaWYgKF9zaG91bGRBcHBseUZpbGwoc291cmNlKSkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG5cbiAgICBpZiAoIV9zaG91bGRBcHBseUZpbGwoc291cmNlKSB8fCBvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldERyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG4iLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRoLCBkcmF3UG9pbnRMZWdlbmQsIHJlbmRlclRleHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtcbiAgX2lzQmV0d2VlbixcbiAgY2FsbGJhY2sgYXMgY2FsbCxcbiAgY2xpcEFyZWEsXG4gIGdldFJ0bEFkYXB0ZXIsXG4gIG92ZXJyaWRlVGV4dERpcmVjdGlvbixcbiAgcmVzdG9yZVRleHREaXJlY3Rpb24sXG4gIHRvRm9udCxcbiAgdG9QYWRkaW5nLFxuICB1bmNsaXBBcmVhLFxuICB2YWx1ZU9yRGVmYXVsdCxcbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdGV4dFgsIF90b0xlZnRSaWdodENlbnRlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge3RvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICovXG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcblxuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuXG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcblxuZXhwb3J0IGNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3sgY3R4OiBhbnk7IG9wdGlvbnM6IGFueTsgY2hhcnQ6IGFueTsgfX0gY29uZmlnXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcblxuICAgIC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuICAgIC8qKlxuIFx0XHQgKiBAcHJpdmF0ZVxuIFx0XHQgKi9cbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG5cbiAgICAvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnM7XG5cbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgdGhpcy5maXQoKTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cblxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCBsYWJlbE9wdHMgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgIGxldCBsZWdlbmRJdGVtcyA9IGNhbGwobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuXG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5zb3J0KChhLCBiKSA9PiBsYWJlbE9wdHMuc29ydChhLCBiLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cblxuICBmaXQoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSB0aGlzO1xuXG4gICAgLy8gVGhlIGxlZ2VuZCBtYXkgbm90IGJlIGRpc3BsYXllZCBmb3IgYSB2YXJpZXR5IG9mIHJlYXNvbnMgaW5jbHVkaW5nXG4gICAgLy8gdGhlIGZhY3QgdGhhdCB0aGUgZGVmYXVsdHMgZ290IHNldCB0byBgZmFsc2VgLlxuICAgIC8vIFdoZW4gdGhlIGxlZ2VuZCBpcyBub3QgZGlzcGxheWVkLCB0aGVyZSBhcmUgbm8gZ3VhcmFudGVlcyB0aGF0IHRoZSBvcHRpb25zXG4gICAgLy8gYXJlIGNvcnJlY3RseSBmb3JtYXR0ZWQgc28gd2UgbmVlZCB0byBiYWlsIG91dCBhcyBlYXJseSBhcyBwb3NzaWJsZS5cbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbE9wdHMgPSBvcHRpb25zLmxhYmVscztcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5tYXhXaWR0aDsgLy8gZmlsbCBhbGwgdGhlIHdpZHRoXG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG4gICAgICB3aWR0aCA9IHRoaXMuX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHdpZHRoLCBvcHRpb25zLm1heFdpZHRoIHx8IHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuXG4gICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0OiAwLCB0b3AsIHJvdywgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cblxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgbGFiZWxGb250LCBib3hXaWR0aCwgX2l0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuXG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcblxuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgY29sID0gMDtcblxuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3Qge2l0ZW1XaWR0aCwgaXRlbUhlaWdodH0gPSBjYWxjdWxhdGVJdGVtU2l6ZShib3hXaWR0aCwgbGFiZWxGb250LCBjdHgsIGxlZ2VuZEl0ZW0sIF9pdGVtSGVpZ2h0KTtcblxuICAgICAgLy8gSWYgdG9vIHRhbGwsIGdvIHRvIG5ldyBjb2x1bW5cbiAgICAgIGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCArIDIgKiBwYWRkaW5nID4gaGVpZ2h0TGltaXQpIHtcbiAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcbiAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2wrKztcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0LCB0b3A6IGN1cnJlbnRDb2xIZWlnaHQsIGNvbCwgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgLy8gR2V0IG1heCB3aWR0aFxuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcblxuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pOyAvLyBwcmV2aW91cyBjb2x1bW4gc2l6ZVxuXG4gICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gIH1cblxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSB0aGlzO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChoaXRib3gubGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGNsaXBBcmVhKGN0eCwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2RyYXcoKTtcblxuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXcoKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHtwYWRkaW5nfSA9IGxhYmVsT3B0cztcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcbiAgICBsZXQgY3Vyc29yO1xuXG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcblxuICAgICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2gsIFtdKSk7XG5cbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICAvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3RpbmdcbiAgICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveEhlaWdodCAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgIHBvaW50U3R5bGU6IGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcbiAgICAgICAgICBib3JkZXJXaWR0aDogbGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyBoYWxmRm9udFNpemU7XG5cbiAgICAgICAgLy8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgZHJhd1BvaW50TGVnZW5kKGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclksIGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggJiYgYm94V2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxuICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb24gd2hlbiBib3hIZWlnaHQgPCBmb250U2l6ZSAod2FudCBpdCBjZW50ZXJlZClcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICB4OiB4Qm94TGVmdCxcbiAgICAgICAgICAgIHk6IHlCb3hUb3AsXG4gICAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5yZWN0KHhCb3hMZWZ0LCB5Qm94VG9wLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGVnZW5kSXRlbS50ZXh0LCB4LCB5ICsgKGl0ZW1IZWlnaHQgLyAyKSwgbGFiZWxGb250LCB7XG4gICAgICAgIHN0cmlrZXRocm91Z2g6IGxlZ2VuZEl0ZW0uaGlkZGVuLFxuICAgICAgICB0ZXh0QWxpZ246IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gSG9yaXpvbnRhbFxuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXG4gICAgICAgIHk6IHRoaXMudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IHRoaXMubGVmdCArIHBhZGRpbmcsXG4gICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yOyAvLyBmb3Igc3RyaWtldGhyb3VnaCBlZmZlY3RcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cbiAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbiB8fCAobGVnZW5kSXRlbS50ZXh0QWxpZ24gPSBsYWJlbE9wdHMudGV4dEFsaWduKSk7XG4gICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xuICAgICAgbGV0IHggPSBjdXJzb3IueDtcbiAgICAgIGxldCB5ID0gY3Vyc29yLnk7XG5cbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcblxuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcblxuICAgICAgLy8gRmlsbCB0aGUgYWN0dWFsIGxhYmVsXG4gICAgICBmaWxsVGV4dChydGxIZWxwZXIueCh4KSwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBmb250TGluZUhlaWdodCA9IGxhYmVsRm9udC5saW5lSGVpZ2h0O1xuICAgICAgICBjdXJzb3IueSArPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gb3B0cy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG5cbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRpdGxlT3B0cy5wb3NpdGlvbjtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgIGxldCB5O1xuXG4gICAgLy8gVGhlc2UgZGVmYXVsdHMgYXJlIHVzZWQgd2hlbiB0aGUgbGVnZW5kIGlzIHZlcnRpY2FsLlxuICAgIC8vIFdoZW4gaG9yaXpvbnRhbCwgdGhleSBhcmUgY29tcHV0ZWQgYmVsb3cuXG4gICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gdGhpcy53aWR0aDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBNb3ZlIGxlZnQgLyByaWdodCBzbyB0aGF0IHRoZSB0aXRsZSBpcyBhYm92ZSB0aGUgbGVnZW5kIGxpbmVzXG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGRvd24gc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBzdGFjayBpbiBldmVyeSBhbGlnbm1lbnRcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGUgbGVmdCBlZGdlIG9mIHRoZSBpbm5lciBsZWdlbmQgYm94LCBjb21wdXRlIHRoZSBjb3JyZWN0XG4gICAgLy8gWCBjb29yZGluYXRlIGZyb20gdGhlIHRpdGxlIGFsaWdubWVudFxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICBsZXQgaSwgaGl0Qm94LCBsaDtcblxuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcbiAgICAgICYmIF9pc0JldHdlZW4oeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgLy8gU2VlIGlmIHdlIGFyZSB0b3VjaGluZyBvbmUgb2YgdGhlIGRhdGFzZXQgYm94ZXNcbiAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBoaXRCb3ggPSBsaFtpXTtcblxuICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcbiAgICAgICAgICAvLyBUb3VjaGluZyBhbiBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsKG9wdHMub25MZWF2ZSwgW2UsIHByZXZpb3VzLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG5cbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0pIHtcbiAgICAgIGNhbGwob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCkge1xuICBjb25zdCBpdGVtV2lkdGggPSBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KTtcbiAgY29uc3QgaXRlbUhlaWdodCA9IGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGxhYmVsRm9udC5saW5lSGVpZ2h0KTtcbiAgcmV0dXJuIHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KSB7XG4gIGxldCBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW0udGV4dDtcbiAgaWYgKGxlZ2VuZEl0ZW1UZXh0ICYmIHR5cGVvZiBsZWdlbmRJdGVtVGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW1UZXh0LnJlZHVjZSgoYSwgYikgPT4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiKTtcbiAgfVxuICByZXR1cm4gYm94V2lkdGggKyAobGFiZWxGb250LnNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtVGV4dCkud2lkdGg7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSB7XG4gIGxldCBpdGVtSGVpZ2h0ID0gX2l0ZW1IZWlnaHQ7XG4gIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gaXRlbUhlaWdodDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBjb25zdCBsYWJlbEhlaWdodCA9IGxlZ2VuZEl0ZW0udGV4dCA/IGxlZ2VuZEl0ZW0udGV4dC5sZW5ndGggOiAwO1xuICByZXR1cm4gZm9udExpbmVIZWlnaHQgKiBsYWJlbEhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICgodHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgdHlwZSA9PT0gJ21vdXNlb3V0JykgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnbGVnZW5kJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogTGVnZW5kLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe2N0eDogY2hhcnQuY3R4LCBvcHRpb25zLCBjaGFydH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICB9LFxuXG4gIC8vIER1cmluZyB0aGUgYmVmb3JlVXBkYXRlIHN0ZXAsIHRoZSBsYXlvdXQgY29uZmlndXJhdGlvbiBuZWVkcyB0byBydW5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgaWYgdGhlIGxlZ2VuZCBwb3NpdGlvbiBjaGFuZ2VzICh2aWEgYW4gb3B0aW9uIHVwZGF0ZSlcbiAgLy8gdGhlIGxheW91dCBzeXN0ZW0gcmVzcGVjdHMgdGhlIGNoYW5nZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy83NTI3XG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIC8vIFRoZSBsYWJlbHMgbmVlZCB0byBiZSBidWlsdCBhZnRlciBkYXRhc2V0cyBhcmUgdXBkYXRlZCB0byBlbnN1cmUgdGhhdCBjb2xvcnNcbiAgLy8gYW5kIG90aGVyIHN0eWxpbmcgYXJlIGNvcnJlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjk2OFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcblxuXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MucmVwbGF5KSB7XG4gICAgICBjaGFydC5sZWdlbmQuaGFuZGxlRXZlbnQoYXJncy5ldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcblxuICAgIC8vIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGhhbmRsZVxuICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XG4gICAgICBpZiAoY2kuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpLnNob3coaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG5cbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgLy8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG4gICAgICAvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcbiAgICAgIC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgIC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG4gICAgICAvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuICAgICAgLy8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuICAgICAgLy8gbGluZURhc2hcbiAgICAgIC8vIGxpbmVEYXNoT2Zmc2V0IDpcbiAgICAgIC8vIGxpbmVKb2luIDpcbiAgICAgIC8vIGxpbmVXaWR0aCA6XG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGNvbnN0IHtsYWJlbHM6IHt1c2VQb2ludFN0eWxlLCBwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yLCB1c2VCb3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1c319ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHVzZUJvcmRlclJhZGl1cyAmJiAoYm9yZGVyUmFkaXVzIHx8IHN0eWxlLmJvcmRlclJhZGl1cyksXG5cbiAgICAgICAgICAgIC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxuICAgIH1cbiAgfSxcbn07XG4iLCJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge1BJLCBpc0FycmF5LCB0b1BhZGRpbmcsIHRvRm9udH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge190b0xlZnRSaWdodENlbnRlciwgX2FsaWduU3RhcnRFbmR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtyZW5kZXJUZXh0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcblxuZXhwb3J0IGNsYXNzIFRpdGxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIC8qKlxuXHQgKiBAcGFyYW0ge3sgY3R4OiBhbnk7IG9wdGlvbnM6IGFueTsgY2hhcnQ6IGFueTsgfX0gY29uZmlnXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5fcGFkZGluZyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuXG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgPSBtYXhXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gbWF4SGVpZ2h0O1xuXG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0ZXh0U2l6ZTtcbiAgICB9XG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG4gIH1cblxuICBfZHJhd0FyZ3Mob2Zmc2V0KSB7XG4gICAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgIHRpdGxlWSA9IHRvcCArIG9mZnNldDtcbiAgICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRpdGxlWCA9IGxlZnQgKyBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAtMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGVYID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0b3AsIGJvdHRvbSk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAwLjU7XG4gICAgICB9XG4gICAgICBtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcbiAgICB9XG4gICAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZm9udE9wdHMgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIHRoaXMuX3BhZGRpbmcudG9wO1xuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRoaXMuX2RyYXdBcmdzKG9mZnNldCk7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgb3B0cy50ZXh0LCAwLCAwLCBmb250T3B0cywge1xuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiBfdG9MZWZ0UmlnaHRDZW50ZXIob3B0cy5hbGlnbiksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgY3R4OiBjaGFydC5jdHgsXG4gICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgIGNoYXJ0XG4gIH0pO1xuXG4gIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcbiAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgY2hhcnQudGl0bGVCbG9jayA9IHRpdGxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAndGl0bGUnLFxuXG4gIC8qKlxuXHQgKiBGb3IgdGVzdHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lbGVtZW50OiBUaXRsZSxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjcmVhdGVUaXRsZShjaGFydCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAyMDAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSB0byBiZSBhYm92ZVxuICB9LFxuXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuIiwiaW1wb3J0IHtUaXRsZX0gZnJvbSAnLi9wbHVnaW4udGl0bGUuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnc3VidGl0bGUnLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG5cbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gICAgbWFwLnNldChjaGFydCwgdGl0bGUpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMTUwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgYW5kIHNtYWxsZXIgdGhhbiB0aXRsZSAoMjAwMClcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsImltcG9ydCBBbmltYXRpb25zIGZyb20gJy4uL2NvcmUvY29yZS5hbmltYXRpb25zLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRofSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7ZWFjaCwgbm9vcCwgaXNOdWxsT3JVbmRlZiwgaXNBcnJheSwgX2VsZW1lbnRzRXF1YWwsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2dldFJ0bEFkYXB0ZXIsIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgcmVzdG9yZVRleHREaXJlY3Rpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5ydGwuanMnO1xuaW1wb3J0IHtkaXN0YW5jZUJldHdlZW5Qb2ludHMsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIGRyYXdQb2ludH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMnKS5DaGFydCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudCB9IEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuaW50ZXJhY3Rpb24uanMnKS5JbnRlcmFjdGlvbkl0ZW0gfSBJbnRlcmFjdGlvbkl0ZW1cbiAqL1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgLyoqXG5cdCAqIEF2ZXJhZ2UgbW9kZSBwbGFjZXMgdGhlIHRvb2x0aXAgYXQgdGhlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRzIHNob3duXG5cdCAqL1xuICBhdmVyYWdlKGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4U2V0ID0gbmV3IFNldCgpO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICB4U2V0LmFkZChwb3MueCk7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gdmlzaWJsZSBpdGVtcyB3aGVyZSBmb3VuZCwgcmV0dXJuIGZhbHNlIHNvIHdlIGRvbid0IGhhdmUgdG8gZGl2aWRlIGJ5IDAgd2hpY2ggcmVkdWNlcyBpbiBOYU5cbiAgICBpZiAoY291bnQgPT09IDAgfHwgeFNldC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgeEF2ZXJhZ2UgPSBbLi4ueFNldF0ucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyB4U2V0LnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeEF2ZXJhZ2UsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cblx0ICovXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCB4ID0gZXZlbnRQb3NpdGlvbi54O1xuICAgIGxldCB5ID0gZXZlbnRQb3NpdGlvbi55O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG5cbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgeCA9IHRwLng7XG4gICAgICB5ID0gdHAueTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICAvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UucHVzaCh0b1B1c2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2Ygc3RyaW5ncyBzcGxpdCBieSBuZXdsaW5lXG4gKiBAcGFyYW0geyp9IHN0ciAtIFRoZSB2YWx1ZSB0byBzcGxpdCBieSBuZXdsaW5lLlxuICogQHJldHVybnMge3N0cmluZ3xzdHJpbmdbXX0gdmFsdWUgaWYgbmV3bGluZSBwcmVzZW50IC0gUmV0dXJuZWQgZnJvbSBTdHJpbmcgc3BsaXQoKSBtZXRob2RcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gY3JlYXRlIGEgdG9vbHRpcCBpdGVtIG1vZGVsXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtBY3RpdmVFbGVtZW50fSBpdGVtIC0ge2VsZW1lbnQsIGluZGV4LCBkYXRhc2V0SW5kZXh9IHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcblxuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0b29sdGlwXG4gKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XG4gIGNvbnN0IHtib2R5LCBmb290ZXIsIHRpdGxlfSA9IHRvb2x0aXA7XG4gIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICBjb25zdCBmb290ZXJMaW5lQ291bnQgPSBmb290ZXIubGVuZ3RoO1xuICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuXG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuXG4gIC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG5cbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZ1xuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICB9XG4gIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgaGVpZ2h0IGRlcGVuZGluZyBvbiBib3hIZWlnaHRcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSBib2R5TGluZUl0ZW1Db3VudCkgKiBib2R5Rm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gIH1cbiAgaWYgKGZvb3RlckxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxuXHRcdFx0KyBmb290ZXJMaW5lQ291bnQgKiBmb290ZXJGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICB9XG5cbiAgLy8gVGl0bGUgd2lkdGhcbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gIGNvbnN0IG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICB9O1xuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSB3aWR0aFxuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcblxuICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgd2lkdGggZHVlIHRvIHRoZSBjb2xvciBib3hcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgYmFjayB0byAwXG4gIHdpZHRoUGFkZGluZyA9IDA7XG5cbiAgLy8gRm9vdGVyIHdpZHRoXG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICAvLyBBZGQgcGFkZGluZ1xuICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSkge1xuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XG5cbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9IGVsc2UgaWYgKHkgPiAoY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH1cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHt3aWR0aDogY2hhcnRXaWR0aCwgY2hhcnRBcmVhOiB7bGVmdCwgcmlnaHR9fSA9IGNoYXJ0O1xuICBsZXQgeEFsaWduID0gJ2NlbnRlcic7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuXG4gIGlmIChkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpKSB7XG4gICAgeEFsaWduID0gJ2NlbnRlcic7XG4gIH1cblxuICByZXR1cm4geEFsaWduO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHlBbGlnbiA9IHNpemUueUFsaWduIHx8IG9wdGlvbnMueUFsaWduIHx8IGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICBjb25zdCB7Y2FyZXRTaXplLCBjYXJldFBhZGRpbmcsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gYWxpZ25tZW50O1xuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG5cbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcblxuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSArIGNhcmV0U2l6ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogX2xpbWl0VmFsdWUoeCwgMCwgY2hhcnQud2lkdGggLSBzaXplLndpZHRoKSxcbiAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuXG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGJ1aWxkIGJlZm9yZSBhbmQgYWZ0ZXIgYm9keSBsaW5lc1xuICovXG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRvb2x0aXAsXG4gICAgdG9vbHRpcEl0ZW1zLFxuICAgIHR5cGU6ICd0b29sdGlwJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuXG5jb25zdCBkZWZhdWx0Q2FsbGJhY2tzID0ge1xuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uZGF0YUluZGV4IDwgbGFiZWxDb3VudCkge1xuICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIGFmdGVyVGl0bGU6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcbiAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBsYWJlbCArPSAnOiAnO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWw7XG4gIH0sXG4gIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIH07XG4gIH0sXG4gIGxhYmVsVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICB9LFxuICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgIH07XG4gIH0sXG4gIGFmdGVyTGFiZWw6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGFmdGVyQm9keTogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlRm9vdGVyOiBub29wLFxuICBmb290ZXI6IG5vb3AsXG4gIGFmdGVyRm9vdGVyOiBub29wXG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayBmcm9tIG9iamVjdCB3aXRoIGNvbnRleHQgYW5kIGFyZ3VtZW50cy5cbiAqIElmIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZW4gd2lsbCBiZSBpbnZva2VkIGRlZmF1bHQgY2FsbGJhY2suXG4gKiBAcGFyYW0ge1JlY29yZDxrZXlvZiB0eXBlb2YgZGVmYXVsdENhbGxiYWNrcywgRnVuY3Rpb24+fSBjYWxsYmFja3NcbiAqIEBwYXJhbSB7a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3N9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gY3R4XG4gKiBAcGFyYW0geyp9IGFyZ1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCBuYW1lLCBjdHgsIGFyZykge1xuICBjb25zdCByZXN1bHQgPSBjYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG5cbiAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRDYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcbiAgICovXG4gIHN0YXRpYyBwb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xuICAgIC8vIFRPRE86IFY0LCBtYWtlIHRoaXMgcHJpdmF0ZSwgcmVuYW1lIHRvIGBfbGFiZWxTdHlsZXNgLCBhbmQgY29tYmluZSB3aXRoIGBsYWJlbFBvaW50U3R5bGVzYFxuICAgIC8vIGFuZCBgbGFiZWxUZXh0Q29sb3JzYCB0byBjcmVhdGUgYSBzaW5nbGUgdmFyaWFibGVcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG5cbiAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICBjb25zdCB0aXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ3RpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2FmdGVyVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcblxuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYmVmb3JlQm9keScsIHRoaXMsIHRvb2x0aXBJdGVtcylcbiAgICApO1xuICB9XG5cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG5cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2JlZm9yZUxhYmVsJywgdGhpcywgY29udGV4dCkpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWwnLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnYWZ0ZXJMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG5cbiAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cblxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKFxuICAgICAgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2sob3B0aW9ucy5jYWxsYmFja3MsICdhZnRlckJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdiZWZvcmVGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2Zvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlckZvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbSh0aGlzLmNoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBsYWJlbENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsQ29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxQb2ludFN0eWxlJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxUZXh0Q29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbGFiZWxQb2ludFN0eWxlcztcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuXG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG5cbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG5cbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIHRoaXMuY2hhcnQpO1xuXG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcztcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcblxuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG5cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7Y2FyZXRTaXplLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCB7eDogcHRYLCB5OiBwdFl9ID0gdG9vbHRpcFBvaW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG5cbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG5cbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBMZWZ0IGRyYXdzIGJvdHRvbSAtPiB0b3AsIHRoaXMgeTEgaXMgb24gdGhlIGJvdHRvbVxuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgeDIgPSB4MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBSaWdodCBkcmF3cyB0b3AgLT4gYm90dG9tLCB0aHVzIHkxIGlzIG9uIHRoZSB0b3BcbiAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgIH1cblxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cblxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gVG9wIGRyYXdzIGxlZnQgLT4gcmlnaHQsIHRodXMgeDEgaXMgb24gdGhlIGxlZnRcbiAgICAgICAgeDEgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIEJvdHRvbSBkcmF3cyByaWdodCAtPiBsZWZ0LCB0aHVzIHgxIGlzIG9uIHRoZSByaWdodFxuICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeTMgPSB5MTtcbiAgICB9XG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcbiAgfVxuXG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcbiAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG5cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxDb2xvciA9IHRoaXMubGFiZWxDb2xvcnNbaV07XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRofSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG5cbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihib3hXaWR0aCwgYm94SGVpZ2h0KSAvIDIsIC8vIGZpdCB0aGUgY2lyY2xlIGluIHRoZSBib3hcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcblxuICAgICAgLy8gRmlsbCB0aGUgcG9pbnQgd2l0aCB3aGl0ZSBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG5cbiAgICAgIC8vIERyYXcgdGhlIHBvaW50XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9yLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3JkZXJcbiAgICAgIGN0eC5saW5lV2lkdGggPSBpc09iamVjdChsYWJlbENvbG9yLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkpIDogKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGggfHwgMSk7IC8vIFRPRE8sIHY0IHJlbW92ZSBmYWxsYmFja1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9yLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvci5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG5cbiAgICAgIC8vIEZpbGwgYSB3aGl0ZSByZWN0IHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG4gICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKTtcbiAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIDIpO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9yLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gSW5uZXIgc3F1YXJlXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSArIDEsXG4gICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIHJlY3RcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSBmaWxsU3R5bGVcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gIH1cblxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcbiAgICBjb25zdCB7Ym9keVNwYWNpbmcsIGJvZHlBbGlnbiwgZGlzcGxheUNvbG9ycywgYm94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG5cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG5cbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG5cbiAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcblxuICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG5cbiAgICAvLyBCZWZvcmUgYm9keSBsaW5lc1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgeExpbmVQYWRkaW5nID0gZGlzcGxheUNvbG9ycyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuICAgICAgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcpIDogKGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcpXG4gICAgICA6IDA7XG5cbiAgICAvLyBEcmF3IGJvZHkgbGluZXMgbm93XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG5cbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICAvLyBEcmF3IExlZ2VuZC1saWtlIGJveGVzIGlmIG5lZWRlZFxuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICAvLyBSZXNldCBmb3IgYW55IGxpbmVzIHRoYXQgZG9uJ3QgaW5jbHVkZSBjb2xvcmJveFxuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBiYWNrIHRvIDAgZm9yIGFmdGVyIGJvZHlcbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcblxuICAgIC8vIEFmdGVyIGJvZHkgbGluZXNcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgcHQueSAtPSBib2R5U3BhY2luZzsgLy8gUmVtb3ZlIGxhc3QgYm9keSBzcGFjaW5nXG4gIH1cblxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeX0gPSBwdDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgeC95IGFuaW1hdGlvbiB0YXJnZXRzIHdoZW4gX2FjdGl2ZSBlbGVtZW50cyBhcmUgYW5pbWF0aW5nIHRvb1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHRvb2x0aXAgd2lsbCBkcmF3IGFueXRoaW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0b29sdGlwIHdpbGwgcmVuZGVyXG4gICAqL1xuICBfd2lsbFJlbmRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG5cbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuXG4gICAgLy8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICAgIC8vIFRydXRoeS9mYWxzZXkgdmFsdWUgZm9yIGVtcHR5IHRvb2x0aXBcbiAgICBjb25zdCBoYXNUb29sdGlwQ29udGVudCA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuXG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cbiAgICAgIC8vIERyYXcgQmFja2dyb3VuZFxuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG5cbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG5cbiAgICAgIC8vIFRpdGxlc1xuICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEJvZHlcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEZvb3RlclxuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEdldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSBhY3RpdmUgaW4gdGhlIHRvb2x0aXBcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSBlbGVtZW50cyBpbiB0aGUgdG9vbHRpcFxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBBcnJheSBvZiBhY3RpdmUgZGF0YXNldEluZGV4L2luZGV4IHBhaXJzLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQb3NpdGlvbiBTeW50aGV0aWMgZXZlbnQgcG9zaXRpb24gdXNlZCBpbiBwb3NpdGlvbmluZ1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuICBoYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhID0gdHJ1ZSkge1xuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgc2hvd24sIGJ1dCB0aGUgdG9vbHRpcCBwb3NpdGlvbiBpcyBuZWFyZXN0IG1vZGVcbiAgICAvLyBhbiB1cGRhdGUgbWF5IG5lZWQgdG8gYmUgbWFkZSBiZWNhdXNlIG91ciBwb3NpdGlvbiBtYXkgaGF2ZSBjaGFuZ2VkIGV2ZW4gdGhvdWdoXG4gICAgLy8gdGhlIGl0ZW1zIGFyZSB0aGUgc2FtZSBhcyBiZWZvcmUuXG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG5cbiAgICAvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcbiAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcblxuICAgIC8vIE9ubHkgaGFuZGxlIHRhcmdldCBldmVudCBvbiB0b29sdGlwIGNoYW5nZVxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG5cbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICB5OiBlLnlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhlbHBlciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGFjdGl2ZSBlbGVtZW50cyBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uSXRlbVtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIFRoaXMgaXMgYSByZXBsYXllZCBldmVudCAoZnJvbSB1cGRhdGUpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIFRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm5zIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBMZXQgdXNlciBjb250cm9sIHRoZSBhY3RpdmUgZWxlbWVudHMgb3V0c2lkZSBjaGFydEFyZWEuIEVnLiB1c2luZyBMZWdlbmQuXG4gICAgICAvLyBCdXQgbWFrZSBzdXJlIHRoYXQgYWN0aXZlIGVsZW1lbnRzIGFyZSBzdGlsbCB2YWxpZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlLmZpbHRlcihpID0+XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tpLmRhdGFzZXRJbmRleF0gJiZcbiAgICAgICAgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpLmRhdGFzZXRJbmRleCkuY29udHJvbGxlci5nZXRQYXJzZWQoaS5pbmRleCkgIT09IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgdG9vbHRpcHNcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG5cbiAgLyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgYWN0aXZlIGVsZW1lbnRzICsgZXZlbnQgY29tYmluYXRpb24gY2hhbmdlcyB0aGVcblx0ICogdG9vbHRpcCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmUgLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gRXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIHBvc2l0aW9uIGNoYW5nZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcG9zaXRpb24gaGFzIGNoYW5nZWRcblx0ICovXG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3Rvb2x0aXAnLFxuICBfZWxlbWVudDogVG9vbHRpcCxcbiAgcG9zaXRpb25lcnMsXG5cbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe2NoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICByZXNldChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcblxuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgdG9vbHRpcFxuICAgICAgfTtcblxuICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3Jywgey4uLmFyZ3MsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcblxuICAgICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgLy8gbm90aWZ5IGNoYXJ0IGFib3V0IHRoZSBjaGFuZ2UsIHNvIGl0IHdpbGwgcmVuZGVyXG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdjYXJldFgnLCAnY2FyZXRZJ10sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IGRlZmF1bHRDYWxsYmFja3NcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6ICdmb250JyxcbiAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgdGl0bGVGb250OiAnZm9udCdcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmVzb2x2ZSBhZGRpdGlvbmFsbHkgZnJvbSBgaW50ZXJhY3Rpb25gIG9wdGlvbnMgYW5kIGRlZmF1bHRzLlxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJ2ludGVyYWN0aW9uJ11cbn07XG4iLCJpbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHQsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuY29uc3QgYWRkSWZTdHJpbmcgPSAobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykgPT4ge1xuICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICBpbmRleCA9IGxhYmVscy5wdXNoKHJhdykgLSAxO1xuICAgIGFkZGVkTGFiZWxzLnVuc2hpZnQoe2luZGV4LCBsYWJlbDogcmF3fSk7XG4gIH0gZWxzZSBpZiAoaXNOYU4ocmF3KSkge1xuICAgIGluZGV4ID0gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSB7XG4gIGNvbnN0IGZpcnN0ID0gbGFiZWxzLmluZGV4T2YocmF3KTtcbiAgaWYgKGZpcnN0ID09PSAtMSkge1xuICAgIHJldHVybiBhZGRJZlN0cmluZyhsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKTtcbiAgfVxuICBjb25zdCBsYXN0ID0gbGFiZWxzLmxhc3RJbmRleE9mKHJhdyk7XG4gIHJldHVybiBmaXJzdCAhPT0gbGFzdCA/IGluZGV4IDogZmlyc3Q7XG59XG5cbmNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXgsIG1heCkgPT4gaW5kZXggPT09IG51bGwgPyBudWxsIDogX2xpbWl0VmFsdWUoTWF0aC5yb3VuZChpbmRleCksIDAsIG1heCk7XG5cbmZ1bmN0aW9uIF9nZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cbiAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPCBsYWJlbHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxhYmVsc1t2YWx1ZV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXRlZ29yeVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICdjYXRlZ29yeSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBfZ2V0TGFiZWxGb3JWYWx1ZVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICB9XG5cbiAgaW5pdChzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBhZGRlZCA9IHRoaXMuX2FkZGVkTGFiZWxzO1xuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICBmb3IgKGNvbnN0IHtpbmRleCwgbGFiZWx9IG9mIGFkZGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNbaW5kZXhdID09PSBsYWJlbCkge1xuICAgICAgICAgIGxhYmVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICAgIH1cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0aW9ucyk7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXhcbiAgICAgIDogZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIHZhbHVlT3JEZWZhdWx0KGluZGV4LCByYXcpLCB0aGlzLl9hZGRlZExhYmVscyk7XG4gICAgcmV0dXJuIHZhbGlkSW5kZXgoaW5kZXgsIGxhYmVscy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQ7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcblxuICAgIC8vIElmIHdlIGFyZSB2aWV3aW5nIHNvbWUgc3Vic2V0IG9mIGxhYmVscywgc2xpY2UgdGhlIG9yaWdpbmFsIGFycmF5XG4gICAgbGFiZWxzID0gKG1pbiA9PT0gMCAmJiBtYXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xuXG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KGxhYmVscy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5taW4gLSAob2Zmc2V0ID8gMC41IDogMCk7XG5cbiAgICBmb3IgKGxldCB2YWx1ZSA9IG1pbjsgdmFsdWUgPD0gbWF4OyB2YWx1ZSsrKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9nZXRMYWJlbEZvclZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHZlcnRpY2FsIGNhdGVnb3J5IHNjYWxlIHJldmVyc2UgaXMgaW52ZXJ0ZWQuXG4gICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gIXRoaXMuX3JldmVyc2VQaXhlbHM7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICAvLyBNdXN0IG92ZXJyaWRlIGJhc2UgaW1wbGVtZW50YXRpb24gYmVjYXVzZSBpdCBjYWxscyBnZXRQaXhlbEZvclZhbHVlXG4gIC8vIGFuZCBjYXRlZ29yeSBzY2FsZSBjYW4gaGF2ZSBkdXBsaWNhdGUgdmFsdWVzXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG59XG4iLCJpbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7YWxtb3N0RXF1YWxzLCBhbG1vc3RXaG9sZSwgbmljZU51bSwgX2RlY2ltYWxQbGFjZXMsIF9zZXRNaW5BbmRNYXhCeUtleSwgc2lnbiwgdG9SYWRpYW5zfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbGluZWFyIHRpY2tzIGZvciBhbiBheGlzXG4gKiAxLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5taW4sIGdlbmVyYXRpb25PcHRpb25zLm1heCwgYW5kIGdlbmVyYXRpb25PcHRpb25zLnN0ZXAgYXJlIGRlZmluZWQ6XG4gKiAgICBpZiAobWF4IC0gbWluKSAvIHN0ZXAgaXMgYW4gaW50ZWdlciwgdGlja3MgYXJlIGdlbmVyYXRlZCBhcyBbbWluLCBtaW4gKyBzdGVwLCAuLi4sIG1heF1cbiAqICAgIE5vdGUgdGhhdCB0aGUgZ2VuZXJhdGlvbk9wdGlvbnMubWF4Q291bnQgc2V0dGluZyBpcyByZXNwZWN0ZWQgaW4gdGhpcyBzY2VuYXJpb1xuICpcbiAqIDIuIElmIGdlbmVyYXRpb25PcHRpb25zLm1pbiwgZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCBhbmQgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gY291bnRcbiAqICAgIFRpY2tzIGFyZSBnZW5lcmF0ZWQgYXMgW21pbiwgbWluICsgc3BhY2luZywgLi4uLCBtYXhdXG4gKlxuICogMy4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBjb3VudFxuICpcbiAqIDQuIENvbXB1dGUgb3B0aW1hbCBzcGFjaW5nIG9mIHRpY2tzIHVzaW5nIG5pY2VOdW0gYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdFtdfSBhcnJheSBvZiB0aWNrIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8vIFRvIGdldCBhIFwibmljZVwiIHZhbHVlIGZvciB0aGUgdGljayBzcGFjaW5nLCB3ZSB3aWxsIHVzZSB0aGUgYXBwcm9wcmlhdGVseSBuYW1lZFxuICAvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNjg4MS9uaWNlLWxhYmVsLWFsZ29yaXRobS1mb3ItY2hhcnRzLXdpdGgtbWluaW11bS10aWNrc1xuICAvLyBmb3IgZGV0YWlscy5cblxuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuICBjb25zdCB7Ym91bmRzLCBzdGVwLCBtaW4sIG1heCwgcHJlY2lzaW9uLCBjb3VudCwgbWF4VGlja3MsIG1heERpZ2l0cywgaW5jbHVkZUJvdW5kc30gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgY29uc3QgdW5pdCA9IHN0ZXAgfHwgMTtcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICBjb25zdCB7bWluOiBybWluLCBtYXg6IHJtYXh9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XG4gIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG5cbiAgLy8gQmV5b25kIE1JTl9TUEFDSU5HIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYmVpbmcgdG8gbG9zZSBwcmVjaXNpb25cbiAgLy8gc3VjaCB0aGF0IHdlIGNhbid0IGRvIHRoZSBtYXRoIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aWNrc1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuXG4gIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgIC8vIElmIHRoZSBjYWxjdWxhdGVkIG51bSBvZiBzcGFjZXMgZXhjZWVkcyBtYXhOdW1TcGFjZXMsIHJlY2FsY3VsYXRlIGl0XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgcHJlY2lzaW9uLCByb3VuZCB0byB0aGF0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cblxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cblxuICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAvLyBDYXNlIDE6IElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBhcmUgc2V0IGFuZCB0aGV5IG1ha2UgYW4gZXZlbmx5IHNwYWNlZCBzY2FsZSB1c2UgaXQuXG4gICAgLy8gc3BhY2luZyA9IHN0ZXA7XG4gICAgLy8gbnVtU3BhY2VzID0gKG1heCAtIG1pbikgLyBzcGFjaW5nO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSByb3VuZCBoZXJlIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbG1vc3RXaG9sZSB0cmFuc2xhdGVkIGFuIEZQIGVycm9yXG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICAvLyBDYXNlcyAyICYgMywgd2UgaGF2ZSBhIGNvdW50IHNwZWNpZmllZC4gSGFuZGxlIG9wdGlvbmFsIHVzZXIgZGVmaW5lZCBlZGdlcyB0byB0aGUgcmFuZ2UuXG4gICAgLy8gU29tZXRpbWVzIHRoZXNlIGFyZSBuby1vcHMsIGJ1dCBpdCBtYWtlcyB0aGUgY29kZSBhIGxvdCBjbGVhcmVyXG4gICAgLy8gYW5kIHdoZW4gYSB1c2VyIGRlZmluZWQgcmFuZ2UgaXMgc3BlY2lmaWVkLCB3ZSB3YW50IHRoZSBjb3JyZWN0IHRpY2tzXG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZSA0XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG5cbiAgICAvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciByb3VuZGVkIHZhbHVlLCB1c2UgaXQuXG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBzcGFjaW5nIHdpbGwgaGF2ZSBjaGFuZ2VkIGluIGNhc2VzIDEsIDIsIGFuZCAzIHNvIHRoZSBmYWN0b3IgY2Fubm90IGJlIGNvbXB1dGVkXG4gIC8vIHVudGlsIHRoaXMgcG9pbnRcbiAgY29uc3QgZGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KFxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxuICAgIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pXG4gICk7XG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcblxuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrOyAvLyBTa2lwIG5pY2VNaW5cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBuZXh0IG5pY2UgdGljayBpcyBjbG9zZSB0byBtaW4sIHNraXAgaXRcbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgY29uc3QgdGlja1ZhbHVlID0gTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgaWYgKG1heERlZmluZWQgJiYgdGlja1ZhbHVlID4gbWF4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWx1ZX0pO1xuICB9XG5cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgdGljayBpcyB0b28gY2xvc2UgdG8gbWF4LCByZXBsYWNlIGl0IHdpdGggbWF4LCBlbHNlIGFkZCBtYXhcbiAgICBpZiAodGlja3MubGVuZ3RoICYmIGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cblxuICByZXR1cm4gdGlja3M7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XG4gIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihyYWQpIDogTWF0aC5jb3MocmFkKSkgfHwgMC4wMDE7XG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuICtyYXc7XG4gIH1cblxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG5cbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGxldCBvZmZzZXQgPSBtYXggPT09IDAgPyAxIDogTWF0aC5hYnMobWF4ICogMC4wNSk7XG5cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuXG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttYXhUaWNrc0xpbWl0LCBzdGVwU2l6ZX0gPSB0aWNrT3B0cztcbiAgICBsZXQgbWF4VGlja3M7XG5cbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHN0ZXBTaXplKSArIDE7XG4gICAgICBpZiAobWF4VGlja3MgPiAxMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG5cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heFRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgICAvLyBGaWd1cmUgb3V0IHdoYXQgdGhlIG1heCBudW1iZXIgb2YgdGlja3Mgd2UgY2FuIHN1cHBvcnQgaXQgaXMgYmFzZWQgb24gdGhlIHNpemUgb2ZcbiAgICAvLyB0aGUgYXhpcyBhcmVhLiBGb3Igbm93LCB3ZSBzYXkgdGhhdCB0aGUgbWluaW11bSB0aWNrIHNwYWNpbmcgaW4gcGl4ZWxzIG11c3QgYmUgNDBcbiAgICAvLyBXZSBhbHNvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byAxMSB3aGljaCBnaXZlcyBhIG5pY2UgMTAgc3F1YXJlcyBvblxuICAgIC8vIHRoZSBncmFwaC4gTWFrZSBzdXJlIHdlIGFsd2F5cyBoYXZlIGF0IGxlYXN0IDIgdGlja3NcbiAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICBtYXhUaWNrcyxcbiAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICBtaW46IG9wdHMubWluLFxuICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IHRoaXMuX3JhbmdlIHx8IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgfVxuXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3RvUmFkaWFuc30gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcblxuICBzdGF0aWMgaWQgPSAnbGluZWFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgIH1cbiAgfTtcblxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBtYXggOiAxO1xuXG4gICAgLy8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIG1pbiwgbWF4LCBiZWdpbkF0WmVyb1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pO1xuICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuXG4gIC8vIFV0aWxzXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuIiwiaW1wb3J0IHtmaW5pdGVPckRlZmF1bHQsIGlzRmluaXRlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHtfc2V0TWluQW5kTWF4QnlLZXksIGxvZzEwfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuXG5jb25zdCBsb2cxMEZsb29yID0gdiA9PiBNYXRoLmZsb29yKGxvZzEwKHYpKTtcbmNvbnN0IGNoYW5nZUV4cG9uZW50ID0gKHYsIG0pID0+IE1hdGgucG93KDEwLCBsb2cxMEZsb29yKHYpICsgbSk7XG5cbmZ1bmN0aW9uIGlzTWFqb3IodGlja1ZhbCkge1xuICBjb25zdCByZW1haW4gPSB0aWNrVmFsIC8gKE1hdGgucG93KDEwLCBsb2cxMEZsb29yKHRpY2tWYWwpKSk7XG4gIHJldHVybiByZW1haW4gPT09IDE7XG59XG5cbmZ1bmN0aW9uIHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkge1xuICBjb25zdCByYW5nZVN0ZXAgPSBNYXRoLnBvdygxMCwgcmFuZ2VFeHApO1xuICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IobWluIC8gcmFuZ2VTdGVwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5jZWlsKG1heCAvIHJhbmdlU3RlcCk7XG4gIHJldHVybiBlbmQgLSBzdGFydDtcbn1cblxuZnVuY3Rpb24gc3RhcnRFeHAobWluLCBtYXgpIHtcbiAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XG4gIGxldCByYW5nZUV4cCA9IGxvZzEwRmxvb3IocmFuZ2UpO1xuICB3aGlsZSAoc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSA+IDEwKSB7XG4gICAgcmFuZ2VFeHArKztcbiAgfVxuICB3aGlsZSAoc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSA8IDEwKSB7XG4gICAgcmFuZ2VFeHAtLTtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4ocmFuZ2VFeHAsIGxvZzEwRmxvb3IobWluKSk7XG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsb2dhcml0aG1pYyB0aWNrc1xuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdFtdfSBhcnJheSBvZiB0aWNrIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywge21pbiwgbWF4fSkge1xuICBtaW4gPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBtaW4pO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBtaW5FeHAgPSBsb2cxMEZsb29yKG1pbik7XG4gIGxldCBleHAgPSBzdGFydEV4cChtaW4sIG1heCk7XG4gIGxldCBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcbiAgY29uc3Qgc3RlcFNpemUgPSBNYXRoLnBvdygxMCwgZXhwKTtcbiAgY29uc3QgYmFzZSA9IG1pbkV4cCA+IGV4cCA/IE1hdGgucG93KDEwLCBtaW5FeHApIDogMDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLnJvdW5kKChtaW4gLSBiYXNlKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIGNvbnN0IG9mZnNldCA9IE1hdGguZmxvb3IoKG1pbiAtIGJhc2UpIC8gc3RlcFNpemUgLyAxMCkgKiBzdGVwU2l6ZSAqIDEwO1xuICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKChzdGFydCAtIG9mZnNldCkgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG4gIGxldCB2YWx1ZSA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucm91bmQoKGJhc2UgKyBvZmZzZXQgKyBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24pO1xuICB3aGlsZSAodmFsdWUgPCBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZSwgbWFqb3I6IGlzTWFqb3IodmFsdWUpLCBzaWduaWZpY2FuZH0pO1xuICAgIGlmIChzaWduaWZpY2FuZCA+PSAxMCkge1xuICAgICAgc2lnbmlmaWNhbmQgPSBzaWduaWZpY2FuZCA8IDE1ID8gMTUgOiAyMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmlmaWNhbmQrKztcbiAgICB9XG4gICAgaWYgKHNpZ25pZmljYW5kID49IDIwKSB7XG4gICAgICBleHArKztcbiAgICAgIHNpZ25pZmljYW5kID0gMjtcbiAgICAgIHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcbiAgICB9XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKChiYXNlICsgb2Zmc2V0ICsgc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9XG4gIGNvbnN0IGxhc3RUaWNrID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1heCwgdmFsdWUpO1xuICB0aWNrcy5wdXNoKHt2YWx1ZTogbGFzdFRpY2ssIG1ham9yOiBpc01ham9yKGxhc3RUaWNrKSwgc2lnbmlmaWNhbmR9KTtcblxuICByZXR1cm4gdGlja3M7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ2xvZ2FyaXRobWljJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWMsXG4gICAgICBtYWpvcjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3JhdywgaW5kZXhdKTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSA/IE1hdGgubWF4KDAsIG1pbikgOiBudWxsO1xuICAgIHRoaXMubWF4ID0gaXNGaW5pdGUobWF4KSA/IE1hdGgubWF4KDAsIG1heCkgOiBudWxsO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybykge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gaWYgZGF0YSBoYXMgYDBgIGluIGl0IG9yIGBiZWdpbkF0WmVyb2AgaXMgdHJ1ZSwgbWluIChub24gemVybykgdmFsdWUgaXMgYXQgYm90dG9tXG4gICAgLy8gb2Ygc2NhbGUsIGFuZCBpdCBkb2VzIG5vdCBlcXVhbCBzdWdnZXN0ZWRNaW4sIGxvd2VyIHRoZSBtaW4gYm91bmQgYnkgb25lIGV4cC5cbiAgICBpZiAodGhpcy5femVybyAmJiB0aGlzLm1pbiAhPT0gdGhpcy5fc3VnZ2VzdGVkTWluICYmICFpc0Zpbml0ZSh0aGlzLl91c2VyTWluKSkge1xuICAgICAgdGhpcy5taW4gPSBtaW4gPT09IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAwKSA/IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAtMSkgOiBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cblxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCBtaW4gPSB0aGlzLm1pbjtcbiAgICBsZXQgbWF4ID0gdGhpcy5tYXg7XG5cbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuXG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBpZiAobWluIDw9IDApIHsgLy8gaW5jbHVkZXMgbnVsbFxuICAgICAgICBzZXRNaW4oMSk7XG4gICAgICAgIHNldE1heCgxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWluLCAtMSkpO1xuICAgICAgICBzZXRNYXgoY2hhbmdlRXhwb25lbnQobWF4LCArMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluIDw9IDApIHtcbiAgICAgIHNldE1pbihjaGFuZ2VFeHBvbmVudChtYXgsIC0xKSk7XG4gICAgfVxuICAgIGlmIChtYXggPD0gMCkge1xuXG4gICAgICBzZXRNYXgoY2hhbmdlRXhwb25lbnQobWluLCArMSkpO1xuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBtaW46IHRoaXMuX3VzZXJNaW4sXG4gICAgICBtYXg6IHRoaXMuX3VzZXJNYXhcbiAgICB9O1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgdGhpcyk7XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzLFxuICAgIC8vIHNpbmNlIHdlIHByb2JhYmx5IGhhdmUgZXhwYW5kZWQgdGhlIHJhbmdlIG9mIHRoZSBzY2FsZVxuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJzAnXG4gICAgICA6IGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5taW47XG5cbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGxvZzEwKHRoaXMubWF4KSAtIGxvZzEwKHN0YXJ0KTtcbiAgfVxuXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKHZhbHVlID09PSB0aGlzLm1pblxuICAgICAgPyAwXG4gICAgICA6IChsb2cxMCh2YWx1ZSkgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGFydFZhbHVlICsgZGVjaW1hbCAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7X2xvbmdlc3RUZXh0LCBhZGRSb3VuZGVkUmVjdFBhdGgsIHJlbmRlclRleHQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7SEFMRl9QSSwgVEFVLCB0b0RlZ3JlZXMsIHRvUmFkaWFucywgX25vcm1hbGl6ZUFuZ2xlLCBQSX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0LCBpc0FycmF5LCBpc0Zpbml0ZSwgY2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCBpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHRvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xuICByZXR1cm4ge1xuICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIHBvaW50IGxhYmVsc1xuICovXG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcblxuICAvLyBSaWdodCwgdGhpcyBpcyByZWFsbHkgY29uZnVzaW5nIGFuZCB0aGVyZSBpcyBhIGxvdCBvZiBtYXRocyBnb2luZyBvbiBoZXJlXG4gIC8vIFRoZSBnaXN0IG9mIHRoZSBwcm9ibGVtIGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25ubmljay82OTZjYzljNTVmNGIwYmViOGZlOVxuICAvL1xuICAvLyBSZWFjdGlvbjogaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMvdG9vbXVjaHNjaWVuY2UuZ2lmXG4gIC8vXG4gIC8vIFNvbHV0aW9uOlxuICAvL1xuICAvLyBXZSBhc3N1bWUgdGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbiBpcyBoYWxmIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgYXQgZmlyc3RcbiAgLy8gYXQgZWFjaCBpbmRleCB3ZSBjaGVjayBpZiB0aGUgdGV4dCBvdmVybGFwcy5cbiAgLy9cbiAgLy8gV2hlcmUgaXQgZG9lcywgd2Ugc3RvcmUgdGhhdCBhbmdsZSBhbmQgdGhhdCBpbmRleC5cbiAgLy9cbiAgLy8gQWZ0ZXIgZmluZGluZyB0aGUgbGFyZ2VzdCBpbmRleCBhbmQgYW5nbGUgd2UgY2FsY3VsYXRlIGhvdyBtdWNoIHdlIG5lZWQgdG8gcmVtb3ZlXG4gIC8vIGZyb20gdGhlIHNoYXBlIHJhZGl1cyB0byBtb3ZlIHRoZSBwb2ludCBpbndhcmRzIGJ5IHRoYXQgeC5cbiAgLy9cbiAgLy8gV2UgYXZlcmFnZSB0aGUgbGVmdCBhbmQgcmlnaHQgZGlzdGFuY2VzIHRvIGdldCB0aGUgbWF4aW11bSBzaGFwZSByYWRpdXMgdGhhdCBjYW4gZml0IGluIHRoZSBib3hcbiAgLy8gYWxvbmcgd2l0aCBsYWJlbHMuXG4gIC8vXG4gIC8vIE9uY2Ugd2UgaGF2ZSB0aGF0LCB3ZSBjYW4gZmluZCB0aGUgY2VudHJlIHBvaW50IGZvciB0aGUgY2hhcnQsIGJ5IHRha2luZyB0aGUgeCB0ZXh0IHByb3RydXNpb25cbiAgLy8gb24gZWFjaCBzaWRlLCByZW1vdmluZyB0aGF0IGZyb20gdGhlIHNpemUsIGhhbHZpbmcgaXQgYW5kIGFkZGluZyB0aGUgbGVmdCB4IHByb3RydXNpb24gd2lkdGguXG4gIC8vXG4gIC8vIFRoaXMgd2lsbCBtZWFuIHdlIGhhdmUgYSBzaGFwZSBmaXR0ZWQgdG8gdGhlIGNhbnZhcywgYXMgbGFyZ2UgYXMgaXQgY2FuIGJlIHdpdGggdGhlIGxhYmVsc1xuICAvLyBhbmQgcG9zaXRpb24gaXQgaW4gdGhlIG1vc3Qgc3BhY2UgZWZmaWNpZW50IG1hbm5lclxuICAvL1xuICAvLyBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My95ZWFoc2NpZW5jZS5naWZcblxuICAvLyBHZXQgbWF4aW11bSByYWRpdXMgb2YgdGhlIHBvbHlnb24uIEVpdGhlciBoYWxmIHRoZSBoZWlnaHQgKG1pbnVzIHRoZSB0ZXh0IHdpZHRoKSBvciBoYWxmIHRoZSB3aWR0aC5cbiAgLy8gVXNlIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgKyBjaGFuZ2UuIC0gTWFrZSBzdXJlIEwvUiBwcm90cnVzaW9uIGlzIGF0IGxlYXN0IDAgdG8gc3RvcCBpc3N1ZXMgd2l0aCBjZW50cmUgcG9pbnRzXG4gIGNvbnN0IG9yaWcgPSB7XG4gICAgbDogc2NhbGUubGVmdCArIHNjYWxlLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgYjogc2NhbGUuYm90dG9tIC0gc2NhbGUuX3BhZGRpbmcuYm90dG9tXG4gIH07XG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IHBvaW50TGFiZWxPcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBfbm9ybWFsaXplQW5nbGUoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSArIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpKTtcbiAgICBjb25zdCBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG4gICAgY29uc3QgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcbiAgICB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZVJhZGlhbnMsIGhMaW1pdHMsIHZMaW1pdHMpO1xuICB9XG5cbiAgc2NhbGUuc2V0Q2VudGVyUG9pbnQoXG4gICAgb3JpZy5sIC0gbGltaXRzLmwsXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXG4gICAgb3JpZy50IC0gbGltaXRzLnQsXG4gICAgbGltaXRzLmIgLSBvcmlnLmJcbiAgKTtcblxuICAvLyBOb3cgdGhhdCB0ZXh0IHNpemUgaXMgZGV0ZXJtaW5lZCwgY29tcHV0ZSB0aGUgZnVsbCBwb3NpdGlvbnNcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcbiAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgeCA9IChvcmlnLmwgLSBoTGltaXRzLnN0YXJ0KSAvIHNpbjtcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgfSBlbHNlIGlmIChoTGltaXRzLmVuZCA+IG9yaWcucikge1xuICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICB9XG4gIGlmICh2TGltaXRzLnN0YXJ0IDwgb3JpZy50KSB7XG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgIGxpbWl0cy5iID0gTWF0aC5tYXgobGltaXRzLmIsIG9yaWcuYiArIHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxJdGVtKHNjYWxlLCBpbmRleCwgaXRlbU9wdHMpIHtcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICBjb25zdCB7ZXh0cmEsIGFkZGl0aW9uYWxBbmdsZSwgcGFkZGluZywgc2l6ZX0gPSBpdGVtT3B0cztcbiAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgcGFkZGluZywgYWRkaXRpb25hbEFuZ2xlKTtcbiAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gIGNvbnN0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBpZiB0byBkcmF3IG9yIG92ZXJsYXBwZWRcbiAgICB2aXNpYmxlOiB0cnVlLFxuXG4gICAgLy8gVGV4dCBwb3NpdGlvblxuICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgIHksXG5cbiAgICAvLyBUZXh0IHJlbmRlcmluZyBkYXRhXG4gICAgdGV4dEFsaWduLFxuXG4gICAgLy8gQm91bmRpbmcgYm94XG4gICAgbGVmdCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgYm90dG9tOiB5ICsgc2l6ZS5oXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKSB7XG4gIGlmICghYXJlYSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gaXRlbTtcbiAgY29uc3QgYXBleGVzSW5BcmVhID0gX2lzUG9pbnRJbkFyZWEoe3g6IGxlZnQsIHk6IHRvcH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHt4OiBsZWZ0LCB5OiBib3R0b219LCBhcmVhKSB8fFxuICAgIF9pc1BvaW50SW5BcmVhKHt4OiByaWdodCwgeTogdG9wfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe3g6IHJpZ2h0LCB5OiBib3R0b219LCBhcmVhKTtcbiAgcmV0dXJuICFhcGV4ZXNJbkFyZWE7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3Qge2NlbnRlclBvaW50TGFiZWxzLCBkaXNwbGF5fSA9IG9wdHMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGl0ZW1PcHRzID0ge1xuICAgIGV4dHJhOiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykgLyAyLFxuICAgIGFkZGl0aW9uYWxBbmdsZTogY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwXG4gIH07XG4gIGxldCBhcmVhO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgaXRlbU9wdHMucGFkZGluZyA9IHBhZGRpbmdbaV07XG4gICAgaXRlbU9wdHMuc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG5cbiAgICBjb25zdCBpdGVtID0gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGksIGl0ZW1PcHRzKTtcbiAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgIGlmIChkaXNwbGF5ID09PSAnYXV0bycpIHtcbiAgICAgIGl0ZW0udmlzaWJsZSA9IGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKTtcbiAgICAgIGlmIChpdGVtLnZpc2libGUpIHtcbiAgICAgICAgYXJlYSA9IGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcbiAgICByZXR1cm4gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9XG5cbiAgcmV0dXJuICdyaWdodCc7XG59XG5cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuICAgIHkgLT0gKGggLyAyKTtcbiAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG4gICAgeSAtPSBoO1xuICB9XG4gIHJldHVybiB5O1xufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHMsIGl0ZW0pIHtcbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBpdGVtO1xuICBjb25zdCB7YmFja2Ryb3BDb2xvcn0gPSBvcHRzO1xuXG4gIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMob3B0cy5ib3JkZXJSYWRpdXMpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcENvbG9yO1xuXG4gICAgY29uc3QgYmFja2Ryb3BMZWZ0ID0gbGVmdCAtIHBhZGRpbmcubGVmdDtcbiAgICBjb25zdCBiYWNrZHJvcFRvcCA9IHRvcCAtIHBhZGRpbmcudG9wO1xuICAgIGNvbnN0IGJhY2tkcm9wV2lkdGggPSByaWdodCAtIGxlZnQgKyBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGJhY2tkcm9wSGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQ7XG5cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICB4OiBiYWNrZHJvcExlZnQsXG4gICAgICAgIHk6IGJhY2tkcm9wVG9wLFxuICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxuICAgICAgICBoOiBiYWNrZHJvcEhlaWdodCxcbiAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICB9KTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuXG4gIGZvciAobGV0IGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBpdGVtID0gc2NhbGUuX3BvaW50TGFiZWxJdGVtc1tpXTtcbiAgICBpZiAoIWl0ZW0udmlzaWJsZSkge1xuICAgICAgLy8gb3ZlcmxhcHBpbmdcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvcHRzQXRJbmRleCA9IHBvaW50TGFiZWxzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0c0F0SW5kZXgsIGl0ZW0pO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICBjb25zdCB7eCwgeSwgdGV4dEFsaWdufSA9IGl0ZW07XG5cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eH0gPSBzY2FsZTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgLy8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIC8vIERyYXcgc3RyYWlnaHQgbGluZXMgY29ubmVjdGluZyBlYWNoIGluZGV4XG4gICAgbGV0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQsIGJvcmRlck9wdHMpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcblxuICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBncmlkTGluZU9wdHM7XG5cbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGJvcmRlck9wdHMuZGFzaCB8fCBbXSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlck9wdHMuZGFzaE9mZnNldDtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuXG4gIHN0YXRpYyBpZCA9ICdyYWRpYWxMaW5lYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHNjYWxpbmcgdGhlIGNoYXJ0IGZyb20gdGhlIGNlbnRyZVxuICAgIGFuaW1hdGU6IHRydWUsXG4gICAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxuXG4gICAgYW5nbGVMaW5lczoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIGJvcmRlckRhc2g6IFtdLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gICAgfSxcblxuICAgIGdyaWQ6IHtcbiAgICAgIGNpcmN1bGFyOiBmYWxzZVxuICAgIH0sXG5cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLy8gbGFiZWwgc2V0dGluZ3NcbiAgICB0aWNrczoge1xuICAgICAgLy8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAgfSxcblxuICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG5cbiAgICAgIC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIGFib3ZlICYgYmVsb3cgdGhlIGxhYmVsIGluIHBpeGVsc1xuICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuXG4gICAgICAvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgc2hvdyBwb2ludCBsYWJlbHNcbiAgICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAgIC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgc2l6ZTogMTBcbiAgICAgIH0sXG5cbiAgICAgIC8vIEZ1bmN0aW9uIC0gVXNlZCB0byBjb252ZXJ0IHBvaW50IGxhYmVsc1xuICAgICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSxcblxuICAgICAgLy8gTnVtYmVyIC0gQWRkaXRpb25sIHBhZGRpbmcgYmV0d2VlbiBzY2FsZSBhbmQgcG9pbnRMYWJlbFxuICAgICAgcGFkZGluZzogNSxcblxuICAgICAgLy8gQm9vbGVhbiAtIGlmIHRydWUsIGNlbnRlciBwb2ludCBsYWJlbHMgdG8gc2xpY2VzIGluIHBvbGFyIGNoYXJ0XG4gICAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgJ2FuZ2xlTGluZXMuY29sb3InOiAnYm9yZGVyQ29sb3InLFxuICAgICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBhbmdsZUxpbmVzOiB7XG4gICAgICBfZmFsbGJhY2s6ICdncmlkJ1xuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgaCAvIDIgKyBwYWRkaW5nLnRvcCk7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuICB9XG5cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0aWNrcyk7XG5cbiAgICAvLyBQb2ludCBsYWJlbHNcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKClcbiAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNhbGxDYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2LCBpKSA9PiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgfVxuXG4gIGZpdCgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cblxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMueUNlbnRlciArPSBNYXRoLmZsb29yKCh0b3BNb3ZlbWVudCAtIGJvdHRvbU1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gIH1cblxuICBnZXRJbmRleEFuZ2xlKGluZGV4KSB7XG4gICAgY29uc3QgYW5nbGVNdWx0aXBsaWVyID0gVEFVIC8gKHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCB8fCAxKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcblxuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG5cbiAgZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvICh0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcblxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyLCBhZGRpdGlvbmFsQW5nbGUgPSAwKSB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcbiAgfVxuXG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2JhY2tncm91bmRDb2xvciwgZ3JpZDoge2NpcmN1bGFyfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkLCBib3JkZXJ9ID0gb3B0cztcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuXG4gICAgbGV0IGksIG9mZnNldCwgcG9zaXRpb247XG5cbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDAgfHwgKGluZGV4ID09PSAwICYmIHRoaXMubWluIDwgMCkpIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG5cbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50LCBvcHRzQXRJbmRleEJvcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGZvciAoaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICAgICAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gb3B0c0F0SW5kZXg7XG5cbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcblxuICAgICAgICBjdHguc2V0TGluZURhc2gob3B0c0F0SW5kZXguYm9yZGVyRGFzaCk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge31cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgIGlmICgoaW5kZXggPT09IDAgJiYgdGhpcy5taW4gPj0gMCkgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XS52YWx1ZSk7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgLW9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gcGFkZGluZy50b3AsXG4gICAgICAgICAgd2lkdGggKyBwYWRkaW5nLndpZHRoLFxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcjogb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHt9XG59XG4iLCJpbXBvcnQgYWRhcHRlcnMgZnJvbSAnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbCwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIG1lcmdlSWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgaXNOdW1iZXIsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7X2FycmF5VW5pcXVlLCBfZmlsdGVyQmV0d2VlbiwgX2xvb2t1cH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5UaW1lVW5pdCB9IFVuaXRcbiAqIEB0eXBlZGVmIHt7Y29tbW9uOiBib29sZWFuLCBzaXplOiBudW1iZXIsIHN0ZXBzPzogbnVtYmVyfX0gSW50ZXJ2YWxcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5EYXRlQWRhcHRlciB9IERhdGVBZGFwdGVyXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PFVuaXQsIEludGVydmFsPn1cbiAqL1xuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcblxuLyoqXG4gKiBAdHlwZSB7VW5pdFtdfVxuICovXG5jb25zdCBVTklUUyA9IC8qKiBAdHlwZSBVbml0W10gKi8gLyogI19fUFVSRV9fICovIChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqL1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHsqfSBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG5cbiAgLy8gT25seSBwYXJzZSBpZiBpdCdzIG5vdCBhIHRpbWVzdGFtcCBhbHJlYWR5XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBwYXJzZXIpXG4gICAgICA6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocm91bmQpIHtcbiAgICB2YWx1ZSA9IHJvdW5kID09PSAnd2VlaycgJiYgKGlzTnVtYmVyKGlzb1dlZWtkYXkpIHx8IGlzb1dlZWtkYXkgPT09IHRydWUpXG4gICAgICA/IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgJ2lzb1dlZWsnLCBpc29XZWVrZGF5KVxuICAgICAgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgfVxuXG4gIHJldHVybiArdmFsdWU7XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHJlc3VsdHMgaW4gYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGF1dG8tZ2VuZXJhdGVkIHRpY2tzXG4gKiBAcGFyYW0ge1VuaXR9IG1pblVuaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuICAgIGNvbnN0IGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcbiAgICBjb25zdCBmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgICBpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCB0byBmb3JtYXQgYSBzZXQgb2YgdGlja3Mgd2l0aFxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtVGlja3NcbiAqIEBwYXJhbSB7VW5pdH0gbWluVW5pdFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHJldHVybiB7VW5pdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgaWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VuaXR9IHVuaXRcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHRpY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICogQHBhcmFtIHtudW1iZXJbXX0gW3RpbWVzdGFtcHNdIC0gaWYgZGVmaW5lZCwgc25hcCB0byB0aGVzZSB0aW1lc3RhbXBzXG4gKi9cbmZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbbG9dID49IHRpbWUgPyB0aW1lc3RhbXBzW2xvXSA6IHRpbWVzdGFtcHNbaGldO1xuICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuICogQHBhcmFtIHtvYmplY3R9IG1hcFxuICogQHBhcmFtIHtVbml0fSBtYWpvclVuaXRcbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XG4gIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgbGV0IG1ham9yLCBpbmRleDtcblxuICBmb3IgKG1ham9yID0gZmlyc3Q7IG1ham9yIDw9IGxhc3Q7IG1ham9yID0gK2FkYXB0ZXIuYWRkKG1ham9yLCAxLCBtYWpvclVuaXQpKSB7XG4gICAgaW5kZXggPSBtYXBbbWFqb3JdO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aWNrc1tpbmRleF0ubWFqb3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7VW5pdHx1bmRlZmluZWR9IFttYWpvclVuaXRdXG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgLyoqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLG9iamVjdD59ICovXG4gIGNvbnN0IG1hcCA9IHt9O1xuICBjb25zdCBpbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgbGV0IGksIHZhbHVlO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBtYXBbdmFsdWVdID0gaTtcblxuICAgIHRpY2tzLnB1c2goe1xuICAgICAgdmFsdWUsXG4gICAgICBtYWpvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdlIHNldCB0aGUgbWFqb3IgdGlja3Mgc2VwYXJhdGVseSBmcm9tIHRoZSBhYm92ZSBsb29wIGJlY2F1c2UgY2FsbGluZyBzdGFydE9mIGZvciBldmVyeSB0aWNrXG4gIC8vIGlzIGV4cGVuc2l2ZSB3aGVuIHRoZXJlIGlzIGEgbGFyZ2UgbnVtYmVyIG9mIHRpY2tzXG4gIHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICd0aW1lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICdkYXRhJyxcblxuICAgIGFkYXB0ZXJzOiB7fSxcbiAgICB0aW1lOiB7XG4gICAgICBwYXJzZXI6IGZhbHNlLCAvLyBmYWxzZSA9PSBhIHBhdHRlcm4gc3RyaW5nIGZyb20gb3IgYSBjdXN0b20gY2FsbGJhY2sgdGhhdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gYSB0aW1lc3RhbXBcbiAgICAgIHVuaXQ6IGZhbHNlLCAvLyBmYWxzZSA9PSBhdXRvbWF0aWMgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuICAgICAgcm91bmQ6IGZhbHNlLCAvLyBub25lLCBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXG4gICAgICBpc29XZWVrZGF5OiBmYWxzZSwgLy8gb3ZlcnJpZGUgd2VlayBzdGFydCBkYXlcbiAgICAgIG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG4gICAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgICB9LFxuICAgIHRpY2tzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRpY2tzIGdlbmVyYXRpb24gaW5wdXQgdmFsdWVzOlxuICAgICAgICogLSAnYXV0byc6IGdlbmVyYXRlcyBcIm9wdGltYWxcIiB0aWNrcyBiYXNlZCBvbiBzY2FsZSBzaXplIGFuZCB0aW1lIG9wdGlvbnMuXG4gICAgICAgKiAtICdkYXRhJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gZGF0YSAoaW5jbHVkaW5nIGxhYmVscyBmcm9tIGRhdGEge3R8eHx5fSBvYmplY3RzKS5cbiAgICAgICAqIC0gJ2xhYmVscyc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIHVzZXIgZ2l2ZW4gYGRhdGEubGFiZWxzYCB2YWx1ZXMgT05MWS5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTA3XG4gICAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgICAqL1xuICAgICAgc291cmNlOiAnYXV0bycsXG5cbiAgICAgIGNhbGxiYWNrOiBmYWxzZSxcblxuICAgICAgbWFqb3I6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuXHQgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAvKiogQHR5cGUge3tkYXRhOiBudW1iZXJbXSwgbGFiZWxzOiBudW1iZXJbXSwgYWxsOiBudW1iZXJbXX19ICovXG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcblxuICAgIC8qKiBAdHlwZSB7VW5pdH0gKi9cbiAgICB0aGlzLl91bml0ID0gJ2RheSc7XG4gICAgLyoqIEB0eXBlIHtVbml0PX0gKi9cbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHt9O1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpbml0KHNjYWxlT3B0cywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdGltZSA9IHNjYWxlT3B0cy50aW1lIHx8IChzY2FsZU9wdHMudGltZSA9IHt9KTtcbiAgICAvKiogQHR5cGUge0RhdGVBZGFwdGVyfSAqL1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyID0gbmV3IGFkYXB0ZXJzLl9kYXRlKHNjYWxlT3B0cy5hZGFwdGVycy5kYXRlKTtcblxuICAgIGFkYXB0ZXIuaW5pdChvcHRzKTtcblxuICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGJlZm9yZSBpbnRyb2R1Y2luZyBhZGFwdGVyLCBgZGlzcGxheUZvcm1hdHNgIHdhc1xuICAgIC8vIHN1cHBvc2VkIHRvIGNvbnRhaW4gKmFsbCogdW5pdC9zdHJpbmcgcGFpcnMgYnV0IHRoaXMgY2FuJ3QgYmUgcmVzb2x2ZWRcbiAgICAvLyB3aGVuIGxvYWRpbmcgdGhlIHNjYWxlIChhZGFwdGVycyBhcmUgbG9hZGVkIGFmdGVyd2FyZCksIHNvIGxldCdzIHBvcHVsYXRlXG4gICAgLy8gbWlzc2luZyBmb3JtYXRzIG9uIHVwZGF0ZVxuICAgIG1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xuXG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgcGFyc2VyOiB0aW1lLnBhcnNlcixcbiAgICAgIHJvdW5kOiB0aW1lLnJvdW5kLFxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XG4gICAgfTtcblxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRzKTtcblxuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBvcHRzLm5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHsqfSByYXdcblx0ICogQHBhcmFtIHtudW1iZXI/fSBbaW5kZXhdXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIHBhcnNlKHJhdywgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmIChyYXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZSh0aGlzLCByYXcpO1xuICB9XG5cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdW5pdCA9IG9wdGlvbnMudGltZS51bml0IHx8ICdkYXknO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuXG4gICAgLyoqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGJvdW5kc1xuXHRcdCAqL1xuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1pbikpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBib3VuZHMubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1heCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHVzZXIgcHJvdmlkZWQgYG1pbmAgYW5kIGBtYXhgIGxhYmVscyAvIGRhdGEgYm91bmRzIGNhbiBiZSBpZ25vcmVkXG4gICAgaWYgKCFtaW5EZWZpbmVkIHx8ICFtYXhEZWZpbmVkKSB7XG4gICAgICAvLyBMYWJlbHMgYXJlIGFsd2F5cyBjb25zaWRlcmVkLCB3aGVuIHVzZXIgZGlkIG5vdCBmb3JjZSBib3VuZHNcbiAgICAgIF9hcHBseUJvdW5kcyh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKTtcblxuICAgICAgLy8gSWYgYGJvdW5kc2AgaXMgYCd0aWNrcydgIGFuZCBgdGlja3Muc291cmNlYCBpcyBgJ2xhYmVscydgLFxuICAgICAgLy8gZGF0YSBib3VuZHMgYXJlIGlnbm9yZWQgKGFuZCBkb24ndCBuZWVkIHRvIGJlIGRldGVybWluZWQpXG4gICAgICBpZiAob3B0aW9ucy5ib3VuZHMgIT09ICd0aWNrcycgfHwgb3B0aW9ucy50aWNrcy5zb3VyY2UgIT09ICdsYWJlbHMnKSB7XG4gICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLmdldE1pbk1heChmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1pbiA9IGlzRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpO1xuICAgIG1heCA9IGlzRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDE7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgdGltZXNlcmllcyBsb29rdXAgdGFibGUpXG4gICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xuICAgIHRoaXMubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsQm91bmRzKCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiB7bWluLCBtYXh9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGlja09wdHMuc291cmNlID09PSAnbGFiZWxzJyA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1pbiA9IHRoaXMuX3VzZXJNaW4gfHwgdGltZXN0YW1wc1swXTtcbiAgICAgIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG5cbiAgICBjb25zdCB0aWNrcyA9IF9maWx0ZXJCZXR3ZWVuKHRpbWVzdGFtcHMsIG1pbiwgbWF4KTtcblxuICAgIC8vIFBSSVZBVEVcbiAgICAvLyBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyByZWxpZXMgb24gdGhlIG51bWJlciBvZiB0aWNrcyBzbyB3ZSBkb24ndCB1c2UgaXQgd2hlblxuICAgIC8vIGF1dG9Ta2lwIGlzIGVuYWJsZWQgYmVjYXVzZSB3ZSBkb24ndCB5ZXQga25vdyB3aGF0IHRoZSBmaW5hbCBudW1iZXIgb2YgdGlja3Mgd2lsbCBiZVxuICAgIHRoaXMuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8ICh0aWNrT3B0cy5hdXRvU2tpcFxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxuICAgICAgOiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyh0aGlzLCB0aWNrcy5sZW5ndGgsIHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZFxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQodGhpcy5fdW5pdCk7XG4gICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcblxuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCB0aWNrcywgdGhpcy5fbWFqb3JVbml0KTtcbiAgfVxuXG4gIGFmdGVyQXV0b1NraXAoKSB7XG4gICAgLy8gT2Zmc2V0cyBmb3IgYmFyIGNoYXJ0cyBuZWVkIHRvIGJlIGhhbmRsZWQgd2l0aCB0aGUgYXV0byBza2lwcGVkXG4gICAgLy8gdGlja3MuIE9uY2UgdGlja3MgaGF2ZSBiZWVuIHNraXBwZWQsIHdlIHJlLWNvbXB1dGUgdGhlIG9mZnNldHMuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXRBZnRlckF1dG9za2lwKSB7XG4gICAgICB0aGlzLmluaXRPZmZzZXRzKHRoaXMudGlja3MubWFwKHRpY2sgPT4gK3RpY2sudmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBvZmZzZXRzIGZyb20gZWRnZXMgaW4gdGhlIGZvcm0gb2Yge3N0YXJ0LCBlbmR9XG5cdCAqIHdoZXJlIGVhY2ggdmFsdWUgaXMgYSByZWxhdGl2ZSB3aWR0aCB0byB0aGUgc2NhbGUgYW5kIHJhbmdlcyBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cblx0ICogT2Zmc2V0cyBhcmUgYWRkZWQgd2hlbiB0aGUgYG9mZnNldGAgb3B0aW9uIGlzIHRydWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5pdE9mZnNldHModGltZXN0YW1wcyA9IFtdKSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBsZXQgZmlyc3QsIGxhc3Q7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IDEgLSBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMV0pIC0gZmlyc3QpIC8gMjtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSAobGFzdCAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB0aW1lc3RhbXBzLmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIGxpbWl0KTtcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcblxuICAgIHRoaXMuX29mZnNldHMgPSB7c3RhcnQsIGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdlbmVyYXRlcyBhIG1heGltdW0gb2YgYGNhcGFjaXR5YCB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHJvdW5kZWQgdG8gdGhlXG5cdCAqIGBtaW5vcmAgdW5pdCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXG5cdCAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcblx0ICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSk7XG4gICAgY29uc3Qgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLnN0ZXBTaXplLCAxKTtcbiAgICBjb25zdCB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcbiAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICBjb25zdCB0aWNrcyA9IHt9O1xuICAgIGxldCBmaXJzdCA9IG1pbjtcbiAgICBsZXQgdGltZSwgY291bnQ7XG5cbiAgICAvLyBGb3IgJ3dlZWsnIHVuaXQsIGhhbmRsZSB0aGUgZmlyc3QgZGF5IG9mIHdlZWsgb3B0aW9uXG4gICAgaWYgKGhhc1dlZWtkYXkpIHtcbiAgICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcbiAgICB9XG5cbiAgICAvLyBBbGlnbiBmaXJzdCB0aWNrcyBvbiB1bml0XG4gICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cbiAgICAvLyBQcmV2ZW50IGJyb3dzZXIgZnJvbSBmcmVlemluZyBpbiBjYXNlIHVzZXIgb3B0aW9ucyByZXF1ZXN0IG1pbGxpb25zIG9mIG1pbGxpc2Vjb25kc1xuICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcik7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWUgPT09IG1heCB8fCBvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyB8fCBjb3VudCA9PT0gMSkge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aWNrcykuc29ydChzb3J0ZXIpLm1hcCh4ID0+ICt4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG5cbiAgICBpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuICAgICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZm9ybWF0XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGZvcm1hdCh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IGZtdCA9IGZvcm1hdCB8fCBmb3JtYXRzW3VuaXRdO1xuICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh2YWx1ZSwgZm10KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBGdW5jdGlvbiB0byBmb3JtYXQgYW4gaW5kaXZpZHVhbCB0aWNrIG1hcmtcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gW2Zvcm1hdF1cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gb3B0aW9ucy50aWNrcy5jYWxsYmFjaztcblxuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiBjYWxsKGZvcm1hdHRlciwgW3RpbWUsIGluZGV4LCB0aWNrc10sIHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgbWFqb3JVbml0ID0gdGhpcy5fbWFqb3JVbml0O1xuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xuICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcblxuICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgfHwgKG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG5cdCAqL1xuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24odGljay52YWx1ZSwgaSwgdGlja3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgob2Zmc2V0cy5zdGFydCArIHBvcykgKiBvZmZzZXRzLmZhY3Rvcik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiB0aGlzLm1pbiArIHBvcyAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcblx0ICogQHJldHVybiB7e3c6bnVtYmVyLCBoOm51bWJlcn19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxTaXplKGxhYmVsKSB7XG4gICAgY29uc3QgdGlja3NPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tMYWJlbFdpZHRoID0gdGhpcy5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIGNvbnN0IGFuZ2xlID0gdG9SYWRpYW5zKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aWNrc09wdHMubWF4Um90YXRpb24gOiB0aWNrc09wdHMubWluUm90YXRpb24pO1xuICAgIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHRpY2tGb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkuc2l6ZTtcblxuICAgIHJldHVybiB7XG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxuICAgICAgaDogKHRpY2tMYWJlbFdpZHRoICogc2luUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uKVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGV4YW1wbGVUaW1lXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbENhcGFjaXR5KGV4YW1wbGVUaW1lKSB7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBjb25zdCBkaXNwbGF5Rm9ybWF0cyA9IHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzO1xuXG4gICAgLy8gcGljayB0aGUgbG9uZ2VzdCBmb3JtYXQgKG1pbGxpc2Vjb25kcykgZm9yIGd1ZXNzdGltYXRpb25cbiAgICBjb25zdCBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcbiAgICBjb25zdCBleGFtcGxlTGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgW2V4YW1wbGVUaW1lXSwgdGhpcy5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0TGFiZWxTaXplKGV4YW1wbGVMYWJlbCk7XG4gICAgLy8gc3VidHJhY3QgMSAtIGlmIG9mZnNldCB0aGVuIHRoZXJlJ3Mgb25lIGxlc3MgbGFiZWwgdGhhbiB0aWNrXG4gICAgLy8gaWYgbm90IG9mZnNldCB0aGVuIG9uZSBoYWxmIGxhYmVsIHBhZGRpbmcgaXMgYWRkZWQgdG8gZWFjaCBlbmQgbGVhdmluZyByb29tIGZvciBvbmUgbGVzcyBsYWJlbFxuICAgIGNvbnN0IGNhcGFjaXR5ID0gTWF0aC5mbG9vcih0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCAvIHNpemUudyA6IHRoaXMuaGVpZ2h0IC8gc2l6ZS5oKSAtIDE7XG4gICAgcmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmRhdGEgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuXG4gICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuY29uY2F0KG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxUaW1lc3RhbXBzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5sYWJlbHMgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChwYXJzZSh0aGlzLCBsYWJlbHNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHZhbHVlc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBub3JtYWxpemUodmFsdWVzKSB7XG4gICAgLy8gSXQgc2VlbXMgdG8gYmUgc29tZXdoYXQgZmFzdGVyIHRvIGRvIHNvcnRpbmcgZmlyc3RcbiAgICByZXR1cm4gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KHNvcnRlcikpO1xuICB9XG59XG4iLCJpbXBvcnQgVGltZVNjYWxlIGZyb20gJy4vc2NhbGUudGltZS5qcyc7XG5pbXBvcnQge19sb29rdXBCeUtleX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlcyB0aGUgZ2l2ZW4gc291cmNlIGB2YWxgIHVzaW5nIHRoZSB0YWJsZS4gSWYgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcywgdmFsdWVzXG4gKiBhdCBlZGdlcyBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIGxvb2t1cCB0aW1lIGJhc2VkIG9uIHBvc2l0aW9uIGluc3RlYWQgb2YgdmljZSB2ZXJzYVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0YWJsZSwgdmFsLCByZXZlcnNlKSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2U291cmNlLCBuZXh0U291cmNlLCBwcmV2VGFyZ2V0LCBuZXh0VGFyZ2V0O1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgfVxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHtwb3M6IG5leHRTb3VyY2UsIHRpbWU6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgIH1cbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7dGltZTogbmV4dFNvdXJjZSwgcG9zOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH1cblxuICBjb25zdCBzcGFuID0gbmV4dFNvdXJjZSAtIHByZXZTb3VyY2U7XG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cblxuY2xhc3MgVGltZVNlcmllc1NjYWxlIGV4dGVuZHMgVGltZVNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZXNlcmllcyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuXHQgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAvKiogQHR5cGUge29iamVjdFtdfSAqL1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fdGFibGUgPSB0aGlzLmJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcyk7XG4gICAgdGhpcy5fbWluUG9zID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWluKTtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICBzdXBlci5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxuXHQgKiAoYHBvc2ApIG9uIHRoZSBzY2FsZSwgYnkgc2VhcmNoaW5nIGVudHJpZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgcmVxdWVzdGVkIHZhbHVlLiBgcG9zYCBpc1xuXHQgKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcblx0ICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XG5cdCAqIHN0b3JlIHByZS1jb21wdXRlZCBwaXhlbHMsIGJ1dCB0aGUgc2NhbGUgZGltZW5zaW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgYXQgdGhlIHRpbWUgd2UgbmVlZFxuXHQgKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgbGV0IGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuICAgICAgaWYgKGN1cnIgPj0gbWluICYmIGN1cnIgPD0gbWF4KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbGVzcyB0aGF0IDIgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCB0aGUgc2NhbGUgaXMgZGVmaW5lZCBieSBtaW4gYW5kIG1heFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3RpbWU6IG1pbiwgcG9zOiAwfSxcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxuICAgICAgXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBuZXh0ID0gaXRlbXNbaSArIDFdO1xuICAgICAgcHJldiA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgIGN1cnIgPSBpdGVtc1tpXTtcblxuICAgICAgLy8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcbiAgICAgIGlmIChNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuICAgICAgICB0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgICogR2VuZXJhdGVzIGFsbCB0aW1lc3RhbXBzIGRlZmluZWQgaW4gdGhlIGRhdGEuXG4gICAgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG4gICAgKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGxldCB0aW1lc3RhbXBzID0gc3VwZXIuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBpZiAoIXRpbWVzdGFtcHMuaW5jbHVkZXMobWluKSB8fCAhdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRpbWVzdGFtcHMuc3BsaWNlKDAsIDAsIG1pbik7XG4gICAgfVxuICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtYXgpIHx8IHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gobWF4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYWxsIHRpbWVzdGFtcHNcblx0ICogQHJldHVybiB7bnVtYmVyW119XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsIHx8IFtdO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICAvLyBJZiBjb21iaW5pbmcgbGFiZWxzIGFuZCBkYXRhIChkYXRhIG1pZ2h0IG5vdCBjb250YWluIGFsbCBsYWJlbHMpLFxuICAgICAgLy8gd2UgbmVlZCB0byByZWNoZWNrIHVuaXF1ZW5lc3MgYW5kIHNvcnRcbiAgICAgIHRpbWVzdGFtcHMgPSB0aGlzLm5vcm1hbGl6ZShkYXRhLmNvbmNhdChsYWJlbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lc3RhbXBzID0gZGF0YS5sZW5ndGggPyBkYXRhIDogbGFiZWw7XG4gICAgfVxuICAgIHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgPSB0aW1lc3RhbXBzO1xuXG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIHZhbHVlKSAtIHRoaXMuX21pblBvcykgLyB0aGlzLl90YWJsZVJhbmdlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCBkZWNpbWFsICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgdHJ1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZVNlcmllc1NjYWxlO1xuIiwiZXhwb3J0ICogZnJvbSAnLi9jb250cm9sbGVycy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsYXRmb3JtL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NjYWxlcy9pbmRleC5qcyc7XG5cbmltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBzY2FsZXMgZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5leHBvcnQge1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlcmFibGVzID0gW1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbl07XG4iXSwibmFtZXMiOlsiQW5pbWF0b3IiLCJfbm90aWZ5IiwiY2hhcnQiLCJhbmltcyIsImRhdGUiLCJ0eXBlIiwiY2FsbGJhY2tzIiwibGlzdGVuZXJzIiwibnVtU3RlcHMiLCJkdXJhdGlvbiIsImZvckVhY2giLCJmbiIsImluaXRpYWwiLCJjdXJyZW50U3RlcCIsIk1hdGgiLCJtaW4iLCJzdGFydCIsIl9yZWZyZXNoIiwiX3JlcXVlc3QiLCJfcnVubmluZyIsInJlcXVlc3RBbmltRnJhbWUiLCJjYWxsIiwid2luZG93IiwiX3VwZGF0ZSIsIkRhdGUiLCJub3ciLCJyZW1haW5pbmciLCJfY2hhcnRzIiwicnVubmluZyIsIml0ZW1zIiwibGVuZ3RoIiwiaSIsImRyYXciLCJpdGVtIiwiX2FjdGl2ZSIsIl90b3RhbCIsInRpY2siLCJwb3AiLCJfbGFzdERhdGUiLCJfZ2V0QW5pbXMiLCJjaGFydHMiLCJnZXQiLCJjb21wbGV0ZSIsInByb2dyZXNzIiwic2V0IiwibGlzdGVuIiwiZXZlbnQiLCJjYiIsInB1c2giLCJhZGQiLCJoYXMiLCJyZWR1Y2UiLCJhY2MiLCJjdXIiLCJtYXgiLCJfZHVyYXRpb24iLCJzdG9wIiwiY2FuY2VsIiwicmVtb3ZlIiwiZGVsZXRlIiwiY29uc3RydWN0b3IiLCJNYXAiLCJ1bmRlZmluZWQiLCJhbmltYXRvciIsInRyYW5zcGFyZW50IiwiaW50ZXJwb2xhdG9ycyIsImJvb2xlYW4iLCJmcm9tIiwidG8iLCJmYWN0b3IiLCJjb2xvciIsImMwIiwiaGVscGVyc0NvbG9yIiwiYzEiLCJ2YWxpZCIsIm1peCIsImhleFN0cmluZyIsIm51bWJlciIsIkFuaW1hdGlvbiIsImFjdGl2ZSIsInVwZGF0ZSIsImNmZyIsImN1cnJlbnRWYWx1ZSIsIl90YXJnZXQiLCJfcHJvcCIsImVsYXBzZWQiLCJfc3RhcnQiLCJyZW1haW4iLCJmbG9vciIsIl9sb29wIiwibG9vcCIsIl90byIsInJlc29sdmUiLCJfZnJvbSIsInByb3AiLCJfZWFzaW5nIiwiX2ZuIiwid2FpdCIsInByb21pc2VzIiwiX3Byb21pc2VzIiwiUHJvbWlzZSIsInJlcyIsInJlaiIsInJlc29sdmVkIiwibWV0aG9kIiwidGFyZ2V0IiwiZWZmZWN0cyIsImVhc2luZyIsImxpbmVhciIsImRlbGF5IiwiQW5pbWF0aW9ucyIsImNvbmZpZ3VyZSIsImNvbmZpZyIsImlzT2JqZWN0IiwiYW5pbWF0aW9uT3B0aW9ucyIsIk9iamVjdCIsImtleXMiLCJkZWZhdWx0cyIsImFuaW1hdGlvbiIsImFuaW1hdGVkUHJvcHMiLCJfcHJvcGVydGllcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJrZXkiLCJvcHRpb24iLCJpc0FycmF5IiwicHJvcGVydGllcyIsIl9hbmltYXRlT3B0aW9ucyIsInZhbHVlcyIsIm5ld09wdGlvbnMiLCJvcHRpb25zIiwicmVzb2x2ZVRhcmdldE9wdGlvbnMiLCJhbmltYXRpb25zIiwiX2NyZWF0ZUFuaW1hdGlvbnMiLCIkc2hhcmVkIiwiYXdhaXRBbGwiLCIkYW5pbWF0aW9ucyIsInRoZW4iLCJwcm9wcyIsImNoYXJBdCIsInZhbHVlIiwic2l6ZSIsImFzc2lnbiIsIl9jaGFydCIsImFuaW0iLCJhbGwiLCJzY2FsZUNsaXAiLCJzY2FsZSIsImFsbG93ZWRPdmVyZmxvdyIsIm9wdHMiLCJyZXZlcnNlIiwiZW5kIiwiZGVmYXVsdENsaXAiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ4IiwieSIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInRvQ2xpcCIsInQiLCJyIiwiYiIsImwiLCJkaXNhYmxlZCIsImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwiZmlsdGVyVmlzaWJsZSIsIm1ldGFzZXRzIiwiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsImlsZW4iLCJpbmRleCIsImFwcGx5U3RhY2siLCJzdGFjayIsImRzSW5kZXgiLCJzaW5nbGVNb2RlIiwibW9kZSIsImRhdGFzZXRJbmRleCIsIm90aGVyVmFsdWUiLCJmb3VuZCIsImlzRmluaXRlIiwic2lnbiIsImNvbnZlcnRPYmplY3REYXRhVG9BcnJheSIsImRhdGEiLCJtZXRhIiwiaVNjYWxlIiwidlNjYWxlIiwiaUF4aXNLZXkiLCJheGlzIiwidkF4aXNLZXkiLCJhZGF0YSIsIkFycmF5IiwiaXNTdGFja2VkIiwic3RhY2tlZCIsImdldFN0YWNrS2V5IiwiaW5kZXhTY2FsZSIsInZhbHVlU2NhbGUiLCJpZCIsImdldFVzZXJCb3VuZHMiLCJtaW5EZWZpbmVkIiwibWF4RGVmaW5lZCIsIk51bWJlciIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJnZXRPckNyZWF0ZVN0YWNrIiwic3RhY2tzIiwic3RhY2tLZXkiLCJpbmRleFZhbHVlIiwic3ViU3RhY2siLCJnZXRMYXN0SW5kZXhJblN0YWNrIiwicG9zaXRpdmUiLCJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsInVwZGF0ZVN0YWNrcyIsImNvbnRyb2xsZXIiLCJwYXJzZWQiLCJfY2FjaGVkTWV0YSIsIl9zdGFja3MiLCJpQXhpcyIsInZBeGlzIiwiaXRlbVN0YWNrcyIsIl90b3AiLCJfYm90dG9tIiwidmlzdWFsVmFsdWVzIiwiX3Zpc3VhbFZhbHVlcyIsImdldEZpcnN0U2NhbGVJZCIsInNjYWxlcyIsImZpbHRlciIsInNoaWZ0IiwiY3JlYXRlRGF0YXNldENvbnRleHQiLCJwYXJlbnQiLCJjcmVhdGVDb250ZXh0IiwiZGF0YXNldCIsImNyZWF0ZURhdGFDb250ZXh0IiwiZWxlbWVudCIsImRhdGFJbmRleCIsInJhdyIsImNsZWFyU3RhY2tzIiwiX3BhcnNlZCIsImlzRGlyZWN0VXBkYXRlTW9kZSIsImNsb25lSWZOb3RTaGFyZWQiLCJjYWNoZWQiLCJzaGFyZWQiLCJjcmVhdGVTdGFjayIsImNhblN0YWNrIiwiaGlkZGVuIiwiX3N0YWNrZWQiLCJEYXRhc2V0Q29udHJvbGxlciIsImluaXRpYWxpemUiLCJsaW5rU2NhbGVzIiwiYWRkRWxlbWVudHMiLCJmaWxsIiwiaXNQbHVnaW5FbmFibGVkIiwiY29uc29sZSIsIndhcm4iLCJ1cGRhdGVJbmRleCIsImdldERhdGFzZXQiLCJjaG9vc2VJZCIsInhpZCIsInhBeGlzSUQiLCJ2YWx1ZU9yRGVmYXVsdCIsInlpZCIsInlBeGlzSUQiLCJyaWQiLCJyQXhpc0lEIiwiaW5kZXhBeGlzIiwiaWlkIiwiaUF4aXNJRCIsInZpZCIsInZBeGlzSUQiLCJnZXRTY2FsZUZvcklkIiwiclNjYWxlIiwiZGF0YXNldHMiLCJnZXRNZXRhIiwiZ2V0RGF0YXNldE1ldGEiLCJzY2FsZUlEIiwiX2dldE90aGVyU2NhbGUiLCJyZXNldCIsIl9kZXN0cm95IiwiX2RhdGEiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwiX2RhdGFDaGVjayIsImlzRXh0ZW5zaWJsZSIsImxpc3RlbkFycmF5RXZlbnRzIiwiX3N5bmNMaXN0IiwiZGF0YXNldEVsZW1lbnRUeXBlIiwiYnVpbGRPclVwZGF0ZUVsZW1lbnRzIiwicmVzZXROZXdFbGVtZW50cyIsInN0YWNrQ2hhbmdlZCIsIm9sZFN0YWNrZWQiLCJfcmVzeW5jRWxlbWVudHMiLCJzY29wZUtleXMiLCJkYXRhc2V0U2NvcGVLZXlzIiwiX3R5cGUiLCJzY29wZXMiLCJnZXRPcHRpb25TY29wZXMiLCJjcmVhdGVSZXNvbHZlciIsImdldENvbnRleHQiLCJfcGFyc2luZyIsInBhcnNpbmciLCJfY2FjaGVkRGF0YU9wdHMiLCJwYXJzZSIsImNvdW50Iiwic29ydGVkIiwiX3NvcnRlZCIsInByZXYiLCJwYXJzZUFycmF5RGF0YSIsInBhcnNlT2JqZWN0RGF0YSIsInBhcnNlUHJpbWl0aXZlRGF0YSIsImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwibGFiZWxzIiwiZ2V0TGFiZWxzIiwic2luZ2xlU2NhbGUiLCJ4QXhpc0tleSIsInlBeGlzS2V5IiwicmVzb2x2ZU9iamVjdEtleSIsImdldFBhcnNlZCIsImdldERhdGFFbGVtZW50IiwidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwicmFuZ2UiLCJwYXJzZWRWYWx1ZSIsIk5hTiIsImdldE1pbk1heCIsIm90aGVyU2NhbGUiLCJvdGhlck1pbiIsIm90aGVyTWF4IiwiX3NraXAiLCJnZXRBbGxQYXJzZWRWYWx1ZXMiLCJnZXRNYXhPdmVyZmxvdyIsImdldExhYmVsQW5kVmFsdWUiLCJsYWJlbCIsImdldExhYmVsRm9yVmFsdWUiLCJfY2xpcCIsImNsaXAiLCJjdHgiLCJfY3R4IiwiZWxlbWVudHMiLCJhcmVhIiwiY2hhcnRBcmVhIiwiX2RyYXdTdGFydCIsIl9kcmF3Q291bnQiLCJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsImdldFN0eWxlIiwicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsInJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMiLCJjb250ZXh0IiwiJGNvbnRleHQiLCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zIiwiZGF0YUVsZW1lbnRUeXBlIiwiZWxlbWVudFR5cGUiLCJjYWNoZSIsImNhY2hlS2V5Iiwic2hhcmluZyIsImVuYWJsZU9wdGlvblNoYXJpbmciLCJkZWZpbmVkIiwiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCJwcmVmaXhlcyIsIm5hbWVzIiwicmVzb2x2ZU5hbWVkT3B0aW9ucyIsImZyZWV6ZSIsIl9yZXNvbHZlQW5pbWF0aW9ucyIsInRyYW5zaXRpb24iLCJkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzIiwiX2NhY2hlYWJsZSIsImdldFNoYXJlZE9wdGlvbnMiLCJfc2hhcmVkT3B0aW9ucyIsImluY2x1ZGVPcHRpb25zIiwic2hhcmVkT3B0aW9ucyIsIl9hbmltYXRpb25zRGlzYWJsZWQiLCJfZ2V0U2hhcmVkT3B0aW9ucyIsImZpcnN0T3B0cyIsInByZXZpb3VzbHlTaGFyZWRPcHRpb25zIiwidXBkYXRlU2hhcmVkT3B0aW9ucyIsInVwZGF0ZUVsZW1lbnQiLCJfc2V0U3R5bGUiLCJyZW1vdmVIb3ZlclN0eWxlIiwic2V0SG92ZXJTdHlsZSIsIl9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSIsIl9zZXREYXRhc2V0SG92ZXJTdHlsZSIsImFyZzEiLCJhcmcyIiwibnVtTWV0YSIsIm51bURhdGEiLCJfaW5zZXJ0RWxlbWVudHMiLCJfcmVtb3ZlRWxlbWVudHMiLCJtb3ZlIiwiYXJyIiwidXBkYXRlRWxlbWVudHMiLCJyZW1vdmVkIiwic3BsaWNlIiwiX3N5bmMiLCJhcmdzIiwiX2RhdGFDaGFuZ2VzIiwiX29uRGF0YVB1c2giLCJhcmd1bWVudHMiLCJfb25EYXRhUG9wIiwiX29uRGF0YVNoaWZ0IiwiX29uRGF0YVNwbGljZSIsIm5ld0NvdW50IiwiX29uRGF0YVVuc2hpZnQiLCJfb2JqZWN0RGF0YSIsInN1cHBvcnRzRGVjaW1hdGlvbiIsImdldEFsbFNjYWxlVmFsdWVzIiwiX2NhY2hlIiwiJGJhciIsInZpc2libGVNZXRhcyIsImNvbmNhdCIsIl9hcnJheVVuaXF1ZSIsInNvcnQiLCJhIiwiY29tcHV0ZU1pblNhbXBsZVNpemUiLCJfbGVuZ3RoIiwiY3VyciIsInVwZGF0ZU1pbkFuZFByZXYiLCJhYnMiLCJnZXRQaXhlbEZvclZhbHVlIiwidGlja3MiLCJnZXRQaXhlbEZvclRpY2siLCJjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMiLCJydWxlciIsInN0YWNrQ291bnQiLCJ0aGlja25lc3MiLCJiYXJUaGlja25lc3MiLCJyYXRpbyIsImlzTnVsbE9yVW5kZWYiLCJjYXRlZ29yeVBlcmNlbnRhZ2UiLCJiYXJQZXJjZW50YWdlIiwiY2h1bmsiLCJwaXhlbHMiLCJjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzIiwibmV4dCIsInBlcmNlbnQiLCJwYXJzZUZsb2F0QmFyIiwiZW50cnkiLCJzdGFydFZhbHVlIiwiZW5kVmFsdWUiLCJiYXJTdGFydCIsImJhckVuZCIsIl9jdXN0b20iLCJwYXJzZVZhbHVlIiwicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwiaXNGbG9hdEJhciIsImN1c3RvbSIsImJhclNpZ24iLCJhY3R1YWxCYXNlIiwiaXNIb3Jpem9udGFsIiwiYm9yZGVyUHJvcHMiLCJob3Jpem9udGFsIiwiYmFzZSIsInNldEJvcmRlclNraXBwZWQiLCJlZGdlIiwiYm9yZGVyU2tpcHBlZCIsImVuYWJsZUJvcmRlclJhZGl1cyIsInBhcnNlRWRnZSIsInN3YXAiLCJzdGFydEVuZCIsIm9yaWciLCJ2MSIsInYyIiwidiIsInNldEluZmxhdGVBbW91bnQiLCJpbmZsYXRlQW1vdW50IiwiQmFyQ29udHJvbGxlciIsIm9iaiIsImJhcnMiLCJnZXRCYXNlUGl4ZWwiLCJfZ2V0UnVsZXIiLCJ2cGl4ZWxzIiwiaGVhZCIsIl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyIsImlwaXhlbHMiLCJfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMiLCJjZW50ZXIiLCJoZWlnaHQiLCJ3aWR0aCIsIl9nZXRTdGFja3MiLCJsYXN0IiwiZ3JvdXBlZCIsImN1cnJlbnRQYXJzZWQiLCJpU2NhbGVWYWx1ZSIsInNraXBOdWxsIiwiZmluZCIsInZhbCIsImlzTmFOIiwiaW5kZXhPZiIsIl9nZXRTdGFja0NvdW50IiwiX2dldEF4aXNDb3VudCIsIl9nZXRBeGlzIiwiZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzIiwiaW5kZXhTY2FsZUlkIiwiZmlyc3RTY2FsZUF4aXNJZCIsIl9nZXRTdGFja0luZGV4IiwibmFtZSIsIl9zdGFydFBpeGVsIiwiX2VuZFBpeGVsIiwiYmFzZVZhbHVlIiwibWluQmFyTGVuZ3RoIiwiZmxvYXRpbmciLCJnZXREYXRhVmlzaWJpbGl0eSIsInN0YXJ0UGl4ZWwiLCJnZXRQaXhlbEZvckRlY2ltYWwiLCJlbmRQaXhlbCIsImdldFZhbHVlRm9yUGl4ZWwiLCJoYWxmR3JpZCIsImdldExpbmVXaWR0aEZvclZhbHVlIiwibWF4QmFyVGhpY2tuZXNzIiwiSW5maW5pdHkiLCJheGlzQ291bnQiLCJheGlzSUQiLCJheGlzTnVtYmVyIiwic3RhY2tJbmRleCIsInJlY3RzIiwibnVtYmVycyIsIm92ZXJyaWRlcyIsIl9pbmRleF8iLCJvZmZzZXQiLCJncmlkIiwiX3ZhbHVlXyIsImJlZ2luQXRaZXJvIiwiQnViYmxlQ29udHJvbGxlciIsInJhZGl1cyIsInBvaW50cyIsInBvaW50IiwiaVBpeGVsIiwidlBpeGVsIiwic2tpcCIsImdldFJhdGlvQW5kT2Zmc2V0Iiwicm90YXRpb24iLCJjaXJjdW1mZXJlbmNlIiwiY3V0b3V0IiwicmF0aW9YIiwicmF0aW9ZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJUQVUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJzdGFydFgiLCJjb3MiLCJzdGFydFkiLCJzaW4iLCJlbmRYIiwiZW5kWSIsImNhbGNNYXgiLCJhbmdsZSIsIl9hbmdsZUJldHdlZW4iLCJjYWxjTWluIiwibWF4WCIsIm1heFkiLCJIQUxGX1BJIiwibWluWCIsIlBJIiwibWluWSIsIkRvdWdobnV0Q29udHJvbGxlciIsImdldHRlciIsIl9nZXRSb3RhdGlvbiIsInRvUmFkaWFucyIsIl9nZXRDaXJjdW1mZXJlbmNlIiwiX2dldFJvdGF0aW9uRXh0ZW50cyIsImlzRGF0YXNldFZpc2libGUiLCJhcmNzIiwic3BhY2luZyIsImdldE1heEJvcmRlcldpZHRoIiwiZ2V0TWF4T2Zmc2V0IiwibWF4U2l6ZSIsInRvUGVyY2VudGFnZSIsImNoYXJ0V2VpZ2h0IiwiX2dldFJpbmdXZWlnaHQiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1heFJhZGl1cyIsIm91dGVyUmFkaXVzIiwidG9EaW1lbnNpb24iLCJpbm5lclJhZGl1cyIsInJhZGl1c0xlbmd0aCIsIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwidG90YWwiLCJjYWxjdWxhdGVUb3RhbCIsIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwiX2NpcmN1bWZlcmVuY2UiLCJhbmltYXRlUm90YXRlIiwiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsImFuaW1hdGlvbk9wdHMiLCJjZW50ZXJYIiwiY2VudGVyWSIsImFuaW1hdGVTY2FsZSIsImFyYyIsIm1ldGFEYXRhIiwiZm9ybWF0TnVtYmVyIiwibG9jYWxlIiwiYm9yZGVyQWxpZ24iLCJib3JkZXJXaWR0aCIsImhvdmVyQm9yZGVyV2lkdGgiLCJob3Zlck9mZnNldCIsInJpbmdXZWlnaHRPZmZzZXQiLCJ3ZWlnaHQiLCJkZXNjcmlwdG9ycyIsIl9zY3JpcHRhYmxlIiwiX2luZGV4YWJsZSIsInN0YXJ0c1dpdGgiLCJhc3BlY3RSYXRpbyIsInBsdWdpbnMiLCJsZWdlbmQiLCJnZW5lcmF0ZUxhYmVscyIsInBvaW50U3R5bGUiLCJ0ZXh0QWxpZ24iLCJ1c2VCb3JkZXJSYWRpdXMiLCJib3JkZXJSYWRpdXMiLCJtYXAiLCJzdHlsZSIsInRleHQiLCJmaWxsU3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJmb250Q29sb3IiLCJsaW5lRGFzaCIsImJvcmRlckRhc2giLCJsaW5lRGFzaE9mZnNldCIsImJvcmRlckRhc2hPZmZzZXQiLCJsaW5lSm9pbiIsImJvcmRlckpvaW5TdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwiYm9yZGVyQ29sb3IiLCJvbkNsaWNrIiwiZSIsImxlZ2VuZEl0ZW0iLCJ0b2dnbGVEYXRhVmlzaWJpbGl0eSIsIkxpbmVDb250cm9sbGVyIiwibGluZSIsIl9kYXRhc2V0IiwiYW5pbWF0aW9uc0Rpc2FibGVkIiwiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwiX2RhdGFzZXRJbmRleCIsIl9kZWNpbWF0ZWQiLCJzaG93TGluZSIsInNlZ21lbnQiLCJhbmltYXRlZCIsInNwYW5HYXBzIiwibWF4R2FwTGVuZ3RoIiwiaXNOdW1iZXIiLCJkaXJlY3RVcGRhdGUiLCJwb2ludHNDb3VudCIsInByZXZQYXJzZWQiLCJudWxsRGF0YSIsImJvcmRlciIsImZpcnN0UG9pbnQiLCJsYXN0UG9pbnQiLCJ1cGRhdGVDb250cm9sUG9pbnRzIiwiUG9sYXJBcmVhQ29udHJvbGxlciIsIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsImJpbmQiLCJfdXBkYXRlUmFkaXVzIiwibWluU2l6ZSIsImN1dG91dFBlcmNlbnRhZ2UiLCJnZXRWaXNpYmxlRGF0YXNldENvdW50IiwieENlbnRlciIsInlDZW50ZXIiLCJkYXRhc2V0U3RhcnRBbmdsZSIsImdldEluZGV4QW5nbGUiLCJkZWZhdWx0QW5nbGUiLCJjb3VudFZpc2libGVFbGVtZW50cyIsIl9jb21wdXRlQW5nbGUiLCJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsImFuZ2xlTGluZXMiLCJkaXNwbGF5IiwiY2lyY3VsYXIiLCJwb2ludExhYmVscyIsIlBpZUNvbnRyb2xsZXIiLCJSYWRhckNvbnRyb2xsZXIiLCJfZnVsbExvb3AiLCJwb2ludFBvc2l0aW9uIiwiZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlIiwiU2NhdHRlckNvbnRyb2xsZXIiLCJyZWdpc3RyeSIsImdldEVsZW1lbnQiLCJpbnRlcmFjdGlvbiIsImFic3RyYWN0IiwiRXJyb3IiLCJEYXRlQWRhcHRlckJhc2UiLCJvdmVycmlkZSIsIm1lbWJlcnMiLCJwcm90b3R5cGUiLCJpbml0IiwiZm9ybWF0cyIsImZvcm1hdCIsImRpZmYiLCJzdGFydE9mIiwiZW5kT2YiLCJhZGFwdGVycyIsIl9kYXRlIiwiYmluYXJ5U2VhcmNoIiwibWV0YXNldCIsImludGVyc2VjdCIsImxvb2t1cE1ldGhvZCIsIl9yZXZlcnNlUGl4ZWxzIiwiX3Jsb29rdXBCeUtleSIsIl9sb29rdXBCeUtleSIsInJlc3VsdCIsImRpc3RhbmNlVG9EZWZpbmVkTG8iLCJzbGljZSIsImxvIiwiZmluZEluZGV4IiwiZGlzdGFuY2VUb0RlZmluZWRIaSIsImhpIiwiZWwiLCJnZXRSYW5nZSIsImV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyIsInBvc2l0aW9uIiwiaGFuZGxlciIsImdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMiLCJqIiwiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwidXNlWCIsInVzZVkiLCJwdDEiLCJwdDIiLCJkZWx0YVgiLCJkZWx0YVkiLCJzcXJ0IiwicG93IiwiZ2V0SW50ZXJzZWN0SXRlbXMiLCJ1c2VGaW5hbFBvc2l0aW9uIiwiaW5jbHVkZUludmlzaWJsZSIsImlzUG9pbnRJbkFyZWEiLCJldmFsdWF0aW9uRnVuYyIsIl9pc1BvaW50SW5BcmVhIiwiaW5SYW5nZSIsImdldE5lYXJlc3RSYWRpYWxJdGVtcyIsImdldFByb3BzIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMiLCJkaXN0YW5jZU1ldHJpYyIsIm1pbkRpc3RhbmNlIiwiZ2V0Q2VudGVyUG9pbnQiLCJwb2ludEluQXJlYSIsImRpc3RhbmNlIiwiZ2V0TmVhcmVzdEl0ZW1zIiwiZ2V0QXhpc0l0ZW1zIiwicmFuZ2VNZXRob2QiLCJpbnRlcnNlY3RzSXRlbSIsIkludGVyYWN0aW9uIiwibW9kZXMiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwibmVhcmVzdCIsIlNUQVRJQ19QT1NJVElPTlMiLCJmaWx0ZXJCeVBvc2l0aW9uIiwiYXJyYXkiLCJwb3MiLCJmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMiLCJib3giLCJzb3J0QnlXZWlnaHQiLCJ2MCIsIndyYXBCb3hlcyIsImJveGVzIiwibGF5b3V0Qm94ZXMiLCJzdGFja1dlaWdodCIsImJ1aWxkU3RhY2tzIiwibGF5b3V0cyIsIndyYXAiLCJpbmNsdWRlcyIsIl9zdGFjayIsInBsYWNlZCIsInNldExheW91dERpbXMiLCJwYXJhbXMiLCJ2Qm94TWF4V2lkdGgiLCJoQm94TWF4SGVpZ2h0IiwibGF5b3V0IiwiZnVsbFNpemUiLCJhdmFpbGFibGVXaWR0aCIsImF2YWlsYWJsZUhlaWdodCIsImJ1aWxkTGF5b3V0Qm94ZXMiLCJjZW50ZXJIb3Jpem9udGFsIiwiY2VudGVyVmVydGljYWwiLCJsZWZ0QW5kVG9wIiwicmlnaHRBbmRCb3R0b20iLCJ2ZXJ0aWNhbCIsImdldENvbWJpbmVkTWF4IiwibWF4UGFkZGluZyIsInVwZGF0ZU1heFBhZGRpbmciLCJib3hQYWRkaW5nIiwidXBkYXRlRGltcyIsImdldFBhZGRpbmciLCJuZXdXaWR0aCIsIm91dGVyV2lkdGgiLCJuZXdIZWlnaHQiLCJvdXRlckhlaWdodCIsIndpZHRoQ2hhbmdlZCIsInciLCJoZWlnaHRDaGFuZ2VkIiwiaCIsInNhbWUiLCJvdGhlciIsImhhbmRsZU1heFBhZGRpbmciLCJ1cGRhdGVQb3MiLCJjaGFuZ2UiLCJnZXRNYXJnaW5zIiwibWFyZ2luRm9yUG9zaXRpb25zIiwicG9zaXRpb25zIiwibWFyZ2luIiwiZml0Qm94ZXMiLCJyZWZpdEJveGVzIiwicmVmaXQiLCJjaGFuZ2VkIiwic2V0Qm94RGltcyIsInBsYWNlQm94ZXMiLCJ1c2VyUGFkZGluZyIsInBhZGRpbmciLCJhZGRCb3giLCJfbGF5ZXJzIiwieiIsInJlbW92ZUJveCIsImxheW91dEl0ZW0iLCJtaW5QYWRkaW5nIiwidG9QYWRkaW5nIiwidmVydGljYWxCb3hlcyIsImhvcml6b250YWxCb3hlcyIsImVhY2giLCJiZWZvcmVMYXlvdXQiLCJ2aXNpYmxlVmVydGljYWxCb3hDb3VudCIsIkJhc2VQbGF0Zm9ybSIsImFjcXVpcmVDb250ZXh0IiwiY2FudmFzIiwicmVsZWFzZUNvbnRleHQiLCJhZGRFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImdldE1heGltdW1TaXplIiwiaXNBdHRhY2hlZCIsInVwZGF0ZUNvbmZpZyIsIkJhc2ljUGxhdGZvcm0iLCJFWFBBTkRPX0tFWSIsIkVWRU5UX1RZUEVTIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJvdXQiLCJpc051bGxPckVtcHR5IiwiaW5pdENhbnZhcyIsInJlbmRlckhlaWdodCIsImdldEF0dHJpYnV0ZSIsInJlbmRlcldpZHRoIiwiYm94U2l6aW5nIiwiZGlzcGxheVdpZHRoIiwicmVhZFVzZWRTaXplIiwiZGlzcGxheUhlaWdodCIsImV2ZW50TGlzdGVuZXJPcHRpb25zIiwic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsInBhc3NpdmUiLCJhZGRMaXN0ZW5lciIsIm5vZGUiLCJyZW1vdmVMaXN0ZW5lciIsImZyb21OYXRpdmVFdmVudCIsIm5hdGl2ZSIsIm5vZGVMaXN0Q29udGFpbnMiLCJub2RlTGlzdCIsImNvbnRhaW5zIiwiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwidHJpZ2dlciIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJvYnNlcnZlIiwiZG9jdW1lbnQiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiY3JlYXRlRGV0YWNoT2JzZXJ2ZXIiLCJkcnBMaXN0ZW5pbmdDaGFydHMiLCJvbGREZXZpY2VQaXhlbFJhdGlvIiwib25XaW5kb3dSZXNpemUiLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwicmVzaXplIiwiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCJsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsInVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCJjcmVhdGVSZXNpemVPYnNlcnZlciIsImNvbnRhaW5lciIsIl9nZXRQYXJlbnROb2RlIiwidGhyb3R0bGVkIiwiY2xpZW50V2lkdGgiLCJSZXNpemVPYnNlcnZlciIsImNvbnRlbnRSZWN0IiwicmVsZWFzZU9ic2VydmVyIiwiZGlzY29ubmVjdCIsImNyZWF0ZVByb3h5QW5kTGlzdGVuIiwicHJveHkiLCJEb21QbGF0Zm9ybSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInByb3hpZXMiLCIkcHJveGllcyIsImhhbmRsZXJzIiwiYXR0YWNoIiwiZGV0YWNoIiwiaXNDb25uZWN0ZWQiLCJfZGV0ZWN0UGxhdGZvcm0iLCJfaXNEb21TdXBwb3J0ZWQiLCJPZmZzY3JlZW5DYW52YXMiLCJFbGVtZW50IiwidG9vbHRpcFBvc2l0aW9uIiwiaGFzVmFsdWUiLCJmaW5hbCIsInJldCIsImRlZmF1bHRSb3V0ZXMiLCJhdXRvU2tpcCIsInRpY2tPcHRzIiwiZGV0ZXJtaW5lZE1heFRpY2tzIiwiZGV0ZXJtaW5lTWF4VGlja3MiLCJ0aWNrc0xpbWl0IiwibWF4VGlja3NMaW1pdCIsIm1ham9ySW5kaWNlcyIsIm1ham9yIiwiZW5hYmxlZCIsImdldE1ham9ySW5kaWNlcyIsIm51bU1ham9ySW5kaWNlcyIsImZpcnN0IiwibmV3VGlja3MiLCJza2lwTWFqb3JzIiwiY2FsY3VsYXRlU3BhY2luZyIsImF2Z01ham9yU3BhY2luZyIsInJvdW5kIiwidGlja0xlbmd0aCIsIl90aWNrU2l6ZSIsIm1heFNjYWxlIiwibWF4Q2hhcnQiLCJfbWF4TGVuZ3RoIiwiZXZlbk1ham9yU3BhY2luZyIsImdldEV2ZW5TcGFjaW5nIiwiZmFjdG9ycyIsIl9mYWN0b3JpemUiLCJjZWlsIiwibWFqb3JTdGFydCIsIm1ham9yRW5kIiwibGVuIiwicmV2ZXJzZUFsaWduIiwiYWxpZ24iLCJvZmZzZXRGcm9tRWRnZSIsImdldFRpY2tzTGltaXQiLCJ0aWNrc0xlbmd0aCIsInNhbXBsZSIsIm51bUl0ZW1zIiwiaW5jcmVtZW50IiwiZ2V0UGl4ZWxGb3JHcmlkTGluZSIsIm9mZnNldEdyaWRMaW5lcyIsInZhbGlkSW5kZXgiLCJlcHNpbG9uIiwibGluZVZhbHVlIiwiZ2FyYmFnZUNvbGxlY3QiLCJjYWNoZXMiLCJnYyIsImdjTGVuIiwiZ2V0VGlja01hcmtMZW5ndGgiLCJkcmF3VGlja3MiLCJnZXRUaXRsZUhlaWdodCIsImZhbGxiYWNrIiwiZm9udCIsInRvRm9udCIsImxpbmVzIiwibGluZUhlaWdodCIsImNyZWF0ZVNjYWxlQ29udGV4dCIsImNyZWF0ZVRpY2tDb250ZXh0IiwidGl0bGVBbGlnbiIsIl90b0xlZnRSaWdodENlbnRlciIsInRpdGxlQXJncyIsInRpdGxlWCIsInRpdGxlWSIsIl9hbGlnblN0YXJ0RW5kIiwicG9zaXRpb25BeGlzSUQiLCJTY2FsZSIsInNldENvbnRleHQiLCJfdXNlck1pbiIsIl91c2VyTWF4IiwiX3N1Z2dlc3RlZE1pbiIsInN1Z2dlc3RlZE1pbiIsIl9zdWdnZXN0ZWRNYXgiLCJzdWdnZXN0ZWRNYXgiLCJmaW5pdGVPckRlZmF1bHQiLCJtZXRhcyIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdCb3R0b20iLCJnZXRUaWNrcyIsInhMYWJlbHMiLCJ5TGFiZWxzIiwiZ2V0TGFiZWxJdGVtcyIsIl9sYWJlbEl0ZW1zIiwiX2NvbXB1dGVMYWJlbEl0ZW1zIiwiX2RhdGFMaW1pdHNDYWNoZWQiLCJiZWZvcmVVcGRhdGUiLCJtYXJnaW5zIiwiZ3JhY2UiLCJzYW1wbGVTaXplIiwiX21hcmdpbnMiLCJfbGFiZWxTaXplcyIsIl9ncmlkTGluZUl0ZW1zIiwiYmVmb3JlU2V0RGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJhZnRlclNldERpbWVuc2lvbnMiLCJiZWZvcmVEYXRhTGltaXRzIiwiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsImFmdGVyRGF0YUxpbWl0cyIsIl9yYW5nZSIsIl9hZGRHcmFjZSIsImJlZm9yZUJ1aWxkVGlja3MiLCJidWlsZFRpY2tzIiwiYWZ0ZXJCdWlsZFRpY2tzIiwic2FtcGxpbmdFbmFibGVkIiwiX2NvbnZlcnRUaWNrc1RvTGFiZWxzIiwiYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsImNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCJhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCJzb3VyY2UiLCJhZnRlckF1dG9Ta2lwIiwiYmVmb3JlRml0IiwiZml0IiwiYWZ0ZXJGaXQiLCJhZnRlclVwZGF0ZSIsInJldmVyc2VQaXhlbHMiLCJfYWxpZ25Ub1BpeGVscyIsImFsaWduVG9QaXhlbHMiLCJfY2FsbEhvb2tzIiwibm90aWZ5UGx1Z2lucyIsImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImdlbmVyYXRlVGlja0xhYmVscyIsImNhbGxiYWNrIiwiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJudW1UaWNrcyIsIm1pblJvdGF0aW9uIiwibWF4Um90YXRpb24iLCJsYWJlbFJvdGF0aW9uIiwidGlja1dpZHRoIiwibWF4TGFiZWxEaWFnb25hbCIsIl9pc1Zpc2libGUiLCJsYWJlbFNpemVzIiwiX2dldExhYmVsU2l6ZXMiLCJtYXhMYWJlbFdpZHRoIiwid2lkZXN0IiwibWF4TGFiZWxIZWlnaHQiLCJoaWdoZXN0IiwiX2xpbWl0VmFsdWUiLCJ0aXRsZSIsInRvRGVncmVlcyIsImFzaW4iLCJ0aXRsZU9wdHMiLCJncmlkT3B0cyIsInRpdGxlSGVpZ2h0IiwidGlja1BhZGRpbmciLCJhbmdsZVJhZGlhbnMiLCJsYWJlbEhlaWdodCIsIm1pcnJvciIsImxhYmVsV2lkdGgiLCJfY2FsY3VsYXRlUGFkZGluZyIsIl9oYW5kbGVNYXJnaW5zIiwiaXNSb3RhdGVkIiwibGFiZWxzQmVsb3dUaWNrcyIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsImlzRnVsbFNpemUiLCJfY29tcHV0ZUxhYmVsU2l6ZXMiLCJfbG9uZ2VzdFRleHRDYWNoZSIsIndpZHRocyIsImhlaWdodHMiLCJ3aWRlc3RMYWJlbFNpemUiLCJoaWdoZXN0TGFiZWxTaXplIiwiamxlbiIsInRpY2tGb250IiwiZm9udFN0cmluZyIsIm5lc3RlZExhYmVsIiwiX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMiLCJzdHJpbmciLCJfbWVhc3VyZVRleHQiLCJ2YWx1ZUF0IiwiaWR4IiwicGl4ZWwiLCJkZWNpbWFsIiwiX2ludDE2UmFuZ2UiLCJfYWxpZ25QaXhlbCIsImdldERlY2ltYWxGb3JQaXhlbCIsImdldEJhc2VWYWx1ZSIsIm9wdGlvblRpY2tzIiwicm90IiwiYXV0b1NraXBQYWRkaW5nIiwiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwidGwiLCJib3JkZXJPcHRzIiwiYXhpc1dpZHRoIiwiYXhpc0hhbGZXaWR0aCIsImFsaWduQm9yZGVyVmFsdWUiLCJib3JkZXJWYWx1ZSIsImFsaWduZWRMaW5lVmFsdWUiLCJ0eDEiLCJ0eTEiLCJ0eDIiLCJ0eTIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxpbWl0Iiwic3RlcCIsIm9wdHNBdEluZGV4Iiwib3B0c0F0SW5kZXhCb3JkZXIiLCJsaW5lQ29sb3IiLCJkYXNoIiwiZGFzaE9mZnNldCIsInRpY2tDb2xvciIsInRpY2tCb3JkZXJEYXNoIiwidGlja0JvcmRlckRhc2hPZmZzZXQiLCJfdGlja3NMZW5ndGgiLCJfYm9yZGVyVmFsdWUiLCJjcm9zc0FsaWduIiwidGlja0FuZFBhZGRpbmciLCJoVGlja0FuZFBhZGRpbmciLCJsaW5lQ291bnQiLCJ0ZXh0T2Zmc2V0IiwidGV4dEJhc2VsaW5lIiwiX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQiLCJfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCIsImxhYmVsT2Zmc2V0IiwiaGFsZkNvdW50Iiwic3Ryb2tlQ29sb3IiLCJ0ZXh0U3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsInRleHRTdHJva2VXaWR0aCIsInRpY2tUZXh0QWxpZ24iLCJzaG93TGFiZWxCYWNrZHJvcCIsImJhY2tkcm9wIiwibGFiZWxQYWRkaW5nIiwiYmFja2Ryb3BQYWRkaW5nIiwiYmFja2Ryb3BDb2xvciIsInRyYW5zbGF0aW9uIiwiX2NvbXB1dGVMYWJlbEFyZWEiLCJkcmF3QmFja2dyb3VuZCIsInNhdmUiLCJmaWxsUmVjdCIsInJlc3RvcmUiLCJkcmF3R3JpZCIsImRyYXdMaW5lIiwicDEiLCJwMiIsInNldExpbmVEYXNoIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd0JvcmRlciIsImxhc3RMaW5lV2lkdGgiLCJkcmF3TGFiZWxzIiwiY2xpcEFyZWEiLCJyZW5kZXJUZXh0T3B0aW9ucyIsInJlbmRlclRleHQiLCJ1bmNsaXBBcmVhIiwiZHJhd1RpdGxlIiwidHoiLCJneiIsImJ6IiwiX21heERpZ2l0cyIsImZvbnRTaXplIiwiVHlwZWRSZWdpc3RyeSIsImlzRm9yVHlwZSIsImlzUHJvdG90eXBlT2YiLCJyZWdpc3RlciIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJwYXJlbnRTY29wZSIsImlzSUNoYXJ0Q29tcG9uZW50Iiwic2NvcGUiLCJyZWdpc3RlckRlZmF1bHRzIiwidW5yZWdpc3RlciIsImNyZWF0ZSIsIml0ZW1EZWZhdWx0cyIsIm1lcmdlIiwicm91dGVEZWZhdWx0cyIsImRlc2NyaWJlIiwicm91dGVzIiwicHJvcGVydHkiLCJwcm9wZXJ0eVBhcnRzIiwic3BsaXQiLCJzb3VyY2VOYW1lIiwic291cmNlU2NvcGUiLCJqb2luIiwicGFydHMiLCJ0YXJnZXROYW1lIiwidGFyZ2V0U2NvcGUiLCJyb3V0ZSIsIlJlZ2lzdHJ5IiwiX2VhY2giLCJhZGRDb250cm9sbGVycyIsImNvbnRyb2xsZXJzIiwiYWRkUGx1Z2lucyIsImFkZFNjYWxlcyIsImdldENvbnRyb2xsZXIiLCJfZ2V0IiwiZ2V0UGx1Z2luIiwiZ2V0U2NhbGUiLCJyZW1vdmVDb250cm9sbGVycyIsInJlbW92ZUVsZW1lbnRzIiwicmVtb3ZlUGx1Z2lucyIsInJlbW92ZVNjYWxlcyIsInR5cGVkUmVnaXN0cnkiLCJhcmciLCJyZWciLCJfZ2V0UmVnaXN0cnlGb3JUeXBlIiwiX2V4ZWMiLCJpdGVtUmVnIiwiY29tcG9uZW50IiwiY2FtZWxNZXRob2QiLCJfY2FwaXRhbGl6ZSIsIl90eXBlZFJlZ2lzdHJpZXMiLCJQbHVnaW5TZXJ2aWNlIiwibm90aWZ5IiwiaG9vayIsIl9pbml0IiwiX2NyZWF0ZURlc2NyaXB0b3JzIiwiX2Rlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsInBsdWdpbiIsImNhbGxDYWxsYmFjayIsImNhbmNlbGFibGUiLCJpbnZhbGlkYXRlIiwiX29sZENhY2hlIiwiX25vdGlmeVN0YXRlQ2hhbmdlcyIsImFsbFBsdWdpbnMiLCJjcmVhdGVEZXNjcmlwdG9ycyIsInByZXZpb3VzRGVzY3JpcHRvcnMiLCJzb21lIiwibG9jYWxJZHMiLCJsb2NhbCIsImdldE9wdHMiLCJwbHVnaW5PcHRzIiwicGx1Z2luU2NvcGVLZXlzIiwic2NyaXB0YWJsZSIsImluZGV4YWJsZSIsImFsbEtleXMiLCJnZXRJbmRleEF4aXMiLCJkYXRhc2V0RGVmYXVsdHMiLCJkYXRhc2V0T3B0aW9ucyIsImdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQiLCJnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzIiwiaWRNYXRjaGVzQXhpcyIsImF4aXNGcm9tUG9zaXRpb24iLCJkZXRlcm1pbmVBeGlzIiwic2NhbGVPcHRpb25zIiwidG9Mb3dlckNhc2UiLCJnZXRBeGlzRnJvbURhdGFzZXQiLCJyZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMiLCJib3VuZERzIiwiZCIsIm1lcmdlU2NhbGVDb25maWciLCJjaGFydERlZmF1bHRzIiwiY29uZmlnU2NhbGVzIiwiY2hhcnRJbmRleEF4aXMiLCJzY2FsZUNvbmYiLCJlcnJvciIsIl9wcm94eSIsImRlZmF1bHRJZCIsImRlZmF1bHRTY2FsZU9wdGlvbnMiLCJtZXJnZUlmIiwiZGVmYXVsdElEIiwiaW5pdE9wdGlvbnMiLCJpbml0RGF0YSIsImluaXRDb25maWciLCJrZXlDYWNoZSIsImtleXNDYWNoZWQiLCJTZXQiLCJjYWNoZWRLZXlzIiwiZ2VuZXJhdGUiLCJhZGRJZkZvdW5kIiwiQ29uZmlnIiwicGxhdGZvcm0iLCJfY29uZmlnIiwiY2xlYXJDYWNoZSIsIl9zY29wZUNhY2hlIiwiY2xlYXIiLCJfcmVzb2x2ZXJDYWNoZSIsImRhdGFzZXRUeXBlIiwiYWRkaXRpb25hbE9wdGlvblNjb3BlcyIsIl9jYWNoZWRTY29wZXMiLCJtYWluU2NvcGUiLCJyZXNldENhY2hlIiwia2V5TGlzdHMiLCJjaGFydE9wdGlvblNjb3BlcyIsInJlc29sdmVyIiwic3ViUHJlZml4ZXMiLCJnZXRSZXNvbHZlciIsIm5lZWRDb250ZXh0IiwiaXNGdW5jdGlvbiIsInN1YlJlc29sdmVyIiwiX2F0dGFjaENvbnRleHQiLCJkZXNjcmlwdG9yRGVmYXVsdHMiLCJyZXNvbHZlckNhY2hlIiwiX2NyZWF0ZVJlc29sdmVyIiwicCIsImhhc0Z1bmN0aW9uIiwiaXNTY3JpcHRhYmxlIiwiaXNJbmRleGFibGUiLCJLTk9XTl9QT1NJVElPTlMiLCJwb3NpdGlvbklzSG9yaXpvbnRhbCIsImNvbXBhcmUyTGV2ZWwiLCJsMSIsImwyIiwib25BbmltYXRpb25zQ29tcGxldGUiLCJvbkNvbXBsZXRlIiwib25BbmltYXRpb25Qcm9ncmVzcyIsIm9uUHJvZ3Jlc3MiLCJnZXRDYW52YXMiLCJnZXRFbGVtZW50QnlJZCIsImluc3RhbmNlcyIsImdldENoYXJ0IiwiYyIsIm1vdmVOdW1lcmljS2V5cyIsImludEtleSIsImRldGVybWluZUxhc3RFdmVudCIsImxhc3RFdmVudCIsImluQ2hhcnRBcmVhIiwiaXNDbGljayIsIkNoYXJ0IiwiaW52YWxpZGF0ZVBsdWdpbnMiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwiX2FzcGVjdFJhdGlvIiwiX29wdGlvbnMiLCJfaW5pdGlhbGl6ZSIsInJlc3BvbnNpdmUiLCJyZXRpbmFTY2FsZSIsImJpbmRFdmVudHMiLCJjbGVhckNhbnZhcyIsIl9yZXNpemUiLCJfcmVzaXplQmVmb3JlRHJhdyIsIm5ld1NpemUiLCJuZXdSYXRpbyIsIm9uUmVzaXplIiwiYXR0YWNoZWQiLCJfZG9SZXNpemUiLCJyZW5kZXIiLCJlbnN1cmVTY2FsZXNIYXZlSURzIiwic2NhbGVzT3B0aW9ucyIsImF4aXNPcHRpb25zIiwiYnVpbGRPclVwZGF0ZVNjYWxlcyIsInNjYWxlT3B0cyIsInVwZGF0ZWQiLCJpc1JhZGlhbCIsImRwb3NpdGlvbiIsImR0eXBlIiwic2NhbGVUeXBlIiwic2NhbGVDbGFzcyIsImhhc1VwZGF0ZWQiLCJfdXBkYXRlTWV0YXNldHMiLCJfbWV0YXNldHMiLCJfZGVzdHJveURhdGFzZXRNZXRhIiwiX3NvcnRlZE1ldGFzZXRzIiwiX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzIiwiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwibmV3Q29udHJvbGxlcnMiLCJvcmRlciIsInZpc2libGUiLCJDb250cm9sbGVyQ2xhc3MiLCJfcmVzZXRFbGVtZW50cyIsImFuaW1zRGlzYWJsZWQiLCJfdXBkYXRlU2NhbGVzIiwiX2NoZWNrRXZlbnRCaW5kaW5ncyIsIl91cGRhdGVIaWRkZW5JbmRpY2VzIiwiX3BsdWdpbnMiLCJfbWluUGFkZGluZyIsImF1dG9QYWRkaW5nIiwiX3VwZGF0ZUxheW91dCIsIl91cGRhdGVEYXRhc2V0cyIsIl9sYXN0RXZlbnQiLCJfZXZlbnRIYW5kbGVyIiwiX3VwZGF0ZUhvdmVyU3R5bGVzIiwiZXhpc3RpbmdFdmVudHMiLCJfbGlzdGVuZXJzIiwibmV3RXZlbnRzIiwiZXZlbnRzIiwic2V0c0VxdWFsIiwiX3Jlc3BvbnNpdmVMaXN0ZW5lcnMiLCJ1bmJpbmRFdmVudHMiLCJfaGlkZGVuSW5kaWNlcyIsImNoYW5nZXMiLCJfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzIiwiZGF0YXNldENvdW50IiwibWFrZVNldCIsImNoYW5nZVNldCIsIm5vQXJlYSIsIl9pZHgiLCJfdXBkYXRlRGF0YXNldCIsImxheWVycyIsIl9kcmF3RGF0YXNldHMiLCJfZHJhd0RhdGFzZXQiLCJnZXREYXRhc2V0Q2xpcEFyZWEiLCJnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlIiwic2V0RGF0YXNldFZpc2liaWxpdHkiLCJfdXBkYXRlVmlzaWJpbGl0eSIsImhpZGUiLCJzaG93IiwiX3N0b3AiLCJkZXN0cm95IiwidG9CYXNlNjRJbWFnZSIsInRvRGF0YVVSTCIsImJpbmRVc2VyRXZlbnRzIiwiYmluZFJlc3BvbnNpdmVFdmVudHMiLCJfYWRkIiwiX3JlbW92ZSIsImRldGFjaGVkIiwidXBkYXRlSG92ZXJTdHlsZSIsInByZWZpeCIsImdldEFjdGl2ZUVsZW1lbnRzIiwic2V0QWN0aXZlRWxlbWVudHMiLCJhY3RpdmVFbGVtZW50cyIsImxhc3RBY3RpdmUiLCJfZWxlbWVudHNFcXVhbCIsInBsdWdpbklkIiwicmVwbGF5IiwiaG92ZXJPcHRpb25zIiwiaG92ZXIiLCJkZWFjdGl2YXRlZCIsImFjdGl2YXRlZCIsImV2ZW50RmlsdGVyIiwiX2hhbmRsZUV2ZW50IiwiX2dldEFjdGl2ZUVsZW1lbnRzIiwiX2lzQ2xpY2tFdmVudCIsIm9uSG92ZXIiLCJ1c2VyQ29uZmlnIiwiaW5pdGlhbENhbnZhcyIsImV4aXN0aW5nQ2hhcnQiLCJ1aWQiLCJkZWJvdW5jZSIsInJlc2l6ZURlbGF5IiwidmVyc2lvbiIsImNsaXBTZWxmIiwib3V0ZXJBbmdsZUNsaXAiLCJfbm9ybWFsaXplQW5nbGUiLCJpbm5lckFuZ2xlQ2xpcCIsImNsaXBXaWR0aCIsImNsb3NlUGF0aCIsInJlY3QiLCJjbGlwQXJjIiwicGl4ZWxNYXJnaW4iLCJhbmdsZU1hcmdpbiIsInRvUmFkaXVzQ29ybmVycyIsIl9yZWFkVmFsdWVUb1Byb3BzIiwicGFyc2VCb3JkZXJSYWRpdXMiLCJhbmdsZURlbHRhIiwibyIsImhhbGZUaGlja25lc3MiLCJpbm5lckxpbWl0IiwiY29tcHV0ZU91dGVyTGltaXQiLCJvdXRlckFyY0xpbWl0Iiwib3V0ZXJTdGFydCIsIm91dGVyRW5kIiwiaW5uZXJTdGFydCIsImlubmVyRW5kIiwiclRoZXRhVG9YWSIsInRoZXRhIiwicGF0aEFyYyIsImlubmVyUiIsInNwYWNpbmdPZmZzZXQiLCJhbHBoYSIsIm5vU3BhY2luZ0lubmVyUmFkaXVzIiwibm9TcGFjaW5nT3V0ZXJSYWRpdXMiLCJhdk5vZ1NwYWNpbmdSYWRpdXMiLCJhZGp1c3RlZEFuZ2xlIiwiYmV0YSIsImFuZ2xlT2Zmc2V0Iiwib3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzIiwib3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyIsIm91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwib3V0ZXJFbmRBZGp1c3RlZEFuZ2xlIiwiaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzIiwiaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyIsImlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwiaW5uZXJFbmRBZGp1c3RlZEFuZ2xlIiwib3V0ZXJNaWRBZGp1c3RlZEFuZ2xlIiwicENlbnRlciIsInA0IiwiaW5uZXJNaWRBZGp1c3RlZEFuZ2xlIiwicDgiLCJvdXRlclN0YXJ0WCIsIm91dGVyU3RhcnRZIiwib3V0ZXJFbmRYIiwib3V0ZXJFbmRZIiwiZHJhd0FyYyIsImZ1bGxDaXJjbGVzIiwiaW5uZXIiLCJzZWxmSm9pbiIsIkFyY0VsZW1lbnQiLCJjaGFydFgiLCJjaGFydFkiLCJyQWRqdXN0Iiwibm9uWmVyb0JldHdlZW4iLCJiZXR3ZWVuQW5nbGVzIiwid2l0aGluUmFkaXVzIiwiX2lzQmV0d2VlbiIsImhhbGZBbmdsZSIsImhhbGZSYWRpdXMiLCJ0cmFuc2xhdGUiLCJmaXgiLCJyYWRpdXNPZmZzZXQiLCJzZXRTdHlsZSIsImxpbmVDYXAiLCJib3JkZXJDYXBTdHlsZSIsInByZXZpb3VzIiwiZ2V0TGluZU1ldGhvZCIsInN0ZXBwZWQiLCJfc3RlcHBlZExpbmVUbyIsInRlbnNpb24iLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwiX2JlemllckN1cnZlVG8iLCJwYXRoVmFycyIsInBhcmFtc1N0YXJ0IiwicGFyYW1zRW5kIiwic2VnbWVudFN0YXJ0Iiwic2VnbWVudEVuZCIsIm91dHNpZGUiLCJwYXRoU2VnbWVudCIsImxpbmVNZXRob2QiLCJmYXN0UGF0aFNlZ21lbnQiLCJhdmdYIiwiY291bnRYIiwicHJldlgiLCJsYXN0WSIsInBvaW50SW5kZXgiLCJkcmF3WCIsInRydW5jWCIsIl9nZXRTZWdtZW50TWV0aG9kIiwidXNlRmFzdFBhdGgiLCJfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZCIsIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsIl9iZXppZXJJbnRlcnBvbGF0aW9uIiwiX3BvaW50SW5MaW5lIiwic3Ryb2tlUGF0aFdpdGhDYWNoZSIsInBhdGgiLCJfcGF0aCIsIlBhdGgyRCIsInN0cm9rZVBhdGhEaXJlY3QiLCJzZWdtZW50cyIsInNlZ21lbnRNZXRob2QiLCJ1c2VQYXRoMkQiLCJMaW5lRWxlbWVudCIsIl9wb2ludHNVcGRhdGVkIiwiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCJfcG9pbnRzIiwiX3NlZ21lbnRzIiwiX2NvbXB1dGVTZWdtZW50cyIsImludGVycG9sYXRlIiwiX2JvdW5kU2VnbWVudHMiLCJfaW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWQiLCJjYXBCZXppZXJQb2ludHMiLCJoaXRSYWRpdXMiLCJQb2ludEVsZW1lbnQiLCJtb3VzZVgiLCJtb3VzZVkiLCJpblhSYW5nZSIsImluWVJhbmdlIiwiaG92ZXJSYWRpdXMiLCJkcmF3UG9pbnQiLCJnZXRCYXJCb3VuZHMiLCJiYXIiLCJoYWxmIiwic2tpcE9yTGltaXQiLCJwYXJzZUJvcmRlcldpZHRoIiwibWF4VyIsIm1heEgiLCJ0b1RSQkwiLCJ0b1RSQkxDb3JuZXJzIiwibWF4UiIsImVuYWJsZUJvcmRlciIsInRvcExlZnQiLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsImJvdW5kaW5nUmVjdHMiLCJib3VuZHMiLCJvdXRlciIsInNraXBYIiwic2tpcFkiLCJza2lwQm90aCIsImhhc1JhZGl1cyIsImFkZE5vcm1hbFJlY3RQYXRoIiwiaW5mbGF0ZVJlY3QiLCJhbW91bnQiLCJyZWZSZWN0IiwiQmFyRWxlbWVudCIsImFkZFJlY3RQYXRoIiwiYWRkUm91bmRlZFJlY3RQYXRoIiwiQk9SREVSX0NPTE9SUyIsIkJBQ0tHUk9VTkRfQ09MT1JTIiwicmVwbGFjZSIsImdldEJvcmRlckNvbG9yIiwiZ2V0QmFja2dyb3VuZENvbG9yIiwiY29sb3JpemVEZWZhdWx0RGF0YXNldCIsImNvbG9yaXplRG91Z2hudXREYXRhc2V0IiwiY29sb3JpemVQb2xhckFyZWFEYXRhc2V0IiwiZ2V0Q29sb3JpemVyIiwiY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyIsImsiLCJjb250YWluc0NvbG9yc0RlZmluaXRpb24iLCJjb250YWluc0RlZmF1bHRDb2xvcnNEZWZlbml0aW9ucyIsInBsdWdpbl9jb2xvcnMiLCJmb3JjZU92ZXJyaWRlIiwiX2FyZ3MiLCJjaGFydE9wdGlvbnMiLCJjb250YWluc0NvbG9yRGVmZW5pdGlvbiIsImNvbG9yaXplciIsImx0dGJEZWNpbWF0aW9uIiwic2FtcGxlcyIsImRlY2ltYXRlZCIsImJ1Y2tldFdpZHRoIiwic2FtcGxlZEluZGV4IiwiZW5kSW5kZXgiLCJtYXhBcmVhUG9pbnQiLCJtYXhBcmVhIiwibmV4dEEiLCJhdmdZIiwiYXZnUmFuZ2VTdGFydCIsImF2Z1JhbmdlRW5kIiwiYXZnUmFuZ2VMZW5ndGgiLCJyYW5nZU9mZnMiLCJyYW5nZVRvIiwicG9pbnRBeCIsInBvaW50QXkiLCJtaW5NYXhEZWNpbWF0aW9uIiwibWluSW5kZXgiLCJtYXhJbmRleCIsInN0YXJ0SW5kZXgiLCJ4TWluIiwieE1heCIsImR4IiwibGFzdEluZGV4IiwiaW50ZXJtZWRpYXRlSW5kZXgxIiwiaW50ZXJtZWRpYXRlSW5kZXgyIiwiY2xlYW5EZWNpbWF0ZWREYXRhc2V0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjbGVhbkRlY2ltYXRlZERhdGEiLCJnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZCIsInBvaW50Q291bnQiLCJwbHVnaW5fZGVjaW1hdGlvbiIsImFsZ29yaXRobSIsImJlZm9yZUVsZW1lbnRzVXBkYXRlIiwieEF4aXMiLCJ0aHJlc2hvbGQiLCJ0cG9pbnRzIiwiX2ZpbmRTZWdtZW50RW5kIiwiX2dldEJvdW5kcyIsInRhcmdldFNlZ21lbnRzIiwidGd0Iiwic3ViQm91bmRzIiwiZmlsbFNvdXJjZXMiLCJfYm91bmRTZWdtZW50IiwiZmlsbFNvdXJjZSIsIl9nZXRFZGdlIiwiX3BvaW50c0Zyb21TZWdtZW50cyIsImJvdW5kYXJ5IiwibGluZVBvaW50cyIsIl9jcmVhdGVCb3VuZGFyeUxpbmUiLCJfc2hvdWxkQXBwbHlGaWxsIiwiX3Jlc29sdmVUYXJnZXQiLCJzb3VyY2VzIiwicHJvcGFnYXRlIiwidmlzaXRlZCIsIl9kZWNvZGVGaWxsIiwicGFyc2VGaWxsT3B0aW9uIiwicGFyc2VGbG9hdCIsImRlY29kZVRhcmdldEluZGV4IiwiZmlyc3RDaCIsIl9nZXRUYXJnZXRQaXhlbCIsIl9nZXRUYXJnZXRWYWx1ZSIsImZpbGxPcHRpb24iLCJfYnVpbGRTdGFja0xpbmUiLCJzb3VyY2VQb2ludHMiLCJsaW5lc0JlbG93IiwiZ2V0TGluZXNCZWxvdyIsImFkZFBvaW50c0JlbG93IiwiYmVsb3ciLCJ1bnNoaWZ0Iiwic291cmNlUG9pbnQiLCJwb3N0cG9uZWQiLCJmaW5kUG9pbnQiLCJwb2ludFZhbHVlIiwiZmlyc3RWYWx1ZSIsImxhc3RWYWx1ZSIsInNpbXBsZUFyYyIsIl9nZXRUYXJnZXQiLCJnZXRMaW5lQnlJbmRleCIsImNvbXB1dGVCb3VuZGFyeSIsImNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5IiwiY29tcHV0ZUxpbmVhckJvdW5kYXJ5IiwiX2RyYXdmaWxsIiwibGluZU9wdHMiLCJhYm92ZSIsImRvRmlsbCIsImZpbGxDb2xvciIsImNsaXBWZXJ0aWNhbCIsImNsaXBIb3Jpem9udGFsIiwiY2xpcFkiLCJsaW5lTG9vcCIsImNsaXBYIiwic3JjIiwibm90U2hhcGUiLCJjbGlwQm91bmRzIiwiaW50ZXJwb2xhdGVkTGluZVRvIiwidGFyZ2V0TG9vcCIsImludGVycG9sYXRlZFBvaW50IiwiYWZ0ZXJEYXRhc2V0c1VwZGF0ZSIsIiRmaWxsZXIiLCJiZWZvcmVEcmF3IiwiZHJhd1RpbWUiLCJiZWZvcmVEYXRhc2V0c0RyYXciLCJiZWZvcmVEYXRhc2V0RHJhdyIsImdldEJveFNpemUiLCJsYWJlbE9wdHMiLCJib3hIZWlnaHQiLCJib3hXaWR0aCIsInVzZVBvaW50U3R5bGUiLCJwb2ludFN0eWxlV2lkdGgiLCJpdGVtSGVpZ2h0IiwiaXRlbXNFcXVhbCIsIkxlZ2VuZCIsImJ1aWxkTGFiZWxzIiwibGVnZW5kSXRlbXMiLCJsYWJlbEZvbnQiLCJfY29tcHV0ZVRpdGxlSGVpZ2h0IiwiX2ZpdFJvd3MiLCJfZml0Q29scyIsImhpdGJveGVzIiwibGVnZW5kSGl0Qm94ZXMiLCJsaW5lV2lkdGhzIiwidG90YWxIZWlnaHQiLCJyb3ciLCJpdGVtV2lkdGgiLCJtZWFzdXJlVGV4dCIsIl9pdGVtSGVpZ2h0IiwiY29sdW1uU2l6ZXMiLCJoZWlnaHRMaW1pdCIsInRvdGFsV2lkdGgiLCJjdXJyZW50Q29sV2lkdGgiLCJjdXJyZW50Q29sSGVpZ2h0IiwiY29sIiwiY2FsY3VsYXRlSXRlbVNpemUiLCJhZGp1c3RIaXRCb3hlcyIsInJ0bCIsInJ0bEhlbHBlciIsImdldFJ0bEFkYXB0ZXIiLCJoaXRib3giLCJsZWZ0Rm9yTHRyIiwiX2RyYXciLCJkZWZhdWx0Q29sb3IiLCJoYWxmRm9udFNpemUiLCJjdXJzb3IiLCJkcmF3TGVnZW5kQm94IiwiZHJhd09wdGlvbnMiLCJTUVJUMiIsInhQbHVzIiwiZHJhd1BvaW50TGVnZW5kIiwieUJveFRvcCIsInhCb3hMZWZ0IiwiZmlsbFRleHQiLCJzdHJpa2V0aHJvdWdoIiwib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwidGV4dERpcmVjdGlvbiIsInRleHRXaWR0aCIsInNldFdpZHRoIiwicmVhbFgiLCJfdGV4dFgiLCJmb250TGluZUhlaWdodCIsImNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQiLCJyZXN0b3JlVGV4dERpcmVjdGlvbiIsInRpdGxlRm9udCIsInRpdGxlUGFkZGluZyIsInRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplIiwiX2dldExlZ2VuZEl0ZW1BdCIsImhpdEJveCIsImxoIiwiaGFuZGxlRXZlbnQiLCJpc0xpc3RlbmVkIiwiaG92ZXJlZEl0ZW0iLCJfaG92ZXJlZEl0ZW0iLCJzYW1lSXRlbSIsIm9uTGVhdmUiLCJfYWRkZWQiLCJkb3VnaG51dE1vZGUiLCJjYWxjdWxhdGVJdGVtV2lkdGgiLCJjYWxjdWxhdGVJdGVtSGVpZ2h0IiwibGVnZW5kSXRlbVRleHQiLCJwbHVnaW5fbGVnZW5kIiwiX2VsZW1lbnQiLCJhZnRlckV2ZW50IiwiY2kiLCJUaXRsZSIsIl9wYWRkaW5nIiwidGV4dFNpemUiLCJfZHJhd0FyZ3MiLCJmb250T3B0cyIsImNyZWF0ZVRpdGxlIiwidGl0bGVCbG9jayIsInBsdWdpbl90aXRsZSIsIldlYWtNYXAiLCJwbHVnaW5fc3VidGl0bGUiLCJwb3NpdGlvbmVycyIsImF2ZXJhZ2UiLCJ4U2V0IiwieEF2ZXJhZ2UiLCJldmVudFBvc2l0aW9uIiwibmVhcmVzdEVsZW1lbnQiLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJ0cCIsInB1c2hPckNvbmNhdCIsInRvUHVzaCIsImFwcGx5Iiwic3BsaXROZXdsaW5lcyIsInN0ciIsIlN0cmluZyIsImNyZWF0ZVRvb2x0aXBJdGVtIiwiZm9ybWF0dGVkVmFsdWUiLCJnZXRUb29sdGlwU2l6ZSIsInRvb2x0aXAiLCJib2R5IiwiZm9vdGVyIiwiYm9keUZvbnQiLCJmb290ZXJGb250IiwidGl0bGVMaW5lQ291bnQiLCJmb290ZXJMaW5lQ291bnQiLCJib2R5TGluZUl0ZW1Db3VudCIsImNvbWJpbmVkQm9keUxlbmd0aCIsImJvZHlJdGVtIiwiYmVmb3JlIiwiYWZ0ZXIiLCJiZWZvcmVCb2R5IiwiYWZ0ZXJCb2R5IiwidGl0bGVTcGFjaW5nIiwidGl0bGVNYXJnaW5Cb3R0b20iLCJib2R5TGluZUhlaWdodCIsImRpc3BsYXlDb2xvcnMiLCJib2R5U3BhY2luZyIsImZvb3Rlck1hcmdpblRvcCIsImZvb3RlclNwYWNpbmciLCJ3aWR0aFBhZGRpbmciLCJtYXhMaW5lV2lkdGgiLCJkZXRlcm1pbmVZQWxpZ24iLCJkb2VzTm90Rml0V2l0aEFsaWduIiwieEFsaWduIiwiY2FyZXQiLCJjYXJldFNpemUiLCJjYXJldFBhZGRpbmciLCJkZXRlcm1pbmVYQWxpZ24iLCJ5QWxpZ24iLCJjaGFydFdpZHRoIiwiZGV0ZXJtaW5lQWxpZ25tZW50IiwiYWxpZ25YIiwiYWxpZ25ZIiwicGFkZGluZ0FuZFNpemUiLCJnZXRCYWNrZ3JvdW5kUG9pbnQiLCJhbGlnbm1lbnQiLCJjb3JuZXJSYWRpdXMiLCJnZXRBbGlnbmVkWCIsImdldEJlZm9yZUFmdGVyQm9keUxpbmVzIiwiY3JlYXRlVG9vbHRpcENvbnRleHQiLCJ0b29sdGlwSXRlbXMiLCJvdmVycmlkZUNhbGxiYWNrcyIsImRlZmF1bHRDYWxsYmFja3MiLCJiZWZvcmVUaXRsZSIsIm5vb3AiLCJsYWJlbENvdW50IiwiYWZ0ZXJUaXRsZSIsImJlZm9yZUxhYmVsIiwidG9vbHRpcEl0ZW0iLCJsYWJlbENvbG9yIiwibGFiZWxUZXh0Q29sb3IiLCJib2R5Q29sb3IiLCJsYWJlbFBvaW50U3R5bGUiLCJhZnRlckxhYmVsIiwiYmVmb3JlRm9vdGVyIiwiYWZ0ZXJGb290ZXIiLCJpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayIsIlRvb2x0aXAiLCJfY2FjaGVkQW5pbWF0aW9ucyIsIl90b29sdGlwSXRlbXMiLCJnZXRUaXRsZSIsImdldEJlZm9yZUJvZHkiLCJnZXRCb2R5IiwiYm9keUl0ZW1zIiwic2NvcGVkIiwiZ2V0QWZ0ZXJCb2R5IiwiZ2V0Rm9vdGVyIiwiX2NyZWF0ZUl0ZW1zIiwibGFiZWxDb2xvcnMiLCJsYWJlbFBvaW50U3R5bGVzIiwibGFiZWxUZXh0Q29sb3JzIiwiaXRlbVNvcnQiLCJkYXRhUG9pbnRzIiwib3BhY2l0eSIsIl9ldmVudFBvc2l0aW9uIiwiX3NpemUiLCJwb3NpdGlvbkFuZFNpemUiLCJiYWNrZ3JvdW5kUG9pbnQiLCJjYXJldFgiLCJjYXJldFkiLCJleHRlcm5hbCIsImRyYXdDYXJldCIsInRvb2x0aXBQb2ludCIsImNhcmV0UG9zaXRpb24iLCJnZXRDYXJldFBvc2l0aW9uIiwieDMiLCJ5MyIsInB0WCIsInB0WSIsInB0IiwidGl0bGVDb2xvciIsIl9kcmF3Q29sb3JCb3giLCJjb2xvclgiLCJydGxDb2xvclgiLCJ5T2ZmU2V0IiwiY29sb3JZIiwibXVsdGlLZXlCYWNrZ3JvdW5kIiwib3V0ZXJYIiwiaW5uZXJYIiwic3Ryb2tlUmVjdCIsImRyYXdCb2R5IiwiYm9keUFsaWduIiwieExpbmVQYWRkaW5nIiwiZmlsbExpbmVPZlRleHQiLCJib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiIsInRleHRDb2xvciIsImRyYXdGb290ZXIiLCJmb290ZXJBbGlnbiIsImZvb3RlckNvbG9yIiwidG9vbHRpcFNpemUiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiX3VwZGF0ZUFuaW1hdGlvblRhcmdldCIsImFuaW1YIiwiYW5pbVkiLCJfd2lsbFJlbmRlciIsImhhc1Rvb2x0aXBDb250ZW50IiwiZ2xvYmFsQWxwaGEiLCJwb3NpdGlvbkNoYW5nZWQiLCJfcG9zaXRpb25DaGFuZ2VkIiwiX2lnbm9yZVJlcGxheUV2ZW50cyIsInBsdWdpbl90b29sdGlwIiwiYWZ0ZXJJbml0IiwiYWZ0ZXJEcmF3IiwiX2ZhbGxiYWNrIiwiYWRkSWZTdHJpbmciLCJhZGRlZExhYmVscyIsImZpbmRPckFkZExhYmVsIiwibGFzdEluZGV4T2YiLCJfZ2V0TGFiZWxGb3JWYWx1ZSIsIkNhdGVnb3J5U2NhbGUiLCJhZGRlZCIsIl9hZGRlZExhYmVscyIsIl92YWx1ZVJhbmdlIiwiX3N0YXJ0VmFsdWUiLCJnZW5lcmF0ZVRpY2tzIiwiZ2VuZXJhdGlvbk9wdGlvbnMiLCJkYXRhUmFuZ2UiLCJNSU5fU1BBQ0lORyIsInByZWNpc2lvbiIsIm1heFRpY2tzIiwibWF4RGlnaXRzIiwiaW5jbHVkZUJvdW5kcyIsInVuaXQiLCJtYXhTcGFjZXMiLCJybWluIiwicm1heCIsImNvdW50RGVmaW5lZCIsIm1pblNwYWNpbmciLCJuaWNlTnVtIiwibmljZU1pbiIsIm5pY2VNYXgiLCJudW1TcGFjZXMiLCJhbG1vc3RXaG9sZSIsImFsbW9zdEVxdWFscyIsImRlY2ltYWxQbGFjZXMiLCJfZGVjaW1hbFBsYWNlcyIsInJlbGF0aXZlTGFiZWxTaXplIiwidGlja1ZhbHVlIiwicmFkIiwiTGluZWFyU2NhbGVCYXNlIiwiaGFuZGxlVGlja1JhbmdlT3B0aW9ucyIsInNldE1pbiIsInNldE1heCIsIm1pblNpZ24iLCJtYXhTaWduIiwiZ2V0VGlja0xpbWl0Iiwic3RlcFNpemUiLCJjb21wdXRlVGlja0xpbWl0IiwibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCJfc2V0TWluQW5kTWF4QnlLZXkiLCJfZW5kVmFsdWUiLCJMaW5lYXJTY2FsZSIsIlRpY2tzIiwiZm9ybWF0dGVycyIsIm51bWVyaWMiLCJsb2cxMEZsb29yIiwibG9nMTAiLCJjaGFuZ2VFeHBvbmVudCIsIm0iLCJpc01ham9yIiwidGlja1ZhbCIsInN0ZXBzIiwicmFuZ2VFeHAiLCJyYW5nZVN0ZXAiLCJzdGFydEV4cCIsIm1pbkV4cCIsImV4cCIsInNpZ25pZmljYW5kIiwibGFzdFRpY2siLCJMb2dhcml0aG1pY1NjYWxlIiwiX3plcm8iLCJsb2dhcml0aG1pYyIsImdldFRpY2tCYWNrZHJvcEhlaWdodCIsIm1lYXN1cmVMYWJlbFNpemUiLCJfbG9uZ2VzdFRleHQiLCJkZXRlcm1pbmVMaW1pdHMiLCJmaXRXaXRoUG9pbnRMYWJlbHMiLCJsaW1pdHMiLCJ2YWx1ZUNvdW50IiwiX3BvaW50TGFiZWxzIiwicG9pbnRMYWJlbE9wdHMiLCJhZGRpdGlvbmFsQW5nbGUiLCJjZW50ZXJQb2ludExhYmVscyIsImdldFBvaW50TGFiZWxDb250ZXh0IiwiZ2V0UG9pbnRQb3NpdGlvbiIsImRyYXdpbmdBcmVhIiwicGxGb250IiwiaExpbWl0cyIsInZMaW1pdHMiLCJ1cGRhdGVMaW1pdHMiLCJzZXRDZW50ZXJQb2ludCIsIl9wb2ludExhYmVsSXRlbXMiLCJidWlsZFBvaW50TGFiZWxJdGVtcyIsImNyZWF0ZVBvaW50TGFiZWxJdGVtIiwiaXRlbU9wdHMiLCJvdXRlckRpc3RhbmNlIiwiZXh0cmEiLCJwb2ludExhYmVsUG9zaXRpb24iLCJ5Rm9yQW5nbGUiLCJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsImxlZnRGb3JUZXh0QWxpZ24iLCJpc05vdE92ZXJsYXBwZWQiLCJhcGV4ZXNJbkFyZWEiLCJkcmF3UG9pbnRMYWJlbEJveCIsImJhY2tkcm9wTGVmdCIsImJhY2tkcm9wVG9wIiwiYmFja2Ryb3BXaWR0aCIsImJhY2tkcm9wSGVpZ2h0IiwiZHJhd1BvaW50TGFiZWxzIiwicGF0aFJhZGl1c0xpbmUiLCJkcmF3UmFkaXVzTGluZSIsImdyaWRMaW5lT3B0cyIsImNyZWF0ZVBvaW50TGFiZWxDb250ZXh0IiwiUmFkaWFsTGluZWFyU2NhbGUiLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsImFuZ2xlTXVsdGlwbGllciIsInNjYWxpbmdGYWN0b3IiLCJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsInNjYWxlZERpc3RhbmNlIiwicG9pbnRMYWJlbCIsImRpc3RhbmNlRnJvbUNlbnRlciIsImdldEJhc2VQb3NpdGlvbiIsImdldFBvaW50TGFiZWxQb3NpdGlvbiIsInJvdGF0ZSIsImFuaW1hdGUiLCJJTlRFUlZBTFMiLCJtaWxsaXNlY29uZCIsImNvbW1vbiIsInNlY29uZCIsIm1pbnV0ZSIsImhvdXIiLCJkYXkiLCJ3ZWVrIiwibW9udGgiLCJxdWFydGVyIiwieWVhciIsIlVOSVRTIiwic29ydGVyIiwiaW5wdXQiLCJhZGFwdGVyIiwiX2FkYXB0ZXIiLCJwYXJzZXIiLCJpc29XZWVrZGF5IiwiX3BhcnNlT3B0cyIsImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCJtaW5Vbml0IiwiY2FwYWNpdHkiLCJpbnRlcnZhbCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsImRldGVybWluZU1ham9yVW5pdCIsImFkZFRpY2siLCJ0aW1lIiwidGltZXN0YW1wcyIsIl9sb29rdXAiLCJ0aW1lc3RhbXAiLCJzZXRNYWpvclRpY2tzIiwibWFqb3JVbml0IiwidGlja3NGcm9tVGltZXN0YW1wcyIsIlRpbWVTY2FsZSIsImRpc3BsYXlGb3JtYXRzIiwiX25vcm1hbGl6ZWQiLCJub3JtYWxpemVkIiwiX2FwcGx5Qm91bmRzIiwiX2dldExhYmVsQm91bmRzIiwiZ2V0TGFiZWxUaW1lc3RhbXBzIiwidGltZU9wdHMiLCJfZ2VuZXJhdGUiLCJfZmlsdGVyQmV0d2VlbiIsIl91bml0IiwiX2dldExhYmVsQ2FwYWNpdHkiLCJfbWFqb3JVbml0IiwiaW5pdE9mZnNldHMiLCJvZmZzZXRBZnRlckF1dG9za2lwIiwiZ2V0RGVjaW1hbEZvclZhbHVlIiwiX29mZnNldHMiLCJtaW5vciIsIndlZWtkYXkiLCJoYXNXZWVrZGF5IiwiZ2V0RGF0YVRpbWVzdGFtcHMiLCJ0b29sdGlwRm9ybWF0IiwiZGF0ZXRpbWUiLCJmbXQiLCJfdGlja0Zvcm1hdEZ1bmN0aW9uIiwiZm9ybWF0dGVyIiwibWlub3JGb3JtYXQiLCJtYWpvckZvcm1hdCIsIm9mZnNldHMiLCJfZ2V0TGFiZWxTaXplIiwidGlja3NPcHRzIiwidGlja0xhYmVsV2lkdGgiLCJjb3NSb3RhdGlvbiIsInNpblJvdGF0aW9uIiwidGlja0ZvbnRTaXplIiwiZXhhbXBsZVRpbWUiLCJleGFtcGxlTGFiZWwiLCJub3JtYWxpemUiLCJ0YWJsZSIsInByZXZTb3VyY2UiLCJuZXh0U291cmNlIiwicHJldlRhcmdldCIsIm5leHRUYXJnZXQiLCJzcGFuIiwiVGltZVNlcmllc1NjYWxlIiwiX2dldFRpbWVzdGFtcHNGb3JUYWJsZSIsIl90YWJsZSIsImJ1aWxkTG9va3VwVGFibGUiLCJfbWluUG9zIiwiX3RhYmxlUmFuZ2UiLCJyZWdpc3RlcmFibGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/chart.js/dist/chart.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/chart.js/dist/chunks/helpers.dataset.js":
/*!**************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.dataset.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: function() { return /* binding */ unclipArea; },\n/* harmony export */   A: function() { return /* binding */ _rlookupByKey; },\n/* harmony export */   B: function() { return /* binding */ _lookupByKey; },\n/* harmony export */   C: function() { return /* binding */ _isPointInArea; },\n/* harmony export */   D: function() { return /* binding */ getAngleFromPoint; },\n/* harmony export */   E: function() { return /* binding */ toPadding; },\n/* harmony export */   F: function() { return /* binding */ each; },\n/* harmony export */   G: function() { return /* binding */ getMaximumSize; },\n/* harmony export */   H: function() { return /* binding */ HALF_PI; },\n/* harmony export */   I: function() { return /* binding */ _getParentNode; },\n/* harmony export */   J: function() { return /* binding */ readUsedSize; },\n/* harmony export */   K: function() { return /* binding */ supportsEventListenerOptions; },\n/* harmony export */   L: function() { return /* binding */ throttled; },\n/* harmony export */   M: function() { return /* binding */ _isDomSupported; },\n/* harmony export */   N: function() { return /* binding */ _factorize; },\n/* harmony export */   O: function() { return /* binding */ finiteOrDefault; },\n/* harmony export */   P: function() { return /* binding */ PI; },\n/* harmony export */   Q: function() { return /* binding */ callback; },\n/* harmony export */   R: function() { return /* binding */ _addGrace; },\n/* harmony export */   S: function() { return /* binding */ _limitValue; },\n/* harmony export */   T: function() { return /* binding */ TAU; },\n/* harmony export */   U: function() { return /* binding */ toDegrees; },\n/* harmony export */   V: function() { return /* binding */ _measureText; },\n/* harmony export */   W: function() { return /* binding */ _int16Range; },\n/* harmony export */   X: function() { return /* binding */ _alignPixel; },\n/* harmony export */   Y: function() { return /* binding */ clipArea; },\n/* harmony export */   Z: function() { return /* binding */ renderText; },\n/* harmony export */   _: function() { return /* binding */ _arrayUnique; },\n/* harmony export */   a: function() { return /* binding */ resolve; },\n/* harmony export */   a$: function() { return /* binding */ getStyle; },\n/* harmony export */   a0: function() { return /* binding */ toFont; },\n/* harmony export */   a1: function() { return /* binding */ _toLeftRightCenter; },\n/* harmony export */   a2: function() { return /* binding */ _alignStartEnd; },\n/* harmony export */   a3: function() { return /* binding */ overrides; },\n/* harmony export */   a4: function() { return /* binding */ merge; },\n/* harmony export */   a5: function() { return /* binding */ _capitalize; },\n/* harmony export */   a6: function() { return /* binding */ descriptors; },\n/* harmony export */   a7: function() { return /* binding */ isFunction; },\n/* harmony export */   a8: function() { return /* binding */ _attachContext; },\n/* harmony export */   a9: function() { return /* binding */ _createResolver; },\n/* harmony export */   aA: function() { return /* binding */ getRtlAdapter; },\n/* harmony export */   aB: function() { return /* binding */ overrideTextDirection; },\n/* harmony export */   aC: function() { return /* binding */ _textX; },\n/* harmony export */   aD: function() { return /* binding */ restoreTextDirection; },\n/* harmony export */   aE: function() { return /* binding */ drawPointLegend; },\n/* harmony export */   aF: function() { return /* binding */ distanceBetweenPoints; },\n/* harmony export */   aG: function() { return /* binding */ noop; },\n/* harmony export */   aH: function() { return /* binding */ _setMinAndMaxByKey; },\n/* harmony export */   aI: function() { return /* binding */ niceNum; },\n/* harmony export */   aJ: function() { return /* binding */ almostWhole; },\n/* harmony export */   aK: function() { return /* binding */ almostEquals; },\n/* harmony export */   aL: function() { return /* binding */ _decimalPlaces; },\n/* harmony export */   aM: function() { return /* binding */ Ticks; },\n/* harmony export */   aN: function() { return /* binding */ log10; },\n/* harmony export */   aO: function() { return /* binding */ _longestText; },\n/* harmony export */   aP: function() { return /* binding */ _filterBetween; },\n/* harmony export */   aQ: function() { return /* binding */ _lookup; },\n/* harmony export */   aR: function() { return /* binding */ isPatternOrGradient; },\n/* harmony export */   aS: function() { return /* binding */ getHoverColor; },\n/* harmony export */   aT: function() { return /* binding */ clone; },\n/* harmony export */   aU: function() { return /* binding */ _merger; },\n/* harmony export */   aV: function() { return /* binding */ _mergerIf; },\n/* harmony export */   aW: function() { return /* binding */ _deprecated; },\n/* harmony export */   aX: function() { return /* binding */ _splitKey; },\n/* harmony export */   aY: function() { return /* binding */ toFontString; },\n/* harmony export */   aZ: function() { return /* binding */ splineCurve; },\n/* harmony export */   a_: function() { return /* binding */ splineCurveMonotone; },\n/* harmony export */   aa: function() { return /* binding */ _descriptors; },\n/* harmony export */   ab: function() { return /* binding */ mergeIf; },\n/* harmony export */   ac: function() { return /* binding */ uid; },\n/* harmony export */   ad: function() { return /* binding */ debounce; },\n/* harmony export */   ae: function() { return /* binding */ retinaScale; },\n/* harmony export */   af: function() { return /* binding */ clearCanvas; },\n/* harmony export */   ag: function() { return /* binding */ setsEqual; },\n/* harmony export */   ah: function() { return /* binding */ getDatasetClipArea; },\n/* harmony export */   ai: function() { return /* binding */ _elementsEqual; },\n/* harmony export */   aj: function() { return /* binding */ _isClickEvent; },\n/* harmony export */   ak: function() { return /* binding */ _isBetween; },\n/* harmony export */   al: function() { return /* binding */ _normalizeAngle; },\n/* harmony export */   am: function() { return /* binding */ _readValueToProps; },\n/* harmony export */   an: function() { return /* binding */ _updateBezierControlPoints; },\n/* harmony export */   ao: function() { return /* binding */ _computeSegments; },\n/* harmony export */   ap: function() { return /* binding */ _boundSegments; },\n/* harmony export */   aq: function() { return /* binding */ _steppedInterpolation; },\n/* harmony export */   ar: function() { return /* binding */ _bezierInterpolation; },\n/* harmony export */   as: function() { return /* binding */ _pointInLine; },\n/* harmony export */   at: function() { return /* binding */ _steppedLineTo; },\n/* harmony export */   au: function() { return /* binding */ _bezierCurveTo; },\n/* harmony export */   av: function() { return /* binding */ drawPoint; },\n/* harmony export */   aw: function() { return /* binding */ addRoundedRectPath; },\n/* harmony export */   ax: function() { return /* binding */ toTRBL; },\n/* harmony export */   ay: function() { return /* binding */ toTRBLCorners; },\n/* harmony export */   az: function() { return /* binding */ _boundSegment; },\n/* harmony export */   b: function() { return /* binding */ isArray; },\n/* harmony export */   b0: function() { return /* binding */ fontString; },\n/* harmony export */   b1: function() { return /* binding */ toLineHeight; },\n/* harmony export */   b2: function() { return /* binding */ PITAU; },\n/* harmony export */   b3: function() { return /* binding */ INFINITY; },\n/* harmony export */   b4: function() { return /* binding */ RAD_PER_DEG; },\n/* harmony export */   b5: function() { return /* binding */ QUARTER_PI; },\n/* harmony export */   b6: function() { return /* binding */ TWO_THIRDS_PI; },\n/* harmony export */   b7: function() { return /* binding */ _angleDiff; },\n/* harmony export */   c: function() { return /* binding */ color; },\n/* harmony export */   d: function() { return /* binding */ defaults; },\n/* harmony export */   e: function() { return /* binding */ effects; },\n/* harmony export */   f: function() { return /* binding */ resolveObjectKey; },\n/* harmony export */   g: function() { return /* binding */ isNumberFinite; },\n/* harmony export */   h: function() { return /* binding */ defined; },\n/* harmony export */   i: function() { return /* binding */ isObject; },\n/* harmony export */   j: function() { return /* binding */ createContext; },\n/* harmony export */   k: function() { return /* binding */ isNullOrUndef; },\n/* harmony export */   l: function() { return /* binding */ listenArrayEvents; },\n/* harmony export */   m: function() { return /* binding */ toPercentage; },\n/* harmony export */   n: function() { return /* binding */ toDimension; },\n/* harmony export */   o: function() { return /* binding */ formatNumber; },\n/* harmony export */   p: function() { return /* binding */ _angleBetween; },\n/* harmony export */   q: function() { return /* binding */ _getStartAndCountOfVisiblePoints; },\n/* harmony export */   r: function() { return /* binding */ requestAnimFrame; },\n/* harmony export */   s: function() { return /* binding */ sign; },\n/* harmony export */   t: function() { return /* binding */ toRadians; },\n/* harmony export */   u: function() { return /* binding */ unlistenArrayEvents; },\n/* harmony export */   v: function() { return /* binding */ valueOrDefault; },\n/* harmony export */   w: function() { return /* binding */ _scaleRangesChanged; },\n/* harmony export */   x: function() { return /* binding */ isNumber; },\n/* harmony export */   y: function() { return /* binding */ _parseObjectDataRadialScale; },\n/* harmony export */   z: function() { return /* binding */ getRelativePosition; }\n/* harmony export */ });\n/* harmony import */ var _kurkle_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kurkle/color */ \"(app-pages-browser)/./node_modules/@kurkle/color/dist/color.esm.js\");\n/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */ var _s = $RefreshSig$();\n\n/**\n * @namespace Chart.helpers\n */ /**\n * An empty function that can be used, for example, for optional callback.\n */ function noop() {\n/* noop */ }\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */ const uid = (()=>{\n    let id = 0;\n    return ()=>id++;\n})();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isNullOrUndef(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */ function isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === \"[object\" && type.slice(-6) === \"Array]\") {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === \"[object Object]\";\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */ function isNumberFinite(value) {\n    return (typeof value === \"number\" || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */ function finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */ function valueOrDefault(value, defaultValue) {\n    return typeof value === \"undefined\" ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 : +value / dimension;\nconst toDimension = (value, dimension)=>typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 * dimension : +value;\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */ function callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === \"function\") {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */ function _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */ function clone(source) {\n    if (isArray(source)) {\n        return source.map(clone);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        \"__proto__\",\n        \"prototype\",\n        \"constructor\"\n    ].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */ function _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    let current;\n    for(let i = 0; i < ilen; ++i){\n        current = sources[i];\n        if (!isObject(current)) {\n            continue;\n        }\n        const keys = Object.keys(current);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, current, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */ function _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone(sval);\n    }\n}\n/**\n * @private\n */ function _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n    // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n    \"\": (v)=>v,\n    // default resolvers\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\n/**\n * @private\n */ function _splitKey(key) {\n    const parts = key.split(\".\");\n    const keys = [];\n    let tmp = \"\";\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith(\"\\\\\")) {\n            tmp = tmp.slice(0, -1) + \".\";\n        } else {\n            keys.push(tmp);\n            tmp = \"\";\n        }\n    }\n    return keys;\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === \"\") {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\n/**\n * @private\n */ function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== \"undefined\";\nconst isFunction = (value)=>typeof value === \"function\";\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param e - The event\n * @private\n */ function _isClickEvent(e) {\n    return e.type === \"mouseup\" || e.type === \"click\" || e.type === \"contextmenu\";\n}\n/**\n * @alias Chart.helpers.math\n * @namespace\n */ const PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */ function niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */ function _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */ function isNonPrimitive(n) {\n    return typeof n === \"symbol\" || typeof n === \"object\" && n !== null && !(Symbol.toPrimitive in n || \"toString\" in n || \"valueOf\" in n);\n}\nfunction isNumber(n) {\n    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */ function _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */ function _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */ function _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */ function _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */ function _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */ function _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */ function _isBetween(value, start, end) {\n    let epsilon = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1e-6;\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{\n        const ti = table[index][key];\n        return ti < value || ti === value && table[index + 1][key] === value;\n    } : (index)=>table[index][key] < value);\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */ function _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    \"push\",\n    \"pop\",\n    \"shift\",\n    \"splice\",\n    \"unshift\"\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, \"_chartjs\", {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = \"_onData\" + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value () {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === \"function\") {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\n/**\n * @param items\n */ function _arrayUnique(items) {\n    const set = new Set(items);\n    if (set.size === items.length) {\n        return items;\n    }\n    return Array.from(set);\n}\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + \" \" + pixelSize + \"px \" + fontFamily;\n}\n/**\n* Request animation polyfill\n*/ const requestAnimFrame = function() {\n    if (typeof window === \"undefined\") {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */ function throttled(fn, thisArg) {\n    let argsToUse = [];\n    let ticking = false;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        // Save the args for use later\n        argsToUse = args;\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, argsToUse);\n            });\n        }\n    };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */ function debounce(fn, delay) {\n    let timeout;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */ const _toLeftRightCenter = (align)=>align === \"start\" ? \"left\" : align === \"end\" ? \"right\" : \"center\";\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */ const _alignStartEnd = (align, start, end)=>align === \"start\" ? start : align === \"end\" ? end : (start + end) / 2;\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */ const _textX = (align, left, right, rtl)=>{\n    const check = rtl ? \"left\" : \"right\";\n    return align === check ? right : align === \"center\" ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale, vScale, _parsed } = meta;\n        const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n        const axis = iScale.axis;\n        const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n        if (minDefined) {\n            start = Math.min(_lookupByKey(_parsed, axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n            if (spanGaps) {\n                const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                start -= Math.max(0, distanceToDefinedLo);\n            }\n            start = _limitValue(start, 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            let end = Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n            if (spanGaps) {\n                const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                end += Math.max(0, distanceToDefinedHi);\n            }\n            count = _limitValue(end, start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */ function _scaleRangesChanged(meta) {\n    const { xScale, yScale, _scaleRanges } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */ const effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === \"object\") {\n        const type = value.toString();\n        return type === \"[object CanvasPattern]\" || type === \"[object CanvasGradient]\";\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : new _kurkle_color__WEBPACK_IMPORTED_MODULE_0__.Color(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : new _kurkle_color__WEBPACK_IMPORTED_MODULE_0__.Color(value).saturate(0.5).darken(0.1).hexString();\n}\nconst numbers = [\n    \"x\",\n    \"y\",\n    \"borderWidth\",\n    \"radius\",\n    \"tension\"\n];\nconst colors = [\n    \"color\",\n    \"borderColor\",\n    \"backgroundColor\"\n];\nfunction applyAnimationsDefaults(defaults) {\n    defaults.set(\"animation\", {\n        delay: undefined,\n        duration: 1000,\n        easing: \"easeOutQuart\",\n        fn: undefined,\n        from: undefined,\n        loop: undefined,\n        to: undefined,\n        type: undefined\n    });\n    defaults.describe(\"animation\", {\n        _fallback: false,\n        _indexable: false,\n        _scriptable: (name)=>name !== \"onProgress\" && name !== \"onComplete\" && name !== \"fn\"\n    });\n    defaults.set(\"animations\", {\n        colors: {\n            type: \"color\",\n            properties: colors\n        },\n        numbers: {\n            type: \"number\",\n            properties: numbers\n        }\n    });\n    defaults.describe(\"animations\", {\n        _fallback: \"animation\"\n    });\n    defaults.set(\"transitions\", {\n        active: {\n            animation: {\n                duration: 400\n            }\n        },\n        resize: {\n            animation: {\n                duration: 0\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    from: \"transparent\"\n                },\n                visible: {\n                    type: \"boolean\",\n                    duration: 0\n                }\n            }\n        },\n        hide: {\n            animations: {\n                colors: {\n                    to: \"transparent\"\n                },\n                visible: {\n                    type: \"boolean\",\n                    easing: \"linear\",\n                    fn: (v)=>v | 0\n                }\n            }\n        }\n    });\n}\nfunction applyLayoutsDefaults(defaults) {\n    defaults.set(\"layout\", {\n        autoPadding: true,\n        padding: {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    });\n}\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\nconst formatters = {\n    values (value) {\n        return isArray(value) ? value : \"\" + value;\n    },\n    numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return \"0\";\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = \"scientific\";\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = log10(Math.abs(delta));\n        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return formatNumber(tickValue, locale, options);\n    },\n    logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return \"0\";\n        }\n        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n        if ([\n            1,\n            2,\n            3,\n            5,\n            10,\n            15\n        ].includes(remain) || index > 0.8 * ticks.length) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return \"\";\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\nvar Ticks = {\n    formatters\n};\nfunction applyScaleDefaults(defaults) {\n    defaults.set(\"scale\", {\n        display: true,\n        offset: false,\n        reverse: false,\n        beginAtZero: false,\n        bounds: \"ticks\",\n        clip: true,\n        grace: 0,\n        grid: {\n            display: true,\n            lineWidth: 1,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickLength: 8,\n            tickWidth: (_ctx, options)=>options.lineWidth,\n            tickColor: (_ctx, options)=>options.color,\n            offset: false\n        },\n        border: {\n            display: true,\n            dash: [],\n            dashOffset: 0.0,\n            width: 1\n        },\n        title: {\n            display: false,\n            text: \"\",\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            textStrokeWidth: 0,\n            textStrokeColor: \"\",\n            padding: 3,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 3,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {},\n            align: \"center\",\n            crossAlign: \"near\",\n            showLabelBackdrop: false,\n            backdropColor: \"rgba(255, 255, 255, 0.75)\",\n            backdropPadding: 2\n        }\n    });\n    defaults.route(\"scale.ticks\", \"color\", \"\", \"color\");\n    defaults.route(\"scale.grid\", \"color\", \"\", \"borderColor\");\n    defaults.route(\"scale.border\", \"color\", \"\", \"borderColor\");\n    defaults.route(\"scale.title\", \"color\", \"\", \"color\");\n    defaults.describe(\"scale\", {\n        _fallback: false,\n        _scriptable: (name)=>!name.startsWith(\"before\") && !name.startsWith(\"after\") && name !== \"callback\" && name !== \"parser\",\n        _indexable: (name)=>name !== \"borderDash\" && name !== \"tickBorderDash\" && name !== \"dash\"\n    });\n    defaults.describe(\"scales\", {\n        _fallback: \"scale\"\n    });\n    defaults.describe(\"scale.ticks\", {\n        _scriptable: (name)=>name !== \"backdropPadding\" && name !== \"callback\",\n        _indexable: (name)=>name !== \"backdropPadding\"\n    });\n}\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split(\".\");\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === \"string\") {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, \"\"), scope);\n}\nclass Defaults {\n    set(scope, values) {\n        return set(this, scope, values);\n    }\n    get(scope) {\n        return getScope$1(this, scope);\n    }\n    describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n    route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = \"_\" + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n    apply(appliers) {\n        appliers.forEach((apply)=>apply(this));\n    }\n    constructor(_descriptors, _appliers){\n        this.animation = undefined;\n        this.backgroundColor = \"rgba(0,0,0,0.1)\";\n        this.borderColor = \"rgba(0,0,0,0.1)\";\n        this.color = \"#666\";\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            \"mousemove\",\n            \"mouseout\",\n            \"click\",\n            \"touchstart\",\n            \"touchmove\"\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: \"normal\",\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = \"x\";\n        this.interaction = {\n            mode: \"nearest\",\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n        this.apply(_appliers);\n    }\n}\nvar defaults = /* #__PURE__ */ new Defaults({\n    _scriptable: (name)=>!name.startsWith(\"on\"),\n    _indexable: (name)=>name !== \"events\",\n    hover: {\n        _fallback: \"interaction\"\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n}, [\n    applyAnimationsDefaults,\n    applyLayoutsDefaults,\n    applyScaleDefaults\n]);\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */ function toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + \" \" : \"\") + (font.weight ? font.weight + \" \" : \"\") + font.size + \"px \" + font.family;\n}\n/**\n * @private\n */ function _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\n/**\n * @private\n */ // eslint-disable-next-line complexity\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        // Undefined strings and arrays should not be measured\n        if (thing !== undefined && thing !== null && !isArray(thing)) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            // if it is an array lets measure each element\n            // to do maybe simplify this function a bit so we can do this more recursively?\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                // Undefined strings and arrays should not be measured\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */ function _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n/**\n * Clears the entire canvas.\n */ function clearCanvas(canvas, ctx) {\n    if (!ctx && !canvas) {\n        return;\n    }\n    ctx = ctx || canvas.getContext(\"2d\");\n    ctx.save();\n    // canvas.width and canvas.height do not consider the canvas transform,\n    // while clearRect does\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    drawPointLegend(ctx, options, x, y, null);\n}\n// eslint-disable-next-line complexity\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === \"object\") {\n        type = style.toString();\n        if (type === \"[object HTMLImageElement]\" || type === \"[object HTMLCanvasElement]\") {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        // Default includes circle\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case \"triangle\":\n            width = w ? w / 2 : radius;\n            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case \"rectRounded\":\n            // NOTE: the rounded rect implementation changed to use `arc` instead of\n            // `quadraticCurveTo` since it generates better results when rect is\n            // almost a circle. 0.516 (instead of 0.5) produces results with visually\n            // closer proportion to the previous impl and it is inscribed in the\n            // circle with `radius`. For more details, see the following PRs:\n            // https://github.com/chartjs/Chart.js/issues/5597\n            // https://github.com/chartjs/Chart.js/issues/5858\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case \"rect\":\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        /* falls through */ case \"rectRot\":\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            ctx.closePath();\n            break;\n        case \"crossRot\":\n            rad += QUARTER_PI;\n        /* falls through */ case \"cross\":\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case \"star\":\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            rad += QUARTER_PI;\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case \"line\":\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case \"dash\":\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n            break;\n        case false:\n            ctx.closePath();\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */ function _isPointInArea(point, area, margin) {\n    margin = margin || 0.5; // margin - default is to match rounded decimals\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\n/**\n * @private\n */ function _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === \"middle\") {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === \"after\" !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\n/**\n * @private\n */ function _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */ const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction drawBackdrop(ctx, opts) {\n    const oldColor = ctx.fillStyle;\n    ctx.fillStyle = opts.color;\n    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n    ctx.fillStyle = oldColor;\n}\n/**\n * Render text onto the canvas\n */ function renderText(ctx, text, x, y, font) {\n    let opts = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== \"\";\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (opts.backdrop) {\n            drawBackdrop(ctx, opts.backdrop);\n        }\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += Number(font.lineHeight);\n    }\n    ctx.restore();\n}\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */ function addRoundedRectPath(ctx, rect) {\n    const { x, y, w, h, radius } = rect;\n    // top left arc\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n    // line from top left to bottom left\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    // bottom left arc\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    // line from bottom left to bottom right\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    // bottom right arc\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    // line from bottom right to top right\n    ctx.lineTo(x + w, y + radius.topRight);\n    // top right arc\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    // line from top right to top left\n    ctx.lineTo(x + radius.topLeft, y);\n}\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */ function toLineHeight(value, size) {\n    const matches = (\"\" + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === \"normal\") {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case \"px\":\n            return value;\n        case \"%\":\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */ function toTRBL(value) {\n    return _readValueToProps(value, {\n        top: \"y\",\n        right: \"x\",\n        bottom: \"y\",\n        left: \"x\"\n    });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */ function toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        \"topLeft\",\n        \"topRight\",\n        \"bottomLeft\",\n        \"bottomRight\"\n    ]);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */ function toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */ function toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === \"string\") {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !(\"\" + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = undefined;\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: \"\"\n    };\n    font.string = toFontString(font);\n    return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */ function resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === \"function\") {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */ function _addGrace(minmax, grace, beginAtZero) {\n    const { min, max } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */ function _createResolver(scopes) {\n    let prefixes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [\n        \"\"\n    ], rootScopes = arguments.length > 2 ? arguments[2] : void 0, fallback = arguments.length > 3 ? arguments[3] : void 0, getTarget = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ()=>scopes[0];\n    const finalRootScopes = rootScopes || scopes;\n    if (typeof fallback === \"undefined\") {\n        fallback = _resolve(\"_fallback\", scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: \"Object\",\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: finalRootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, finalRootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete target._keys; // remove cached keys\n            delete scopes[0][prop]; // remove from top level scope\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value; // set to top level scope + cache\n            delete target._keys; // remove cached keys\n            return true;\n        }\n    });\n}\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete proxy[prop]; // remove from proxy\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            proxy[prop] = value; // set to proxy\n            delete target[prop]; // remove from cache\n            return true;\n        }\n    });\n}\n/**\n * @private\n */ function _descriptors(proxy) {\n    let defaults = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n        scriptable: true,\n        indexable: true\n    };\n    const { _scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== \"adapters\" && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === \"constructor\") {\n        return target[prop];\n    }\n    const value = resolve();\n    // cache the resolved value\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    let value = _proxy[prop]; // resolve from proxy\n    // resolve with context\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        // if the resolved value is an object, create a sub resolver for it\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, getValue, target, receiver) {\n    const { _proxy, _context, _subProxy, _stack } = target;\n    if (_stack.has(prop)) {\n        throw new Error(\"Recursion detected: \" + Array.from(_stack).join(\"->\") + \"->\" + prop);\n    }\n    _stack.add(prop);\n    let value = getValue(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        // When scriptable option returns an object, create a resolver on that.\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    if (typeof _context.index !== \"undefined\" && isIndexable(prop)) {\n        return value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        // Array of objects, return array or resolvers\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === \"string\" ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (typeof fallback !== \"undefined\" && fallback !== key && fallback !== parentFallback) {\n                // When we reach the descriptor that defines a new _fallback, return that.\n                // The fallback will resume to that new scope.\n                return fallback;\n            }\n        } else if (scope === false && typeof parentFallback !== \"undefined\" && key !== parentFallback) {\n            // Fallback to `false` results to `false`, when falling back to different key.\n            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (typeof fallback !== \"undefined\" && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        \"\"\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        // For array of objects, the object is used to store updated values\n        return value;\n    }\n    return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (typeof value !== \"undefined\") {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (typeof value !== \"undefined\") {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith(\"_\"))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale } = meta;\n    const { key = \"r\" } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === \"x\" ? \"y\" : \"x\";\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    // Props to Rob Spencer at scaled innovation for his post on splining between points\n    // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n    // This function must also respect \"skipped\" points\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    // If all points are the same, s01 & s02 will be inf\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01; // scaling factor for triangle Ta\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */ function monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK) {\n    let indexAxis = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"x\";\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[\"cp1\".concat(indexAxis)] = iPixel - delta;\n            pointCurrent[\"cp1\".concat(valueAxis)] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[\"cp2\".concat(indexAxis)] = iPixel + delta;\n            pointCurrent[\"cp2\".concat(valueAxis)] = vPixel + delta * mK[i];\n        }\n    }\n}\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */ function splineCurveMonotone(points) {\n    let indexAxis = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"x\";\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    // Calculate slopes (deltaK) and initialize tangents (mK)\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\n/**\n * @private\n */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    // Only consider points that are drawn in case the spanGaps option is used\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === \"monotone\") {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\n/**\n * @private\n */ function _isDomSupported() {\n    return typeof window !== \"undefined\" && typeof document !== \"undefined\";\n}\n/**\n * @private\n */ function _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === \"[object ShadowRoot]\") {\n        parent = parent.host;\n    }\n    return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */ function parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === \"string\") {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf(\"%\") !== -1) {\n            // percentage * size in dimension\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? \"-\" + suffix : \"\";\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + \"-\" + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */ function getCanvasPosition(e, canvas) {\n    _s();\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX, offsetY } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\n_s(getCanvasPosition, \"TaN0hAexdpaD4eVsFTeI6MwcRTY=\", false, function() {\n    return [\n        useOffsetPos\n    ];\n});\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */ function getRelativePosition(event, chart) {\n    if (\"native\" in event) {\n        return event;\n    }\n    const { canvas, currentDevicePixelRatio } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === \"border-box\";\n    const paddings = getPositionedStyle(style, \"padding\");\n    const borders = getPositionedStyle(style, \"border\", \"width\");\n    const { x, y, box } = getCanvasPosition(event, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width, height } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = canvas && _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect(); // this is the border box of the container\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, \"border\", \"width\");\n            const containerPadding = getPositionedStyle(containerStyle, \"padding\");\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, \"clientWidth\");\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, \"clientHeight\");\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, \"margin\");\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, \"clientWidth\") || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, \"clientHeight\") || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width, height } = containerSize;\n    if (style.boxSizing === \"content-box\") {\n        const borders = getPositionedStyle(style, \"border\", \"width\");\n        const paddings = getPositionedStyle(style, \"padding\");\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        // https://github.com/chartjs/Chart.js/issues/4659\n        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n        height = round1(width / 2);\n    }\n    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n        height = containerSize.height;\n        width = round1(Math.floor(height * aspectRatio));\n    }\n    return {\n        width,\n        height\n    };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */ function retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = round1(chart.height * pixelRatio);\n    const deviceWidth = round1(chart.width * pixelRatio);\n    chart.height = round1(chart.height);\n    chart.width = round1(chart.width);\n    const canvas = chart.canvas;\n    // If no style has been set on the canvas, the render size is used as display size,\n    // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n    // See https://github.com/chartjs/Chart.js/issues/3575\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = \"\".concat(chart.height, \"px\");\n        canvas.style.width = \"\".concat(chart.width, \"px\");\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */ const supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        if (_isDomSupported()) {\n            window.addEventListener(\"test\", null, options);\n            window.removeEventListener(\"test\", null, options);\n        }\n    } catch (e) {\n    // continue regardless of error\n    }\n    return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */ function readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\n/**\n * @private\n */ function _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\n/**\n * @private\n */ function _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === \"middle\" ? t < 0.5 ? p1.y : p2.y : mode === \"after\" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\n/**\n * @private\n */ function _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === \"center\") {\n                return align;\n            }\n            return align === \"right\" ? \"left\" : \"right\";\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === \"ltr\" || direction === \"rtl\") {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue(\"direction\"),\n            style.getPropertyPriority(\"direction\")\n        ];\n        style.setProperty(\"direction\", direction, \"important\");\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty(\"direction\", original[0], original[1]);\n    }\n}\nfunction propertyFn(property) {\n    if (property === \"angle\") {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment(param) {\n    let { start, end, count, loop, style } = param;\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property, start: startBound, end: endBound } = bounds;\n    const { between, normalize } = propertyFn(property);\n    const count = points.length;\n    let { start, end, loop } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\nfunction _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property, start: startBound, end: endBound } = bounds;\n    const count = points.length;\n    const { compare, between, normalize } = propertyFn(property);\n    const { start, end, loop, style } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\nfunction _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\nfunction solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: \"segment\",\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    if (!prevStyle) {\n        return false;\n    }\n    const cache = [];\n    const replacer = function(key, value) {\n        if (!isPatternOrGradient(value)) {\n            return value;\n        }\n        if (!cache.includes(value)) {\n            cache.push(value);\n        }\n        return cache.indexOf(value);\n    };\n    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\nfunction getSizeForArea(scale, chartArea, field) {\n    return scale.options.clip ? scale[field] : chartArea[field];\n}\nfunction getDatasetArea(meta, chartArea) {\n    const { xScale, yScale } = meta;\n    if (xScale && yScale) {\n        return {\n            left: getSizeForArea(xScale, chartArea, \"left\"),\n            right: getSizeForArea(xScale, chartArea, \"right\"),\n            top: getSizeForArea(yScale, chartArea, \"top\"),\n            bottom: getSizeForArea(yScale, chartArea, \"bottom\")\n        };\n    }\n    return chartArea;\n}\nfunction getDatasetClipArea(chart, meta) {\n    const clip = meta._clip;\n    if (clip.disabled) {\n        return false;\n    }\n    const area = getDatasetArea(meta, chart.chartArea);\n    return {\n        left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),\n        right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),\n        top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),\n        bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)\n    };\n}\n //# sourceMappingURL=helpers.dataset.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NodW5rcy9oZWxwZXJzLmRhdGFzZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztJQVVPLFNBQVNBO0FBQ2Q7QUFHRjs7Q0FFQyxHQUNNLE1BQU1DLE1BQU87SUFDbEIsSUFBSUMsS0FBSztJQUNULE9BQU8sSUFBTUE7QUFDZjtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTQyxjQUFjQyxLQUFjO0lBQzFDLE9BQU9BLFVBQVUsUUFBUUEsVUFBVUM7QUFDckM7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0MsUUFBcUJGLEtBQWM7SUFDakQsSUFBSUcsTUFBTUQsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLENBQUNGLFFBQVE7UUFDekMsT0FBTzs7SUFFVCxNQUFNSSxPQUFPQyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUjtJQUM1QyxJQUFJSSxLQUFLSyxLQUFLLENBQUMsR0FBRyxPQUFPLGFBQWFMLEtBQUtLLEtBQUssQ0FBQyxDQUFDLE9BQU8sVUFBVTtRQUNqRSxPQUFPOztJQUVULE9BQU87QUFDVDtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTQyxTQUFTVixLQUFjO0lBQ3JDLE9BQU9BLFVBQVUsUUFBUUssT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1IsV0FBVztBQUNyRTtBQUVBOzs7SUFJQSxTQUFTVyxlQUFlWCxLQUFjO0lBQ3BDLE9BQVEsUUFBT0EsVUFBVSxZQUFZQSxpQkFBaUJZLE1BQUFBLEtBQVdDLFNBQVMsQ0FBQ2I7QUFDN0U7QUFLQTs7OztDQUlDLEdBQ00sU0FBU2MsZ0JBQWdCZCxLQUFj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QzdGMEcsS0FBS3VDLEtBQUt2QyxHQUFHLEtBQUssUUFBUSxJQUFJb0wsS0FBS3BMLEdBQUcsR0FBSXVDLENBQUFBLEtBQUt2QyxHQUFHLEtBQUssT0FBTyxJQUFJdUMsS0FBS3ZDLEdBQUc7UUFDMUVDLFFBQVFzQyxLQUFLdEMsTUFBTSxLQUFLLFFBQVFtQixNQUFNb0ksTUFBTSxHQUFHNEIsS0FBS25MLE1BQU0sR0FBSXNDLENBQUFBLEtBQUt0QyxNQUFNLEtBQUssT0FBTyxJQUFJc0MsS0FBS3RDLE1BQUs7SUFDckc7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5jb3JlLnRzPzU2M2EiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLm1hdGgudHM/MmU4MSIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi50cz8xNDkzIiwid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5leHRyYXMudHM/NTAzOSIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLnRzPzk2ZDciLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLmNvbG9yLnRzPzBjMWQiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanM/MTI4NyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcz82MTc2Iiwid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5pbnRsLnRzPzFiYTYiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY29yZS9jb3JlLnRpY2tzLmpzP2RjNTYiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY29yZS9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzPzUxYzciLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY29yZS9jb3JlLmRlZmF1bHRzLmpzPzA3YmEiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLmNhbnZhcy50cz83OWEyIiwid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLnRzPzZlZDUiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLmNvbmZpZy50cz9kY2Y3Iiwid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5jdXJ2ZS50cz83YjIyIiwid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5kb20udHM/ZTYwNyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50ZXJwb2xhdGlvbi50cz8wOTFjIiwid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5ydGwudHM/MmFjMiIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9oZWxwZXJzL2hlbHBlcnMuc2VnbWVudC5qcz9kYzNjIiwid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5kYXRhc2V0LnRzPzkyODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnNcbiAqL1xuXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7QWN0aXZlRGF0YVBvaW50LCBDaGFydEV2ZW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbi8qKlxuICogQW4gZW1wdHkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIGZvciBvcHRpb25hbCBjYWxsYmFjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8qIG5vb3AgKi9cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdW5pcXVlIGlkLCBzZXF1ZW50aWFsbHkgZ2VuZXJhdGVkIGZyb20gYSBnbG9iYWwgdmFyaWFibGUuXG4gKi9cbmV4cG9ydCBjb25zdCB1aWQgPSAoKCkgPT4ge1xuICBsZXQgaWQgPSAwO1xuICByZXR1cm4gKCkgPT4gaWQrKztcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgbmVpdGhlciBudWxsIG5vciB1bmRlZmluZWQsIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IChpbmNsdWRpbmcgdHlwZWQgYXJyYXlzKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXk8VCA9IHVua25vd24+KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgVFtdIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHR5cGUuc2xpY2UoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnNsaWNlKC02KSA9PT0gJ0FycmF5XScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEFueU9iamVjdCB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgcmV0dXJucyBmYWxzZVxuICogQHBhcmFtIHZhbHVlICAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICovXG5mdW5jdGlvbiBpc051bWJlckZpbml0ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bWJlciB7XG4gIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK3ZhbHVlKTtcbn1cbmV4cG9ydCB7XG4gIGlzTnVtYmVyRmluaXRlIGFzIGlzRmluaXRlLFxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGB2YWx1ZWAgaWYgZmluaXRlLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIG5vdCBmaW5pdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5pdGVPckRlZmF1bHQodmFsdWU6IHVua25vd24sIGRlZmF1bHRWYWx1ZTogbnVtYmVyKSB7XG4gIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB2YWx1ZWAgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdDxUPih2YWx1ZTogVCB8IHVuZGVmaW5lZCwgZGVmYXVsdFZhbHVlOiBUKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59XG5cbmV4cG9ydCBjb25zdCB0b1BlcmNlbnRhZ2UgPSAodmFsdWU6IG51bWJlciB8IHN0cmluZywgZGltZW5zaW9uOiBudW1iZXIpID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDBcbiAgICA6ICt2YWx1ZSAvIGRpbWVuc2lvbjtcblxuZXhwb3J0IGNvbnN0IHRvRGltZW5zaW9uID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGRpbWVuc2lvbjogbnVtYmVyKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogZGltZW5zaW9uXG4gICAgOiArdmFsdWU7XG5cbi8qKlxuICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgcmV0dXJuZWQgYnkgYGZuYC4gSWYgYGZuYCBpcyBub3QgYSBmdW5jdGlvbiwgdGhpcyBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB3aXRoIHdoaWNoIGBmbmAgc2hvdWxkIGJlIGNhbGxlZC5cbiAqIEBwYXJhbSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsbGJhY2s8VCBleHRlbmRzICh0aGlzOiBUQSwgLi4ucmVzdEFyZ3M6IHVua25vd25bXSkgPT4gUiwgVEEsIFI+KFxuICBmbjogVCB8IHVuZGVmaW5lZCxcbiAgYXJnczogdW5rbm93bltdLFxuICB0aGlzQXJnPzogVEFcbik6IFIgfCB1bmRlZmluZWQge1xuICBpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3RlKFNCKSBmb3IgcGVyZm9ybWFuY2Ugc2FrZSwgdGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIGxvb3BhYmxlIHR5cGVcbiAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXG4gKiBpdCdzIHByZWZlcmFibGUgdG8gdXNlIGEgcmVndWxhciBmb3IoKSBsb29wIGFuZCBzYXZlIGV4dHJhIGZ1bmN0aW9uIGNhbGxzLlxuICogQHBhcmFtIGxvb3BhYmxlIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSBpdGVyYXRlZC5cbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cbiAqIEBwYXJhbSBbcmV2ZXJzZV0gLSBJZiB0cnVlLCBpdGVyYXRlcyBiYWNrd2FyZCBvbiB0aGUgbG9vcGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQsIFRBPihcbiAgbG9vcGFibGU6IFJlY29yZDxzdHJpbmcsIFQ+LFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBzdHJpbmcpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBUW10sXG4gIGZuOiAodGhpczogVEEsIHY6IFQsIGk6IG51bWJlcikgPT4gdm9pZCxcbiAgdGhpc0FyZz86IFRBLFxuICByZXZlcnNlPzogYm9vbGVhblxuKTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQsIFRBPihcbiAgbG9vcGFibGU6IFRbXSB8IFJlY29yZDxzdHJpbmcsIFQ+LFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBhbnkpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbikge1xuICBsZXQgaTogbnVtYmVyLCBsZW46IG51bWJlciwga2V5czogc3RyaW5nW107XG4gIGlmIChpc0FycmF5KGxvb3BhYmxlKSkge1xuICAgIGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobG9vcGFibGUpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGxvb3BhYmxlKTtcbiAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVba2V5c1tpXV0sIGtleXNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYGEwYCBhbmQgYGExYCBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gYTAgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuICogQHBhcmFtIGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZWxlbWVudHNFcXVhbChhMDogQWN0aXZlRGF0YVBvaW50W10sIGExOiBBY3RpdmVEYXRhUG9pbnRbXSkge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHYwOiBBY3RpdmVEYXRhUG9pbnQsIHYxOiBBY3RpdmVEYXRhUG9pbnQ7XG5cbiAgaWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdjAgPSBhMFtpXTtcbiAgICB2MSA9IGExW2ldO1xuXG4gICAgaWYgKHYwLmRhdGFzZXRJbmRleCAhPT0gdjEuZGF0YXNldEluZGV4IHx8IHYwLmluZGV4ICE9PSB2MS5pbmRleCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBkZWVwIGNvcHkgb2YgYHNvdXJjZWAgd2l0aG91dCBrZWVwaW5nIHJlZmVyZW5jZXMgb24gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICogQHBhcmFtIHNvdXJjZSAtIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lPFQ+KHNvdXJjZTogVCk6IFQge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoY2xvbmUpIGFzIHVua25vd24gYXMgVDtcbiAgfVxuXG4gIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBjb25zdCBrbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGsgPSAwO1xuXG4gICAgZm9yICg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIHRhcmdldFtrZXlzW2tdXSA9IGNsb25lKHNvdXJjZVtrZXlzW2tdXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgbWVyZ2VyIHdoZW4gQ2hhcnQuaGVscGVycy5tZXJnZSBpcyBjYWxsZWQgd2l0aG91dCBtZXJnZXIgb3B0aW9uLlxuICogTm90ZShTQik6IGFsc28gdXNlZCBieSBtZXJnZUNvbmZpZyBhbmQgbWVyZ2VTY2FsZUNvbmZpZyBhcyBmYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VyKGtleTogc3RyaW5nLCB0YXJnZXQ6IEFueU9iamVjdCwgc291cmNlOiBBbnlPYmplY3QsIG9wdGlvbnM6IEFueU9iamVjdCkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICBtZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVyZ2VPcHRpb25zIHtcbiAgbWVyZ2VyPzogKGtleTogc3RyaW5nLCB0YXJnZXQ6IEFueU9iamVjdCwgc291cmNlOiBBbnlPYmplY3QsIG9wdGlvbnM/OiBBbnlPYmplY3QpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG4gKiBAcGFyYW0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXG4gKiBAcGFyYW0gW29wdGlvbnNdIC0gTWVyZ2luZyBvcHRpb25zOlxuICogQHBhcmFtIFtvcHRpb25zLm1lcmdlcl0gLSBUaGUgbWVyZ2UgbWV0aG9kIChrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuICogQHJldHVybnMgVGhlIGB0YXJnZXRgIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBTMSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMV0sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMl0sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzEgJiBTMjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMSwgUzIsIFMzPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMiwgUzNdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxICYgUzIgJiBTMztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMSwgUzIsIFMzLCBTND4oXG4gIHRhcmdldDogVCxcbiAgc291cmNlOiBbUzEsIFMyLCBTMywgUzRdLFxuICBvcHRpb25zPzogTWVyZ2VPcHRpb25zXG4pOiBUICYgUzEgJiBTMiAmIFMzICYgUzQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogQW55T2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IEFueU9iamVjdCB7XG4gIGNvbnN0IHNvdXJjZXMgPSBpc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbiAgY29uc3QgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuXG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQgYXMgQW55T2JqZWN0O1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1lcmdlciA9IG9wdGlvbnMubWVyZ2VyIHx8IF9tZXJnZXI7XG4gIGxldCBjdXJyZW50OiBBbnlPYmplY3Q7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyZW50ID0gc291cmNlc1tpXTtcbiAgICBpZiAoIWlzT2JqZWN0KGN1cnJlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY3VycmVudCk7XG4gICAgZm9yIChsZXQgayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgY3VycmVudCwgb3B0aW9ucyBhcyBBbnlPYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgICpvbmx5KiBpZiBub3QgZGVmaW5lZCBpbiB0YXJnZXQuXG4gKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuICogQHJldHVybnMgVGhlIGB0YXJnZXRgIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IFtdKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogUzEpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMV0pOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMSwgUzI+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyXSk6IFQgJiBTMSAmIFMyO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyLCBTMz4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzXSk6IFQgJiBTMSAmIFMyICYgUzM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMSwgUzIsIFMzLCBTND4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzLCBTNF0pOiBUICYgUzEgJiBTMiAmIFMzICYgUzQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10pOiBBbnlPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10pOiBBbnlPYmplY3Qge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIHJldHVybiBtZXJnZTxUPih0YXJnZXQsIHNvdXJjZSwge21lcmdlcjogX21lcmdlcklmfSk7XG59XG5cbi8qKlxuICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZXJnZXJJZihrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0KSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG5cbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2VJZih0dmFsLCBzdmFsKTtcbiAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUoc3ZhbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlcHJlY2F0ZWQoc2NvcGU6IHN0cmluZywgdmFsdWU6IHVua25vd24sIHByZXZpb3VzOiBzdHJpbmcsIGN1cnJlbnQ6IHN0cmluZykge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybihzY29wZSArICc6IFwiJyArIHByZXZpb3VzICtcbiAgICAgICdcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiJyArIGN1cnJlbnQgKyAnXCIgaW5zdGVhZCcpO1xuICB9XG59XG5cbi8vIHJlc29sdmVPYmplY3RLZXkgcmVzb2x2ZXIgY2FjaGVcbmNvbnN0IGtleVJlc29sdmVycyA9IHtcbiAgLy8gQ2hhcnQuaGVscGVycy5jb3JlIHJlc29sdmVPYmplY3RLZXkgc2hvdWxkIHJlc29sdmUgZW1wdHkga2V5IHRvIHJvb3Qgb2JqZWN0XG4gICcnOiB2ID0+IHYsXG4gIC8vIGRlZmF1bHQgcmVzb2x2ZXJzXG4gIHg6IG8gPT4gby54LFxuICB5OiBvID0+IG8ueVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NwbGl0S2V5KGtleTogc3RyaW5nKSB7XG4gIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XG4gIGxldCB0bXAgPSAnJztcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgdG1wICs9IHBhcnQ7XG4gICAgaWYgKHRtcC5lbmRzV2l0aCgnXFxcXCcpKSB7XG4gICAgICB0bXAgPSB0bXAuc2xpY2UoMCwgLTEpICsgJy4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2godG1wKTtcbiAgICAgIHRtcCA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX2dldEtleVJlc29sdmVyKGtleTogc3RyaW5nKSB7XG4gIGNvbnN0IGtleXMgPSBfc3BsaXRLZXkoa2V5KTtcbiAgcmV0dXJuIG9iaiA9PiB7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgIGlmIChrID09PSAnJykge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTpcbiAgICAgICAgLy8gQ2hhcnQuaGVscGVycy5jb3JlIHJlc29sdmVPYmplY3RLZXkgc2hvdWxkIGJyZWFrIGF0IGVtcHR5IGtleVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9iaiAmJiBvYmpba107XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT2JqZWN0S2V5KG9iajogQW55T2JqZWN0LCBrZXk6IHN0cmluZyk6IGFueSB7XG4gIGNvbnN0IHJlc29sdmVyID0ga2V5UmVzb2x2ZXJzW2tleV0gfHwgKGtleVJlc29sdmVyc1trZXldID0gX2dldEtleVJlc29sdmVyKGtleSkpO1xuICByZXR1cm4gcmVzb2x2ZXIob2JqKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuXG5leHBvcnQgY29uc3QgZGVmaW5lZCA9ICh2YWx1ZTogdW5rbm93bikgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyAoLi4uYXJnczogYW55W10pID0+IGFueSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMTEyODg1NS9jb21wYXJpbmctZWNtYTYtc2V0cy1mb3ItZXF1YWxpdHkjMzExMjkzODRcbmV4cG9ydCBjb25zdCBzZXRzRXF1YWwgPSA8VD4oYTogU2V0PFQ+LCBiOiBTZXQ8VD4pID0+IHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBlIC0gVGhlIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzQ2xpY2tFdmVudChlOiBDaGFydEV2ZW50KSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAnY29udGV4dG1lbnUnO1xufVxuIiwiaW1wb3J0IHR5cGUge1BvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHtpc0Zpbml0ZSBhcyBpc0Zpbml0ZU51bWJlcn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm1hdGhcbiAqIEBuYW1lc3BhY2VcbiAqL1xuXG5leHBvcnQgY29uc3QgUEkgPSBNYXRoLlBJO1xuZXhwb3J0IGNvbnN0IFRBVSA9IDIgKiBQSTtcbmV4cG9ydCBjb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuZXhwb3J0IGNvbnN0IElORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuZXhwb3J0IGNvbnN0IFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG5leHBvcnQgY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmV4cG9ydCBjb25zdCBRVUFSVEVSX1BJID0gUEkgLyA0O1xuZXhwb3J0IGNvbnN0IFRXT19USElSRFNfUEkgPSBQSSAqIDIgLyAzO1xuXG5leHBvcnQgY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwO1xuZXhwb3J0IGNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5cbmV4cG9ydCBmdW5jdGlvbiBhbG1vc3RFcXVhbHMoeDogbnVtYmVyLCB5OiBudW1iZXIsIGVwc2lsb246IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmljZU51bShyYW5nZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZhY3RvcnMgc29ydGVkIGZyb20gMSB0byBzcXJ0KHZhbHVlKVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWU6IG51bWJlcikge1xuICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTogbnVtYmVyO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcbiAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgfVxuICB9XG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7IC8vIGlmIHZhbHVlIGlzIGEgc3F1YXJlIG51bWJlclxuICAgIHJlc3VsdC5wdXNoKHNxcnQpO1xuICB9XG5cbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGF0dGVtcHRpbmcgdG8gY29lcmNlIG4gdG8gc3RyaW5nIG9yIG51bWJlciB3b24ndCB0aHJvdyBhIFR5cGVFcnJvci5cbiAqL1xuZnVuY3Rpb24gaXNOb25QcmltaXRpdmUobjogdW5rbm93bikge1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdzeW1ib2wnIHx8ICh0eXBlb2YgbiA9PT0gJ29iamVjdCcgJiYgbiAhPT0gbnVsbCAmJiAhKFN5bWJvbC50b1ByaW1pdGl2ZSBpbiBuIHx8ICd0b1N0cmluZycgaW4gbiB8fCAndmFsdWVPZicgaW4gbikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobjogdW5rbm93bik6IG4gaXMgbnVtYmVyIHtcbiAgcmV0dXJuICFpc05vblByaW1pdGl2ZShuKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChuIGFzIHN0cmluZykpICYmIGlzRmluaXRlKG4gYXMgbnVtYmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdFdob2xlKHg6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zZXRNaW5BbmRNYXhCeUtleShcbiAgYXJyYXk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAgdGFyZ2V0OiB7IG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciB9LFxuICBwcm9wZXJ0eTogc3RyaW5nXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycmF5W2ldW3Byb3BlcnR5XTtcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdGFyZ2V0Lm1pbiA9IE1hdGgubWluKHRhcmdldC5taW4sIHZhbHVlKTtcbiAgICAgIHRhcmdldC5tYXggPSBNYXRoLm1heCh0YXJnZXQubWF4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlczogbnVtYmVyKSB7XG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zOiBudW1iZXIpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogaS5lLiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgb2YgdGhlIHZhbHVlIG9mIHRoaXMgTnVtYmVyLlxuICogQHBhcmFtIHggLSBBIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeDogbnVtYmVyKSB7XG4gIGlmICghaXNGaW5pdGVOdW1iZXIoeCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSAxO1xuICBsZXQgcCA9IDA7XG4gIHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcbiAgICBlICo9IDEwO1xuICAgIHArKztcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuLy8gR2V0cyB0aGUgYW5nbGUgZnJvbSB2ZXJ0aWNhbCB1cHJpZ2h0IHRvIHRoZSBwb2ludCBhYm91dCBhIGNlbnRyZS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChcbiAgY2VudHJlUG9pbnQ6IFBvaW50LFxuICBhbmdsZVBvaW50OiBQb2ludFxuKSB7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuICBjb25zdCBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcbiAgY29uc3QgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuXG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG5cbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7IC8vIG1ha2Ugc3VyZSB0aGUgcmV0dXJuZWQgYW5nbGUgaXMgaW4gdGhlIHJhbmdlIG9mICgtUEkvMiwgM1BJLzJdXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFuZ2xlLFxuICAgIGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlblBvaW50cyhwdDE6IFBvaW50LCBwdDI6IFBvaW50KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG59XG5cbi8qKlxuICogU2hvcnRlc3QgZGlzdGFuY2UgYmV0d2VlbiBhbmdsZXMsIGluIGVpdGhlciBkaXJlY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FuZ2xlRGlmZihhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFuZ2xlIHRvIGJlIGJldHdlZW4gMCBhbmQgMipQSVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ub3JtYWxpemVBbmdsZShhOiBudW1iZXIpIHtcbiAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlPzogYm9vbGVhbikge1xuICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XG4gIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IChzYW1lQW5nbGVJc0Z1bGxDaXJjbGUgJiYgcyA9PT0gZSlcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcbn1cblxuLyoqXG4gKiBMaW1pdCBgdmFsdWVgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbGltaXRWYWx1ZSh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlOiBudW1iZXIpIHtcbiAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICogQHBhcmFtIFtlcHNpbG9uXVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0JldHdlZW4odmFsdWU6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIGVwc2lsb24gPSAxZS02KSB7XG4gIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbihzdGFydCwgZW5kKSAtIGVwc2lsb24gJiYgdmFsdWUgPD0gTWF0aC5tYXgoc3RhcnQsIGVuZCkgKyBlcHNpbG9uO1xufVxuIiwiaW1wb3J0IHtfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGNtcFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiBudW1iZXJbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbik6IHtsbzogbnVtYmVyLCBoaTogbnVtYmVyfTtcbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwPFQ+KFxuICB0YWJsZTogVFtdLFxuICB2YWx1ZTogbnVtYmVyLFxuICBjbXA6ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cChcbiAgdGFibGU6IHVua25vd25bXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbikge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0gbGFzdCAtIGxvb2t1cCBsYXN0IGluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2xvb2t1cEJ5S2V5ID0gKFxuICB0YWJsZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IG51bWJlcixcbiAgbGFzdD86IGJvb2xlYW5cbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3RcbiAgICA/IGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHRpID0gdGFibGVbaW5kZXhdW2tleV07XG4gICAgICByZXR1cm4gdGkgPCB2YWx1ZSB8fCB0aSA9PT0gdmFsdWUgJiYgdGFibGVbaW5kZXggKyAxXVtrZXldID09PSB2YWx1ZTtcbiAgICB9XG4gICAgOiBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcblxuLyoqXG4gKiBSZXZlcnNlIGJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3Jsb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXJcbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcblxuLyoqXG4gKiBSZXR1cm4gc3Vic2V0IG9mIGB2YWx1ZXNgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIGluY2x1c2l2ZS5cbiAqIFZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWVzIC0gc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIG1pbiAtIG1pbiB2YWx1ZVxuICogQHBhcmFtIG1heCAtIG1heCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzOiBudW1iZXJbXSwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cblxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuXG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGludGVyZmFjZSBBcnJheUxpc3RlbmVyPFQ+IHtcbiAgX29uRGF0YVB1c2g/KC4uLml0ZW06IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFQb3A/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTaGlmdD8oKTogdm9pZDtcbiAgX29uRGF0YVNwbGljZT8oaW5kZXg6IG51bWJlciwgZGVsZXRlQ291bnQ6IG51bWJlciwgLi4uaXRlbXM6IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFVbnNoaWZ0PyguLi5pdGVtOiBUW10pOiB2b2lkO1xufVxuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdfb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIF9vbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50czxUPihhcnJheTogVFtdLCBsaXN0ZW5lcjogQXJyYXlMaXN0ZW5lcjxUPik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcblxuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8qKlxuICogQHBhcmFtIGl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXJyYXlVbmlxdWU8VD4oaXRlbXM6IFRbXSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0PFQ+KGl0ZW1zKTtcblxuICBpZiAoc2V0LnNpemUgPT09IGl0ZW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG4iLCJpbXBvcnQgdHlwZSB7Q2hhcnRNZXRhLCBQb2ludEVsZW1lbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuaW1wb3J0IHtfbGltaXRWYWx1ZX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfbG9va3VwQnlLZXl9IGZyb20gJy4vaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemU6IG51bWJlciwgZm9udFN0eWxlOiBzdHJpbmcsIGZvbnRGYW1pbHk6IHN0cmluZykge1xuICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuXG4vKipcbiogUmVxdWVzdCBhbmltYXRpb24gcG9seWZpbGxcbiovXG5leHBvcnQgY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpKTtcblxuLyoqXG4gKiBUaHJvdHRsZXMgY2FsbGluZyBgZm5gIG9uY2UgcGVyIGFuaW1hdGlvbiBmcmFtZVxuICogTGF0ZXN0IGFyZ3VtZW50cyBhcmUgdXNlZCBvbiB0aGUgYWN0dWFsIGNhbGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlZDxUQXJncyBleHRlbmRzIEFycmF5PGFueT4+KFxuICBmbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiB2b2lkLFxuICB0aGlzQXJnOiBhbnksXG4pIHtcbiAgbGV0IGFyZ3NUb1VzZSA9IFtdIGFzIFRBcmdzO1xuICBsZXQgdGlja2luZyA9IGZhbHNlO1xuXG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzOiBUQXJncykge1xuICAgIC8vIFNhdmUgdGhlIGFyZ3MgZm9yIHVzZSBsYXRlclxuICAgIGFyZ3NUb1VzZSA9IGFyZ3M7XG4gICAgaWYgKCF0aWNraW5nKSB7XG4gICAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgICAgdGlja2luZyA9IGZhbHNlO1xuICAgICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmdzVG9Vc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIERlYm91bmNlcyBjYWxsaW5nIGBmbmAgZm9yIGBkZWxheWAgbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlPFRBcmdzIGV4dGVuZHMgQXJyYXk8YW55Pj4oZm46ICguLi5hcmdzOiBUQXJncykgPT4gdm9pZCwgZGVsYXk6IG51bWJlcikge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IFRBcmdzKSB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXksIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzICdzdGFydCcgdG8gJ2xlZnQnLCAnZW5kJyB0byAncmlnaHQnIGFuZCBvdGhlcnMgdG8gJ2NlbnRlcidcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfdG9MZWZ0UmlnaHRDZW50ZXIgPSAoYWxpZ246ICdzdGFydCcgfCAnZW5kJyB8ICdjZW50ZXInKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcblxuLyoqXG4gKiBSZXR1cm5zIGBzdGFydGAsIGBlbmRgIG9yIGAoc3RhcnQgKyBlbmQpIC8gMmAgZGVwZW5kaW5nIG9uIGBhbGlnbmAuIERlZmF1bHRzIHRvIGBjZW50ZXJgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2FsaWduU3RhcnRFbmQgPSAoYWxpZ246ICdzdGFydCcgfCAnZW5kJyB8ICdjZW50ZXInLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikgPT4gYWxpZ24gPT09ICdzdGFydCcgPyBzdGFydCA6IGFsaWduID09PSAnZW5kJyA/IGVuZCA6IChzdGFydCArIGVuZCkgLyAyO1xuXG4vKipcbiAqIFJldHVybnMgYGxlZnRgLCBgcmlnaHRgIG9yIGAobGVmdCArIHJpZ2h0KSAvIDJgIGRlcGVuZGluZyBvbiBgYWxpZ25gLiBEZWZhdWx0cyB0byBgbGVmdGBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfdGV4dFggPSAoYWxpZ246ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJywgbGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBydGw6IGJvb2xlYW4pID0+IHtcbiAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gc3RhcnQgYW5kIGNvdW50IG9mIHZpc2libGUgcG9pbnRzLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGE6IENoYXJ0TWV0YTwnbGluZScgfCAnc2NhdHRlcic+LCBwb2ludHM6IFBvaW50RWxlbWVudFtdLCBhbmltYXRpb25zRGlzYWJsZWQ6IGJvb2xlYW4pIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50ID0gcG9pbnRDb3VudDtcblxuICBpZiAobWV0YS5fc29ydGVkKSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3Qgc3BhbkdhcHMgPSBtZXRhLmRhdGFzZXQgPyBtZXRhLmRhdGFzZXQub3B0aW9ucyA/IG1ldGEuZGF0YXNldC5vcHRpb25zLnNwYW5HYXBzIDogbnVsbCA6IG51bGw7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gICAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5taW4oXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byB0eXBlIF9wYXJzZWRcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGF4aXMsIG1pbikubG8sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyk7XG4gICAgICBpZiAoc3BhbkdhcHMpIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRMbyA9IChfcGFyc2VkXG4gICAgICAgICAgLnNsaWNlKDAsIHN0YXJ0ICsgMSlcbiAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgLmZpbmRJbmRleChcbiAgICAgICAgICAgIHBvaW50ID0+ICFpc051bGxPclVuZGVmKHBvaW50W3ZTY2FsZS5heGlzXSkpKTtcbiAgICAgICAgc3RhcnQgLT0gTWF0aC5tYXgoMCwgZGlzdGFuY2VUb0RlZmluZWRMbyk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBsZXQgZW5kID0gTWF0aC5tYXgoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byB0eXBlIF9wYXJzZWRcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtYXgsIHRydWUpLmhpICsgMSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIGZpeCB0eXBlcyBvbiBfbG9va3VwQnlLZXlcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCksIHRydWUpLmhpICsgMSk7XG4gICAgICBpZiAoc3BhbkdhcHMpIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRIaSA9IChfcGFyc2VkXG4gICAgICAgICAgLnNsaWNlKGVuZCAtIDEpXG4gICAgICAgICAgLmZpbmRJbmRleChcbiAgICAgICAgICAgIHBvaW50ID0+ICFpc051bGxPclVuZGVmKHBvaW50W3ZTY2FsZS5heGlzXSkpKTtcbiAgICAgICAgZW5kICs9IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkSGkpO1xuICAgICAgfVxuICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShlbmQsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzY2FsZSByYW5nZXMgaGF2ZSBjaGFuZ2VkLlxuICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGEuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpIHtcbiAgY29uc3Qge3hTY2FsZSwgeVNjYWxlLCBfc2NhbGVSYW5nZXN9ID0gbWV0YTtcbiAgY29uc3QgbmV3UmFuZ2VzID0ge1xuICAgIHhtaW46IHhTY2FsZS5taW4sXG4gICAgeG1heDogeFNjYWxlLm1heCxcbiAgICB5bWluOiB5U2NhbGUubWluLFxuICAgIHltYXg6IHlTY2FsZS5tYXhcbiAgfTtcbiAgaWYgKCFfc2NhbGVSYW5nZXMpIHtcbiAgICBtZXRhLl9zY2FsZVJhbmdlcyA9IG5ld1JhbmdlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBjaGFuZ2VkID0gX3NjYWxlUmFuZ2VzLnhtaW4gIT09IHhTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueG1heCAhPT0geFNjYWxlLm1heFxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWluICE9PSB5U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltYXggIT09IHlTY2FsZS5tYXg7XG5cbiAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XG4gIHJldHVybiBjaGFuZ2VkO1xufVxuIiwiaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbmNvbnN0IGF0RWRnZSA9ICh0OiBudW1iZXIpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodDogbnVtYmVyLCBzOiBudW1iZXIsIHA6IG51bWJlcikgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXG4gKi9cbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogKHQ6IG51bWJlcikgPT4gdCxcblxuICBlYXNlSW5RdWFkOiAodDogbnVtYmVyKSA9PiB0ICogdCxcblxuICBlYXNlT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gLXQgKiAodCAtIDIpLFxuXG4gIGVhc2VJbk91dFF1YWQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuXG4gIGVhc2VJbkN1YmljOiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dEN1YmljOiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRDdWJpYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblF1YXJ0OiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFydDogKHQ6IG51bWJlcikgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuXG4gIGVhc2VJbk91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG5cbiAgZWFzZUluUXVpbnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWludDogKHQ6IG51bWJlcikgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRRdWludDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcblxuICBlYXNlSW5TaW5lOiAodDogbnVtYmVyKSA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcblxuICBlYXNlT3V0U2luZTogKHQ6IG51bWJlcikgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuXG4gIGVhc2VJbk91dFNpbmU6ICh0OiBudW1iZXIpID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuXG4gIGVhc2VJbkV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuXG4gIGVhc2VPdXRFeHBvOiAodDogbnVtYmVyKSA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcblxuICBlYXNlSW5PdXRFeHBvOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG5cbiAgZWFzZUluQ2lyYzogKHQ6IG51bWJlcikgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuXG4gIGVhc2VPdXRDaXJjOiAodDogbnVtYmVyKSA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG5cbiAgZWFzZUluT3V0Q2lyYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG5cbiAgZWFzZUluRWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlT3V0RWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG5cbiAgZWFzZUluT3V0RWxhc3RpYyh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuXG4gIGVhc2VJbkJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG5cbiAgZWFzZU91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcblxuICBlYXNlSW5PdXRCYWNrKHQ6IG51bWJlcikge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuXG4gIGVhc2VJbkJvdW5jZTogKHQ6IG51bWJlcikgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG5cbiAgZWFzZU91dEJvdW5jZSh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcblxuICBlYXNlSW5PdXRCb3VuY2U6ICh0OiBudW1iZXIpID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIEVhc2luZ0Z1bmN0aW9uID0ga2V5b2YgdHlwZW9mIGVmZmVjdHNcblxuZXhwb3J0IGRlZmF1bHQgZWZmZWN0cztcbiIsImltcG9ydCB7Q29sb3J9IGZyb20gJ0BrdXJrbGUvY29sb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIENhbnZhc1BhdHRlcm4gfCBDYW52YXNHcmFkaWVudCB7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJyB8fCB0eXBlID09PSAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWU6IENhbnZhc0dyYWRpZW50KTogQ2FudmFzR3JhZGllbnQ7XG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKFxuICB2YWx1ZTpcbiAgfCBzdHJpbmdcbiAgfCB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXI7IGE6IG51bWJlciB9XG4gIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdXG4gIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cbik6IENvbG9yO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogbmV3IENvbG9yKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc0dyYWRpZW50KTogQ2FudmFzR3JhZGllbnQ7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogQ2FudmFzUGF0dGVybik6IENhbnZhc1BhdHRlcm47XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogc3RyaW5nKTogc3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogbmV3IENvbG9yKHZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxuIiwiY29uc3QgbnVtYmVycyA9IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cycsICd0ZW5zaW9uJ107XG5jb25zdCBjb2xvcnMgPSBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JhY2tncm91bmRDb2xvciddO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlBbmltYXRpb25zRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdhbmltYXRpb24nLCB7XG4gICAgZGVsYXk6IHVuZGVmaW5lZCxcbiAgICBkdXJhdGlvbjogMTAwMCxcbiAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICAgIGZuOiB1bmRlZmluZWQsXG4gICAgZnJvbTogdW5kZWZpbmVkLFxuICAgIGxvb3A6IHVuZGVmaW5lZCxcbiAgICB0bzogdW5kZWZpbmVkLFxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbicsIHtcbiAgICBfZmFsbGJhY2s6IGZhbHNlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ29uUHJvZ3Jlc3MnICYmIG5hbWUgIT09ICdvbkNvbXBsZXRlJyAmJiBuYW1lICE9PSAnZm4nLFxuICB9KTtcblxuICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbnMnLCB7XG4gICAgY29sb3JzOiB7XG4gICAgICB0eXBlOiAnY29sb3InLFxuICAgICAgcHJvcGVydGllczogY29sb3JzXG4gICAgfSxcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IG51bWJlcnNcbiAgICB9LFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9ucycsIHtcbiAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nLFxuICB9KTtcblxuICBkZWZhdWx0cy5zZXQoJ3RyYW5zaXRpb25zJywge1xuICAgIGFjdGl2ZToge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGR1cmF0aW9uOiA0MDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2l6ZToge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93OiB7XG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIGNvbG9yczoge1xuICAgICAgICAgIGZyb206ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkdXJhdGlvbjogMCAvLyBzaG93IGltbWVkaWF0ZWx5XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSxcbiAgICBoaWRlOiB7XG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIGNvbG9yczoge1xuICAgICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgICBmbjogdiA9PiB2IHwgMCAvLyBmb3Iga2VlcGluZyB0aGUgZGF0YXNldCB2aXNpYmxlIGFsbCB0aGUgd2F5IHRocm91Z2ggdGhlIGFuaW1hdGlvblxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYXBwbHlMYXlvdXRzRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gICAgYXV0b1BhZGRpbmc6IHRydWUsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfVxuICB9KTtcbn1cbiIsIlxuY29uc3QgaW50bENhY2hlID0gbmV3IE1hcDxzdHJpbmcsIEludGwuTnVtYmVyRm9ybWF0PigpO1xuXG5mdW5jdGlvbiBnZXROdW1iZXJGb3JtYXQobG9jYWxlOiBzdHJpbmcsIG9wdGlvbnM/OiBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtOiBudW1iZXIsIGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cbiIsImltcG9ydCB7aXNBcnJheX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7bG9nMTB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3NcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3MuZm9ybWF0dGVyc1xuICovXG5jb25zdCBmb3JtYXR0ZXJzID0ge1xuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciB2YWx1ZSBsYWJlbHNcbiAgICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLnZhbHVlc1xuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGRpc3BsYXlcbiAgICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfSB0aGUgbGFiZWwgdG8gZGlzcGxheVxuICAgKi9cbiAgdmFsdWVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi8gKHZhbHVlKSA6ICcnICsgdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgbnVtZXJpYyB0aWNrc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcbiAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcbiAgICogQHBhcmFtIHRpY2tzIHtvYmplY3RbXX0gdGhlIGxpc3Qgb2YgdGlja3MgYmVpbmcgY29udmVydGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXG4gICAqL1xuICBudW1lcmljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJzsgLy8gbmV2ZXIgc2hvdyBkZWNpbWFsIHBsYWNlcyBmb3IgMFxuICAgIH1cblxuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGU7XG4gICAgbGV0IG5vdGF0aW9uO1xuICAgIGxldCBkZWx0YSA9IHRpY2tWYWx1ZTsgLy8gVGhpcyBpcyB1c2VkIHdoZW4gdGhlcmUgYXJlIGxlc3MgdGhhbiAyIHRpY2tzIGFzIHRoZSB0aWNrIGludGVydmFsLlxuXG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGFsbCB0aWNrcyBhcmUgc21hbGwgb3IgdGhlcmUgaHVnZSBudW1iZXJzOyB1c2Ugc2NpZW50aWZpYyBub3RhdGlvblxuICAgICAgY29uc3QgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdLnZhbHVlKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgIGlmIChtYXhUaWNrIDwgMWUtNCB8fCBtYXhUaWNrID4gMWUrMTUpIHtcbiAgICAgICAgbm90YXRpb24gPSAnc2NpZW50aWZpYyc7XG4gICAgICB9XG5cbiAgICAgIGRlbHRhID0gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcyk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuXG4gICAgLy8gV2hlbiBkYXRhc2V0cyBoYXZlIHZhbHVlcyBhcHByb2FjaGluZyBOdW1iZXIuTUFYX1ZBTFVFLCB0aGUgdGljayBjYWxjdWxhdGlvbnMgbWlnaHQgcmVzdWx0IGluXG4gICAgLy8gaW5maW5pdHkgYW5kIGV2ZW50dWFsbHkgTmFOLiBQYXNzaW5nIE5hTiBmb3IgbWluaW11bUZyYWN0aW9uRGlnaXRzIG9yIG1heGltdW1GcmFjdGlvbkRpZ2l0c1xuICAgIC8vIHdpbGwgbWFrZSB0aGUgbnVtYmVyIGZvcm1hdHRlciB0aHJvdy4gU28gaW5zdGVhZCB3ZSBjaGVjayBmb3IgaXNOYU4gYW5kIHVzZSBhIGZhbGxiYWNrIHZhbHVlLlxuICAgIC8vXG4gICAgLy8gdG9GaXhlZCBoYXMgYSBtYXggb2YgMjAgZGVjaW1hbCBwbGFjZXNcbiAgICBjb25zdCBudW1EZWNpbWFsID0gaXNOYU4obG9nRGVsdGEpID8gMSA6IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSksIDIwKSwgMCk7XG5cbiAgICBjb25zdCBvcHRpb25zID0ge25vdGF0aW9uLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWwsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbH07XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcblxuICAgIHJldHVybiBmb3JtYXROdW1iZXIodGlja1ZhbHVlLCBsb2NhbGUsIG9wdGlvbnMpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgbG9nYXJpdGhtaWMgdGlja3NcbiAgICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXG4gICAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuICAgKiBAcGFyYW0gdGlja3Mge29iamVjdFtdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcbiAgICovXG4gIGxvZ2FyaXRobWljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgcmVtYWluID0gdGlja3NbaW5kZXhdLnNpZ25pZmljYW5kIHx8ICh0aWNrVmFsdWUgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbHVlKSkpKSk7XG4gICAgaWYgKFsxLCAyLCAzLCA1LCAxMCwgMTVdLmluY2x1ZGVzKHJlbWFpbikgfHwgaW5kZXggPiAwLjggKiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWVyaWMuY2FsbCh0aGlzLCB0aWNrVmFsdWUsIGluZGV4LCB0aWNrcyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG59O1xuXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpIHtcbiAgLy8gRmlndXJlIG91dCBob3cgbWFueSBkaWdpdHMgdG8gc2hvd1xuICAvLyBUaGUgc3BhY2UgYmV0d2VlbiB0aGUgZmlyc3QgdHdvIHRpY2tzIG1pZ2h0IGJlIHNtYWxsZXIgdGhhbiBub3JtYWwgc3BhY2luZ1xuICBsZXQgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0udmFsdWUgLSB0aWNrc1sxXS52YWx1ZSA6IHRpY2tzWzFdLnZhbHVlIC0gdGlja3NbMF0udmFsdWU7XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIG51bWJlciBsaWtlIDIuNSBhcyB0aGUgZGVsdGEsIGZpZ3VyZSBvdXQgaG93IG1hbnkgZGVjaW1hbCBwbGFjZXMgd2UgbmVlZFxuICBpZiAoTWF0aC5hYnMoZGVsdGEpID49IDEgJiYgdGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcbiAgICAvLyBub3QgYW4gaW50ZWdlclxuICAgIGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuLyoqXG4gKiBOYW1lc3BhY2UgdG8gaG9sZCBzdGF0aWMgdGljayBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrc1xuICovXG5leHBvcnQgZGVmYXVsdCB7Zm9ybWF0dGVyc307XG4iLCJpbXBvcnQgVGlja3MgZnJvbSAnLi9jb3JlLnRpY2tzLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2NhbGVEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICBiZWdpbkF0WmVybzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICd0aWNrcycsXG5cbiAgICBjbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gZ3JhY2UgYWRkZWQgdG8gbWF4IGFuZCByZWR1Y2VkIGZyb20gbWluIGRhdGEgdmFsdWUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICovXG4gICAgZ3JhY2U6IDAsXG5cbiAgICAvLyBncmlkIGxpbmUgc2V0dGluZ3NcbiAgICBncmlkOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgICAgdGlja0xlbmd0aDogOCxcbiAgICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgfSxcblxuICAgIGJvcmRlcjoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGRhc2g6IFtdLFxuICAgICAgZGFzaE9mZnNldDogMC4wLFxuICAgICAgd2lkdGg6IDFcbiAgICB9LFxuXG4gICAgLy8gc2NhbGUgdGl0bGVcbiAgICB0aXRsZToge1xuICAgICAgLy8gZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgZGlzcGxheTogZmFsc2UsXG5cbiAgICAgIC8vIGFjdHVhbCBsYWJlbFxuICAgICAgdGV4dDogJycsXG5cbiAgICAgIC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDQsXG4gICAgICAgIGJvdHRvbTogNFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgIG1pcnJvcjogZmFsc2UsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgICAgcGFkZGluZzogMyxcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgLy8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgICBtaW5vcjoge30sXG4gICAgICBtYWpvcjoge30sXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBjcm9zc0FsaWduOiAnbmVhcicsXG5cbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ib3JkZXInLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2Rhc2gnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICAgIF9mYWxsYmFjazogJ3NjYWxlJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG4gIH0pO1xufVxuIiwiaW1wb3J0IHtnZXRIb3ZlckNvbG9yfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sb3IuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgbWVyZ2UsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2FwcGx5QW5pbWF0aW9uc0RlZmF1bHRzfSBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2FwcGx5TGF5b3V0c0RlZmF1bHRzfSBmcm9tICcuL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2FwcGx5U2NhbGVEZWZhdWx0c30gZnJvbSAnLi9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzJztcblxuZXhwb3J0IGNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5leHBvcnQgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNjb3BlKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUocm9vdCwgJycpLCBzY29wZSk7XG59XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0cyB7XG4gIGNvbnN0cnVjdG9yKF9kZXNjcmlwdG9ycywgX2FwcGxpZXJzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVJbnZpc2libGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMub25Ib3ZlciA9IG51bGw7XG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuXG4gICAgdGhpcy5kZXNjcmliZShfZGVzY3JpcHRvcnMpO1xuICAgIHRoaXMuYXBwbHkoX2FwcGxpZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNjb3BlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXVxuXHQgKi9cbiAgc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZVxuXHQgKi9cbiAgZ2V0KHNjb3BlKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNjb3BlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXVxuXHQgKi9cbiAgZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQoZGVzY3JpcHRvcnMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSb3V0ZXMgdGhlIG5hbWVkIGRlZmF1bHRzIHRvIGZhbGxiYWNrIHRvIGFub3RoZXIgc2NvcGUvbmFtZS5cblx0ICogVGhpcyByb3V0aW5nIGlzIHVzZWZ1bCB3aGVuIHRob3NlIHRhcmdldCB2YWx1ZXMsIGxpa2UgZGVmYXVsdHMuY29sb3IsIGFyZSBjaGFuZ2VkIHJ1bnRpbWUuXG5cdCAqIElmIHRoZSB2YWx1ZXMgd291bGQgYmUgY29waWVkLCB0aGUgcnVudGltZSBjaGFuZ2Ugd291bGQgbm90IHRha2UgZWZmZWN0LiBCeSByb3V0aW5nLCB0aGVcblx0ICogZmFsbGJhY2sgaXMgZXZhbHVhdGVkIGF0IGVhY2ggYWNjZXNzLCBzbyBpdHMgYWx3YXlzIHVwIHRvIGRhdGUuXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqXG5cdCAqIFx0ZGVmYXVsdHMucm91dGUoJ2VsZW1lbnRzLmFyYycsICdiYWNrZ3JvdW5kQ29sb3InLCAnJywgJ2NvbG9yJylcblx0ICogICAtIHJlYWRzIHRoZSBiYWNrZ3JvdW5kQ29sb3IgZnJvbSBkZWZhdWx0cy5jb2xvciB3aGVuIHVuZGVmaW5lZCBsb2NhbGx5XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSBTY29wZSB0aGlzIHJvdXRlIGFwcGxpZXMgdG8uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWUgdGhhdCBzaG91bGQgYmUgcm91dGVkIHRvIGRpZmZlcmVudCBuYW1lc3BhY2Ugd2hlbiBub3QgZGVmaW5lZCBoZXJlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0U2NvcGUgVGhlIG5hbWVzcGFjZSB3aGVyZSB0aG9zZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqIEVtcHR5IHN0cmluZyAoJycpIGlzIHRoZSByb290IG9mIGRlZmF1bHRzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0TmFtZSBUaGUgdGFyZ2V0IG5hbWUgaW4gdGhlIHRhcmdldCBzY29wZSB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJvdXRlZCB0by5cblx0ICovXG4gIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUodGhpcywgc2NvcGUpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gJ18nICsgbmFtZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICAvLyBBIHByaXZhdGUgcHJvcGVydHkgaXMgZGVmaW5lZCB0byBob2xkIHRoZSBhY3R1YWwgdmFsdWUsIHdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgaW4gaXRzIHNjb3BlIChzZXQgaW4gdGhlIHNldHRlcilcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcbiAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIC8vIFRoZSBhY3R1YWwgcHJvcGVydHkgaXMgZGVmaW5lZCBhcyBnZXR0ZXIvc2V0dGVyIHNvIHdlIGNhbiBkbyB0aGUgcm91dGluZyB3aGVuIHZhbHVlIGlzIG5vdCBsb2NhbGx5IHNldC5cbiAgICAgIFtuYW1lXToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzW3ByaXZhdGVOYW1lXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXBwbHkoYXBwbGllcnMpIHtcbiAgICBhcHBsaWVycy5mb3JFYWNoKChhcHBseSkgPT4gYXBwbHkodGhpcykpO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBEZWZhdWx0cyh7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdldmVudHMnLFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogJ2ludGVyYWN0aW9uJ1xuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfVxufSwgW2FwcGx5QW5pbWF0aW9uc0RlZmF1bHRzLCBhcHBseUxheW91dHNEZWZhdWx0cywgYXBwbHlTY2FsZURlZmF1bHRzXSk7XG4iLCJpbXBvcnQgdHlwZSB7XG4gIENoYXJ0LFxuICBQb2ludCxcbiAgRm9udFNwZWMsXG4gIENhbnZhc0ZvbnRTcGVjLFxuICBQb2ludFN0eWxlLFxuICBSZW5kZXJUZXh0T3B0cyxcbiAgQmFja2Ryb3BPcHRpb25zXG59IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtcbiAgVFJCTCxcbiAgU3BsaW5lUG9pbnQsXG4gIFJvdW5kZWRSZWN0LFxuICBUUkJMQ29ybmVyc1xufSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc051bGxPclVuZGVmfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge1BJLCBUQVUsIEhBTEZfUEksIFFVQVJURVJfUEksIFRXT19USElSRFNfUEksIFJBRF9QRVJfREVHfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgb2JqZWN0IGludG8gYSBDU1MgZm9udCBzdHJpbmcuXG4gKiBAcGFyYW0gZm9udCAtIEEgZm9udCBvYmplY3QuXG4gKiBAcmV0dXJuIFRoZSBDU1MgZm9udCBzdHJpbmcuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250OiBGb250U3BlYykge1xuICBpZiAoIWZvbnQgfHwgaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKGZvbnQuc3R5bGUgPyBmb250LnN0eWxlICsgJyAnIDogJycpXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcblx0XHQrIGZvbnQuZmFtaWx5O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVhc3VyZVRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICBnYzogc3RyaW5nW10sXG4gIGxvbmdlc3Q6IG51bWJlcixcbiAgc3RyaW5nOiBzdHJpbmdcbikge1xuICBsZXQgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddO1xuICBpZiAoIXRleHRXaWR0aCkge1xuICAgIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuICAgIGdjLnB1c2goc3RyaW5nKTtcbiAgfVxuICBpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuICAgIGxvbmdlc3QgPSB0ZXh0V2lkdGg7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5cbnR5cGUgVGhpbmcgPSBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsXG50eXBlIFRoaW5ncyA9IChUaGluZyB8IFRoaW5nW10pW11cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIF9sb25nZXN0VGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGZvbnQ6IHN0cmluZyxcbiAgYXJyYXlPZlRoaW5nczogVGhpbmdzLFxuICBjYWNoZT86IHtkYXRhPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgZ2FyYmFnZUNvbGxlY3Q/OiBzdHJpbmdbXSwgZm9udD86IHN0cmluZ31cbikge1xuICBjYWNoZSA9IGNhY2hlIHx8IHt9O1xuICBsZXQgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuICBsZXQgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xuXG4gIGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG4gICAgZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcbiAgICBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XG4gICAgY2FjaGUuZm9udCA9IGZvbnQ7XG4gIH1cblxuICBjdHguc2F2ZSgpO1xuXG4gIGN0eC5mb250ID0gZm9udDtcbiAgbGV0IGxvbmdlc3QgPSAwO1xuICBjb25zdCBpbGVuID0gYXJyYXlPZlRoaW5ncy5sZW5ndGg7XG4gIGxldCBpOiBudW1iZXIsIGo6IG51bWJlciwgamxlbjogbnVtYmVyLCB0aGluZzogVGhpbmcgfCBUaGluZ1tdLCBuZXN0ZWRUaGluZzogVGhpbmcgfCBUaGluZ1tdO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdGhpbmcgPSBhcnJheU9mVGhpbmdzW2ldO1xuXG4gICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgaWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkodGhpbmcpKSB7XG4gICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpbmcpKSB7XG4gICAgICAvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXRzIG1lYXN1cmUgZWFjaCBlbGVtZW50XG4gICAgICAvLyB0byBkbyBtYXliZSBzaW1wbGlmeSB0aGlzIGZ1bmN0aW9uIGEgYml0IHNvIHdlIGNhbiBkbyB0aGlzIG1vcmUgcmVjdXJzaXZlbHk/XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIG5lc3RlZFRoaW5nID0gdGhpbmdbal07XG4gICAgICAgIC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgICBpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheShuZXN0ZWRUaGluZykpIHtcbiAgICAgICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIG5lc3RlZFRoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN0eC5yZXN0b3JlKCk7XG5cbiAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICBpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XG4gICAgICBkZWxldGUgZGF0YVtnY1tpXV07XG4gICAgfVxuICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWxpZ25lZCBwaXhlbCB2YWx1ZSB0byBhdm9pZCBhbnRpLWFsaWFzaW5nIGJsdXJcbiAqIEBwYXJhbSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBwaXhlbCAtIEEgcGl4ZWwgdmFsdWUuXG4gKiBAcGFyYW0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcmV0dXJucyBUaGUgYWxpZ25lZCBwaXhlbCB2YWx1ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydDogQ2hhcnQsIHBpeGVsOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAhPT0gMCA/IE1hdGgubWF4KHdpZHRoIC8gMiwgMC41KSA6IDA7XG4gIHJldHVybiBNYXRoLnJvdW5kKChwaXhlbCAtIGhhbGZXaWR0aCkgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBoYWxmV2lkdGg7XG59XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBlbnRpcmUgY2FudmFzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzPzogSFRNTENhbnZhc0VsZW1lbnQsIGN0eD86IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICBpZiAoIWN0eCAmJiAhY2FudmFzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIGN0eC5zYXZlKCk7XG4gIC8vIGNhbnZhcy53aWR0aCBhbmQgY2FudmFzLmhlaWdodCBkbyBub3QgY29uc2lkZXIgdGhlIGNhbnZhcyB0cmFuc2Zvcm0sXG4gIC8vIHdoaWxlIGNsZWFyUmVjdCBkb2VzXG4gIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJhd1BvaW50T3B0aW9ucyB7XG4gIHBvaW50U3R5bGU6IFBvaW50U3R5bGU7XG4gIHJvdGF0aW9uPzogbnVtYmVyO1xuICByYWRpdXM6IG51bWJlcjtcbiAgYm9yZGVyV2lkdGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdQb2ludChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIG9wdGlvbnM6IERyYXdQb2ludE9wdGlvbnMsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyXG4pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCBudWxsKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBkcmF3UG9pbnRMZWdlbmQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBvcHRpb25zOiBEcmF3UG9pbnRPcHRpb25zLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgdzogbnVtYmVyXG4pIHtcbiAgbGV0IHR5cGU6IHN0cmluZywgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlciwgY29ybmVyUmFkaXVzOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIHhPZmZzZXRXOiBudW1iZXIsIHlPZmZzZXRXOiBudW1iZXI7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG5cbiAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnJvdGF0ZShyYWQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzdHlsZSwgLXN0eWxlLndpZHRoIC8gMiwgLXN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBzd2l0Y2ggKHN0eWxlKSB7XG4gIC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIGN0eC5lbGxpcHNlKHgsIHksIHcgLyAyLCByYWRpdXMsIDAsIDAsIFRBVSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogcmFkaXVzO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3RSb3VuZGVkJzpcbiAgICAvLyBOT1RFOiB0aGUgcm91bmRlZCByZWN0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgdG8gdXNlIGBhcmNgIGluc3RlYWQgb2ZcbiAgICAvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xuICAgIC8vIGFsbW9zdCBhIGNpcmNsZS4gMC41MTYgKGluc3RlYWQgb2YgMC41KSBwcm9kdWNlcyByZXN1bHRzIHdpdGggdmlzdWFsbHlcbiAgICAvLyBjbG9zZXIgcHJvcG9ydGlvbiB0byB0aGUgcHJldmlvdXMgaW1wbCBhbmQgaXQgaXMgaW5zY3JpYmVkIGluIHRoZVxuICAgIC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU1OTdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTg1OFxuICAgICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqICh3ID8gdyAvIDIgLSBjb3JuZXJSYWRpdXMgOiBzaXplKTtcbiAgICAgIGN0eC5hcmMoeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcbiAgICAgIGN0eC5hcmMoeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3QnOlxuICAgICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHNpemU7XG4gICAgICAgIGN0eC5yZWN0KHggLSB3aWR0aCwgeSAtIHNpemUsIDIgKiB3aWR0aCwgMiAqIHNpemUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdyZWN0Um90JzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdjcm9zcyc6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzdGFyJzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGluZSc6XG4gICAgICB4T2Zmc2V0ID0gdyA/IHcgLyAyIDogTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGFzaCc6XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZhbHNlOlxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBjdHguZmlsbCgpO1xuICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIGFyZWEgLSBUaGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gbWFyZ2luIC0gYWxsb3dlZCBtYXJnaW5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNQb2ludEluQXJlYShcbiAgcG9pbnQ6IFBvaW50LFxuICBhcmVhOiBUUkJMLFxuICBtYXJnaW4/OiBudW1iZXJcbikge1xuICBtYXJnaW4gPSBtYXJnaW4gfHwgMC41OyAvLyBtYXJnaW4gLSBkZWZhdWx0IGlzIHRvIG1hdGNoIHJvdW5kZWQgZGVjaW1hbHNcblxuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcblx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBtYXJnaW4gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgbWFyZ2luKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBBcmVhKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhcmVhOiBUUkJMKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmNsaXBBcmVhKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcHJldmlvdXM6IFBvaW50LFxuICB0YXJnZXQ6IFBvaW50LFxuICBmbGlwPzogYm9vbGVhbixcbiAgbW9kZT86IHN0cmluZ1xuKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgIGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JlemllckN1cnZlVG8oXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBwcmV2aW91czogU3BsaW5lUG9pbnQsXG4gIHRhcmdldDogU3BsaW5lUG9pbnQsXG4gIGZsaXA/OiBib29sZWFuXG4pIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSxcbiAgICB0YXJnZXQueCxcbiAgICB0YXJnZXQueSk7XG59XG5cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9wdHM6IFJlbmRlclRleHRPcHRzKSB7XG4gIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gIH1cblxuICBpZiAob3B0cy5jb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xuICB9XG5cbiAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICB9XG5cbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBsaW5lOiBzdHJpbmcsXG4gIG9wdHM6IFJlbmRlclRleHRPcHRzXG4pIHtcbiAgaWYgKG9wdHMuc3RyaWtldGhyb3VnaCB8fCBvcHRzLnVuZGVybGluZSkge1xuICAgIC8qKlxuICAgICAqIE5vdyB0aGF0IElFMTEgc3VwcG9ydCBoYXMgYmVlbiBkcm9wcGVkLCB3ZSBjYW4gdXNlIG1vcmVcbiAgICAgKiBvZiB0aGUgVGV4dE1ldHJpY3Mgb2JqZWN0LiBUaGUgYWN0dWFsIGJvdW5kaW5nIGJveGVzXG4gICAgICogYXJlIHVuZmxhZ2dlZCBpbiBDaHJvbWUsIEZpcmVmb3gsIEVkZ2UsIGFuZCBTYWZhcmkgc28gdGhleVxuICAgICAqIGNhbiBiZSBzYWZlbHkgdXNlZC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRNZXRyaWNzI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgICAqL1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQobGluZSk7XG4gICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICBjb25zdCByaWdodCA9IHggKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XG4gICAgY29uc3QgdG9wID0geSAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgIGNvbnN0IHlEZWNvcmF0aW9uID0gb3B0cy5zdHJpa2V0aHJvdWdoID8gKHRvcCArIGJvdHRvbSkgLyAyIDogYm90dG9tO1xuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3QmFja2Ryb3AoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9wdHM6IEJhY2tkcm9wT3B0aW9ucykge1xuICBjb25zdCBvbGRDb2xvciA9IGN0eC5maWxsU3R5bGU7XG5cbiAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3IgYXMgc3RyaW5nO1xuICBjdHguZmlsbFJlY3Qob3B0cy5sZWZ0LCBvcHRzLnRvcCwgb3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICBjdHguZmlsbFN0eWxlID0gb2xkQ29sb3I7XG59XG5cbi8qKlxuICogUmVuZGVyIHRleHQgb250byB0aGUgY2FudmFzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgdGV4dDogc3RyaW5nIHwgc3RyaW5nW10sXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBmb250OiBDYW52YXNGb250U3BlYyxcbiAgb3B0czogUmVuZGVyVGV4dE9wdHMgPSB7fVxuKSB7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF07XG4gIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICBsZXQgaTogbnVtYmVyLCBsaW5lOiBzdHJpbmc7XG5cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgIGlmIChvcHRzLmJhY2tkcm9wKSB7XG4gICAgICBkcmF3QmFja2Ryb3AoY3R4LCBvcHRzLmJhY2tkcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5zdHJva2VXaWR0aCkpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIH1cblxuICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcblxuICAgIHkgKz0gTnVtYmVyKGZvbnQubGluZUhlaWdodCk7XG4gIH1cblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0gcmVjdCAtIEJvdW5kaW5nIHJlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFJvdW5kZWRSZWN0UGF0aChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHJlY3Q6IFJvdW5kZWRSZWN0ICYgeyByYWRpdXM6IFRSQkxDb3JuZXJzIH1cbikge1xuICBjb25zdCB7eCwgeSwgdywgaCwgcmFkaXVzfSA9IHJlY3Q7XG5cbiAgLy8gdG9wIGxlZnQgYXJjXG4gIGN0eC5hcmMoeCArIHJhZGl1cy50b3BMZWZ0LCB5ICsgcmFkaXVzLnRvcExlZnQsIHJhZGl1cy50b3BMZWZ0LCAxLjUgKiBQSSwgUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gbGVmdFxuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuXG4gIC8vIGJvdHRvbSBsZWZ0IGFyY1xuICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gYm90dG9tIGxlZnQgdG8gYm90dG9tIHJpZ2h0XG4gIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoKTtcblxuICAvLyBib3R0b20gcmlnaHQgYXJjXG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSBib3R0b20gcmlnaHQgdG8gdG9wIHJpZ2h0XG4gIGN0eC5saW5lVG8oeCArIHcsIHkgKyByYWRpdXMudG9wUmlnaHQpO1xuXG4gIC8vIHRvcCByaWdodCBhcmNcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy50b3BSaWdodCwgeSArIHJhZGl1cy50b3BSaWdodCwgcmFkaXVzLnRvcFJpZ2h0LCAwLCAtSEFMRl9QSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIHRvcCByaWdodCB0byB0b3AgbGVmdFxuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3QsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0ZvbnRTdHJpbmd9IGZyb20gJy4vaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0QXJlYSwgRm9udFNwZWMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7VFJCTCwgVFJCTENvcm5lcnN9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC87XG5jb25zdCBGT05UX1NUWUxFID0gL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC87XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMub3B0aW9uc1xuICogQG5hbWVzcGFjZVxuICovXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBsaW5lIGhlaWdodCBgdmFsdWVgIGluIHBpeGVscyBmb3IgYSBzcGVjaWZpYyBmb250IGBzaXplYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBsaW5lSGVpZ2h0IHRvIHBhcnNlIChlZy4gMS42LCAnMTRweCcsICc3NSUnLCAnMS42ZW0nKS5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cbiAqIEByZXR1cm5zIFRoZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgaW4gcGl4ZWxzIChzaXplICogMS4yIGlmIHZhbHVlIGlzIGludmFsaWQpLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGluZS1oZWlnaHRcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9MaW5lSGVpZ2h0KHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcbiAgICByZXR1cm4gc2l6ZSAqIDEuMjtcbiAgfVxuXG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG5cbiAgc3dpdGNoIChtYXRjaGVzWzNdKSB7XG4gICAgY2FzZSAncHgnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNhc2UgJyUnOlxuICAgICAgdmFsdWUgLz0gMTAwO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cblxuY29uc3QgbnVtYmVyT3JaZXJvID0gKHY6IHVua25vd24pID0+ICt2IHx8IDA7XG5cbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzPEsgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8SywgbnVtYmVyPiwgcHJvcHM6IEtbXSk6IFJlY29yZDxLLCBudW1iZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzPEsgZXh0ZW5kcyBzdHJpbmcsIFQgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8SyAmIFQsIG51bWJlcj4sIHByb3BzOiBSZWNvcmQ8VCwgSz4pOiBSZWNvcmQ8VCwgbnVtYmVyPjtcbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgcHJvcHM6IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY29uc3Qgb2JqUHJvcHMgPSBpc09iamVjdChwcm9wcyk7XG4gIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXG4gICAgPyBvYmpQcm9wc1xuICAgICAgPyBwcm9wID0+IHZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cbiAgICA6ICgpID0+IHZhbHVlO1xuXG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvKHJlYWQocHJvcCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KVxuICogQHNpbmNlIDMuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1RSQkwodmFsdWU6IG51bWJlciB8IFRSQkwgfCBQb2ludCkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgVFJCTCBjb3JuZXJzIG9iamVjdCAoc2ltaWxhciB3aXRoIGNzcyBib3JkZXItcmFkaXVzKS5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvcm5lciBjb21wb25lbnRzLFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogQHJldHVybnMgVGhlIFRSQkwgY29ybmVyIHZhbHVlcyAodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KVxuICogQHNpbmNlIDMuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlOiBudW1iZXIgfCBUUkJMQ29ybmVycykge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgcGFkZGluZyBvYmplY3Qgd2l0aCBwcmUtY29tcHV0ZWQgd2lkdGgvaGVpZ2h0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUGFkZGluZyh2YWx1ZT86IG51bWJlciB8IFRSQkwpOiBDaGFydEFyZWEge1xuICBjb25zdCBvYmogPSB0b1RSQkwodmFsdWUpIGFzIENoYXJ0QXJlYTtcblxuICBvYmoud2lkdGggPSBvYmoubGVmdCArIG9iai5yaWdodDtcbiAgb2JqLmhlaWdodCA9IG9iai50b3AgKyBvYmouYm90dG9tO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUGFyc2VzIGZvbnQgb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgZm9udCBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZm9udCBvcHRpb25zIHRvIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSBmYWxsYmFjayAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZmFsbGJhY2sgZm9udCBvcHRpb25zLlxuICogQHJldHVybiBUaGUgZm9udCBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0ZvbnQob3B0aW9uczogUGFydGlhbDxGb250U3BlYz4sIGZhbGxiYWNrPzogUGFydGlhbDxGb250U3BlYz4pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udCBhcyBGb250U3BlYztcblxuICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG5cbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gIH1cbiAgbGV0IHN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zdHlsZSwgZmFsbGJhY2suc3R5bGUpO1xuICBpZiAoc3R5bGUgJiYgISgnJyArIHN0eWxlKS5tYXRjaChGT05UX1NUWUxFKSkge1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgc3R5bGUgKyAnXCInKTtcbiAgICBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGZvbnQgPSB7XG4gICAgZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZhbWlseSwgZmFsbGJhY2suZmFtaWx5KSxcbiAgICBsaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBmYWxsYmFjay5saW5lSGVpZ2h0KSwgc2l6ZSksXG4gICAgc2l6ZSxcbiAgICBzdHlsZSxcbiAgICB3ZWlnaHQ6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMud2VpZ2h0LCBmYWxsYmFjay53ZWlnaHQpLFxuICAgIHN0cmluZzogJydcbiAgfTtcblxuICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgcmV0dXJuIGZvbnQ7XG59XG5cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBnaXZlbiBgaW5wdXRzYCBzZXF1ZW50aWFsbHkgYW5kIHJldHVybnMgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWUuXG4gKiBAcGFyYW0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxuICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cbiAqIEBwYXJhbSBpbmRleCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGFuIGFycmF5LCB0aGUgdmFsdWVcbiAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5mbyAtIG9iamVjdCB0byByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgcmVzb2x1dGlvbiBpblxuICogQHBhcmFtIGluZm8uY2FjaGVhYmxlIC0gV2lsbCBiZSBzZXQgdG8gYGZhbHNlYCBpZiBvcHRpb24gaXMgbm90IGNhY2hlYWJsZS5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShpbnB1dHM6IEFycmF5PHVua25vd24+LCBjb250ZXh0Pzogb2JqZWN0LCBpbmRleD86IG51bWJlciwgaW5mbz86IHsgY2FjaGVhYmxlOiBib29sZWFuIH0pIHtcbiAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgdmFsdWU6IHVua25vd247XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGlucHV0c1tpXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICBpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBtaW5tYXhcbiAqIEBwYXJhbSBncmFjZVxuICogQHBhcmFtIGJlZ2luQXRaZXJvXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heDogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXI7IH0sIGdyYWNlOiBudW1iZXIgfCBzdHJpbmcsIGJlZ2luQXRaZXJvOiBib29sZWFuKSB7XG4gIGNvbnN0IHttaW4sIG1heH0gPSBtaW5tYXg7XG4gIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xuICBjb25zdCBrZWVwWmVybyA9ICh2YWx1ZTogbnVtYmVyLCBhZGQ6IG51bWJlcikgPT4gYmVnaW5BdFplcm8gJiYgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUgKyBhZGQ7XG4gIHJldHVybiB7XG4gICAgbWluOiBrZWVwWmVybyhtaW4sIC1NYXRoLmFicyhjaGFuZ2UpKSxcbiAgICBtYXg6IGtlZXBaZXJvKG1heCwgY2hhbmdlKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnRleHQgaW5oZXJpdGluZyBwYXJlbnRDb250ZXh0XG4gKiBAcGFyYW0gcGFyZW50Q29udGV4dFxuICogQHBhcmFtIGNvbnRleHRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0PFQgZXh0ZW5kcyBvYmplY3Q+KHBhcmVudENvbnRleHQ6IG51bGwsIGNvbnRleHQ6IFQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQ8VCBleHRlbmRzIG9iamVjdCwgUCBleHRlbmRzIFQ+KHBhcmVudENvbnRleHQ6IFAsIGNvbnRleHQ6IFQpOiBQICYgVDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KHBhcmVudENvbnRleHQ6IG9iamVjdCwgY29udGV4dDogb2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCksIGNvbnRleHQpO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRNZXRhfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlc29sdmVyT2JqZWN0S2V5LFxuICBSZXNvbHZlckNhY2hlLFxuICBSZXNvbHZlclByb3h5LFxuICBEZXNjcmlwdG9yRGVmYXVsdHMsXG4gIERlc2NyaXB0b3IsXG4gIENvbnRleHRDYWNoZSxcbiAgQ29udGV4dFByb3h5XG59IGZyb20gJy4vaGVscGVycy5jb25maWcudHlwZXMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcmVzb2x2ZU9iamVjdEtleSwgX2NhcGl0YWxpemV9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzLmNvbmZpZy50eXBlcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFByb3h5IGZvciByZXNvbHZpbmcgcmF3IHZhbHVlcyBmb3Igb3B0aW9ucy5cbiAqIEBwYXJhbSBzY29wZXMgLSBUaGUgb3B0aW9uIHNjb3BlcyB0byBsb29rIGZvciB2YWx1ZXMsIGluIHJlc29sdXRpb24gb3JkZXJcbiAqIEBwYXJhbSBwcmVmaXhlcyAtIFRoZSBwcmVmaXhlcyBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyLlxuICogQHBhcmFtIHJvb3RTY29wZXMgLSBUaGUgcm9vdCBvcHRpb24gc2NvcGVzXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBQYXJlbnQgc2NvcGVzIGZhbGxiYWNrXG4gKiBAcGFyYW0gZ2V0VGFyZ2V0IC0gY2FsbGJhY2sgZm9yIGdldHRpbmcgdGhlIHRhcmdldCBmb3IgY2hhbmdlZCB2YWx1ZXNcbiAqIEByZXR1cm5zIFByb3h5XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyPFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgc2NvcGVzOiBULFxuICBwcmVmaXhlcyA9IFsnJ10sXG4gIHJvb3RTY29wZXM/OiBSLFxuICBmYWxsYmFjaz86IFJlc29sdmVyT2JqZWN0S2V5LFxuICBnZXRUYXJnZXQgPSAoKSA9PiBzY29wZXNbMF1cbikge1xuICBjb25zdCBmaW5hbFJvb3RTY29wZXMgPSByb290U2NvcGVzIHx8IHNjb3BlcztcbiAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlOiBSZXNvbHZlckNhY2hlPFQsIFI+ID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3BlczogZmluYWxSb290U2NvcGVzLFxuICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgX2dldFRhcmdldDogZ2V0VGFyZ2V0LFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2NyZWF0ZVJlc29sdmVyKFtzY29wZSwgLi4uc2NvcGVzXSwgcHJlZml4ZXMsIGZpbmFsUm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdOyAvLyByZW1vdmUgZnJvbSB0b3AgbGV2ZWwgc2NvcGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCB0YXJnZXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLlxuICAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBoYXModGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqL1xuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcsIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0Ll9zdG9yYWdlIHx8ICh0YXJnZXQuX3N0b3JhZ2UgPSBnZXRUYXJnZXQoKSk7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7IC8vIHNldCB0byB0b3AgbGV2ZWwgc2NvcGUgKyBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIFJlc29sdmVyUHJveHk8VCwgUj47XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBQcm94eSBmb3IgcmVzb2x2aW5nIG9wdGlvbiB2YWx1ZXMgd2l0aCBjb250ZXh0LlxuICogQHBhcmFtIHByb3h5IC0gVGhlIFByb3h5IHJldHVybmVkIGJ5IGBfY3JlYXRlUmVzb2x2ZXJgXG4gKiBAcGFyYW0gY29udGV4dCAtIENvbnRleHQgb2JqZWN0IGZvciBzY3JpcHRhYmxlL2luZGV4YWJsZSBvcHRpb25zXG4gKiBAcGFyYW0gc3ViUHJveHkgLSBUaGUgcHJveHkgcHJvdmlkZWQgZm9yIHNjcmlwdGFibGUgb3B0aW9uc1xuICogQHBhcmFtIGRlc2NyaXB0b3JEZWZhdWx0cyAtIERlZmF1bHRzIGZvciBkZXNjcmlwdG9yc1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0PFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgcHJveHk6IFJlc29sdmVyUHJveHk8VCwgUj4sXG4gIGNvbnRleHQ6IEFueU9iamVjdCxcbiAgc3ViUHJveHk/OiBSZXNvbHZlclByb3h5PFQsIFI+LFxuICBkZXNjcmlwdG9yRGVmYXVsdHM/OiBEZXNjcmlwdG9yRGVmYXVsdHNcbikge1xuICBjb25zdCBjYWNoZTogQ29udGV4dENhY2hlPFQsIFI+ID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4OiBBbnlPYmplY3QpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIGRlbGV0ZSBwcm94eVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gcHJveHlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZywgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gcHJveHlcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIENvbnRleHRQcm94eTxULCBSPjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKFxuICBwcm94eTogUmVzb2x2ZXJDYWNoZSxcbiAgZGVmYXVsdHM6IERlc2NyaXB0b3JEZWZhdWx0cyA9IHtzY3JpcHRhYmxlOiB0cnVlLCBpbmRleGFibGU6IHRydWV9XG4pOiBEZXNjcmlwdG9yIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4OiBzdHJpbmcsIG5hbWU6IHN0cmluZykgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJyAmJlxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcblxuZnVuY3Rpb24gX2NhY2hlZChcbiAgdGFyZ2V0OiBBbnlPYmplY3QsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVzb2x2ZTogKCkgPT4gdW5rbm93blxuKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSB8fCBwcm9wID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICAvLyBjYWNoZSB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dChcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07IC8vIHJlc29sdmUgZnJvbSBwcm94eVxuXG4gIC8vIHJlc29sdmUgd2l0aCBjb250ZXh0XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFuIG9iamVjdCwgY3JlYXRlIGEgc3ViIHJlc29sdmVyIGZvciBpdFxuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUoXG4gIHByb3A6IHN0cmluZyxcbiAgZ2V0VmFsdWU6IChjdHg6IEFueU9iamVjdCwgc3ViOiBBbnlPYmplY3QpID0+IHVua25vd24sXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICByZWNlaXZlcjogQW55T2JqZWN0XG4pIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIGxldCB2YWx1ZSA9IGdldFZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICAvLyBXaGVuIHNjcmlwdGFibGUgb3B0aW9uIHJldHVybnMgYW4gb2JqZWN0LCBjcmVhdGUgYSByZXNvbHZlciBvbiB0aGF0LlxuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShcbiAgcHJvcDogc3RyaW5nLFxuICB2YWx1ZTogdW5rbm93bltdLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgaXNJbmRleGFibGU6IChrZXk6IHN0cmluZykgPT4gYm9vbGVhblxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuXG4gIGlmICh0eXBlb2YgX2NvbnRleHQuaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgcmV0dXJuIHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICAvLyBBcnJheSBvZiBvYmplY3RzLCByZXR1cm4gYXJyYXkgb3IgcmVzb2x2ZXJzXG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXkgfCAoKHByb3A6IFJlc29sdmVyT2JqZWN0S2V5LCB2YWx1ZTogdW5rbm93bikgPT4gUmVzb2x2ZXJPYmplY3RLZXkpLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cblxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5OiBSZXNvbHZlck9iamVjdEtleSwgcGFyZW50OiBBbnlPYmplY3QpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlcyhcbiAgc2V0OiBTZXQ8QW55T2JqZWN0PixcbiAgcGFyZW50U2NvcGVzOiBBbnlPYmplY3RbXSxcbiAga2V5OiBSZXNvbHZlck9iamVjdEtleSxcbiAgcGFyZW50RmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5LFxuICB2YWx1ZTogdW5rbm93blxuKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgYSBuZXcgX2ZhbGxiYWNrLCByZXR1cm4gdGhhdC5cbiAgICAgICAgLy8gVGhlIGZhbGxiYWNrIHdpbGwgcmVzdW1lIHRvIHRoYXQgbmV3IHNjb3BlLlxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgdHlwZW9mIHBhcmVudEZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBgZmFsc2VgIHJlc3VsdHMgdG8gYGZhbHNlYCwgd2hlbiBmYWxsaW5nIGJhY2sgdG8gZGlmZmVyZW50IGtleS5cbiAgICAgIC8vIEZvciBleGFtcGxlIGBpbnRlcmFjdGlvbmAgZnJvbSBgaG92ZXJgIG9yIGBwbHVnaW5zLnRvb2x0aXBgIGFuZCBgYW5pbWF0aW9uYCBmcm9tIGBhbmltYXRpb25zYFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIoXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxBbnlPYmplY3Q+KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCwgdmFsdWUpO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCBhcyBzdHJpbmcsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIGFsbFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgaXRlbTogdW5rbm93blxuKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChcbiAgcmVzb2x2ZXI6IFJlc29sdmVyQ2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAvLyBGb3IgYXJyYXkgb2Ygb2JqZWN0cywgdGhlIG9iamVjdCBpcyB1c2VkIHRvIHN0b3JlIHVwZGF0ZWQgdmFsdWVzXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQgfHwge307XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKFxuICBwcm9wOiBzdHJpbmcsXG4gIHByZWZpeGVzOiBzdHJpbmdbXSxcbiAgc2NvcGVzOiBBbnlPYmplY3RbXSxcbiAgcHJveHk6IFJlc29sdmVyUHJveHlcbikge1xuICBsZXQgdmFsdWU6IHVua25vd247XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShrZXk6IHN0cmluZywgc2NvcGVzOiBBbnlPYmplY3RbXSkge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0OiBSZXNvbHZlckNhY2hlKSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShcbiAgbWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sXG4gIGRhdGE6IEFueU9iamVjdFtdLFxuICBzdGFydDogbnVtYmVyLFxuICBjb3VudDogbnVtYmVyXG4pIHtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7a2V5ID0gJ3InfSA9IHRoaXMuX3BhcnNpbmc7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheTx7cjogdW5rbm93bn0+KGNvdW50KTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBpdGVtOiBBbnlPYmplY3Q7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsImltcG9ydCB7YWxtb3N0RXF1YWxzLCBkaXN0YW5jZUJldHdlZW5Qb2ludHMsIHNpZ259IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2lzUG9pbnRJbkFyZWF9IGZyb20gJy4vaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0QXJlYX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1NwbGluZVBvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG5jb25zdCBFUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5cbnR5cGUgT3B0aW9uYWxTcGxpbmVQb2ludCA9IFNwbGluZVBvaW50IHwgZmFsc2VcbmNvbnN0IGdldFBvaW50ID0gKHBvaW50czogU3BsaW5lUG9pbnRbXSwgaTogbnVtYmVyKTogT3B0aW9uYWxTcGxpbmVQb2ludCA9PiBpIDwgcG9pbnRzLmxlbmd0aCAmJiAhcG9pbnRzW2ldLnNraXAgJiYgcG9pbnRzW2ldO1xuY29uc3QgZ2V0VmFsdWVBeGlzID0gKGluZGV4QXhpczogJ3gnIHwgJ3knKSA9PiBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGluZUN1cnZlKFxuICBmaXJzdFBvaW50OiBTcGxpbmVQb2ludCxcbiAgbWlkZGxlUG9pbnQ6IFNwbGluZVBvaW50LFxuICBhZnRlclBvaW50OiBTcGxpbmVQb2ludCxcbiAgdDogbnVtYmVyXG4pOiB7XG4gICAgcHJldmlvdXM6IFNwbGluZVBvaW50XG4gICAgbmV4dDogU3BsaW5lUG9pbnRcbiAgfSB7XG4gIC8vIFByb3BzIHRvIFJvYiBTcGVuY2VyIGF0IHNjYWxlZCBpbm5vdmF0aW9uIGZvciBoaXMgcG9zdCBvbiBzcGxpbmluZyBiZXR3ZWVuIHBvaW50c1xuICAvLyBodHRwOi8vc2NhbGVkaW5ub3ZhdGlvbi5jb20vYW5hbHl0aWNzL3NwbGluZXMvYWJvdXRTcGxpbmVzLmh0bWxcblxuICAvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYWxzbyByZXNwZWN0IFwic2tpcHBlZFwiIHBvaW50c1xuXG4gIGNvbnN0IHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuICBjb25zdCBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG4gIGNvbnN0IG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG4gIGNvbnN0IGQwMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhjdXJyZW50LCBwcmV2aW91cyk7XG4gIGNvbnN0IGQxMiA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhuZXh0LCBjdXJyZW50KTtcblxuICBsZXQgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG4gIGxldCBzMTIgPSBkMTIgLyAoZDAxICsgZDEyKTtcblxuICAvLyBJZiBhbGwgcG9pbnRzIGFyZSB0aGUgc2FtZSwgczAxICYgczAyIHdpbGwgYmUgaW5mXG4gIHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuICBzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcblxuICBjb25zdCBmYSA9IHQgKiBzMDE7IC8vIHNjYWxpbmcgZmFjdG9yIGZvciB0cmlhbmdsZSBUYVxuICBjb25zdCBmYiA9IHQgKiBzMTI7XG5cbiAgcmV0dXJuIHtcbiAgICBwcmV2aW91czoge1xuICAgICAgeDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH0sXG4gICAgbmV4dDoge1xuICAgICAgeDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgKyBmYiAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBBZGp1c3QgdGFuZ2VudHMgdG8gZW5zdXJlIG1vbm90b25pYyBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1vbm90b25lQWRqdXN0KHBvaW50czogU3BsaW5lUG9pbnRbXSwgZGVsdGFLOiBudW1iZXJbXSwgbUs6IG51bWJlcltdKSB7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgbGV0IGFscGhhSzogbnVtYmVyLCBiZXRhSzogbnVtYmVyLCB0YXVLOiBudW1iZXIsIHNxdWFyZWRNYWduaXR1ZGU6IG51bWJlciwgcG9pbnRDdXJyZW50OiBPcHRpb25hbFNwbGluZVBvaW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQgfHwgIXBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChhbG1vc3RFcXVhbHMoZGVsdGFLW2ldLCAwLCBFUFNJTE9OKSkge1xuICAgICAgbUtbaV0gPSBtS1tpICsgMV0gPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYWxwaGFLID0gbUtbaV0gLyBkZWx0YUtbaV07XG4gICAgYmV0YUsgPSBtS1tpICsgMV0gLyBkZWx0YUtbaV07XG4gICAgc3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG4gICAgaWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG4gICAgbUtbaV0gPSBhbHBoYUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICAgIG1LW2kgKyAxXSA9IGJldGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb25vdG9uZUNvbXB1dGUocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBtSzogbnVtYmVyW10sIGluZGV4QXhpczogJ3gnIHwgJ3knID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgZGVsdGE6IG51bWJlciwgcG9pbnRCZWZvcmU6IE9wdGlvbmFsU3BsaW5lUG9pbnQsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgaVBpeGVsID0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgY29uc3QgdlBpeGVsID0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc107XG4gICAgaWYgKHBvaW50QmVmb3JlKSB7XG4gICAgICBkZWx0YSA9IChpUGl4ZWwgLSBwb2ludEJlZm9yZVtpbmRleEF4aXNdKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMSR7aW5kZXhBeGlzfWBdID0gaVBpeGVsIC0gZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMSR7dmFsdWVBeGlzfWBdID0gdlBpeGVsIC0gZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGRlbHRhID0gKHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIGlQaXhlbCkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke2luZGV4QXhpc31gXSA9IGlQaXhlbCArIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCArIGRlbHRhICogbUtbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIELDqXppZXIgY29udHJvbCBwb2ludHMgaW4gYSBzaW1pbGFyIHdheSB0aGFuIHxzcGxpbmVDdXJ2ZXwsXG4gKiBidXQgcHJlc2VydmVzIG1vbm90b25pY2l0eSBvZiB0aGUgcHJvdmlkZWQgZGF0YSBhbmQgZW5zdXJlcyBubyBsb2NhbCBleHRyZW11bXMgYXJlIGFkZGVkXG4gKiBiZXR3ZWVuIHRoZSBkYXRhc2V0IGRpc2NyZXRlIHBvaW50cyBkdWUgdG8gdGhlIGludGVycG9sYXRpb24uXG4gKiBTZWUgOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb25vdG9uZV9jdWJpY19pbnRlcnBvbGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50czogU3BsaW5lUG9pbnRbXSwgaW5kZXhBeGlzOiAneCcgfCAneScgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IGRlbHRhSzogbnVtYmVyW10gPSBBcnJheShwb2ludHNMZW4pLmZpbGwoMCk7XG4gIGNvbnN0IG1LOiBudW1iZXJbXSA9IEFycmF5KHBvaW50c0xlbik7XG5cbiAgLy8gQ2FsY3VsYXRlIHNsb3BlcyAoZGVsdGFLKSBhbmQgaW5pdGlhbGl6ZSB0YW5nZW50cyAobUspXG4gIGxldCBpLCBwb2ludEJlZm9yZTogT3B0aW9uYWxTcGxpbmVQb2ludCwgcG9pbnRDdXJyZW50OiBPcHRpb25hbFNwbGluZVBvaW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBjb25zdCBzbG9wZURlbHRhID0gcG9pbnRBZnRlcltpbmRleEF4aXNdIC0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG5cbiAgICAgIC8vIEluIHRoZSBjYXNlIG9mIHR3byBwb2ludHMgdGhhdCBhcHBlYXIgYXQgdGhlIHNhbWUgeCBwaXhlbCwgc2xvcGVEZWx0YVggaXMgMFxuICAgICAgZGVsdGFLW2ldID0gc2xvcGVEZWx0YSAhPT0gMCA/IChwb2ludEFmdGVyW3ZhbHVlQXhpc10gLSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXSkgLyBzbG9wZURlbHRhIDogMDtcbiAgICB9XG4gICAgbUtbaV0gPSAhcG9pbnRCZWZvcmUgPyBkZWx0YUtbaV1cbiAgICAgIDogIXBvaW50QWZ0ZXIgPyBkZWx0YUtbaSAtIDFdXG4gICAgICAgIDogKHNpZ24oZGVsdGFLW2kgLSAxXSkgIT09IHNpZ24oZGVsdGFLW2ldKSkgPyAwXG4gICAgICAgICAgOiAoZGVsdGFLW2kgLSAxXSArIGRlbHRhS1tpXSkgLyAyO1xuICB9XG5cbiAgbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKTtcblxuICBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzKTtcbn1cblxuZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG59XG5cbmZ1bmN0aW9uIGNhcEJlemllclBvaW50cyhwb2ludHM6IFNwbGluZVBvaW50W10sIGFyZWE6IENoYXJ0QXJlYSkge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGluQXJlYSwgaW5BcmVhUHJldjtcbiAgbGV0IGluQXJlYU5leHQgPSBfaXNQb2ludEluQXJlYShwb2ludHNbMF0sIGFyZWEpO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluQXJlYVByZXYgPSBpbkFyZWE7XG4gICAgaW5BcmVhID0gaW5BcmVhTmV4dDtcbiAgICBpbkFyZWFOZXh0ID0gaSA8IGlsZW4gLSAxICYmIF9pc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0sIGFyZWEpO1xuICAgIGlmICghaW5BcmVhKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgaWYgKGluQXJlYVByZXYpIHtcbiAgICAgIHBvaW50LmNwMXggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMXkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gICAgaWYgKGluQXJlYU5leHQpIHtcbiAgICAgIHBvaW50LmNwMnggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMnkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMoXG4gIHBvaW50czogU3BsaW5lUG9pbnRbXSxcbiAgb3B0aW9ucyxcbiAgYXJlYTogQ2hhcnRBcmVhLFxuICBsb29wOiBib29sZWFuLFxuICBpbmRleEF4aXM6ICd4JyB8ICd5J1xuKSB7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgcG9pbnQ6IFNwbGluZVBvaW50LCBjb250cm9sUG9pbnRzOiBSZXR1cm5UeXBlPHR5cGVvZiBzcGxpbmVDdXJ2ZT47XG5cbiAgLy8gT25seSBjb25zaWRlciBwb2ludHMgdGhhdCBhcmUgZHJhd24gaW4gY2FzZSB0aGUgc3BhbkdhcHMgb3B0aW9uIGlzIHVzZWRcbiAgaWYgKG9wdGlvbnMuc3BhbkdhcHMpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKChwdCkgPT4gIXB0LnNraXApO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwcmV2ID0gbG9vcCA/IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gOiBwb2ludHNbMF07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29udHJvbFBvaW50cyA9IHNwbGluZUN1cnZlKFxuICAgICAgICBwcmV2LFxuICAgICAgICBwb2ludCxcbiAgICAgICAgcG9pbnRzW01hdGgubWluKGkgKyAxLCBpbGVuIC0gKGxvb3AgPyAwIDogMSkpICUgaWxlbl0sXG4gICAgICAgIG9wdGlvbnMudGVuc2lvblxuICAgICAgKTtcbiAgICAgIHBvaW50LmNwMXggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XG4gICAgICBwb2ludC5jcDF5ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuICAgICAgcG9pbnQuY3AyeCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuICAgICAgcG9pbnQuY3AyeSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuICAgICAgcHJldiA9IHBvaW50O1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xuICAgIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7Q2hhcnRBcmVhLCBTY2FsZX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUgUHJpdmF0ZUNoYXJ0IGZyb20gJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHtJTkZJTklUWX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNEb21TdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlOiBIVE1MQ2FudmFzRWxlbWVudCk6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gKHBhcmVudCBhcyBTaGFkb3dSb290KS5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG59XG5cbi8qKlxuICogY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWU6IHN0cmluZyB8IG51bWJlciwgbm9kZTogSFRNTEVsZW1lbnQsIHBhcmVudFByb3BlcnR5OiBzdHJpbmcpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM6IG51bWJlcjtcbiAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG5cbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAvLyBwZXJjZW50YWdlICogc2l6ZSBpbiBkaW1lbnNpb25cbiAgICAgIHZhbHVlSW5QaXhlbHMgPSAodmFsdWVJblBpeGVscyAvIDEwMCkgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuXG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9PlxuICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgcHJvcGVydHk6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cblxuY29uc3QgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZXM6IENTU1N0eWxlRGVjbGFyYXRpb24sIHN0eWxlOiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZyk6IENoYXJ0QXJlYSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9IGFzIENoYXJ0QXJlYTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgdGFyZ2V0OiBIVE1MRWxlbWVudCB8IEV2ZW50VGFyZ2V0KSA9PlxuICAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICEodGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5zaGFkb3dSb290KTtcblxuLyoqXG4gKiBAcGFyYW0gZVxuICogQHBhcmFtIGNhbnZhc1xuICogQHJldHVybnMgQ2FudmFzIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKFxuICBlOiBFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4pOiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICBib3g6IGJvb2xlYW47XG4gIH0ge1xuICBjb25zdCB0b3VjaGVzID0gKGUgYXMgVG91Y2hFdmVudCkudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZSkgYXMgTW91c2VFdmVudDtcbiAgY29uc3Qge29mZnNldFgsIG9mZnNldFl9ID0gc291cmNlIGFzIE1vdXNlRXZlbnQ7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5cbi8qKlxuICogR2V0cyBhbiBldmVudCdzIHgsIHkgY29vcmRpbmF0ZXMsIHJlbGF0aXZlIHRvIHRoZSBjaGFydCBhcmVhXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwYXJhbSBjaGFydFxuICogQHJldHVybnMgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihcbiAgZXZlbnQ6IEV2ZW50IHwgQ2hhcnRFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjaGFydDogQ2hhcnQgfCBQcml2YXRlQ2hhcnRcbik6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gIGlmICgnbmF0aXZlJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG5cbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNoYXJ0O1xuICBpZiAoYm9yZGVyQm94KSB7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoKHggLSB4T2Zmc2V0KSAvIHdpZHRoICogY2FudmFzLndpZHRoIC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pLFxuICAgIHk6IE1hdGgucm91bmQoKHkgLSB5T2Zmc2V0KSAvIGhlaWdodCAqIGNhbnZhcy5oZWlnaHQgLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFBhcnRpYWw8U2NhbGU+IHtcbiAgbGV0IG1heFdpZHRoOiBudW1iZXIsIG1heEhlaWdodDogbnVtYmVyO1xuXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gdGhpcyBpcyB0aGUgYm9yZGVyIGJveCBvZiB0aGUgY29udGFpbmVyXG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5cbmNvbnN0IHJvdW5kMSA9ICh2OiBudW1iZXIpID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1heGltdW1TaXplKFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICBiYldpZHRoPzogbnVtYmVyLFxuICBiYkhlaWdodD86IG51bWJlcixcbiAgYXNwZWN0UmF0aW8/OiBudW1iZXJcbik6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBtYXJnaW5zID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnbWFyZ2luJyk7XG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICBjb25zdCBjb250YWluZXJTaXplID0gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XG5cbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyB3aWR0aCAvIGFzcGVjdFJhdGlvIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80NjU5XG4gICAgLy8gSWYgdGhlIGNhbnZhcyBoYXMgd2lkdGgsIGJ1dCBubyBoZWlnaHQsIGRlZmF1bHQgdG8gYXNwZWN0UmF0aW8gb2YgMiAoY2FudmFzIGRlZmF1bHQpXG4gICAgaGVpZ2h0ID0gcm91bmQxKHdpZHRoIC8gMik7XG4gIH1cblxuICBjb25zdCBtYWludGFpbkhlaWdodCA9IGJiV2lkdGggIT09IHVuZGVmaW5lZCB8fCBiYkhlaWdodCAhPT0gdW5kZWZpbmVkO1xuXG4gIGlmIChtYWludGFpbkhlaWdodCAmJiBhc3BlY3RSYXRpbyAmJiBjb250YWluZXJTaXplLmhlaWdodCAmJiBoZWlnaHQgPiBjb250YWluZXJTaXplLmhlaWdodCkge1xuICAgIGhlaWdodCA9IGNvbnRhaW5lclNpemUuaGVpZ2h0O1xuICAgIHdpZHRoID0gcm91bmQxKE1hdGguZmxvb3IoaGVpZ2h0ICogYXNwZWN0UmF0aW8pKTtcbiAgfVxuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbi8qKlxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcGFyYW0gZm9yY2VSYXRpb1xuICogQHBhcmFtIGZvcmNlU3R5bGVcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNhbnZhcyBjb250ZXh0IHNpemUgb3IgdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRpbmFTY2FsZShcbiAgY2hhcnQ6IENoYXJ0IHwgUHJpdmF0ZUNoYXJ0LFxuICBmb3JjZVJhdGlvOiBudW1iZXIsXG4gIGZvcmNlU3R5bGU/OiBib29sZWFuXG4pOiBib29sZWFuIHwgdm9pZCB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8IDE7XG4gIGNvbnN0IGRldmljZUhlaWdodCA9IHJvdW5kMShjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSByb3VuZDEoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcblxuICAoY2hhcnQgYXMgUHJpdmF0ZUNoYXJ0KS5oZWlnaHQgPSByb3VuZDEoY2hhcnQuaGVpZ2h0KTtcbiAgKGNoYXJ0IGFzIFByaXZhdGVDaGFydCkud2lkdGggPSByb3VuZDEoY2hhcnQud2lkdGgpO1xuXG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblxuICAvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuICAvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM1NzVcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG5cbiAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvXG4gICAgICB8fCBjYW52YXMuaGVpZ2h0ICE9PSBkZXZpY2VIZWlnaHRcbiAgICAgIHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcbiAgICAoY2hhcnQgYXMgUHJpdmF0ZUNoYXJ0KS5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGRldmljZUhlaWdodDtcbiAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcbiAgICBjaGFydC5jdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlciBhdHRlbXB0cyB0byBhY2Nlc3MgdGhlIHBhc3NpdmUgcHJvcGVydHkuXG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBhcyBFdmVudExpc3RlbmVyT3B0aW9ucztcblxuICAgIGlmIChfaXNEb21TdXBwb3J0ZWQoKSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcblxuLyoqXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXG4gKiBiZWVuIHBlcmZvcm1lZC4gVGhpcyBtZXRob2QgdXNlcyB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgYGVsZW1lbnRgIGJ1dCByZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG5vdCBleHByZXNzZWQgaW4gcGl4ZWxzLiBUaGF0IGNhbiBoYXBwZW4gaW4gc29tZSBjYXNlcyB3aGVyZVxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcbiAqIGZvciBleGFtcGxlIGJlY2F1c2Ugb2YgYGRpc3BsYXk6IG5vbmVgIG9uIGEgcGFyZW50IG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy91c2VkX3ZhbHVlXG4gKiBAcmV0dXJucyBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFVzZWRTaXplKFxuICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgcHJvcGVydHk6ICd3aWR0aCcgfCAnaGVpZ2h0J1xuKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB0eXBlIHtQb2ludCwgU3BsaW5lUG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9wb2ludEluTGluZShwMTogUG9pbnQsIHAyOiBQb2ludCwgdDogbnVtYmVyLCBtb2RlPykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBwMS55ICsgdCAqIChwMi55IC0gcDEueSlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKFxuICBwMTogUG9pbnQsXG4gIHAyOiBQb2ludCxcbiAgdDogbnVtYmVyLCBtb2RlOiAnbWlkZGxlJyB8ICdhZnRlcicgfCB1bmtub3duXG4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnlcbiAgICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICAgICAgOiB0ID4gMCA/IHAyLnkgOiBwMS55XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxOiBTcGxpbmVQb2ludCwgcDI6IFNwbGluZVBvaW50LCB0OiBudW1iZXIsIG1vZGU/KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGNvbnN0IGNwMSA9IHt4OiBwMS5jcDJ4LCB5OiBwMS5jcDJ5fTtcbiAgY29uc3QgY3AyID0ge3g6IHAyLmNwMXgsIHk6IHAyLmNwMXl9O1xuICBjb25zdCBhID0gX3BvaW50SW5MaW5lKHAxLCBjcDEsIHQpO1xuICBjb25zdCBiID0gX3BvaW50SW5MaW5lKGNwMSwgY3AyLCB0KTtcbiAgY29uc3QgYyA9IF9wb2ludEluTGluZShjcDIsIHAyLCB0KTtcbiAgY29uc3QgZCA9IF9wb2ludEluTGluZShhLCBiLCB0KTtcbiAgY29uc3QgZSA9IF9wb2ludEluTGluZShiLCBjLCB0KTtcbiAgcmV0dXJuIF9wb2ludEluTGluZShkLCBlLCB0KTtcbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgUlRMQWRhcHRlciB7XG4gIHgoeDogbnVtYmVyKTogbnVtYmVyO1xuICBzZXRXaWR0aCh3OiBudW1iZXIpOiB2b2lkO1xuICB0ZXh0QWxpZ24oYWxpZ246ICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0Jyk6ICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0JztcbiAgeFBsdXMoeDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogbnVtYmVyO1xuICBsZWZ0Rm9yTHRyKHg6IG51bWJlciwgaXRlbVdpZHRoOiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmNvbnN0IGdldFJpZ2h0VG9MZWZ0QWRhcHRlciA9IGZ1bmN0aW9uKHJlY3RYOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpOiBSVExBZGFwdGVyIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcblxuY29uc3QgZ2V0TGVmdFRvUmlnaHRBZGFwdGVyID0gZnVuY3Rpb24oKTogUlRMQWRhcHRlciB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICByZXR1cm4gYWxpZ247XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggKyB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgX2l0ZW1XaWR0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdGxBZGFwdGVyKHJ0bDogYm9vbGVhbiwgcmVjdFg6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICByZXR1cm4gcnRsID8gZ2V0UmlnaHRUb0xlZnRBZGFwdGVyKHJlY3RYLCB3aWR0aCkgOiBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZGlyZWN0aW9uOiAnbHRyJyB8ICdydGwnKSB7XG4gIGxldCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgb3JpZ2luYWw6IFtzdHJpbmcsIHN0cmluZ107XG4gIGlmIChkaXJlY3Rpb24gPT09ICdsdHInIHx8IGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICBzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XG4gICAgb3JpZ2luYWwgPSBbXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxuICAgIF07XG5cbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgKGN0eCBhcyB7IHByZXZUZXh0RGlyZWN0aW9uPzogW3N0cmluZywgc3RyaW5nXSB9KS5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlVGV4dERpcmVjdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3JpZ2luYWw/OiBbc3RyaW5nLCBzdHJpbmddKSB7XG4gIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIChjdHggYXMgeyBwcmV2VGV4dERpcmVjdGlvbj86IFtzdHJpbmcsIHN0cmluZ10gfSkucHJldlRleHREaXJlY3Rpb247XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgb3JpZ2luYWxbMF0sIG9yaWdpbmFsWzFdKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBfYW5nbGVEaWZmLCBfaXNCZXR3ZWVuLCBfbm9ybWFsaXplQW5nbGV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dH0gZnJvbSAnLi9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtpc1BhdHRlcm5PckdyYWRpZW50fSBmcm9tICcuL2hlbHBlcnMuY29sb3IuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnKS5kZWZhdWx0IH0gTGluZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICogQHR5cGVkZWYge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgbG9vcDogYm9vbGVhbiwgc3R5bGU/OiBhbnl9fSBTZWdtZW50XG4gKi9cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudCh7c3RhcnQsIGVuZCwgY291bnQsIGxvb3AsIHN0eWxlfSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgIGVuZDogZW5kICUgY291bnQsXG4gICAgbG9vcDogbG9vcCAmJiAoZW5kIC0gc3RhcnQgKyAxKSAlIGNvdW50ID09PSAwLFxuICAgIHN0eWxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBzdGFydCArPSBjb3VudDtcbiAgICBlbmQgKz0gY291bnQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoIWJldHdlZW4obm9ybWFsaXplKHBvaW50c1tzdGFydCAlIGNvdW50XVtwcm9wZXJ0eV0pLCBzdGFydEJvdW5kLCBlbmRCb3VuZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydC0tO1xuICAgICAgZW5kLS07XG4gICAgfVxuICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgIGVuZCAlPSBjb3VudDtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGVuZCArPSBjb3VudDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlOiBzZWdtZW50LnN0eWxlfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdWItc2VnbWVudChzKSBvZiBhIGxpbmUgc2VnbWVudCB0aGF0IGZhbGwgaW4gdGhlIGdpdmVuIGJvdW5kc1xuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50LnN0eWxlXSAtIHNlZ21lbnQgc3R5bGVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50cyAtIHRoZSBwb2ludHMgdGhhdCB0aGlzIHNlZ21lbnQgcmVmZXJzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgb2YgYSBgUG9pbnRFbGVtZW50YCB3ZSBhcmUgYm91bmRpbmcuIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLmVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cblxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7Y29tcGFyZSwgYmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGV9ID0gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcyk7XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xuXG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQsIHByZXYgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW2kgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG5cbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cblxuICAgIGlmIChzdWJTdGFydCAhPT0gbnVsbCAmJiBzaG91bGRTdG9wKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kOiBpLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gICAgICBzdWJTdGFydCA9IG51bGw7XG4gICAgfVxuICAgIHByZXYgPSBpO1xuICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQsIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWdtZW50cyBvZiB0aGUgbGluZSB0aGF0IGFyZSBpbnNpZGUgZ2l2ZW4gYm91bmRzXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgd2UgYXJlIGJvdW5kaW5nIHdpdGguIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIGBwcm9wZXJ0eWBcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuZW5kIC0gZW5kIHZhbHVlIG9mIHRoZSBgcHJvcGVydHlgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZpbmQgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiBhIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gY291bnQgLSAxO1xuXG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIC8vIGxvb3AgYW5kIG5vdCBzcGFubmluZyBnYXBzLCBmaXJzdCBmaW5kIGEgZ2FwIHRvIHN0YXJ0IGZyb21cbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgZmlyc3Qgbm9uIHNraXBwZWQgcG9pbnQgKGFmdGVyIHRoZSBmaXJzdCBnYXAgcG9zc2libHkpXG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cblxuICAvLyBpZiB3ZSBsb29wZWQgdG8gY291bnQsIHN0YXJ0IG5lZWRzIHRvIGJlIDBcbiAgc3RhcnQgJT0gY291bnQ7XG5cbiAgaWYgKGxvb3ApIHtcbiAgICAvLyBsb29wIHdpbGwgZ28gcGFzdCBjb3VudCwgaWYgc3RhcnQgPiAwXG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG5cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCkge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgLy8gZW5kIGNvdWxkIGJlIG1vcmUgdGhhbiBjb3VudCwgbm9ybWFsaXplXG4gIGVuZCAlPSBjb3VudDtcblxuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xufVxuXG4vKipcbiAqIENvbXB1dGUgc29saWQgc2VnbWVudHMgZnJvbSBQb2ludHMsIHdoZW4gc3BhbkdhcHMgPT09IGZhbHNlXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHMgLSB0aGUgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIG1heCBpbmRleCAoY2FuIGdvIHBhc3QgY291bnQgb24gYSBsb29wKVxuICogQHBhcmFtIHtib29sZWFufSBsb29wIC0gYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhpcyB3b3VsZCBiZSBhIGxvb3AgaWYgbm8gZ2FwcyBhcmUgZm91bmRcbiAqL1xuZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGxhc3QgPSBzdGFydDtcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xuICBsZXQgZW5kO1xuXG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZDtcbiAgICAgIGlmIChwcmV2LnNraXApIHtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBjdXI7XG4gIH1cblxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiBsYXN0ICUgY291bnQsIGxvb3B9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY29udGludW91cyBzZWdtZW50cyB0aGF0IGRlZmluZSB0aGUgd2hvbGUgbGluZVxuICogVGhlcmUgY2FuIGJlIHNraXBwZWQgcG9pbnRzIHdpdGhpbiBhIHNlZ21lbnQsIGlmIHNwYW5HYXBzIGlzIHRydWUuXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jb21wdXRlU2VnbWVudHMobGluZSwgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHNwYW5HYXBzID0gbGluZS5vcHRpb25zLnNwYW5HYXBzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG5cbiAgaWYgKHNwYW5HYXBzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgW3tzdGFydCwgZW5kLCBsb29wfV0sIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgbWF4ID0gZW5kIDwgc3RhcnQgPyBlbmQgKyBjb3VudCA6IGVuZDtcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICovXG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqL1xuZnVuY3Rpb24gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGV4dCA9IGxpbmUuX2NoYXJ0LmdldENvbnRleHQoKTtcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gIGNvbnN0IHtfZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsIG9wdGlvbnM6IHtzcGFuR2Fwc319ID0gbGluZTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHByZXZTdHlsZSA9IGJhc2VTdHlsZTtcbiAgbGV0IHN0YXJ0ID0gc2VnbWVudHNbMF0uc3RhcnQ7XG4gIGxldCBpID0gc3RhcnQ7XG5cbiAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcbiAgICBjb25zdCBkaXIgPSBzcGFuR2FwcyA/IC0xIDogMTtcbiAgICBpZiAocyA9PT0gZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdHlsZSBjYW4gbm90IHN0YXJ0L2VuZCBvbiBhIHNraXBwZWQgcG9pbnQsIGFkanVzdCBpbmRpY2VzIGFjY29yZGluZ2x5XG4gICAgcyArPSBjb3VudDtcbiAgICB3aGlsZSAocG9pbnRzW3MgJSBjb3VudF0uc2tpcCkge1xuICAgICAgcyAtPSBkaXI7XG4gICAgfVxuICAgIHdoaWxlIChwb2ludHNbZSAlIGNvdW50XS5za2lwKSB7XG4gICAgICBlICs9IGRpcjtcbiAgICB9XG4gICAgaWYgKHMgJSBjb3VudCAhPT0gZSAlIGNvdW50KSB7XG4gICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHMgJSBjb3VudCwgZW5kOiBlICUgY291bnQsIGxvb3A6IGwsIHN0eWxlOiBzdH0pO1xuICAgICAgcHJldlN0eWxlID0gc3Q7XG4gICAgICBzdGFydCA9IGUgJSBjb3VudDtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzdGFydCA9IHNwYW5HYXBzID8gc3RhcnQgOiBzZWdtZW50LnN0YXJ0O1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0ICUgY291bnRdO1xuICAgIGxldCBzdHlsZTtcbiAgICBmb3IgKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoY3JlYXRlQ29udGV4dChjaGFydENvbnRleHQsIHtcbiAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICBwMDogcHJldixcbiAgICAgICAgcDE6IHB0LFxuICAgICAgICBwMERhdGFJbmRleDogKGkgLSAxKSAlIGNvdW50LFxuICAgICAgICBwMURhdGFJbmRleDogaSAlIGNvdW50LFxuICAgICAgICBkYXRhc2V0SW5kZXhcbiAgICAgIH0pKSk7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpKSB7XG4gICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJldiA9IHB0O1xuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSB7XG4gIGlmICghcHJldlN0eWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhY2hlID0gW107XG4gIGNvbnN0IHJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmICghaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCFjYWNoZS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGUuaW5kZXhPZih2YWx1ZSk7XG4gIH07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHlsZSwgcmVwbGFjZXIpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2U3R5bGUsIHJlcGxhY2VyKTtcbn1cbiIsImltcG9ydCB0eXBlIHtDaGFydCwgQ2hhcnRBcmVhLCBDaGFydE1ldGEsIFNjYWxlLCBUUkJMfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGdldFNpemVGb3JBcmVhKHNjYWxlOiBTY2FsZSwgY2hhcnRBcmVhOiBDaGFydEFyZWEsIGZpZWxkOiBrZXlvZiBDaGFydEFyZWEpIHtcbiAgcmV0dXJuIHNjYWxlLm9wdGlvbnMuY2xpcCA/IHNjYWxlW2ZpZWxkXSA6IGNoYXJ0QXJlYVtmaWVsZF07XG59XG5cbmZ1bmN0aW9uIGdldERhdGFzZXRBcmVhKG1ldGE6IENoYXJ0TWV0YSwgY2hhcnRBcmVhOiBDaGFydEFyZWEpOiBUUkJMIHtcbiAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gIGlmICh4U2NhbGUgJiYgeVNjYWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGdldFNpemVGb3JBcmVhKHhTY2FsZSwgY2hhcnRBcmVhLCAnbGVmdCcpLFxuICAgICAgcmlnaHQ6IGdldFNpemVGb3JBcmVhKHhTY2FsZSwgY2hhcnRBcmVhLCAncmlnaHQnKSxcbiAgICAgIHRvcDogZ2V0U2l6ZUZvckFyZWEoeVNjYWxlLCBjaGFydEFyZWEsICd0b3AnKSxcbiAgICAgIGJvdHRvbTogZ2V0U2l6ZUZvckFyZWEoeVNjYWxlLCBjaGFydEFyZWEsICdib3R0b20nKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNoYXJ0QXJlYTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFzZXRDbGlwQXJlYShjaGFydDogQ2hhcnQsIG1ldGE6IENoYXJ0TWV0YSk6IFRSQkwgfCBmYWxzZSB7XG4gIGNvbnN0IGNsaXAgPSBtZXRhLl9jbGlwO1xuICBpZiAoY2xpcC5kaXNhYmxlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhcmVhID0gZ2V0RGF0YXNldEFyZWEobWV0YSwgY2hhcnQuY2hhcnRBcmVhKTtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGNsaXAubGVmdCA9PT0gZmFsc2UgPyAwIDogYXJlYS5sZWZ0IC0gKGNsaXAubGVmdCA9PT0gdHJ1ZSA/IDAgOiBjbGlwLmxlZnQpLFxuICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IGNoYXJ0LndpZHRoIDogYXJlYS5yaWdodCArIChjbGlwLnJpZ2h0ID09PSB0cnVlID8gMCA6IGNsaXAucmlnaHQpLFxuICAgIHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gKGNsaXAudG9wID09PSB0cnVlID8gMCA6IGNsaXAudG9wKSxcbiAgICBib3R0b206IGNsaXAuYm90dG9tID09PSBmYWxzZSA/IGNoYXJ0LmhlaWdodCA6IGFyZWEuYm90dG9tICsgKGNsaXAuYm90dG9tID09PSB0cnVlID8gMCA6IGNsaXAuYm90dG9tKVxuICB9O1xufVxuIl0sIm5hbWVzIjpbIm5vb3AiLCJ1aWQiLCJpZCIsImlzTnVsbE9yVW5kZWYiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImlzQXJyYXkiLCJBcnJheSIsInR5cGUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImlzT2JqZWN0IiwiaXNOdW1iZXJGaW5pdGUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZpbml0ZU9yRGVmYXVsdCIsImRlZmF1bHRWYWx1ZSIsInZhbHVlT3JEZWZhdWx0IiwidG9QZXJjZW50YWdlIiwiZGltZW5zaW9uIiwiZW5kc1dpdGgiLCJwYXJzZUZsb2F0IiwidG9EaW1lbnNpb24iLCJjYWxsYmFjayIsImZuIiwiYXJncyIsInRoaXNBcmciLCJhcHBseSIsImVhY2giLCJsb29wYWJsZSIsInJldmVyc2UiLCJpIiwibGVuIiwia2V5cyIsImxlbmd0aCIsIl9lbGVtZW50c0VxdWFsIiwiYTAiLCJhMSIsImlsZW4iLCJ2MCIsInYxIiwiZGF0YXNldEluZGV4IiwiaW5kZXgiLCJjbG9uZSIsInNvdXJjZSIsIm1hcCIsInRhcmdldCIsImNyZWF0ZSIsImtsZW4iLCJrIiwiaXNWYWxpZEtleSIsImtleSIsImluZGV4T2YiLCJfbWVyZ2VyIiwib3B0aW9ucyIsInR2YWwiLCJzdmFsIiwibWVyZ2UiLCJzb3VyY2VzIiwibWVyZ2VyIiwiY3VycmVudCIsIm1lcmdlSWYiLCJfbWVyZ2VySWYiLCJoYXNPd25Qcm9wZXJ0eSIsIl9kZXByZWNhdGVkIiwic2NvcGUiLCJwcmV2aW91cyIsImNvbnNvbGUiLCJ3YXJuIiwia2V5UmVzb2x2ZXJzIiwidiIsIngiLCJvIiwieSIsIl9zcGxpdEtleSIsInBhcnRzIiwic3BsaXQiLCJ0bXAiLCJwYXJ0IiwicHVzaCIsIl9nZXRLZXlSZXNvbHZlciIsIm9iaiIsInJlc29sdmVPYmplY3RLZXkiLCJyZXNvbHZlciIsIl9jYXBpdGFsaXplIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJkZWZpbmVkIiwiaXNGdW5jdGlvbiIsInNldHNFcXVhbCIsImEiLCJiIiwic2l6ZSIsIml0ZW0iLCJoYXMiLCJfaXNDbGlja0V2ZW50IiwiZSIsIlBJIiwiTWF0aCIsIlRBVSIsIlBJVEFVIiwiSU5GSU5JVFkiLCJQT1NJVElWRV9JTkZJTklUWSIsIlJBRF9QRVJfREVHIiwiSEFMRl9QSSIsIlFVQVJURVJfUEkiLCJUV09fVEhJUkRTX1BJIiwibG9nMTAiLCJzaWduIiwiYWxtb3N0RXF1YWxzIiwiZXBzaWxvbiIsImFicyIsIm5pY2VOdW0iLCJyYW5nZSIsInJvdW5kZWRSYW5nZSIsInJvdW5kIiwibmljZVJhbmdlIiwicG93IiwiZmxvb3IiLCJmcmFjdGlvbiIsIm5pY2VGcmFjdGlvbiIsIl9mYWN0b3JpemUiLCJyZXN1bHQiLCJzcXJ0Iiwic29ydCIsInBvcCIsImlzTm9uUHJpbWl0aXZlIiwibiIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwiaXNOdW1iZXIiLCJpc05hTiIsImFsbW9zdFdob2xlIiwicm91bmRlZCIsIl9zZXRNaW5BbmRNYXhCeUtleSIsImFycmF5IiwicHJvcGVydHkiLCJtaW4iLCJtYXgiLCJ0b1JhZGlhbnMiLCJkZWdyZWVzIiwidG9EZWdyZWVzIiwicmFkaWFucyIsIl9kZWNpbWFsUGxhY2VzIiwiaXNGaW5pdGVOdW1iZXIiLCJwIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJjZW50cmVQb2ludCIsImFuZ2xlUG9pbnQiLCJkaXN0YW5jZUZyb21YQ2VudGVyIiwiZGlzdGFuY2VGcm9tWUNlbnRlciIsInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsImFuZ2xlIiwiYXRhbjIiLCJkaXN0YW5jZSIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInB0MSIsInB0MiIsIl9hbmdsZURpZmYiLCJfbm9ybWFsaXplQW5nbGUiLCJfYW5nbGVCZXR3ZWVuIiwic3RhcnQiLCJlbmQiLCJzYW1lQW5nbGVJc0Z1bGxDaXJjbGUiLCJzIiwiYW5nbGVUb1N0YXJ0IiwiYW5nbGVUb0VuZCIsInN0YXJ0VG9BbmdsZSIsImVuZFRvQW5nbGUiLCJfbGltaXRWYWx1ZSIsIl9pbnQxNlJhbmdlIiwiX2lzQmV0d2VlbiIsIl9sb29rdXAiLCJ0YWJsZSIsImNtcCIsImhpIiwibG8iLCJtaWQiLCJfbG9va3VwQnlLZXkiLCJsYXN0IiwidGkiLCJfcmxvb2t1cEJ5S2V5IiwiX2ZpbHRlckJldHdlZW4iLCJ2YWx1ZXMiLCJhcnJheUV2ZW50cyIsImxpc3RlbkFycmF5RXZlbnRzIiwibGlzdGVuZXIiLCJfY2hhcnRqcyIsImxpc3RlbmVycyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImZvckVhY2giLCJtZXRob2QiLCJiYXNlIiwicmVzIiwib2JqZWN0IiwidW5saXN0ZW5BcnJheUV2ZW50cyIsInN0dWIiLCJzcGxpY2UiLCJfYXJyYXlVbmlxdWUiLCJpdGVtcyIsInNldCIsIlNldCIsImZyb20iLCJmb250U3RyaW5nIiwicGl4ZWxTaXplIiwiZm9udFN0eWxlIiwiZm9udEZhbWlseSIsInJlcXVlc3RBbmltRnJhbWUiLCJ3aW5kb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aHJvdHRsZWQiLCJhcmdzVG9Vc2UiLCJ0aWNraW5nIiwiZGVib3VuY2UiLCJkZWxheSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiX3RvTGVmdFJpZ2h0Q2VudGVyIiwiYWxpZ24iLCJfYWxpZ25TdGFydEVuZCIsIl90ZXh0WCIsImxlZnQiLCJyaWdodCIsInJ0bCIsImNoZWNrIiwiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCJtZXRhIiwicG9pbnRzIiwiYW5pbWF0aW9uc0Rpc2FibGVkIiwicG9pbnRDb3VudCIsImNvdW50IiwiX3NvcnRlZCIsImlTY2FsZSIsInZTY2FsZSIsIl9wYXJzZWQiLCJzcGFuR2FwcyIsImRhdGFzZXQiLCJheGlzIiwibWluRGVmaW5lZCIsIm1heERlZmluZWQiLCJnZXRVc2VyQm91bmRzIiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsImRpc3RhbmNlVG9EZWZpbmVkTG8iLCJmaW5kSW5kZXgiLCJwb2ludCIsImRpc3RhbmNlVG9EZWZpbmVkSGkiLCJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwieFNjYWxlIiwieVNjYWxlIiwiX3NjYWxlUmFuZ2VzIiwibmV3UmFuZ2VzIiwieG1pbiIsInhtYXgiLCJ5bWluIiwieW1heCIsImNoYW5nZWQiLCJhc3NpZ24iLCJhdEVkZ2UiLCJ0IiwiZWxhc3RpY0luIiwic2luIiwiZWxhc3RpY091dCIsImVmZmVjdHMiLCJsaW5lYXIiLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluQ3ViaWMiLCJlYXNlT3V0Q3ViaWMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJblF1YXJ0IiwiZWFzZU91dFF1YXJ0IiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VPdXRRdWludCIsImVhc2VJbk91dFF1aW50IiwiZWFzZUluU2luZSIsImNvcyIsImVhc2VPdXRTaW5lIiwiZWFzZUluT3V0U2luZSIsImVhc2VJbkV4cG8iLCJlYXNlT3V0RXhwbyIsImVhc2VJbk91dEV4cG8iLCJlYXNlSW5DaXJjIiwiZWFzZU91dENpcmMiLCJlYXNlSW5PdXRDaXJjIiwiZWFzZUluRWxhc3RpYyIsImVhc2VPdXRFbGFzdGljIiwiZWFzZUluT3V0RWxhc3RpYyIsImVhc2VJbkJhY2siLCJlYXNlT3V0QmFjayIsImVhc2VJbk91dEJhY2siLCJlYXNlSW5Cb3VuY2UiLCJlYXNlT3V0Qm91bmNlIiwibSIsImQiLCJlYXNlSW5PdXRCb3VuY2UiLCJpc1BhdHRlcm5PckdyYWRpZW50IiwiY29sb3IiLCJDb2xvciIsImdldEhvdmVyQ29sb3IiLCJzYXR1cmF0ZSIsImRhcmtlbiIsImhleFN0cmluZyIsIm51bWJlcnMiLCJjb2xvcnMiLCJhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyIsImRlZmF1bHRzIiwiZHVyYXRpb24iLCJlYXNpbmciLCJsb29wIiwidG8iLCJkZXNjcmliZSIsIl9mYWxsYmFjayIsIl9pbmRleGFibGUiLCJfc2NyaXB0YWJsZSIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiYWN0aXZlIiwiYW5pbWF0aW9uIiwicmVzaXplIiwic2hvdyIsImFuaW1hdGlvbnMiLCJ2aXNpYmxlIiwiaGlkZSIsImFwcGx5TGF5b3V0c0RlZmF1bHRzIiwiYXV0b1BhZGRpbmciLCJwYWRkaW5nIiwidG9wIiwiYm90dG9tIiwiaW50bENhY2hlIiwiTWFwIiwiZ2V0TnVtYmVyRm9ybWF0IiwibG9jYWxlIiwiY2FjaGVLZXkiLCJKU09OIiwic3RyaW5naWZ5IiwiZm9ybWF0dGVyIiwiZ2V0IiwiSW50bCIsIk51bWJlckZvcm1hdCIsImZvcm1hdE51bWJlciIsIm51bSIsImZvcm1hdCIsImZvcm1hdHRlcnMiLCJudW1lcmljIiwidGlja1ZhbHVlIiwidGlja3MiLCJjaGFydCIsIm5vdGF0aW9uIiwiZGVsdGEiLCJtYXhUaWNrIiwiY2FsY3VsYXRlRGVsdGEiLCJsb2dEZWx0YSIsIm51bURlY2ltYWwiLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJsb2dhcml0aG1pYyIsInJlbWFpbiIsInNpZ25pZmljYW5kIiwiaW5jbHVkZXMiLCJUaWNrcyIsImFwcGx5U2NhbGVEZWZhdWx0cyIsImRpc3BsYXkiLCJvZmZzZXQiLCJiZWdpbkF0WmVybyIsImJvdW5kcyIsImNsaXAiLCJncmFjZSIsImdyaWQiLCJsaW5lV2lkdGgiLCJkcmF3T25DaGFydEFyZWEiLCJkcmF3VGlja3MiLCJ0aWNrTGVuZ3RoIiwidGlja1dpZHRoIiwiX2N0eCIsInRpY2tDb2xvciIsImJvcmRlciIsImRhc2giLCJkYXNoT2Zmc2V0Iiwid2lkdGgiLCJ0aXRsZSIsInRleHQiLCJtaW5Sb3RhdGlvbiIsIm1heFJvdGF0aW9uIiwibWlycm9yIiwidGV4dFN0cm9rZVdpZHRoIiwidGV4dFN0cm9rZUNvbG9yIiwiYXV0b1NraXAiLCJhdXRvU2tpcFBhZGRpbmciLCJsYWJlbE9mZnNldCIsIm1pbm9yIiwibWFqb3IiLCJjcm9zc0FsaWduIiwic2hvd0xhYmVsQmFja2Ryb3AiLCJiYWNrZHJvcENvbG9yIiwiYmFja2Ryb3BQYWRkaW5nIiwicm91dGUiLCJzdGFydHNXaXRoIiwib3ZlcnJpZGVzIiwiZGVzY3JpcHRvcnMiLCJnZXRTY29wZSIsIm5vZGUiLCJyb290IiwiRGVmYXVsdHMiLCJvdmVycmlkZSIsInRhcmdldFNjb3BlIiwidGFyZ2V0TmFtZSIsInNjb3BlT2JqZWN0IiwidGFyZ2V0U2NvcGVPYmplY3QiLCJwcml2YXRlTmFtZSIsImRlZmluZVByb3BlcnRpZXMiLCJ3cml0YWJsZSIsImxvY2FsIiwiYXBwbGllcnMiLCJjb25zdHJ1Y3RvciIsIl9kZXNjcmlwdG9ycyIsIl9hcHBsaWVycyIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwiZGF0YXNldHMiLCJkZXZpY2VQaXhlbFJhdGlvIiwiY29udGV4dCIsInBsYXRmb3JtIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImVsZW1lbnRzIiwiZXZlbnRzIiwiZm9udCIsImZhbWlseSIsInN0eWxlIiwibGluZUhlaWdodCIsIndlaWdodCIsImhvdmVyIiwiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJjdHgiLCJob3ZlckJvcmRlckNvbG9yIiwiaG92ZXJDb2xvciIsImluZGV4QXhpcyIsImludGVyYWN0aW9uIiwibW9kZSIsImludGVyc2VjdCIsImluY2x1ZGVJbnZpc2libGUiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwib25Ib3ZlciIsIm9uQ2xpY2siLCJwYXJzaW5nIiwicGx1Z2lucyIsInJlc3BvbnNpdmUiLCJzY2FsZSIsInNjYWxlcyIsInNob3dMaW5lIiwiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCJ0b0ZvbnRTdHJpbmciLCJfbWVhc3VyZVRleHQiLCJkYXRhIiwiZ2MiLCJsb25nZXN0Iiwic3RyaW5nIiwidGV4dFdpZHRoIiwibWVhc3VyZVRleHQiLCJfbG9uZ2VzdFRleHQiLCJhcnJheU9mVGhpbmdzIiwiY2FjaGUiLCJnYXJiYWdlQ29sbGVjdCIsInNhdmUiLCJqIiwiamxlbiIsInRoaW5nIiwibmVzdGVkVGhpbmciLCJyZXN0b3JlIiwiZ2NMZW4iLCJfYWxpZ25QaXhlbCIsInBpeGVsIiwiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCJoYWxmV2lkdGgiLCJjbGVhckNhbnZhcyIsImNhbnZhcyIsImdldENvbnRleHQiLCJyZXNldFRyYW5zZm9ybSIsImNsZWFyUmVjdCIsImhlaWdodCIsImRyYXdQb2ludCIsImRyYXdQb2ludExlZ2VuZCIsInciLCJ4T2Zmc2V0IiwieU9mZnNldCIsImNvcm5lclJhZGl1cyIsInhPZmZzZXRXIiwieU9mZnNldFciLCJwb2ludFN0eWxlIiwicm90YXRpb24iLCJyYWRpdXMiLCJyYWQiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJkcmF3SW1hZ2UiLCJiZWdpblBhdGgiLCJlbGxpcHNlIiwiYXJjIiwiY2xvc2VQYXRoIiwibW92ZVRvIiwibGluZVRvIiwiU1FSVDFfMiIsInJlY3QiLCJmaWxsIiwiYm9yZGVyV2lkdGgiLCJzdHJva2UiLCJfaXNQb2ludEluQXJlYSIsImFyZWEiLCJtYXJnaW4iLCJjbGlwQXJlYSIsInVuY2xpcEFyZWEiLCJfc3RlcHBlZExpbmVUbyIsImZsaXAiLCJtaWRwb2ludCIsIl9iZXppZXJDdXJ2ZVRvIiwiYmV6aWVyQ3VydmVUbyIsImNwMXgiLCJjcDJ4IiwiY3AxeSIsImNwMnkiLCJzZXRSZW5kZXJPcHRzIiwib3B0cyIsInRyYW5zbGF0aW9uIiwiZmlsbFN0eWxlIiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiZGVjb3JhdGVUZXh0IiwibGluZSIsInN0cmlrZXRocm91Z2giLCJ1bmRlcmxpbmUiLCJtZXRyaWNzIiwiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsImFjdHVhbEJvdW5kaW5nQm94QXNjZW50IiwiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwieURlY29yYXRpb24iLCJzdHJva2VTdHlsZSIsImRlY29yYXRpb25XaWR0aCIsImRyYXdCYWNrZHJvcCIsIm9sZENvbG9yIiwiZmlsbFJlY3QiLCJyZW5kZXJUZXh0IiwibGluZXMiLCJzdHJva2VXaWR0aCIsInN0cm9rZUNvbG9yIiwiYmFja2Ryb3AiLCJzdHJva2VUZXh0IiwibWF4V2lkdGgiLCJmaWxsVGV4dCIsImFkZFJvdW5kZWRSZWN0UGF0aCIsImgiLCJ0b3BMZWZ0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwidG9wUmlnaHQiLCJMSU5FX0hFSUdIVCIsIkZPTlRfU1RZTEUiLCJ0b0xpbmVIZWlnaHQiLCJtYXRjaGVzIiwibWF0Y2giLCJudW1iZXJPclplcm8iLCJfcmVhZFZhbHVlVG9Qcm9wcyIsInByb3BzIiwicmV0Iiwib2JqUHJvcHMiLCJyZWFkIiwicHJvcCIsInRvVFJCTCIsInRvVFJCTENvcm5lcnMiLCJ0b1BhZGRpbmciLCJ0b0ZvbnQiLCJmYWxsYmFjayIsInBhcnNlSW50IiwicmVzb2x2ZSIsImlucHV0cyIsImluZm8iLCJjYWNoZWFibGUiLCJfYWRkR3JhY2UiLCJtaW5tYXgiLCJjaGFuZ2UiLCJrZWVwWmVybyIsImFkZCIsImNyZWF0ZUNvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiX2NyZWF0ZVJlc29sdmVyIiwic2NvcGVzIiwicHJlZml4ZXMiLCJyb290U2NvcGVzIiwiZ2V0VGFyZ2V0IiwiZmluYWxSb290U2NvcGVzIiwiX3Jlc29sdmUiLCJ0b1N0cmluZ1RhZyIsIl9jYWNoZWFibGUiLCJfc2NvcGVzIiwiX3Jvb3RTY29wZXMiLCJfZ2V0VGFyZ2V0IiwiUHJveHkiLCJkZWxldGVQcm9wZXJ0eSIsIl9rZXlzIiwiX2NhY2hlZCIsIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiUmVmbGVjdCIsImdldFByb3RvdHlwZU9mIiwiZ2V0S2V5c0Zyb21BbGxTY29wZXMiLCJvd25LZXlzIiwic3RvcmFnZSIsIl9zdG9yYWdlIiwiX2F0dGFjaENvbnRleHQiLCJwcm94eSIsInN1YlByb3h5IiwiZGVzY3JpcHRvckRlZmF1bHRzIiwiX3Byb3h5IiwiX2NvbnRleHQiLCJfc3ViUHJveHkiLCJfc3RhY2siLCJzZXRDb250ZXh0IiwicmVjZWl2ZXIiLCJfcmVzb2x2ZVdpdGhDb250ZXh0IiwiYWxsS2V5cyIsInNjcmlwdGFibGUiLCJpbmRleGFibGUiLCJfYWxsS2V5cyIsImlzU2NyaXB0YWJsZSIsImlzSW5kZXhhYmxlIiwicmVhZEtleSIsInByZWZpeCIsIm5lZWRzU3ViUmVzb2x2ZXIiLCJfcmVzb2x2ZVNjcmlwdGFibGUiLCJfcmVzb2x2ZUFycmF5IiwiZ2V0VmFsdWUiLCJFcnJvciIsImpvaW4iLCJkZWxldGUiLCJjcmVhdGVTdWJSZXNvbHZlciIsImFyciIsImZpbHRlciIsInJlc29sdmVGYWxsYmFjayIsInBhcmVudCIsImFkZFNjb3BlcyIsInBhcmVudFNjb3BlcyIsInBhcmVudEZhbGxiYWNrIiwiYWxsU2NvcGVzIiwiYWRkU2NvcGVzRnJvbUtleSIsInN1YkdldFRhcmdldCIsInJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyIsIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsIl9wYXJzaW5nIiwicGFyc2VkIiwiciIsInBhcnNlIiwiRVBTSUxPTiIsImdldFBvaW50Iiwic2tpcCIsImdldFZhbHVlQXhpcyIsInNwbGluZUN1cnZlIiwiZmlyc3RQb2ludCIsIm1pZGRsZVBvaW50IiwiYWZ0ZXJQb2ludCIsIm5leHQiLCJkMDEiLCJkMTIiLCJzMDEiLCJzMTIiLCJmYSIsImZiIiwibW9ub3RvbmVBZGp1c3QiLCJkZWx0YUsiLCJtSyIsInBvaW50c0xlbiIsImFscGhhSyIsImJldGFLIiwidGF1SyIsInNxdWFyZWRNYWduaXR1ZGUiLCJwb2ludEN1cnJlbnQiLCJwb2ludEFmdGVyIiwibW9ub3RvbmVDb21wdXRlIiwidmFsdWVBeGlzIiwicG9pbnRCZWZvcmUiLCJpUGl4ZWwiLCJ2UGl4ZWwiLCJzcGxpbmVDdXJ2ZU1vbm90b25lIiwic2xvcGVEZWx0YSIsImNhcENvbnRyb2xQb2ludCIsInB0IiwiY2FwQmV6aWVyUG9pbnRzIiwiaW5BcmVhIiwiaW5BcmVhUHJldiIsImluQXJlYU5leHQiLCJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImNvbnRyb2xQb2ludHMiLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwicHJldiIsInRlbnNpb24iLCJfaXNEb21TdXBwb3J0ZWQiLCJkb2N1bWVudCIsIl9nZXRQYXJlbnROb2RlIiwiZG9tTm9kZSIsInBhcmVudE5vZGUiLCJob3N0IiwicGFyc2VNYXhTdHlsZSIsInN0eWxlVmFsdWUiLCJwYXJlbnRQcm9wZXJ0eSIsInZhbHVlSW5QaXhlbHMiLCJnZXRDb21wdXRlZFN0eWxlIiwiZWxlbWVudCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImdldFN0eWxlIiwiZWwiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb25lZFN0eWxlIiwic3R5bGVzIiwic3VmZml4IiwicG9zIiwidXNlT2Zmc2V0UG9zIiwic2hhZG93Um9vdCIsImdldENhbnZhc1Bvc2l0aW9uIiwidG91Y2hlcyIsIm9mZnNldFgiLCJvZmZzZXRZIiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImNsaWVudFkiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwiZXZlbnQiLCJib3JkZXJCb3giLCJib3hTaXppbmciLCJwYWRkaW5ncyIsImJvcmRlcnMiLCJnZXRDb250YWluZXJTaXplIiwibWF4SGVpZ2h0IiwiY29udGFpbmVyIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJjb250YWluZXJTdHlsZSIsImNvbnRhaW5lckJvcmRlciIsImNvbnRhaW5lclBhZGRpbmciLCJyb3VuZDEiLCJnZXRNYXhpbXVtU2l6ZSIsImJiV2lkdGgiLCJiYkhlaWdodCIsImFzcGVjdFJhdGlvIiwibWFyZ2lucyIsImNvbnRhaW5lclNpemUiLCJtYWludGFpbkhlaWdodCIsInJldGluYVNjYWxlIiwiZm9yY2VSYXRpbyIsImZvcmNlU3R5bGUiLCJwaXhlbFJhdGlvIiwiZGV2aWNlSGVpZ2h0IiwiZGV2aWNlV2lkdGgiLCJzZXRUcmFuc2Zvcm0iLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwicGFzc2l2ZVN1cHBvcnRlZCIsInBhc3NpdmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYWRVc2VkU2l6ZSIsIl9wb2ludEluTGluZSIsInAxIiwicDIiLCJfc3RlcHBlZEludGVycG9sYXRpb24iLCJfYmV6aWVySW50ZXJwb2xhdGlvbiIsImNwMSIsImNwMiIsImMiLCJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCJyZWN0WCIsInNldFdpZHRoIiwieFBsdXMiLCJsZWZ0Rm9yTHRyIiwiaXRlbVdpZHRoIiwiZ2V0TGVmdFRvUmlnaHRBZGFwdGVyIiwiX2l0ZW1XaWR0aCIsImdldFJ0bEFkYXB0ZXIiLCJvdmVycmlkZVRleHREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJvcmlnaW5hbCIsImdldFByb3BlcnR5UHJpb3JpdHkiLCJzZXRQcm9wZXJ0eSIsInByZXZUZXh0RGlyZWN0aW9uIiwicmVzdG9yZVRleHREaXJlY3Rpb24iLCJwcm9wZXJ0eUZuIiwiYmV0d2VlbiIsImNvbXBhcmUiLCJub3JtYWxpemUiLCJub3JtYWxpemVTZWdtZW50IiwiZ2V0U2VnbWVudCIsInNlZ21lbnQiLCJzdGFydEJvdW5kIiwiZW5kQm91bmQiLCJfYm91bmRTZWdtZW50IiwiaW5zaWRlIiwic3ViU3RhcnQiLCJwcmV2VmFsdWUiLCJzdGFydElzQmVmb3JlIiwiZW5kSXNCZWZvcmUiLCJzaG91bGRTdGFydCIsInNob3VsZFN0b3AiLCJfYm91bmRTZWdtZW50cyIsInNlZ21lbnRzIiwic3ViIiwiZmluZFN0YXJ0QW5kRW5kIiwic29saWRTZWdtZW50cyIsImN1ciIsInN0b3AiLCJfY29tcHV0ZVNlZ21lbnRzIiwic2VnbWVudE9wdGlvbnMiLCJfbG9vcCIsInNwbGl0QnlTdHlsZXMiLCJjb21wbGV0ZUxvb3AiLCJfZnVsbExvb3AiLCJkb1NwbGl0QnlTdHlsZXMiLCJjaGFydENvbnRleHQiLCJfY2hhcnQiLCJiYXNlU3R5bGUiLCJyZWFkU3R5bGUiLCJfZGF0YXNldEluZGV4IiwicHJldlN0eWxlIiwiYWRkU3R5bGUiLCJsIiwic3QiLCJkaXIiLCJwMCIsInAwRGF0YUluZGV4IiwicDFEYXRhSW5kZXgiLCJzdHlsZUNoYW5nZWQiLCJib3JkZXJDYXBTdHlsZSIsImJvcmRlckRhc2giLCJib3JkZXJEYXNoT2Zmc2V0IiwiYm9yZGVySm9pblN0eWxlIiwicmVwbGFjZXIiLCJnZXRTaXplRm9yQXJlYSIsImNoYXJ0QXJlYSIsImZpZWxkIiwiZ2V0RGF0YXNldEFyZWEiLCJnZXREYXRhc2V0Q2xpcEFyZWEiLCJfY2xpcCIsImRpc2FibGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/chart.js/dist/chunks/helpers.dataset.js\n"));

/***/ })

}]);