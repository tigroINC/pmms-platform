"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chart.js";
exports.ids = ["vendor-chunks/chart.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/chart.js/auto/auto.js":
/*!********************************************!*\
  !*** ./node_modules/chart.js/auto/auto.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Animation),\n/* harmony export */   Animations: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Animations),\n/* harmony export */   ArcElement: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.ArcElement),\n/* harmony export */   BarController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BarController),\n/* harmony export */   BarElement: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BarElement),\n/* harmony export */   BasePlatform: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BasePlatform),\n/* harmony export */   BasicPlatform: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BasicPlatform),\n/* harmony export */   BubbleController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BubbleController),\n/* harmony export */   CategoryScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.CategoryScale),\n/* harmony export */   Chart: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart),\n/* harmony export */   Colors: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Colors),\n/* harmony export */   DatasetController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.DatasetController),\n/* harmony export */   Decimation: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Decimation),\n/* harmony export */   DomPlatform: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.DomPlatform),\n/* harmony export */   DoughnutController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.DoughnutController),\n/* harmony export */   Element: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Element),\n/* harmony export */   Filler: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Filler),\n/* harmony export */   Interaction: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Interaction),\n/* harmony export */   Legend: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Legend),\n/* harmony export */   LineController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LineController),\n/* harmony export */   LineElement: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LineElement),\n/* harmony export */   LinearScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LinearScale),\n/* harmony export */   LogarithmicScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LogarithmicScale),\n/* harmony export */   PieController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.PieController),\n/* harmony export */   PointElement: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.PointElement),\n/* harmony export */   PolarAreaController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.PolarAreaController),\n/* harmony export */   RadarController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.RadarController),\n/* harmony export */   RadialLinearScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.RadialLinearScale),\n/* harmony export */   Scale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Scale),\n/* harmony export */   ScatterController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.ScatterController),\n/* harmony export */   SubTitle: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.SubTitle),\n/* harmony export */   Ticks: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Ticks),\n/* harmony export */   TimeScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.TimeScale),\n/* harmony export */   TimeSeriesScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.TimeSeriesScale),\n/* harmony export */   Title: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Title),\n/* harmony export */   Tooltip: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Tooltip),\n/* harmony export */   _adapters: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__._adapters),\n/* harmony export */   _detectPlatform: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__._detectPlatform),\n/* harmony export */   animator: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.animator),\n/* harmony export */   controllers: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.controllers),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   defaults: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.defaults),\n/* harmony export */   elements: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.elements),\n/* harmony export */   layouts: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.layouts),\n/* harmony export */   plugins: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.plugins),\n/* harmony export */   registerables: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables),\n/* harmony export */   registry: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.registry),\n/* harmony export */   scales: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.scales)\n/* harmony export */ });\n/* harmony import */ var _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/chart.js */ \"(ssr)/./node_modules/chart.js/dist/chart.js\");\n\n_dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart.register(..._dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvYXV0by9hdXRvLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0Q7QUFFdERBLGlEQUFLQSxDQUFDRSxRQUFRLElBQUlELHlEQUFhQTtBQUVFO0FBQ2pDLGlFQUFlRCxpREFBS0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2F1dG8vYXV0by5qcz8xMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q2hhcnQsIHJlZ2lzdGVyYWJsZXN9IGZyb20gJy4uL2Rpc3QvY2hhcnQuanMnO1xuXG5DaGFydC5yZWdpc3RlciguLi5yZWdpc3RlcmFibGVzKTtcblxuZXhwb3J0ICogZnJvbSAnLi4vZGlzdC9jaGFydC5qcyc7XG5leHBvcnQgZGVmYXVsdCBDaGFydDtcbiJdLCJuYW1lcyI6WyJDaGFydCIsInJlZ2lzdGVyYWJsZXMiLCJyZWdpc3RlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/auto/auto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chart.js/dist/chart.js":
/*!*********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: () => (/* binding */ Animation),\n/* harmony export */   Animations: () => (/* binding */ Animations),\n/* harmony export */   ArcElement: () => (/* binding */ ArcElement),\n/* harmony export */   BarController: () => (/* binding */ BarController),\n/* harmony export */   BarElement: () => (/* binding */ BarElement),\n/* harmony export */   BasePlatform: () => (/* binding */ BasePlatform),\n/* harmony export */   BasicPlatform: () => (/* binding */ BasicPlatform),\n/* harmony export */   BubbleController: () => (/* binding */ BubbleController),\n/* harmony export */   CategoryScale: () => (/* binding */ CategoryScale),\n/* harmony export */   Chart: () => (/* binding */ Chart),\n/* harmony export */   Colors: () => (/* binding */ plugin_colors),\n/* harmony export */   DatasetController: () => (/* binding */ DatasetController),\n/* harmony export */   Decimation: () => (/* binding */ plugin_decimation),\n/* harmony export */   DomPlatform: () => (/* binding */ DomPlatform),\n/* harmony export */   DoughnutController: () => (/* binding */ DoughnutController),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Filler: () => (/* binding */ index),\n/* harmony export */   Interaction: () => (/* binding */ Interaction),\n/* harmony export */   Legend: () => (/* binding */ plugin_legend),\n/* harmony export */   LineController: () => (/* binding */ LineController),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearScale: () => (/* binding */ LinearScale),\n/* harmony export */   LogarithmicScale: () => (/* binding */ LogarithmicScale),\n/* harmony export */   PieController: () => (/* binding */ PieController),\n/* harmony export */   PointElement: () => (/* binding */ PointElement),\n/* harmony export */   PolarAreaController: () => (/* binding */ PolarAreaController),\n/* harmony export */   RadarController: () => (/* binding */ RadarController),\n/* harmony export */   RadialLinearScale: () => (/* binding */ RadialLinearScale),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   ScatterController: () => (/* binding */ ScatterController),\n/* harmony export */   SubTitle: () => (/* binding */ plugin_subtitle),\n/* harmony export */   Ticks: () => (/* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM),\n/* harmony export */   TimeScale: () => (/* binding */ TimeScale),\n/* harmony export */   TimeSeriesScale: () => (/* binding */ TimeSeriesScale),\n/* harmony export */   Title: () => (/* binding */ plugin_title),\n/* harmony export */   Tooltip: () => (/* binding */ plugin_tooltip),\n/* harmony export */   _adapters: () => (/* binding */ adapters),\n/* harmony export */   _detectPlatform: () => (/* binding */ _detectPlatform),\n/* harmony export */   animator: () => (/* binding */ animator),\n/* harmony export */   controllers: () => (/* binding */ controllers),\n/* harmony export */   defaults: () => (/* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   elements: () => (/* binding */ elements),\n/* harmony export */   layouts: () => (/* binding */ layouts),\n/* harmony export */   plugins: () => (/* binding */ plugins),\n/* harmony export */   registerables: () => (/* binding */ registerables),\n/* harmony export */   registry: () => (/* binding */ registry),\n/* harmony export */   scales: () => (/* binding */ scales)\n/* harmony export */ });\n/* harmony import */ var _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.dataset.js */ \"(ssr)/./node_modules/chart.js/dist/chunks/helpers.dataset.js\");\n/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */ \n\nclass Animator {\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n    _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n    _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.r.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n    _update(date = Date.now()) {\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, \"progress\");\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, \"complete\");\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n    _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n    listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n    add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n    has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n    start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n    stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), \"complete\");\n    }\n    remove(chart) {\n        return this._charts.delete(chart);\n    }\n}\nvar animator = /* #__PURE__ */ new Animator();\nconst transparent = \"transparent\";\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n    color (from, to, factor) {\n        const c0 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c)(from || transparent);\n        const c1 = c0.valid && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c)(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e[cfg.easing] || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? \"res\" : \"rej\";\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n}\nclass Animations {\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n    configure(config) {\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(config)) {\n            return;\n        }\n        const animationOptions = Object.keys(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.animation);\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n    _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{});\n        }\n        return animations;\n    }\n    _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === \"$\") {\n                continue;\n            }\n            if (prop === \"options\") {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n    update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n    const keys = stack.keys;\n    const singleMode = options.mode === \"single\";\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    let found = false;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            found = true;\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(otherValue) && (singleMode || value === 0 || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) === (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(otherValue))) {\n            value += otherValue;\n        }\n    }\n    if (!found && !options.all) {\n        return 0;\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data, meta) {\n    const { iScale, vScale } = meta;\n    const iAxisKey = iScale.axis === \"x\" ? \"x\" : \"y\";\n    const vAxisKey = vScale.axis === \"x\" ? \"x\" : \"y\";\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            [iAxisKey]: key,\n            [vAxisKey]: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n    const { min, max, minDefined, maxDefined } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart, _cachedMeta: meta } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale, vScale, index: datasetIndex } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index, [vAxis]: value } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n        const visualValues = stack._visualValues || (stack._visualValues = {});\n        visualValues[datasetIndex] = value;\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: \"default\",\n        type: \"dataset\"\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: \"default\",\n        type: \"data\"\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n            delete stacks[axis]._visualValues[datasetIndex];\n        }\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === \"reset\" || mode === \"none\";\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n    static{\n        this.defaults = {};\n    }\n    static{\n        this.datasetElementType = null;\n    }\n    static{\n        this.dataElementType = null;\n    }\n    constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n        this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.datasetElementType = new.target.datasetElementType;\n        this.dataElementType = new.target.dataElementType;\n        this.initialize();\n    }\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n        if (this.options.fill && !this.chart.isPluginEnabled(\"filler\")) {\n            console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === \"x\" ? x : axis === \"r\" ? r : y;\n        const xid = meta.xAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.xAxisID, getFirstScaleId(chart, \"x\"));\n        const yid = meta.yAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.yAxisID, getFirstScaleId(chart, \"y\"));\n        const rid = meta.rAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.rAxisID, getFirstScaleId(chart, \"r\"));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n    getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n    _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update(\"reset\");\n    }\n    _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u)(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n    _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            const meta = this._cachedMeta;\n            this._data = convertObjectDataToArray(data, meta);\n        } else if (_data !== data) {\n            if (_data) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u)(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.l)(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n            meta._stacked = isStacked(meta.vScale, meta);\n        }\n    }\n    configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n    parse(start, count) {\n        const { _cachedMeta: meta, _data: data } = this;\n        const { iScale, _stacked } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const { xAxisKey = \"x\", yAxisKey = \"y\" } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, xAxisKey), index),\n                y: yScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n    getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n    getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n    applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]._visualValues\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n    getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin, max: otherMax } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n    getMaxOverflow() {\n        return false;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? \"\" + iScale.getLabelForValue(parsed[iScale.axis]) : \"\",\n            value: vScale ? \"\" + vScale.getLabelForValue(parsed[vScale.axis]) : \"\"\n        };\n    }\n    _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || \"default\");\n        meta._clip = toClip((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n    update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n    getStyle(index, active) {\n        const mode = active ? \"active\" : \"default\";\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n    getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n    resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n    resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n    _resolveElementOptions(elementType, mode = \"default\", index) {\n        const active = mode === \"active\";\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + \"-\" + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            `${elementType}Hover`,\n            \"hover\",\n            elementType,\n            \"\"\n        ] : [\n            elementType,\n            \"\"\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.elements[elementType]);\n        const context = ()=>this.getContext(index, active, mode);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n    _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = `animation-${transition}`;\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n    includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n    _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n    updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n    updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n    _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, \"active\", false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, \"active\", true);\n    }\n    _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, \"active\", false);\n        }\n    }\n    _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, \"active\", true);\n        }\n    }\n    _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n    _insertElements(start, count, resetNewElements = true) {\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, \"reset\");\n        }\n    }\n    updateElements(element, start, count, mode) {}\n    _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n    _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            \"_insertElements\",\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            \"_removeElements\",\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            \"_removeElements\",\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                \"_removeElements\",\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                \"_insertElements\",\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            \"_insertElements\",\n            0,\n            arguments.length\n        ]);\n    }\n}\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = \"left\";\n        end = \"right\";\n    } else {\n        reverse = properties.base < properties.y;\n        start = \"bottom\";\n        end = \"top\";\n    }\n    if (reverse) {\n        top = \"end\";\n        bottom = \"start\";\n    } else {\n        top = \"start\";\n        bottom = \"end\";\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start, end, reverse, top, bottom } = borderProps(properties);\n    if (edge === \"middle\" && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === \"start\" ? start : v === \"end\" ? end : v;\n}\nfunction setInflateAmount(properties, { inflateAmount }, ratio) {\n    properties.inflateAmount = inflateAmount === \"auto\" ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    static{\n        this.id = \"bar\";\n    }\n    static{\n        this.defaults = {\n            datasetElementType: false,\n            dataElementType: \"bar\",\n            categoryPercentage: 0.8,\n            barPercentage: 0.9,\n            grouped: true,\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"base\",\n                        \"width\",\n                        \"height\"\n                    ]\n                }\n            }\n        };\n    }\n    static{\n        this.overrides = {\n            scales: {\n                _index_: {\n                    type: \"category\",\n                    offset: true,\n                    grid: {\n                        offset: true\n                    }\n                },\n                _value_: {\n                    type: \"linear\",\n                    beginAtZero: true\n                }\n            }\n        };\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseObjectData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const { xAxisKey = \"x\", yAxisKey = \"y\" } = this._parsing;\n        const iAxisKey = iScale.axis === \"x\" ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === \"x\" ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, iAxisKey), i);\n            parsed.push(parseValue((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n    getMaxOverflow() {\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale, vScale } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? \"[\" + custom.start + \", \" + custom.end + \"]\" : \"\" + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: \"\" + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { index, _cachedMeta: { vScale } } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? \"active\" : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n    _getStacks(last, dataIndex) {\n        const { iScale } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n        const iScaleValue = currentParsed && currentParsed[iScale.axis];\n        const skipNull = (meta)=>{\n            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);\n            const val = parsed && parsed[meta.vScale.axis];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n    _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n    _getAxisCount() {\n        return this._getAxis().length;\n    }\n    getFirstScaleIdForIndexAxis() {\n        const scales = this.chart.scales;\n        const indexScaleId = this.chart.options.indexAxis;\n        return Object.keys(scales).filter((key)=>scales[key].axis === indexScaleId).shift();\n    }\n    _getAxis() {\n        const axis = {};\n        const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();\n        for (const dataset of this.chart.data.datasets){\n            axis[(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.options.indexAxis === \"x\" ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;\n        }\n        return Object.keys(axis);\n    }\n    _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n    _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n    _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) !== (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n            if (_stacked && !floating) {\n                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n            }\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n    _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.maxBarThickness, Infinity);\n        let center, size;\n        const axisCount = this._getAxisCount();\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === \"flex\" ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount) : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);\n            const axisID = this.chart.options.indexAxis === \"x\" ? this.getDataset().xAxisID : this.getDataset().yAxisID;\n            const axisNumber = this._getAxis().indexOf((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(axisID, this.getFirstScaleIdForIndexAxis()));\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\nclass BubbleController extends DatasetController {\n    static{\n        this.id = \"bubble\";\n    }\n    static{\n        this.defaults = {\n            datasetElementType: false,\n            dataElementType: \"point\",\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"borderWidth\",\n                        \"radius\"\n                    ]\n                }\n            }\n        };\n    }\n    static{\n        this.overrides = {\n            scales: {\n                x: {\n                    type: \"linear\"\n                },\n                y: {\n                    type: \"linear\"\n                }\n            }\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale, yScale } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: labels[index] || \"\",\n            value: \"(\" + x + \", \" + y + (r ? \", \" + r : \"\") + \")\"\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n    resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== \"active\") {\n            values.radius = 0;\n        }\n        values.radius += (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(parsed && parsed._custom, radius);\n        return values;\n    }\n}\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        const minX = calcMin(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P, startX, endX);\n        const minY = calcMin(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    static{\n        this.id = \"doughnut\";\n    }\n    static{\n        this.defaults = {\n            datasetElementType: false,\n            dataElementType: \"arc\",\n            animation: {\n                animateRotate: true,\n                animateScale: false\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"circumference\",\n                        \"endAngle\",\n                        \"innerRadius\",\n                        \"outerRadius\",\n                        \"startAngle\",\n                        \"x\",\n                        \"y\",\n                        \"offset\",\n                        \"borderWidth\",\n                        \"spacing\"\n                    ]\n                }\n            },\n            cutout: \"50%\",\n            rotation: 0,\n            circumference: 360,\n            radius: \"100%\",\n            spacing: 0,\n            indexAxis: \"r\"\n        };\n    }\n    static{\n        this.descriptors = {\n            _scriptable: (name)=>name !== \"spacing\",\n            _indexable: (name)=>name !== \"spacing\" && !name.startsWith(\"borderDash\") && !name.startsWith(\"hoverBorderDash\")\n        };\n    }\n    static{\n        this.overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (chart) {\n                            const data = chart.data;\n                            const { labels: { pointStyle, textAlign, color, useBorderRadius, borderRadius } } = chart.legend.options;\n                            if (data.labels.length && data.datasets.length) {\n                                return data.labels.map((label, i)=>{\n                                    const meta = chart.getDatasetMeta(0);\n                                    const style = meta.controller.getStyle(i);\n                                    return {\n                                        text: label,\n                                        fillStyle: style.backgroundColor,\n                                        fontColor: color,\n                                        hidden: !chart.getDataVisibility(i),\n                                        lineDash: style.borderDash,\n                                        lineDashOffset: style.borderDashOffset,\n                                        lineJoin: style.borderJoinStyle,\n                                        lineWidth: style.borderWidth,\n                                        strokeStyle: style.borderColor,\n                                        textAlign: textAlign,\n                                        pointStyle: pointStyle,\n                                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                                        index: i\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (e, legendItem, legend) {\n                        legend.chart.toggleDataVisibility(legendItem.index);\n                        legend.chart.update();\n                    }\n                }\n            }\n        };\n    }\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n    linkScales() {}\n    parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                const { key = \"value\" } = this._parsing;\n                getter = (i)=>+(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n    _getRotation() {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.rotation - 90);\n    }\n    _getCircumference() {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.circumference);\n    }\n    _getRotationExtents() {\n        let min = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T;\n        let max = -_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n    update(mode) {\n        const chart = this.chart;\n        const { chartArea } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.m)(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference, rotation } = this._getRotationExtents();\n        const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.n)(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === \"reset\";\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? \"active\" : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || \"\",\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== \"inner\") {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n    _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n    _getRingWeight(datasetIndex) {\n        return Math.max((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n    _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n}\nclass LineController extends DatasetController {\n    static{\n        this.id = \"line\";\n    }\n    static{\n        this.defaults = {\n            datasetElementType: \"line\",\n            dataElementType: \"point\",\n            showLine: true,\n            spanGaps: false\n        };\n    }\n    static{\n        this.overrides = {\n            scales: {\n                _index_: {\n                    type: \"category\"\n                },\n                _value_: {\n                    type: \"linear\"\n                }\n            }\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line, data: points = [], _dataset } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n        const end = start + count;\n        const pointsCount = points.length;\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = 0; i < pointsCount; ++i){\n            const point = points[i];\n            const properties = directUpdate ? point : {};\n            if (i < start || i >= end) {\n                properties.skip = true;\n                continue;\n            }\n            const parsed = this.getParsed(i);\n            const nullData = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\nclass PolarAreaController extends DatasetController {\n    static{\n        this.id = \"polarArea\";\n    }\n    static{\n        this.defaults = {\n            dataElementType: \"arc\",\n            animation: {\n                animateRotate: true,\n                animateScale: true\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"startAngle\",\n                        \"endAngle\",\n                        \"innerRadius\",\n                        \"outerRadius\"\n                    ]\n                }\n            },\n            indexAxis: \"r\",\n            startAngle: 0\n        };\n    }\n    static{\n        this.overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (chart) {\n                            const data = chart.data;\n                            if (data.labels.length && data.datasets.length) {\n                                const { labels: { pointStyle, color } } = chart.legend.options;\n                                return data.labels.map((label, i)=>{\n                                    const meta = chart.getDatasetMeta(0);\n                                    const style = meta.controller.getStyle(i);\n                                    return {\n                                        text: label,\n                                        fillStyle: style.backgroundColor,\n                                        strokeStyle: style.borderColor,\n                                        fontColor: color,\n                                        lineWidth: style.borderWidth,\n                                        pointStyle: pointStyle,\n                                        hidden: !chart.getDataVisibility(i),\n                                        index: i\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (e, legendItem, legend) {\n                        legend.chart.toggleDataVisibility(legendItem.index);\n                        legend.chart.update();\n                    }\n                }\n            },\n            scales: {\n                r: {\n                    type: \"radialLinear\",\n                    angleLines: {\n                        display: false\n                    },\n                    beginAtZero: true,\n                    grid: {\n                        circular: true\n                    },\n                    pointLabels: {\n                        display: false\n                    },\n                    startAngle: 0\n                }\n            }\n        };\n    }\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || \"\",\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n    _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === \"reset\";\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? \"active\" : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n    _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n}\nclass PieController extends DoughnutController {\n    static{\n        this.id = \"pie\";\n    }\n    static{\n        this.defaults = {\n            cutout: 0,\n            rotation: 0,\n            circumference: 360,\n            radius: \"100%\"\n        };\n    }\n}\nclass RadarController extends DatasetController {\n    static{\n        this.id = \"radar\";\n    }\n    static{\n        this.defaults = {\n            datasetElementType: \"line\",\n            dataElementType: \"point\",\n            indexAxis: \"r\",\n            showLine: true,\n            elements: {\n                line: {\n                    fill: \"start\"\n                }\n            }\n        };\n    }\n    static{\n        this.overrides = {\n            aspectRatio: 1,\n            scales: {\n                r: {\n                    type: \"radialLinear\"\n                }\n            }\n        };\n    }\n    getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: \"\" + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== \"resize\") {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === \"reset\";\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\nclass ScatterController extends DatasetController {\n    static{\n        this.id = \"scatter\";\n    }\n    static{\n        this.defaults = {\n            datasetElementType: false,\n            dataElementType: \"point\",\n            showLine: false,\n            fill: false\n        };\n    }\n    static{\n        this.overrides = {\n            interaction: {\n                mode: \"point\"\n            },\n            scales: {\n                x: {\n                    type: \"linear\"\n                },\n                y: {\n                    type: \"linear\"\n                }\n            }\n        };\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale, yScale } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        return {\n            label: labels[index] || \"\",\n            value: \"(\" + x + \", \" + y + \")\"\n        };\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = [] } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            if (!this.datasetElementType) {\n                this.addElements();\n            }\n            const { dataset: line, _dataset } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        } else if (this.datasetElementType) {\n            delete meta.dataset;\n            this.datasetElementType = false;\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = this.chart.registry.getElement(\"line\");\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\nvar controllers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BarController: BarController,\n    BubbleController: BubbleController,\n    DoughnutController: DoughnutController,\n    LineController: LineController,\n    PieController: PieController,\n    PolarAreaController: PolarAreaController,\n    RadarController: RadarController,\n    ScatterController: ScatterController\n});\n/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */ function abstract() {\n    throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */ class DateAdapterBase {\n    /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */ static override(members) {\n        Object.assign(DateAdapterBase.prototype, members);\n    }\n    constructor(options){\n        this.options = options || {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    init() {}\n    formats() {\n        return abstract();\n    }\n    parse() {\n        return abstract();\n    }\n    format() {\n        return abstract();\n    }\n    add() {\n        return abstract();\n    }\n    diff() {\n        return abstract();\n    }\n    startOf() {\n        return abstract();\n    }\n    endOf() {\n        return abstract();\n    }\n}\nvar adapters = {\n    _date: DateAdapterBase\n};\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller, data, _sorted } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n    if (iScale && axis === iScale.axis && axis !== \"r\" && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.A : _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B;\n        if (!intersect) {\n            const result = lookupMethod(data, axis, value);\n            if (spanGaps) {\n                const { vScale } = controller._cachedMeta;\n                const { _parsed } = metaset;\n                const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point)=>!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(point[vScale.axis]));\n                result.lo -= Math.max(0, distanceToDefinedLo);\n                const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point)=>!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(point[vScale.axis]));\n                result.hi += Math.max(0, distanceToDefinedHi);\n            }\n            return result;\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === \"function\" && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index, data } = metasets[i];\n        const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\nfunction getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf(\"x\") !== -1;\n    const useY = axis.indexOf(\"y\") !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle, endAngle } = element.getProps([\n            \"startAngle\",\n            \"endAngle\"\n        ], useFinalPosition);\n        const { angle } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D)(element, {\n            x: position.x,\n            y: position.y\n        });\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === \"r\" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === \"x\" ? \"inXRange\" : \"inYRange\";\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\nvar Interaction = {\n    evaluateInteractionItems,\n    modes: {\n        index (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || \"x\";\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n        dataset (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n        point (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n        nearest (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n        x (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            return getAxisItems(chart, position, \"x\", options.intersect, useFinalPosition);\n        },\n        y (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            return getAxisItems(chart, position, \"y\", options.intersect, useFinalPosition);\n        }\n    }\n};\nconst STATIC_POSITIONS = [\n    \"left\",\n    \"top\",\n    \"right\",\n    \"bottom\"\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos, options: { stack, stackWeight = 1 } } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack, pos, stackWeight } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth, hBoxMaxHeight } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, \"left\"), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, \"right\"));\n    const top = sortByWeight(filterByPosition(layoutBoxes, \"top\"), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, \"bottom\"));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, \"x\");\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, \"y\");\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, \"chartArea\"),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos, box } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, \"left\", \"right\"));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, \"top\", \"bottom\"));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos(\"top\");\n    chartArea.x += updatePos(\"left\");\n    updatePos(\"right\");\n    updatePos(\"bottom\");\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        \"left\",\n        \"right\"\n    ]) : marginForPositions([\n        \"top\",\n        \"bottom\"\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same, other } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x, y } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\nvar layouts = {\n    addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || \"top\";\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n    removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n    configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n    update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === \"function\") {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\nclass BasePlatform {\n    acquireContext(canvas, aspectRatio) {}\n    releaseContext(context) {\n        return false;\n    }\n    addEventListener(chart, type, listener) {}\n    removeEventListener(chart, type, listener) {}\n    getDevicePixelRatio() {\n        return 1;\n    }\n    getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n    isAttached(canvas) {\n        return true;\n    }\n    updateConfig(config) {}\n}\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext(\"2d\") || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\nconst EXPANDO_KEY = \"$chartjs\";\nconst EVENT_TYPES = {\n    touchstart: \"mousedown\",\n    touchmove: \"mousemove\",\n    touchend: \"mouseup\",\n    pointerenter: \"mouseenter\",\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointerleave: \"mouseout\",\n    pointerout: \"mouseout\"\n};\nconst isNullOrEmpty = (value)=>value === null || value === \"\";\nfunction initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute(\"height\");\n    const renderWidth = canvas.getAttribute(\"width\");\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || \"block\";\n    style.boxSizing = style.boxSizing || \"border-box\";\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J)(canvas, \"width\");\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === \"\") {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J)(canvas, \"height\");\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.K ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    if (node) {\n        node.addEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction removeListener(chart, type, listener) {\n    if (chart && chart.canvas) {\n        chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x, y } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener(\"resize\", onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener(\"resize\", onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I)(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L)((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === \"resize\") {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L)((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart);\n    addListener(canvas, type, proxy);\n    return proxy;\n}\nclass DomPlatform extends BasePlatform {\n    acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext(\"2d\");\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n    releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            \"height\",\n            \"width\"\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n    addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n    removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n    getMaximumSize(canvas, width, height, aspectRatio) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.G)(canvas, width, height, aspectRatio);\n    }\n    isAttached(canvas) {\n        const container = canvas && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I)(canvas);\n        return !!(container && container.isConnected);\n    }\n}\nfunction _detectPlatform(canvas) {\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M)() || typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\nclass Element {\n    static{\n        this.defaults = {};\n    }\n    static{\n        this.defaultRoutes = undefined;\n    }\n    tooltipPosition(useFinalPosition) {\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.x) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            // let's not create an object, if not needed\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n    constructor(){\n        this.active = false;\n    }\n}\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const determinedMaxTicks = determineMaxTicks(scale);\n    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.N)(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorStart, 0);\n    const end = Math.min((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\nfunction getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\nconst reverseAlign = (align)=>align === \"left\" ? \"right\" : align === \"right\" ? \"left\" : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === \"top\" || edge === \"left\" ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);\nfunction sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\nfunction garbageCollect(caches, length) {\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\nfunction getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.font, fallback);\n    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n    const lines = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        scale,\n        type: \"scale\"\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        tick,\n        index,\n        type: \"tick\"\n    });\n}\nfunction titleAlign(align, position, reverse) {\n    let ret = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(align);\n    if (reverse && position !== \"right\" || !reverse && position === \"right\") {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top, left, bottom, right, chart } = scale;\n    const { chartArea, scales } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, left, right);\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === \"center\") {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === \"center\") {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, bottom, top);\n        rotation = position === \"left\" ? -_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H : _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    constructor(cfg){\n        super();\n        this.id = cfg.id;\n        this.type = cfg.type;\n        this.options = undefined;\n        this.ctx = cfg.ctx;\n        this.chart = cfg.chart;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n        this.maxWidth = undefined;\n        this.maxHeight = undefined;\n        this.paddingTop = undefined;\n        this.paddingBottom = undefined;\n        this.paddingLeft = undefined;\n        this.paddingRight = undefined;\n        this.axis = undefined;\n        this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n        this.ticks = [];\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n        this._startPixel = undefined;\n        this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n    init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n    parse(raw, index) {\n        return raw;\n    }\n    getUserBounds() {\n        let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;\n        _userMin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMin, _suggestedMin),\n            max: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMax, _suggestedMax),\n            minDefined: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMin),\n            maxDefined: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMax)\n        };\n    }\n    getMinMax(canStack) {\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(min, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(max, min)),\n            max: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(max, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(min, max))\n        };\n    }\n    getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n    getTicks() {\n        return this.ticks;\n    }\n    getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n    getLabelItems(chartArea = this.chart.chartArea) {\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        return items;\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n    update(maxWidth, maxHeight, margins) {\n        const { beginAtZero, grace, ticks: tickOpts } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.R)(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === \"auto\")) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n    configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks(\"beforeDataLimits\");\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks(\"afterDataLimits\");\n    }\n    beforeBuildTicks() {\n        this._callHooks(\"beforeBuildTicks\");\n    }\n    buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks(\"afterBuildTicks\");\n    }\n    beforeTickToLabelConversion() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n    generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(Math.min(Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first, last, widest, highest } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align, padding }, position } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== \"top\" && this.axis === \"x\";\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === \"start\") {\n                paddingRight = last.width;\n            } else if (align === \"end\") {\n                paddingLeft = first.width;\n            } else if (align !== \"inner\") {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === \"start\") {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === \"end\") {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n    _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterFit, [\n            this\n        ]);\n    }\n    isHorizontal() {\n        const { axis, position } = this.options;\n        return position === \"top\" || position === \"bottom\" || axis === \"x\";\n    }\n    isFullSize() {\n        return this.options.fullSize;\n    }\n    _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n    _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n        }\n        return labelSizes;\n    }\n    _computeLabelSizes(ticks, length, maxTicksLimit) {\n        const { ctx, _longestTextCache: caches } = this;\n        const widths = [];\n        const heights = [];\n        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; i += increment){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(label) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                width = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel = label[j];\n                    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(nestedLabel) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(nestedLabel)) {\n                        width = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n    getLabelForValue(value) {\n        return value;\n    }\n    getPixelForValue(value, index) {\n        return NaN;\n    }\n    getValueForPixel(pixel) {}\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.W)(this._alignToPixels ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(this.chart, pixel, 0) : pixel);\n    }\n    getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n    getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n    getBaseValue() {\n        const { min, max } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n    getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n    _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n    _isVisible() {\n        const display = this.options.display;\n        if (display !== \"auto\") {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n    _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid, position, border } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = borderOpts.display ? borderOpts.width : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === \"top\") {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === \"bottom\") {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === \"left\") {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === \"right\") {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === \"x\") {\n            if (position === \"center\") {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === \"y\") {\n            if (position === \"center\") {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const context = this.getContext(i);\n            const optsAtIndex = grid.setContext(context);\n            const optsAtIndexBorder = border.setContext(context);\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndexBorder.dash || [];\n            const borderDashOffset = optsAtIndexBorder.dashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n    _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position, ticks: optionTicks } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align, crossAlign, padding, mirror } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = \"middle\";\n        if (position === \"top\") {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === \"bottom\") {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === \"left\") {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === \"right\") {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === \"x\") {\n            if (position === \"center\") {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === \"y\") {\n            if (position === \"center\") {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === \"y\") {\n            if (align === \"start\") {\n                textBaseline = \"top\";\n            } else if (align === \"end\") {\n                textBaseline = \"bottom\";\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === \"inner\") {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? \"right\" : \"left\";\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? \"left\" : \"right\";\n                    } else {\n                        tickTextAlign = \"center\";\n                    }\n                }\n                if (position === \"top\") {\n                    if (crossAlign === \"near\" || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === \"center\") {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === \"near\" || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === \"center\") {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n                    x += lineHeight / 2 * Math.sin(rotation);\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = textOffset - labelPadding.top;\n                let left = 0 - labelPadding.left;\n                switch(textBaseline){\n                    case \"middle\":\n                        top -= height / 2;\n                        break;\n                    case \"bottom\":\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case \"center\":\n                        left -= width / 2;\n                        break;\n                    case \"right\":\n                        left -= width;\n                        break;\n                    case \"inner\":\n                        if (i === ilen - 1) {\n                            left -= width;\n                        } else if (i > 0) {\n                            left -= width / 2;\n                        }\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                label,\n                font,\n                textOffset,\n                options: {\n                    rotation,\n                    color,\n                    strokeColor,\n                    strokeWidth,\n                    textAlign: tickTextAlign,\n                    textBaseline,\n                    translation: [\n                        x,\n                        y\n                    ],\n                    backdrop\n                }\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position, ticks } = this.options;\n        const rotation = -(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        if (rotation) {\n            return position === \"top\" ? \"left\" : \"right\";\n        }\n        let align = \"center\";\n        if (ticks.align === \"start\") {\n            align = \"left\";\n        } else if (ticks.align === \"end\") {\n            align = \"right\";\n        } else if (ticks.align === \"inner\") {\n            align = \"inner\";\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position, ticks: { crossAlign, mirror, padding } } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === \"left\") {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"left\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x += widest / 2;\n                } else {\n                    textAlign = \"right\";\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"right\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x -= widest / 2;\n                } else {\n                    textAlign = \"left\";\n                    x = this.left;\n                }\n            }\n        } else if (position === \"right\") {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"right\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x -= widest / 2;\n                } else {\n                    textAlign = \"left\";\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"left\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x += widest / 2;\n                } else {\n                    textAlign = \"right\";\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = \"right\";\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n    _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === \"left\" || position === \"right\") {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === \"top\" || position === \"bottom\") {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n    drawBackground() {\n        const { ctx, options: { backgroundColor }, left, top, width, height } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n    drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n    drawBorder() {\n        const { chart, ctx, options: { border, grid } } = this;\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = border.display ? borderOpts.width : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.width;\n        ctx.strokeStyle = borderOpts.color;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n    drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, area);\n        }\n        const items = this.getLabelItems(chartArea);\n        for (const item of items){\n            const renderTextOptions = item.options;\n            const tickFont = item.font;\n            const label = item.label;\n            const y = item.textOffset;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, label, 0, y, tickFont, renderTextOptions);\n        }\n        if (area) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n        }\n    }\n    drawTitle() {\n        const { ctx, options: { position, title, reverse } } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(title.font);\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === \"bottom\" || position === \"center\" || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            offset += padding.bottom;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: \"middle\",\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n    _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(opts.grid && opts.grid.z, -1);\n        const bz = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(opts.border && opts.border.z, 0);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: bz,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n    getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + \"AxisID\";\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);\n    }\n    _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n}\nclass TypedRegistry {\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n    register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + \".\" + id;\n        if (!id) {\n            throw new Error(\"class does not have id: \" + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n    get(id) {\n        return this.items[id];\n    }\n    unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d[scope]) {\n            delete _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d[scope][id];\n            if (this.override) {\n                delete _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[id];\n            }\n        }\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a4)(Object.create(null), [\n        parentScope ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.get(parentScope) : {},\n        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.get(scope),\n        item.defaults\n    ]);\n    _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split(\".\");\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join(\".\");\n        const parts = routes[property].split(\".\");\n        const targetName = parts.pop();\n        const targetScope = parts.join(\".\");\n        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return \"id\" in proto && \"defaults\" in proto;\n}\nclass Registry {\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, \"datasets\", true);\n        this.elements = new TypedRegistry(Element, \"elements\");\n        this.plugins = new TypedRegistry(Object, \"plugins\");\n        this.scales = new TypedRegistry(Scale, \"scales\");\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n    add(...args) {\n        this._each(\"register\", args);\n    }\n    remove(...args) {\n        this._each(\"unregister\", args);\n    }\n    addControllers(...args) {\n        this._each(\"register\", args, this.controllers);\n    }\n    addElements(...args) {\n        this._each(\"register\", args, this.elements);\n    }\n    addPlugins(...args) {\n        this._each(\"register\", args, this.plugins);\n    }\n    addScales(...args) {\n        this._each(\"register\", args, this.scales);\n    }\n    getController(id) {\n        return this._get(id, this.controllers, \"controller\");\n    }\n    getElement(id) {\n        return this._get(id, this.elements, \"element\");\n    }\n    getPlugin(id) {\n        return this._get(id, this.plugins, \"plugin\");\n    }\n    getScale(id) {\n        return this._get(id, this.scales, \"scale\");\n    }\n    removeControllers(...args) {\n        this._each(\"unregister\", args, this.controllers);\n    }\n    removeElements(...args) {\n        this._each(\"unregister\", args, this.elements);\n    }\n    removePlugins(...args) {\n        this._each(\"unregister\", args, this.plugins);\n    }\n    removeScales(...args) {\n        this._each(\"unregister\", args, this.scales);\n    }\n    _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n    _exec(method, registry, component) {\n        const camelMethod = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a5)(method);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(component[\"before\" + camelMethod], [], component);\n        registry[method](component);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(component[\"after\" + camelMethod], [], component);\n    }\n    _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n    _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + \".\");\n        }\n        return item;\n    }\n}\nvar registry = /* #__PURE__ */ new Registry();\nclass PluginService {\n    constructor(){\n        this._init = undefined;\n    }\n    notify(chart, hook, args, filter) {\n        if (hook === \"beforeInit\") {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, \"install\");\n        }\n        if (this._init === undefined) {\n            return;\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === \"afterDestroy\") {\n            this._notify(descriptors, chart, \"stop\");\n            this._notify(this._init, chart, \"uninstall\");\n            this._init = undefined;\n        }\n        return result;\n    }\n    _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n    _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n    _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, \"stop\");\n        this._notify(diff(descriptors, previousDescriptors), chart, \"start\");\n    }\n}\nfunction allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, { plugins, localIds }, options, all) {\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, { plugin, local }, opts, context) {\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        \"\"\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || \"x\";\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === \"_index_\") {\n        axis = indexAxis;\n    } else if (id === \"_value_\") {\n        axis = indexAxis === \"x\" ? \"y\" : \"x\";\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? \"_index_\" : \"_value_\";\n}\nfunction idMatchesAxis(id) {\n    if (id === \"x\" || id === \"y\" || id === \"r\") {\n        return id;\n    }\n}\nfunction axisFromPosition(position) {\n    if (position === \"top\" || position === \"bottom\") {\n        return \"x\";\n    }\n    if (position === \"left\" || position === \"right\") {\n        return \"y\";\n    }\n}\nfunction determineAxis(id, ...scaleOptions) {\n    if (idMatchesAxis(id)) {\n        return id;\n    }\n    for (const opts of scaleOptions){\n        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n        if (axis) {\n            return axis;\n        }\n    }\n    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\nfunction getAxisFromDataset(id, axis, dataset) {\n    if (dataset[axis + \"AxisID\"] === id) {\n        return {\n            axis\n        };\n    }\n}\nfunction retrieveAxisFromDatasets(id, config) {\n    if (config.data && config.data.datasets) {\n        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);\n        if (boundDs.length) {\n            return getAxisFromDataset(id, \"x\", boundDs[0]) || getAxisFromDataset(id, \"y\", boundDs[0]);\n        }\n    }\n    return {};\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(scaleConf)) {\n            return console.error(`Invalid scale configuration for scale: ${id}`);\n        }\n        if (scaleConf._proxy) {\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n        }\n        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[scaleConf.type]);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        scales[id] = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + \"AxisID\"] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(scale, [\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[scale.type],\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n    datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    `datasets.${datasetType}`,\n                    \"\"\n                ]\n            ]);\n    }\n    datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\n                [\n                    `datasets.${datasetType}.transitions.${transition}`,\n                    `transitions.${transition}`\n                ],\n                [\n                    `datasets.${datasetType}`,\n                    \"\"\n                ]\n            ]);\n    }\n    datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\n                [\n                    `datasets.${datasetType}.elements.${elementType}`,\n                    `datasets.${datasetType}`,\n                    `elements.${elementType}`,\n                    \"\"\n                ]\n            ]);\n    }\n    pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\n                [\n                    `plugins.${id}`,\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n    _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n    getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options, type } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a6, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n    chartOptionScopes() {\n        const { options, type } = this;\n        return [\n            options,\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {},\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {},\n            {\n                type\n            },\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d,\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a6\n        ];\n    }\n    resolveNamedOptions(scopes, names, context, prefixes = [\n        \"\"\n    ]) {\n        const result = {\n            $shared: true\n        };\n        const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8)(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n    createResolver(scopes, context, prefixes = [\n        \"\"\n    ], descriptorDefaults) {\n        const { resolver } = getResolver(this._resolverCache, scopes, prefixes);\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(context) ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8)(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a9)(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes(\"hover\"))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value) && Object.getOwnPropertyNames(value).some((key)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(value[key]));\nfunction needContext(proxy, names) {\n    const { isScriptable, isIndexable } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aa)(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(value) || hasFunction(value)) || indexable && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(value)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar version = \"4.5.1\";\nconst KNOWN_POSITIONS = [\n    \"top\",\n    \"bottom\",\n    \"left\",\n    \"right\",\n    \"chartArea\"\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === \"top\" || position === \"bottom\" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === \"x\";\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins(\"afterRender\");\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\nfunction getCanvas(item) {\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M)() && typeof item === \"string\") {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === \"mouseout\") {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nclass Chart {\n    static{\n        this.defaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d;\n    }\n    static{\n        this.instances = instances;\n    }\n    static{\n        this.overrides = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3;\n    }\n    static{\n        this.registry = registry;\n    }\n    static{\n        this.version = version;\n    }\n    static{\n        this.getChart = getChart;\n    }\n    static register(...items) {\n        registry.add(...items);\n        invalidatePlugins();\n    }\n    static unregister(...items) {\n        registry.remove(...items);\n        invalidatePlugins();\n    }\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error(\"Canvas is already in use. Chart with ID '\" + existingChart.id + \"'\" + \" must be destroyed before the canvas with ID '\" + existingChart.canvas.id + \"' can be reused.\");\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ac)();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n        this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ad)((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, \"complete\", onAnimationsComplete);\n        animator.listen(this, \"progress\", onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    get registry() {\n        return registry;\n    }\n    _initialize() {\n        this.notifyPlugins(\"beforeInit\");\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins(\"afterInit\");\n        return this;\n    }\n    clear() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af)(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n    resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? \"resize\" : \"attach\";\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins(\"resize\", {\n            size: newSize\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n    buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === \"r\";\n                const isHorizontal = axis === \"x\";\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? \"chartArea\" : isHorizontal ? \"bottom\" : \"left\",\n                    dtype: isRadial ? \"radialLinear\" : isHorizontal ? \"category\" : \"linear\"\n                };\n            }));\n        }\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n    _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level(\"order\", \"index\"));\n    }\n    _removeUnreferencedMetasets() {\n        const { _metasets: metasets, data: { datasets } } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = \"\" + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType, dataElementType } = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type];\n                Object.assign(ControllerClass, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n    _resetElements() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n    reset() {\n        this._resetElements();\n        this.notifyPlugins(\"reset\");\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins(\"beforeUpdate\", {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins(\"beforeElementsUpdate\");\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins(\"afterUpdate\", {\n            mode\n        });\n        this._layers.sort(compare2Level(\"z\", \"_idx\"));\n        const { _active, _lastEvent } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n    _updateScales() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n    _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n    _updateHiddenIndices() {\n        const { _hiddenIndices } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method, start, count } of changes){\n            const move = method === \"_removeElements\" ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n    _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + \",\" + c.splice(1).join(\",\")));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag)(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(\",\")).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n    _updateLayout(minPadding) {\n        if (this.notifyPlugins(\"beforeLayout\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.boxes, (box)=>{\n            if (noArea && box.position === \"chartArea\") {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins(\"afterLayout\");\n    }\n    _updateDatasets(mode) {\n        if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins(\"afterDatasetsUpdate\", {\n            mode\n        });\n    }\n    _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins(\"beforeDatasetUpdate\", args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins(\"afterDatasetUpdate\", args);\n    }\n    render() {\n        if (this.notifyPlugins(\"beforeRender\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width, height } = this._resizeBeforeDraw;\n            this._resizeBeforeDraw = null;\n            this._resize(width, height);\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins(\"beforeDraw\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins(\"afterDraw\");\n    }\n    _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n    _drawDatasets() {\n        if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins(\"afterDatasetsDraw\");\n    }\n    _drawDataset(meta) {\n        const ctx = this.ctx;\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        const clip = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah)(this, meta);\n        if (this.notifyPlugins(\"beforeDatasetDraw\", args) === false) {\n            return;\n        }\n        if (clip) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, clip);\n        }\n        meta.controller.draw();\n        if (clip) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins(\"afterDatasetDraw\", args);\n    }\n    isPointInArea(point) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === \"function\") {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(null, {\n            chart: this,\n            type: \"chart\"\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === \"boolean\" ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n    _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? \"show\" : \"hide\";\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n    _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins(\"beforeDestroy\");\n        const { canvas, ctx } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af)(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        delete instances[this.id];\n        this.notifyPlugins(\"afterDestroy\");\n    }\n    toBase64Image(...args) {\n        return this.canvas.toDataURL(...args);\n    }\n    bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n    bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.options.events, (type)=>_add(type, listener));\n    }\n    bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove(\"attach\", attached);\n            this.attached = true;\n            this.resize();\n            _add(\"resize\", listener);\n            _add(\"detach\", detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove(\"resize\", listener);\n            this._stop();\n            this._resize(0, 0);\n            _add(\"attach\", attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n    unbindEvents() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? \"set\" : \"remove\";\n        let meta, item, i, ilen;\n        if (mode === \"dataset\") {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller[\"_\" + prefix + \"DatasetHoverStyle\"]();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + \"HoverStyle\"](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map(({ datasetIndex, index })=>{\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error(\"No dataset found at index \" + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n    notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n    isPluginEnabled(pluginId) {\n        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;\n    }\n    _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n    _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins(\"beforeEvent\", args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins(\"afterEvent\", args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n    _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [], options } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aj)(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === \"mouseout\") {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n}\nfunction invalidatePlugins() {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(Chart.instances, (chart)=>chart._plugins.invalidate());\n}\nfunction clipSelf(ctx, element, endAngle) {\n    const { startAngle, x, y, outerRadius, innerRadius, options } = element;\n    const { borderWidth, borderJoinStyle } = options;\n    const outerAngleClip = Math.min(borderWidth / outerRadius, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);\n    if (innerRadius > 0) {\n        const innerAngleClip = Math.min(borderWidth / innerRadius, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));\n        ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);\n    } else {\n        const clipWidth = Math.min(borderWidth / 2, outerRadius * (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));\n        if (borderJoinStyle === \"round\") {\n            ctx.arc(x, y, clipWidth, endAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2, startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2, true);\n        } else if (borderJoinStyle === \"bevel\") {\n            const r = 2 * clipWidth * clipWidth;\n            const endX = -r * Math.cos(endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + x;\n            const endY = -r * Math.sin(endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + y;\n            const startX = r * Math.cos(startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + x;\n            const startY = r * Math.sin(startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + y;\n            ctx.lineTo(endX, endY);\n            ctx.lineTo(startX, startY);\n        }\n    }\n    ctx.closePath();\n    ctx.moveTo(0, 0);\n    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.clip(\"evenodd\");\n}\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    // Draw an inner border by clipping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.am)(value, [\n        \"outerStart\",\n        \"outerEnd\",\n        \"innerStart\",\n        \"innerEnd\"\n    ]);\n}\n/**\n * Parse border radius from the provided options\n */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    // Outer limits are complicated. We want to compute the available angular distance at\n    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n    //\n    // If the borderRadius is large, that value can become negative.\n    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n    // we know that the thickness term will dominate and compute the limits at that point\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(o.innerStart, 0, innerLimit),\n        innerEnd: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(o.innerEnd, 0, innerLimit)\n    };\n}\n/**\n * Convert (r, ) to (x, y)\n */ function rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */ function pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        // When spacing is present, it is the same for all items\n        // So we adjust the start and end angle of the arc such that\n        // the distance is the same as it would be without the spacing\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        // The first arc segments from point 1 to point a to point 2\n        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n        // The corner segment from point 2 to point 3\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        // The line from point 3 to point 4\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        // The corner segment from point 4 to point 5\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, innerEndAdjustedAngle + Math.PI);\n        }\n        // The inner arc from point 5 to point b to point 6\n        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\n        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\n        // The corner segment from point 6 to point 7\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        // The line from point 7 to point 8\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        // The corner segment from point 8 to point 1\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles, startAngle, circumference } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawBorder(ctx, element, offset, spacing, circular) {\n    const { fullCircles, startAngle, circumference, options } = element;\n    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset, borderRadius } = options;\n    const inner = options.borderAlign === \"inner\";\n    if (!borderWidth) {\n        return;\n    }\n    ctx.setLineDash(borderDash || []);\n    ctx.lineDashOffset = borderDashOffset;\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || \"round\";\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || \"bevel\";\n    }\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.stroke();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n        }\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    if (options.selfJoin && endAngle - startAngle >= _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P && borderRadius === 0 && borderJoinStyle !== \"miter\") {\n        clipSelf(ctx, element, endAngle);\n    }\n    if (!fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        ctx.stroke();\n    }\n}\nclass ArcElement extends Element {\n    static{\n        this.id = \"arc\";\n    }\n    static{\n        this.defaults = {\n            borderAlign: \"center\",\n            borderColor: \"#fff\",\n            borderDash: [],\n            borderDashOffset: 0,\n            borderJoinStyle: undefined,\n            borderRadius: 0,\n            borderWidth: 2,\n            offset: 0,\n            spacing: 0,\n            angle: undefined,\n            circular: true,\n            selfJoin: false\n        };\n    }\n    static{\n        this.defaultRoutes = {\n            backgroundColor: \"backgroundColor\"\n        };\n    }\n    static{\n        this.descriptors = {\n            _scriptable: true,\n            _indexable: (name)=>name !== \"borderDash\"\n        };\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        const { angle, distance } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D)(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([\n            \"startAngle\",\n            \"endAngle\",\n            \"innerRadius\",\n            \"outerRadius\",\n            \"circumference\"\n        ], useFinalPosition);\n        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n        const _circumference = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(circumference, endAngle - startAngle);\n        const nonZeroBetween = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle) && startAngle !== endAngle;\n        const betweenAngles = _circumference >= _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || nonZeroBetween;\n        const withinRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([\n            \"x\",\n            \"y\",\n            \"startAngle\",\n            \"endAngle\",\n            \"innerRadius\",\n            \"outerRadius\"\n        ], useFinalPosition);\n        const { offset, spacing } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options, circumference } = this;\n        const offset = (options.offset || 0) / 4;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === \"inner\" ? 0.33 : 0;\n        this.fullCircles = circumference > _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T ? Math.floor(circumference / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        const halfAngle = (this.startAngle + this.endAngle) / 2;\n        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n        const fix = 1 - Math.sin(Math.min(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P, circumference || 0));\n        const radiusOffset = offset * fix;\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, circular);\n        ctx.restore();\n    }\n}\nfunction setStyle(ctx, options, style = options) {\n    ctx.lineCap = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.at;\n    }\n    if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.au;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n    const count = points.length;\n    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;\n    const { start: segmentStart, end: segmentEnd } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\nfunction pathSegment(ctx, line, segment, params) {\n    const { points, options } = line;\n    const { count, start, loop, ilen } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move = true, reverse } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count, start, ilen } = pathVars(points, segment, params);\n    const { move = true, reverse } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\nfunction _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== \"monotone\" && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aq;\n    }\n    if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ar;\n    }\n    return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.as;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments, options } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === \"function\";\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    static{\n        this.id = \"line\";\n    }\n    static{\n        this.defaults = {\n            borderCapStyle: \"butt\",\n            borderDash: [],\n            borderDashOffset: 0,\n            borderJoinStyle: \"miter\",\n            borderWidth: 3,\n            capBezierPoints: true,\n            cubicInterpolationMode: \"default\",\n            fill: false,\n            spanGaps: false,\n            stepped: false,\n            tension: 0\n        };\n    }\n    static{\n        this.defaultRoutes = {\n            backgroundColor: \"backgroundColor\",\n            borderColor: \"borderColor\"\n        };\n    }\n    static{\n        this.descriptors = {\n            _scriptable: true,\n            _indexable: (name)=>name !== \"borderDash\" && name !== \"fill\"\n        };\n    }\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === \"monotone\") && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.an)(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ao)(this, this.options.segment));\n    }\n    first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n    last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n    interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ap)(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start, end } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n    path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n    draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n}\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    static{\n        this.id = \"point\";\n    }\n    static{\n        /**\n   * @type {any}\n   */ this.defaults = {\n            borderWidth: 1,\n            hitRadius: 1,\n            hoverBorderWidth: 1,\n            hoverRadius: 4,\n            pointStyle: \"circle\",\n            radius: 3,\n            rotation: 0\n        };\n    }\n    static{\n        /**\n   * @type {any}\n   */ this.defaultRoutes = {\n            backgroundColor: \"backgroundColor\",\n            borderColor: \"borderColor\"\n        };\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, \"x\", useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, \"y\", useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        // @ts-expect-error Fallbacks should never be hit in practice\n        return options.radius + options.hitRadius;\n    }\n}\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x, y, base, width, height } = bar.getProps([\n        \"x\",\n        \"y\",\n        \"base\",\n        \"width\",\n        \"height\"\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius } = bar.getProps([\n        \"enableBorderRadius\"\n    ]);\n    const value = bar.options.borderRadius;\n    const o = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, bounds.left, bounds.right)) && (skipY || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    static{\n        this.id = \"bar\";\n    }\n    static{\n        this.defaults = {\n            borderSkipped: \"start\",\n            borderWidth: 0,\n            borderRadius: 0,\n            inflateAmount: \"auto\",\n            pointStyle: undefined\n        };\n    }\n    static{\n        this.defaultRoutes = {\n            backgroundColor: \"backgroundColor\",\n            borderColor: \"borderColor\"\n        };\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    draw(ctx) {\n        const { inflateAmount, options: { borderColor, backgroundColor } } = this;\n        const { inner, outer } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill(\"evenodd\");\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, base, horizontal } = this.getProps([\n            \"x\",\n            \"y\",\n            \"base\",\n            \"horizontal\"\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === \"x\" ? this.width / 2 : this.height / 2;\n    }\n}\nvar elements = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ArcElement: ArcElement,\n    BarElement: BarElement,\n    LineElement: LineElement,\n    PointElement: PointElement\n});\nconst BORDER_COLORS = [\n    \"rgb(54, 162, 235)\",\n    \"rgb(255, 99, 132)\",\n    \"rgb(255, 159, 64)\",\n    \"rgb(255, 205, 86)\",\n    \"rgb(75, 192, 192)\",\n    \"rgb(153, 102, 255)\",\n    \"rgb(201, 203, 207)\" // grey\n];\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace(\"rgb(\", \"rgba(\").replace(\")\", \", 0.5)\"));\nfunction getBorderColor(i) {\n    return BORDER_COLORS[i % BORDER_COLORS.length];\n}\nfunction getBackgroundColor(i) {\n    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\nfunction colorizeDefaultDataset(dataset, i) {\n    dataset.borderColor = getBorderColor(i);\n    dataset.backgroundColor = getBackgroundColor(i);\n    return ++i;\n}\nfunction colorizeDoughnutDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));\n    return i;\n}\nfunction colorizePolarAreaDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));\n    return i;\n}\nfunction getColorizer(chart) {\n    let i = 0;\n    return (dataset, datasetIndex)=>{\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\n        if (controller instanceof DoughnutController) {\n            i = colorizeDoughnutDataset(dataset, i);\n        } else if (controller instanceof PolarAreaController) {\n            i = colorizePolarAreaDataset(dataset, i);\n        } else if (controller) {\n            i = colorizeDefaultDataset(dataset, i);\n        }\n    };\n}\nfunction containsColorsDefinitions(descriptors) {\n    let k;\n    for(k in descriptors){\n        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction containsColorsDefinition(descriptor) {\n    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\nfunction containsDefaultColorsDefenitions() {\n    return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.borderColor !== \"rgba(0,0,0,0.1)\" || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.backgroundColor !== \"rgba(0,0,0,0.1)\";\n}\nvar plugin_colors = {\n    id: \"colors\",\n    defaults: {\n        enabled: true,\n        forceOverride: false\n    },\n    beforeLayout (chart, _args, options) {\n        if (!options.enabled) {\n            return;\n        }\n        const { data: { datasets }, options: chartOptions } = chart.config;\n        const { elements } = chartOptions;\n        const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();\n        if (!options.forceOverride && containsColorDefenition) {\n            return;\n        }\n        const colorizer = getColorizer(chart);\n        datasets.forEach(colorizer);\n    }\n};\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n    const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx, y: pointAy } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(minIndex) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, \"data\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale } = meta;\n    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n    if (minDefined) {\n        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: \"decimation\",\n    defaults: {\n        algorithm: \"min-max\",\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data, indexAxis } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === \"y\") {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== \"linear\" && xAxis.type !== \"time\") {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, \"data\", {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case \"lttb\":\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case \"min-max\":\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start, end } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ap)(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.az)(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, \"start\", Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, \"end\", Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === \"angle\") {\n        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(start);\n        end = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x = null, y = null } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach(({ start, end })=>{\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\nfunction _decodeFill(line, index, count) {\n    const fill = parseFillOption(line);\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        \"origin\",\n        \"start\",\n        \"end\",\n        \"stack\",\n        \"shape\"\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === \"-\" || firstCh === \"+\") {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\nfunction _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === \"start\") {\n        pixel = scale.bottom;\n    } else if (fill === \"end\") {\n        pixel = scale.top;\n    } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === \"start\") {\n        value = startValue;\n    } else if (fill === \"end\") {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\nfunction parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return \"origin\";\n    }\n    return fill;\n}\nfunction _buildStackLine(source) {\n    const { scale, index, line } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\nfunction getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas(\"line\");\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first, last, point } = findPoint(line, sourcePoint, \"x\");\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\nclass simpleArc {\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n    pathSegment(ctx, bounds, opts) {\n        const { x, y, radius } = this;\n        bounds = bounds || {\n            start: 0,\n            end: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x, y, radius } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n}\nfunction _getTarget(source) {\n    const { chart, fill, line } = source;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === \"stack\") {\n        return _buildStackLine(source);\n    }\n    if (fill === \"shape\") {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale = {}, fill } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale, fill } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { chart, index, line, scale, axis } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above = color, below = color } = fillOption || {};\n    const meta = chart.getDatasetMeta(index);\n    const clip = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah)(chart, meta);\n    if (target && line.points.length) {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis,\n            clip\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line, target, above, below, area, scale, clip } = cfg;\n    const property = line._loop ? \"angle\" : cfg.axis;\n    ctx.save();\n    let fillColor = below;\n    if (below !== above) {\n        if (property === \"x\") {\n            clipVertical(ctx, target, area.top);\n            fill(ctx, {\n                line,\n                target,\n                color: above,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipVertical(ctx, target, area.bottom);\n        } else if (property === \"y\") {\n            clipHorizontal(ctx, target, area.left);\n            fill(ctx, {\n                line,\n                target,\n                color: below,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipHorizontal(ctx, target, area.right);\n            fillColor = above;\n        }\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: fillColor,\n        scale,\n        property,\n        clip\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments, points } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start, end } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction clipHorizontal(ctx, target, clipX) {\n    const { segments, points } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start, end } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(clipX, firstPoint.y);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(clipX, lastPoint.y);\n        }\n    }\n    ctx.lineTo(clipX, target.first().y);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line, target, property, color, scale, clip } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src, target: tgt, start, end } of segments){\n        const { style: { backgroundColor = color } = {} } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? \"evenodd\" : \"nonzero\");\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, clip, bounds) {\n    const chartArea = scale.chart.chartArea;\n    const { property, start, end } = bounds || {};\n    if (property === \"x\" || property === \"y\") {\n        let left, top, right, bottom;\n        if (property === \"x\") {\n            left = start;\n            top = chartArea.top;\n            right = end;\n            bottom = chartArea.bottom;\n        } else {\n            left = chartArea.left;\n            top = start;\n            right = chartArea.right;\n            bottom = end;\n        }\n        ctx.beginPath();\n        if (clip) {\n            left = Math.max(left, clip.left);\n            right = Math.min(right, clip.right);\n            top = Math.max(top, clip.top);\n            bottom = Math.min(bottom, clip.bottom);\n        }\n        ctx.rect(left, top, right - left, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\nvar index = {\n    id: \"filler\",\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === \"beforeDraw\";\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== \"beforeDatasetsDraw\") {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== \"beforeDatasetDraw\") {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: \"beforeDatasetDraw\"\n    }\n};\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n    constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n        this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options, ctx } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx, maxWidth, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = \"left\";\n        ctx.textBaseline = \"middle\";\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n        const { ctx, maxHeight, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === \"top\" || this.options.position === \"bottom\";\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, this);\n            this._draw();\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n        }\n    }\n    _draw() {\n        const { options: opts, columnSizes, lineWidths, ctx } = this;\n        const { align, labels: labelOpts } = opts;\n        const defaultColor = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.color;\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const labelFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(labelOpts.font);\n        const { padding } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign(\"left\");\n        ctx.textBaseline = \"middle\";\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineWidth, 1);\n            ctx.fillStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineCap, \"butt\");\n            ctx.lineDashOffset = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineJoin, \"miter\");\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aE)(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB)(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor;\n            ctx.fillStyle = legendItem.fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aC)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else if (typeof legendItem.text !== \"string\") {\n                const fontLineHeight = labelFont.lineHeight;\n                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD)(this.ctx, opts.textDirection);\n    }\n    drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(position));\n        ctx.textBaseline = \"middle\";\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, titleOpts.text, x, y, titleFont);\n    }\n    _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n    _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, this.left, this.right) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, hitBox.left, hitBox.left + hitBox.width) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n    handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === \"mousemove\" || e.type === \"mouseout\") {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n}\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n    return {\n        itemWidth,\n        itemHeight\n    };\n}\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n    let legendItemText = legendItem.text;\n    if (legendItemText && typeof legendItemText !== \"string\") {\n        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);\n    }\n    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\n}\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n    let itemHeight = _itemHeight;\n    if (typeof legendItem.text !== \"string\") {\n        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n    }\n    return itemHeight;\n}\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n    const labelHeight = legendItem.text ? legendItem.text.length : 0;\n    return fontLineHeight * labelHeight;\n}\nfunction isListened(type, opts) {\n    if ((type === \"mousemove\" || type === \"mouseout\") && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === \"click\" || type === \"mouseup\")) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: \"legend\",\n    _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: \"top\",\n        align: \"center\",\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius } } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: \"center\",\n            text: \"\"\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith(\"on\"),\n        labels: {\n            _scriptable: (name)=>![\n                    \"generateLabels\",\n                    \"filter\",\n                    \"sort\"\n                ].includes(name)\n        }\n    }\n};\nclass Title extends Element {\n    constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(opts.text) ? opts.text.length : 1;\n        this._padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(opts.padding);\n        const textSize = lineCount * (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === \"top\" || pos === \"bottom\";\n    }\n    _drawArgs(offset) {\n        const { top, left, bottom, right, options } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === \"left\") {\n                titleX = left + offset;\n                titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, bottom, top);\n                rotation = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, top, bottom);\n                rotation = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(opts.align),\n            textBaseline: \"middle\",\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: \"title\",\n    _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: \"center\",\n        display: false,\n        font: {\n            weight: \"bold\"\n        },\n        fullSize: true,\n        padding: 10,\n        position: \"top\",\n        text: \"\",\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: \"color\"\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: \"subtitle\",\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: \"center\",\n        display: false,\n        font: {\n            weight: \"normal\"\n        },\n        fullSize: true,\n        padding: 0,\n        position: \"top\",\n        text: \"\",\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: \"color\"\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst positioners = {\n    average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let xSet = new Set();\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                xSet.add(pos.x);\n                y += pos.y;\n                ++count;\n            }\n        }\n        if (count === 0 || xSet.size === 0) {\n            return false;\n        }\n        const xAverage = [\n            ...xSet\n        ].reduce((a, b)=>a + b) / xSet.size;\n        return {\n            x: xAverage,\n            y: y / count\n        };\n    },\n    nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aF)(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\nfunction splitNewlines(str) {\n    if ((typeof str === \"string\" || str instanceof String) && str.indexOf(\"\\n\") > -1) {\n        return str.split(\"\\n\");\n    }\n    return str;\n}\nfunction createTooltipItem(chart, item) {\n    const { element, datasetIndex, index } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label, value } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\nfunction getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body, footer, title } = tooltip;\n    const { boxWidth, boxHeight } = options;\n    const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);\n    const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.titleFont);\n    const footerFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(body, (bodyItem)=>{\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.before, maxLineWidth);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.lines, maxLineWidth);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y, height } = size;\n    if (y < height / 2) {\n        return \"top\";\n    } else if (y > chart.height - height / 2) {\n        return \"bottom\";\n    }\n    return \"center\";\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x, width } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === \"left\" && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === \"right\" && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x, width } = size;\n    const { width: chartWidth, chartArea: { left, right } } = chart;\n    let xAlign = \"center\";\n    if (yAlign === \"center\") {\n        xAlign = x <= (left + right) / 2 ? \"left\" : \"right\";\n    } else if (x <= width / 2) {\n        xAlign = \"left\";\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = \"right\";\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = \"center\";\n    }\n    return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x, width } = size;\n    if (xAlign === \"right\") {\n        x -= width;\n    } else if (xAlign === \"center\") {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y, height } = size;\n    if (yAlign === \"top\") {\n        y += paddingAndSize;\n    } else if (yAlign === \"bottom\") {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize, caretPadding, cornerRadius } = options;\n    const { xAlign, yAlign } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === \"center\") {\n        if (xAlign === \"left\") {\n            x += paddingAndSize;\n        } else if (xAlign === \"right\") {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === \"left\") {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === \"right\") {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(x, 0, chart.width - size.width),\n        y: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n    return align === \"center\" ? tooltip.x + tooltip.width / 2 : align === \"right\" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        tooltip,\n        tooltipItems,\n        type: \"tooltip\"\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nconst defaultCallbacks = {\n    beforeTitle: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    title (tooltipItems) {\n        if (tooltipItems.length > 0) {\n            const item = tooltipItems[0];\n            const labels = item.chart.data.labels;\n            const labelCount = labels ? labels.length : 0;\n            if (this && this.options && this.options.mode === \"dataset\") {\n                return item.dataset.label || \"\";\n            } else if (item.label) {\n                return item.label;\n            } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                return labels[item.dataIndex];\n            }\n        }\n        return \"\";\n    },\n    afterTitle: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    beforeBody: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    beforeLabel: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    label (tooltipItem) {\n        if (this && this.options && this.options.mode === \"dataset\") {\n            return tooltipItem.label + \": \" + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || \"\";\n        if (label) {\n            label += \": \";\n        }\n        const value = tooltipItem.formattedValue;\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n            label += value;\n        }\n        return label;\n    },\n    labelColor (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            borderColor: options.borderColor,\n            backgroundColor: options.backgroundColor,\n            borderWidth: options.borderWidth,\n            borderDash: options.borderDash,\n            borderDashOffset: options.borderDashOffset,\n            borderRadius: 0\n        };\n    },\n    labelTextColor () {\n        return this.options.bodyColor;\n    },\n    labelPointStyle (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            pointStyle: options.pointStyle,\n            rotation: options.rotation\n        };\n    },\n    afterLabel: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    afterBody: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    beforeFooter: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    footer: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    afterFooter: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG\n};\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n    const result = callbacks[name].call(ctx, arg);\n    if (typeof result === \"undefined\") {\n        return defaultCallbacks[name].call(ctx, arg);\n    }\n    return result;\n}\nclass Tooltip extends Element {\n    static{\n        this.positioners = positioners;\n    }\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n    _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks } = options;\n        const beforeTitle = invokeCallbackWithFallback(callbacks, \"beforeTitle\", this, context);\n        const title = invokeCallbackWithFallback(callbacks, \"title\", this, context);\n        const afterTitle = invokeCallbackWithFallback(callbacks, \"afterTitle\", this, context);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, \"beforeBody\", this, tooltipItems));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks } = options;\n        const bodyItems = [];\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, \"beforeLabel\", this, context)));\n            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, \"label\", this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, \"afterLabel\", this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, \"afterBody\", this, tooltipItems));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks } = options;\n        const beforeFooter = invokeCallbackWithFallback(callbacks, \"beforeFooter\", this, tooltipItems);\n        const footer = invokeCallbackWithFallback(callbacks, \"footer\", this, tooltipItems);\n        const afterFooter = invokeCallbackWithFallback(callbacks, \"afterFooter\", this, tooltipItems);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n    _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(invokeCallbackWithFallback(scoped, \"labelColor\", this, context));\n            labelPointStyles.push(invokeCallbackWithFallback(scoped, \"labelPointStyle\", this, context));\n            labelTextColors.push(invokeCallbackWithFallback(scoped, \"labelTextColor\", this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign, yAlign } = this;\n        const { caretSize, cornerRadius } = options;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(cornerRadius);\n        const { x: ptX, y: ptY } = tooltipPoint;\n        const { width, height } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === \"center\") {\n            y2 = ptY + height / 2;\n            if (xAlign === \"left\") {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === \"left\") {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === \"right\") {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === \"top\") {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = \"middle\";\n            titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n    _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColor = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight, boxWidth } = options;\n        const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);\n        const colorX = getAlignedX(this, \"left\", options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.fillStyle = labelColor.backgroundColor;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.setLineDash(labelColor.borderDash || []);\n            ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n            const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(labelColor.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.beginPath();\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body } = this;\n        const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;\n        const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = \"middle\";\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== \"right\" ? bodyAlign === \"center\" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = \"middle\";\n            footerFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign, yAlign } = this;\n        const { x, y } = pt;\n        const { width, height } = tooltipSize;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === \"top\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === \"center\" && xAlign === \"right\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === \"bottom\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === \"center\" && xAlign === \"left\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n    _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n    _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB)(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD)(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map(({ datasetIndex, index })=>{\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error(\"Cannot find a dataset at index \" + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n    handleEvent(e, replay, inChartArea = true) {\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n    _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === \"mouseout\") {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n    _positionChanged(active, e) {\n        const { caretX, caretY, options } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n}\nvar plugin_tooltip = {\n    id: \"tooltip\",\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins(\"beforeTooltipDraw\", {\n                ...args,\n                cancelable: true\n            }) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins(\"afterTooltipDraw\", args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: \"average\",\n        backgroundColor: \"rgba(0,0,0,0.8)\",\n        titleColor: \"#fff\",\n        titleFont: {\n            weight: \"bold\"\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: \"left\",\n        bodyColor: \"#fff\",\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: \"left\",\n        footerColor: \"#fff\",\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: \"bold\"\n        },\n        footerAlign: \"left\",\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: \"#fff\",\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: \"rgba(0,0,0,0)\",\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: \"easeOutQuart\"\n        },\n        animations: {\n            numbers: {\n                type: \"number\",\n                properties: [\n                    \"x\",\n                    \"y\",\n                    \"width\",\n                    \"height\",\n                    \"caretX\",\n                    \"caretY\"\n                ]\n            },\n            opacity: {\n                easing: \"linear\",\n                duration: 200\n            }\n        },\n        callbacks: defaultCallbacks\n    },\n    defaultRoutes: {\n        bodyFont: \"font\",\n        footerFont: \"font\",\n        titleFont: \"font\"\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== \"filter\" && name !== \"itemSort\" && name !== \"external\",\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: \"animation\"\n        }\n    },\n    additionalOptionScopes: [\n        \"interaction\"\n    ]\n};\nvar plugins = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Colors: plugin_colors,\n    Decimation: plugin_decimation,\n    Filler: index,\n    Legend: plugin_legend,\n    SubTitle: plugin_subtitle,\n    Title: plugin_title,\n    Tooltip: plugin_tooltip\n});\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === \"string\") {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(Math.round(index), 0, max);\nfunction _getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n        return labels[value];\n    }\n    return value;\n}\nclass CategoryScale extends Scale {\n    static{\n        this.id = \"category\";\n    }\n    static{\n        this.defaults = {\n            ticks: {\n                callback: _getLabelForValue\n            }\n        };\n    }\n    constructor(cfg){\n        super(cfg);\n        this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index, label } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this.getMinMax(true);\n        if (this.options.bounds === \"ticks\") {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return _getLabelForValue.call(this, value);\n    }\n    configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== \"number\") {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n}\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin, max: rmax } = dataRange;\n    const minDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(min);\n    const maxDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(max);\n    const countDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI)((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI)(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === \"ticks\") {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aJ)((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL)(spacing), (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL)(niceMin));\n    factor = Math.pow(10, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n        if (maxDefined && tickValue > max) {\n            break;\n        }\n        ticks.push({\n            value: tickValue\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {\n    const rad = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * (\"\" + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._endValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        if ((typeof raw === \"number\" || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero } = this.options;\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(min);\n            const maxSign = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit, stepSize } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n    computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === \"ticks\") {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, \"value\");\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n}\nclass LinearScale extends LinearScaleBase {\n    static{\n        this.id = \"linear\";\n    }\n    static{\n        this.defaults = {\n            ticks: {\n                callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.numeric\n            }\n        };\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? min : 0;\n        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\nconst log10Floor = (v)=>Math.floor((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(v));\nconst changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, log10Floor(tickVal));\n    return remain === 1;\n}\nfunction steps(min, max, rangeExp) {\n    const rangeStep = Math.pow(10, rangeExp);\n    const start = Math.floor(min / rangeStep);\n    const end = Math.ceil(max / rangeStep);\n    return end - start;\n}\nfunction startExp(min, max) {\n    const range = max - min;\n    let rangeExp = log10Floor(range);\n    while(steps(min, max, rangeExp) > 10){\n        rangeExp++;\n    }\n    while(steps(min, max, rangeExp) < 10){\n        rangeExp--;\n    }\n    return Math.min(rangeExp, log10Floor(min));\n}\nfunction generateTicks(generationOptions, { min, max }) {\n    min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.min, min);\n    const ticks = [];\n    const minExp = log10Floor(min);\n    let exp = startExp(min, max);\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    const stepSize = Math.pow(10, exp);\n    const base = minExp > exp ? Math.pow(10, minExp) : 0;\n    const start = Math.round((min - base) * precision) / precision;\n    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n    let significand = Math.floor((start - offset) / Math.pow(10, exp));\n    let value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n    while(value < max){\n        ticks.push({\n            value,\n            major: isMajor(value),\n            significand\n        });\n        if (significand >= 10) {\n            significand = significand < 15 ? 15 : 20;\n        } else {\n            significand++;\n        }\n        if (significand >= 20) {\n            exp++;\n            significand = 2;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n    }\n    const lastTick = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.max, value);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(lastTick),\n        significand\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    static{\n        this.id = \"logarithmic\";\n    }\n    static{\n        this.defaults = {\n            ticks: {\n                callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.logarithmic,\n                major: {\n                    enabled: true\n                }\n            }\n        };\n    }\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? Math.max(0, min) : null;\n        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        if (this._zero && this.min !== this._suggestedMin && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(this._userMin)) {\n            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(changeExponent(min, -1));\n                setMax(changeExponent(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(changeExponent(max, -1));\n        }\n        if (max <= 0) {\n            setMax(changeExponent(min, +1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === \"ticks\") {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, \"value\");\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return value === undefined ? \"0\" : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n    configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(start);\n        this._valueRange = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(this.max) - (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n}\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(tickOpts.backdropPadding);\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(tickOpts.font && tickOpts.font.size, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label : [\n        label\n    ];\n    return {\n        w: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aO)(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\nfunction fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction createPointLabelItem(scale, index, itemOpts) {\n    const outerDistance = scale.drawingArea;\n    const { extra, additionalAngle, padding, size } = itemOpts;\n    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n    const angle = Math.round((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(pointLabelPosition.angle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H)));\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    return {\n        visible: true,\n        x: pointLabelPosition.x,\n        y,\n        textAlign,\n        left,\n        top: y,\n        right: left + size.w,\n        bottom: y + size.h\n    };\n}\nfunction isNotOverlapped(item, area) {\n    if (!area) {\n        return true;\n    }\n    const { left, top, right, bottom } = item;\n    const apexesInArea = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: left,\n        y: top\n    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: left,\n        y: bottom\n    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: right,\n        y: top\n    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: right,\n        y: bottom\n    }, area);\n    return !apexesInArea;\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const { centerPointLabels, display } = opts.pointLabels;\n    const itemOpts = {\n        extra: getTickBackdropHeight(opts) / 2,\n        additionalAngle: centerPointLabels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0\n    };\n    let area;\n    for(let i = 0; i < valueCount; i++){\n        itemOpts.padding = padding[i];\n        itemOpts.size = labelSizes[i];\n        const item = createPointLabelItem(scale, i, itemOpts);\n        items.push(item);\n        if (display === \"auto\") {\n            item.visible = isNotOverlapped(item, area);\n            if (item.visible) {\n                area = item;\n            }\n        }\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return \"center\";\n    } else if (angle < 180) {\n        return \"left\";\n    }\n    return \"right\";\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === \"right\") {\n        x -= w;\n    } else if (align === \"center\") {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabelBox(ctx, opts, item) {\n    const { left, top, right, bottom } = item;\n    const { backdropColor } = opts;\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(backdropColor)) {\n        const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(opts.borderRadius);\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(opts.backdropPadding);\n        ctx.fillStyle = backdropColor;\n        const backdropLeft = left - padding.left;\n        const backdropTop = top - padding.top;\n        const backdropWidth = right - left + padding.width;\n        const backdropHeight = bottom - top + padding.height;\n        if (Object.values(borderRadius).some((v)=>v !== 0)) {\n            ctx.beginPath();\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                x: backdropLeft,\n                y: backdropTop,\n                w: backdropWidth,\n                h: backdropHeight,\n                radius: borderRadius\n            });\n            ctx.fill();\n        } else {\n            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n        }\n    }\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx, options: { pointLabels } } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const item = scale._pointLabelItems[i];\n        if (!item.visible) {\n            continue;\n        }\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        drawPointLabelBox(ctx, optsAtIndex, item);\n        const plFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(optsAtIndex.font);\n        const { x, y, textAlign } = item;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: \"middle\"\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color, lineWidth } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(borderOpts.dash || []);\n    ctx.lineDashOffset = borderOpts.dashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        label,\n        index,\n        type: \"pointLabel\"\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    static{\n        this.id = \"radialLinear\";\n    }\n    static{\n        this.defaults = {\n            display: true,\n            animate: true,\n            position: \"chartArea\",\n            angleLines: {\n                display: true,\n                lineWidth: 1,\n                borderDash: [],\n                borderDashOffset: 0.0\n            },\n            grid: {\n                circular: false\n            },\n            startAngle: 0,\n            ticks: {\n                showLabelBackdrop: true,\n                callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.numeric\n            },\n            pointLabels: {\n                backdropColor: undefined,\n                backdropPadding: 2,\n                display: true,\n                font: {\n                    size: 10\n                },\n                callback (label) {\n                    return label;\n                },\n                padding: 5,\n                centerPointLabels: false\n            }\n        };\n    }\n    static{\n        this.defaultRoutes = {\n            \"angleLines.color\": \"borderColor\",\n            \"pointLabels.color\": \"color\",\n            \"ticks.color\": \"color\"\n        };\n    }\n    static{\n        this.descriptors = {\n            angleLines: {\n                _fallback: \"grid\"\n            }\n        };\n    }\n    constructor(cfg){\n        super(cfg);\n        this.xCenter = undefined;\n        this.yCenter = undefined;\n        this.drawingArea = undefined;\n        this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n    setDimensions() {\n        const padding = this._padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(false);\n        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : 0;\n        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : \"\";\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(index * angleMultiplier + (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n        const angle = this.getIndexAngle(index) - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left, top, right, bottom } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n    drawBackground() {\n        const { backgroundColor, grid: { circular } } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n    drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines, grid, border } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0 || index === 0 && this.min < 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const context = this.getContext(index);\n                    const optsAtIndex = grid.setContext(context);\n                    const optsAtIndexBorder = border.setContext(context);\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color, lineWidth } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n    drawBorder() {}\n    drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && this.min >= 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color,\n                strokeColor: optsAtIndex.textStrokeColor,\n                strokeWidth: optsAtIndex.textStrokeWidth\n            });\n        });\n        ctx.restore();\n    }\n    drawTitle() {}\n}\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\nconst UNITS = /* #__PURE__ */ Object.keys(INTERVALS);\nfunction sorter(a, b) {\n    return a - b;\n}\nfunction parse(scale, input) {\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser, round, isoWeekday } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === \"function\") {\n        value = parser(value);\n    }\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n        value = typeof parser === \"string\" ? adapter.parse(value, parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === \"week\" && ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, \"isoWeek\", isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\nfunction addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo, hi } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aQ)(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n    const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    static{\n        this.id = \"time\";\n    }\n    static{\n        this.defaults = {\n            bounds: \"data\",\n            adapters: {},\n            time: {\n                parser: false,\n                unit: false,\n                round: false,\n                isoWeekday: false,\n                minUnit: \"millisecond\",\n                displayFormats: {}\n            },\n            ticks: {\n                source: \"auto\",\n                callback: false,\n                major: {\n                    enabled: false\n                }\n            }\n        };\n    }\n    constructor(props){\n        super(props);\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n        this._unit = \"day\";\n        this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n    init(scaleOpts, opts = {}) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n    parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || \"day\";\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== \"ticks\" || options.ticks.source !== \"labels\") {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n    _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n    buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === \"ticks\" && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aP)(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === \"year\" ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n    initOffsets(timestamps = []) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(start, 0, limit);\n        end = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n    _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.stepSize, 1);\n        const weekday = minor === \"week\" ? timeOpts.isoWeekday : false;\n        const hasWeekday = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, \"isoWeek\", weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? \"day\" : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + \" and \" + max + \" are too far apart with stepSize of \" + stepSize + \" \" + minor);\n        }\n        const timestamps = options.ticks.source === \"data\" && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === \"ticks\" || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort(sorter).map((x)=>+x);\n    }\n    getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n    format(value, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const fmt = format || formats[unit];\n        return this._adapter.format(value, fmt);\n    }\n    _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formatter = options.ticks.callback;\n        if (formatter) {\n            return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(formatter, [\n                time,\n                index,\n                ticks\n            ], this);\n        }\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    }\n    generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n    getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n    getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n    _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n    _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n    getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n    getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n    normalize(values) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort(sorter));\n    }\n}\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo, hi } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(table, \"pos\", val));\n        }\n        ({ pos: prevSource, time: prevTarget } = table[lo]);\n        ({ pos: nextSource, time: nextTarget } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo, hi } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(table, \"time\", val));\n        }\n        ({ time: prevSource, pos: prevTarget } = table[lo]);\n        ({ time: nextSource, pos: nextTarget } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    static{\n        this.id = \"timeseries\";\n    }\n    static{\n        this.defaults = TimeScale.defaults;\n    }\n    constructor(props){\n        super(props);\n        this._table = [];\n        this._minPos = undefined;\n        this._tableRange = undefined;\n    }\n    initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n    buildLookupTable(timestamps) {\n        const { min, max } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n    _generate() {\n        const min = this.min;\n        const max = this.max;\n        let timestamps = super.getDataTimestamps();\n        if (!timestamps.includes(min) || !timestamps.length) {\n            timestamps.splice(0, 0, min);\n        }\n        if (!timestamps.includes(max) || timestamps.length === 1) {\n            timestamps.push(max);\n        }\n        return timestamps.sort((a, b)=>a - b);\n    }\n    _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n    getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n}\nvar scales = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    CategoryScale: CategoryScale,\n    LinearScale: LinearScale,\n    LogarithmicScale: LogarithmicScale,\n    RadialLinearScale: RadialLinearScale,\n    TimeScale: TimeScale,\n    TimeSeriesScale: TimeSeriesScale\n});\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n //# sourceMappingURL=chart.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaGFydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBV08sTUFBTUE7SUFDWEMsYUFBYztRQUNaLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDO1FBQ25CLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQztJQUNuQjtJQUtBQyxRQUFRQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUU7UUFDaEMsTUFBTUMsWUFBWUgsTUFBTUksU0FBUyxDQUFDRixLQUFLO1FBQ3ZDLE1BQU1HLFdBQVdMLE1BQU1NLFFBQVE7UUFFL0JILFVBQVVJLE9BQU8sQ0FBQ0MsQ0FBQUEsS0FBTUEsR0FBRztnQkFDekJUO2dCQUNBVSxTQUFTVCxNQUFNUyxPQUFPO2dCQUN0Qko7Z0JBQ0FLLGFBQWFDLEtBQUtDLEdBQUcsQ0FBQ1gsT0FBT0QsTUFBTWEsS0FBSyxFQUFFUjtZQUM1QztJQUNGO0lBS0FTLFdBQVc7UUFDVCxJQUFJLElBQUksQ0FBQ3RCLFFBQVEsRUFBRTtZQUNqQjs7UUFFRixJQUFJLENBQUNHLFFBQVEsR0FBRztRQUVoQixJQUFJLENBQUNILFFBQVEsR0FBR3VCLHlEQUFnQkEsQ0FBQ0MsSUFBSSxDQUFDQyxRQUFRO1lBQzVDLElBQUksQ0FBQ0MsT0FBTztZQUNaLElBQUksQ0FBQzFCLFFBQVEsR0FBRztZQUVoQixJQUFJLElBQUksQ0FBQ0csUUFBUSxFQUFFO2dCQUNqQixJQUFJLENBQUNtQixRQUFROztRQUVqQjtJQUNGO0lBS0FJLFFBQVFqQixPQUFPa0IsS0FBS0MsR0FBRyxFQUFFLEVBQUU7UUFDekIsSUFBSUMsWUFBWTtRQUVoQixJQUFJLENBQUM1QixPQUFPLENBQUNjLE9BQU8sQ0FBQyxDQUFD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TSxDQUFDbEU7ZUFDbkM7WUFDTHV1RCxhQUFhbjRELEtBQUtySixNQUFNLEdBQUdxSixPQUFPNEo7O1FBRXBDdXVELGFBQWEsSUFBSSxDQUFDeHFELE1BQU0sQ0FBQ2xRLEdBQUcsR0FBRzA2RDtRQUUvQixPQUFPQTtJQUNUO0lBTUFzQixtQkFBbUJwOEQsS0FBSyxFQUFFO1FBQ3hCLE9BQU8sQ0FBQ3M0QyxZQUFZLElBQUksQ0FBQzJsQixNQUFNLEVBQUVqK0QsU0FBUyxJQUFJLENBQUNrK0QsT0FBTSxJQUFLLElBQUksQ0FBQ0MsV0FBVztJQUM1RTtJQU1Bbm5ELGlCQUFpQmdrQixLQUFLLEVBQUU7UUFDdEIsTUFBTWdpQyxVQUFVLElBQUksQ0FBQ3hCLFFBQVE7UUFDN0IsTUFBTXZnQyxVQUFVLElBQUksQ0FBQ0csa0JBQWtCLENBQUNKLFNBQVNnaUMsUUFBUXZoRSxNQUFNLEdBQUd1aEUsUUFBUXQ4RCxHQUFHO1FBQzdFLE9BQU80M0MsWUFBWSxJQUFJLENBQUMybEIsTUFBTSxFQUFFaGpDLFVBQVUsSUFBSSxDQUFDa2pDLFdBQVcsR0FBRyxJQUFJLENBQUNELE9BQU8sRUFBRTtJQUM3RTtBQUNGOzs7Ozs7Ozs7O01DM0phSSxnQkFBZ0I7SUFDM0J0OEI7SUFDQXIxQjtJQUNBME47SUFDQWhWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2NvcmUvY29yZS5hbmltYXRvci5qcz8xYmYxIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9uLmpzPzkxZjAiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmpzPzM3YmQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcz9kMDViIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJhci5qcz84ZGMxIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJ1YmJsZS5qcz8xNmEyIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmRvdWdobnV0LmpzP2NhYmEiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIubGluZS5qcz85NzU2Iiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBvbGFyQXJlYS5qcz8xOWNhIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBpZS5qcz8wNjk4Iiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnJhZGFyLmpzP2QwMWEiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuc2NhdHRlci5qcz85NDBhIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9jb3JlL2NvcmUuYWRhcHRlcnMudHM/ZmJiOSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvY29yZS9jb3JlLmludGVyYWN0aW9uLmpzPzNiNWEiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2NvcmUvY29yZS5sYXlvdXRzLmpzP2M0ZTAiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanM/YzRlYSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzaWMuanM/OTA3ZiIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uZG9tLmpzPzYyNjQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3BsYXRmb3JtL2luZGV4LmpzPzU2YjUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2NvcmUvY29yZS5lbGVtZW50LnRzP2I3MWUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2NvcmUvY29yZS5zY2FsZS5hdXRvc2tpcC5qcz9kMTM1Iiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9jb3JlL2NvcmUuc2NhbGUuanM/ODg4YiIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvY29yZS9jb3JlLnR5cGVkUmVnaXN0cnkuanM/N2Y5OSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvY29yZS9jb3JlLnJlZ2lzdHJ5LmpzPzIwMTkiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2NvcmUvY29yZS5wbHVnaW5zLmpzPzdjM2UiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2NvcmUvY29yZS5jb25maWcuanM/NTIzZiIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvY29yZS9jb3JlLmNvbnRyb2xsZXIuanM/NzcyNyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvZWxlbWVudHMvZWxlbWVudC5hcmMudHM/ZDFlYiIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvZWxlbWVudHMvZWxlbWVudC5saW5lLmpzPzVmNmUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQudHM/NWU2YyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvZWxlbWVudHMvZWxlbWVudC5iYXIuanM/MDdiMyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvcGx1Z2lucy9wbHVnaW4uY29sb3JzLnRzPzVkNDgiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLmRlY2ltYXRpb24uanM/ZDg2NCIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5zZWdtZW50LmpzP2E2NTUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuaGVscGVyLmpzPzg4YWQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIub3B0aW9ucy5qcz9iY2UwIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5zdGFjay5qcz8yMWVhIiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvc2ltcGxlQXJjLmpzPzg3ZmEiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIudGFyZ2V0LmpzPzhjNjYiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuZHJhd2luZy5qcz8xYTM0Iiwid2VicGFjazovL2Zyb250ZW5kLy4uL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvaW5kZXguanM/NzEzZCIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvcGx1Z2lucy9wbHVnaW4ubGVnZW5kLmpzPzI4YjMiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLnRpdGxlLmpzP2FiMTYiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLnN1YnRpdGxlLmpzP2MyM2EiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanM/ZGYxZCIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvc2NhbGVzL3NjYWxlLmNhdGVnb3J5LmpzP2JkODQiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3NjYWxlcy9zY2FsZS5saW5lYXJiYXNlLmpzPzMyNTUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3NjYWxlcy9zY2FsZS5saW5lYXIuanM/YTAxMiIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvc2NhbGVzL3NjYWxlLmxvZ2FyaXRobWljLmpzPzVhNTUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vc3JjL3NjYWxlcy9zY2FsZS5yYWRpYWxMaW5lYXIuanM/ZjRhNyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvc2NhbGVzL3NjYWxlLnRpbWUuanM/OWU1MSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvc2NhbGVzL3NjYWxlLnRpbWVzZXJpZXMuanM/NDBmMCIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9zcmMvaW5kZXgudHM/NTJkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3JlcXVlc3RBbmltRnJhbWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuYW5pbWF0aW9uLmpzJykuZGVmYXVsdCB9IEFuaW1hdGlvblxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuLyoqXG4gKiBQbGVhc2UgdXNlIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydCB3aGljaCBwcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuICogTm90ZTogY2xhc3MgaXMgZXhwb3J0IGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG5cbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG5cbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuXG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChpdGVtLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFuZCBpdHMgZHVyYXRpb24gcHJvbG9uZ2VkLFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRvdGFsIGR1cmF0aW9uIG9mIGN1cnJlbnQgYW5pbWF0aW9ucyBydW4gKGZvciBwcm9ncmVzcyBldmVudClcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW0gYnkgcmVwbGFjaW5nIGl0IHdpdGggbGFzdCBpdGVtIGFuZCByZW1vdmluZyB0aGUgbGFzdFxuICAgICAgICAgIC8vIEEgbG90IGZhc3RlciB0aGFuIHNwbGljZS5cbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNoYXJ0LmRyYXcoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFuaW1zLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcblxuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrXG5cdCAqL1xuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZCBhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uW119IGl0ZW1zIC0gYW5pbWF0aW9uc1xuXHQgKi9cbiAgYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gIH1cblxuICAvKipcblx0ICogQ291bnRzIG51bWJlciBvZiBhY3RpdmUgYW5pbWF0aW9ucyBmb3IgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcblx0ICogU3RhcnQgYW5pbWF0aW5nIChhbGwgY2hhcnRzKVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG5cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdG9wIGFsbCBhbmltYXRpb25zIGZvciB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcblx0ICogUmVtb3ZlIGNoYXJ0IGZyb20gQW5pbWF0b3Jcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHJlbW92ZShjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgQW5pbWF0b3IoKTtcbiIsImltcG9ydCBlZmZlY3RzIGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5lYXNpbmcuanMnO1xuaW1wb3J0IHtyZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2NvbG9yIGFzIGhlbHBlcnNDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yXG4gICAqL1xuICBjb2xvcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc3QgYzAgPSBoZWxwZXJzQ29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBoZWxwZXJzQ29sb3IodG8gfHwgdHJhbnNwYXJlbnQpO1xuICAgIHJldHVybiBjMSAmJiBjMS52YWxpZFxuICAgICAgPyBjMS5taXgoYzAsIGZhY3RvcikuaGV4U3RyaW5nKClcbiAgICAgIDogdG87XG4gIH0sXG4gIG51bWJlcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgY29uc3QgZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2ZuID0gY2ZnLmZuIHx8IGludGVycG9sYXRvcnNbY2ZnLnR5cGUgfHwgdHlwZW9mIGZyb21dO1xuICAgIHRoaXMuX2Vhc2luZyA9IGVmZmVjdHNbY2ZnLmVhc2luZ10gfHwgZWZmZWN0cy5saW5lYXI7XG4gICAgdGhpcy5fc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgKyAoY2ZnLmRlbGF5IHx8IDApKTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcihjZmcuZHVyYXRpb24pO1xuICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9wcm9wID0gcHJvcDtcbiAgICB0aGlzLl9mcm9tID0gZnJvbTtcbiAgICB0aGlzLl90byA9IHRvO1xuICAgIHRoaXMuX3Byb21pc2VzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wXTtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICBjb25zdCByZW1haW4gPSB0aGlzLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XG4gICAgICB0aGlzLl9zdGFydCA9IGRhdGU7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgocmVtYWluLCBjZmcuZHVyYXRpb24pKTtcbiAgICAgIHRoaXMuX3RvdGFsICs9IGVsYXBzZWQ7XG4gICAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICAgIHRoaXMuX3RvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgICAgdGhpcy5fZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IGV2YWx1YXRlZCB2YWx1ZSwgZm9yIHNtb290aGVyIGFuaW1hdGlvbnNcbiAgICAgIHRoaXMudGljayhEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICB0aWNrKGRhdGUpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuX3Byb3A7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgY29uc3QgdG8gPSB0aGlzLl90bztcbiAgICBsZXQgZmFjdG9yO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gZnJvbSAhPT0gdG8gJiYgKGxvb3AgfHwgKGVsYXBzZWQgPCBkdXJhdGlvbikpO1xuXG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgdGhpcy5fbm90aWZ5KHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGFwc2VkIDwgMCkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gZnJvbTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWN0b3IgPSAoZWxhcHNlZCAvIGR1cmF0aW9uKSAlIDI7XG4gICAgZmFjdG9yID0gbG9vcCAmJiBmYWN0b3IgPiAxID8gMiAtIGZhY3RvciA6IGZhY3RvcjtcbiAgICBmYWN0b3IgPSB0aGlzLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZmFjdG9yKSkpO1xuXG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cblxuICB3YWl0KCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goe3JlcywgcmVqfSk7XG4gICAgfSk7XG4gIH1cblxuICBfbm90aWZ5KHJlc29sdmVkKSB7XG4gICAgY29uc3QgbWV0aG9kID0gcmVzb2x2ZWQgPyAncmVzJyA6ICdyZWonO1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZXNbaV1bbWV0aG9kXSgpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IGFuaW1hdG9yIGZyb20gJy4vY29yZS5hbmltYXRvci5qcyc7XG5pbXBvcnQgQW5pbWF0aW9uIGZyb20gJy4vY29yZS5hbmltYXRpb24uanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgY29uZmlnKSB7XG4gICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XG4gIH1cblxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGNmZyA9IGNvbmZpZ1trZXldO1xuICAgICAgaWYgKCFpc09iamVjdChjZmcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBhbmltYXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJlc29sdmVkW29wdGlvbl0gPSBjZmdbb3B0aW9uXTtcbiAgICAgIH1cblxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IHRvIGhhbmRsZSBhbmltYXRpb24gb2YgYG9wdGlvbnNgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IHZhbHVlcy5vcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIC8vIEdvaW5nIHRvIHNoYXJlZCBvcHRpb25zOlxuICAgICAgLy8gQWZ0ZXIgYWxsIGFuaW1hdGlvbnMgYXJlIGRvbmUsIGFzc2lnbiB0aGUgc2hhcmVkIG9wdGlvbnMgb2JqZWN0IHRvIHRoZSBlbGVtZW50XG4gICAgICAvLyBTbyBhbnkgbmV3IHVwZGF0ZXMgdG8gdGhlIHNoYXJlZCBvcHRpb25zIGFyZSBvYnNlcnZlZFxuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIC8vIHJlamVjdGVkLCBub29wXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgcnVubmluZyA9IHRhcmdldC4kYW5pbWF0aW9ucyB8fCAodGFyZ2V0LiRhbmltYXRpb25zID0ge30pO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IHByb3BzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAocHJvcC5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBhbiBleGlzdGluZyBhY3RpdmUgYW5pbWF0aW9uLCBsZXQncyB1cGRhdGUgdGhhdFxuICAgICAgICAgIGFuaW1hdGlvbi51cGRhdGUoY2ZnLCB2YWx1ZSwgZGF0ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNmZyB8fCAhY2ZnLmR1cmF0aW9uKSB7XG4gICAgICAgIC8vIG5vdCBhbmltYXRlZCwgc2V0IGRpcmVjdGx5IHRvIG5ldyB2YWx1ZVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJ1bm5pbmdbcHJvcF0gPSBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGNmZywgdGFyZ2V0LCBwcm9wLCB2YWx1ZSk7XG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgYHRhcmdldGAgcHJvcGVydGllcyB0byBuZXcgdmFsdWVzLCB1c2luZyBjb25maWd1cmVkIGFuaW1hdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIG9iamVjdCB0byB1cGRhdGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAtIG5ldyB0YXJnZXQgcHJvcGVydGllc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbnx1bmRlZmluZWR9IC0gYHRydWVgIGlmIGFuaW1hdGlvbnMgd2VyZSBzdGFydGVkXG5cdCAqKi9cbiAgdXBkYXRlKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgLy8gTm90aGluZyBpcyBhbmltYXRlZCwganVzdCBhcHBseSB0aGUgbmV3IHZhbHVlcy5cbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKTtcblxuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHJ1bm5pbmcgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhbmltID0gYW5pbWF0aW9uc1trZXlzW2ldXTtcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgIH1cbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBQcm9taXNlLmFsbChydW5uaW5nKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAvLyBHb2luZyBmcm9tIHNoYXJlZCBvcHRpb25zIHRvIGRpc3RpbmN0IG9uZTpcbiAgICAvLyBDcmVhdGUgbmV3IG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9sZCBzaGFyZWQgdmFsdWVzIGFuZCBzdGFydCB1cGRhdGluZyB0aGF0LlxuICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHskc2hhcmVkOiBmYWxzZSwgJGFuaW1hdGlvbnM6IHt9fSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG4iLCJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNGaW5pdGUsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdCwgcmVzb2x2ZU9iamVjdEtleSwgZGVmaW5lZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtsaXN0ZW5BcnJheUV2ZW50cywgdW5saXN0ZW5BcnJheUV2ZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBzaWdufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqL1xuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcblxuICByZXR1cm4ge1xuICAgIHRvcDogeS5lbmQsXG4gICAgcmlnaHQ6IHguZW5kLFxuICAgIGJvdHRvbTogeS5zdGFydCxcbiAgICBsZWZ0OiB4LnN0YXJ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcblxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogcixcbiAgICBib3R0b206IGIsXG4gICAgbGVmdDogbCxcbiAgICBkaXNhYmxlZDogdmFsdWUgPT09IGZhbHNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIGRzSW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XG4gIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRhdGFzZXRJbmRleCA9ICtrZXlzW2ldO1xuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKGlzRmluaXRlKG90aGVyVmFsdWUpICYmIChzaW5nbGVNb2RlIHx8ICh2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpKSB7XG4gICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghZm91bmQgJiYgIW9wdGlvbnMuYWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhLCBtZXRhKSB7XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyAneCcgOiAneSc7XG4gIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/ICd4JyA6ICd5JztcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICBjb25zdCBhZGF0YSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gIGxldCBpLCBpbGVuLCBrZXk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgYWRhdGFbaV0gPSB7XG4gICAgICBbaUF4aXNLZXldOiBrZXksXG4gICAgICBbdkF4aXNLZXldOiBkYXRhW2tleV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhZGF0YTtcbn1cblxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICByZXR1cm4gYCR7aW5kZXhTY2FsZS5pZH0uJHt2YWx1ZVNjYWxlLmlkfS4ke21ldGEuc3RhY2sgfHwgbWV0YS50eXBlfWA7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbkRlZmluZWQgPyBtaW4gOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgcG9zaXRpdmUsIHR5cGUpIHtcbiAgZm9yIChjb25zdCBtZXRhIG9mIHZTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xuICAgIGlmICgocG9zaXRpdmUgJiYgdmFsdWUgPiAwKSB8fCAoIXBvc2l0aXZlICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgIHJldHVybiBtZXRhLmluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGFja3MoY29udHJvbGxlciwgcGFyc2VkKSB7XG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcbiAgY29uc3Qgc3RhY2tzID0gY2hhcnQuX3N0YWNrcyB8fCAoY2hhcnQuX3N0YWNrcyA9IHt9KTsgLy8gbWFwIHN0cnVjdHVyZSBpcyB7c3RhY2tLZXk6IHtkYXRhc2V0SW5kZXg6IHZhbHVlfX1cbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBpbmRleDogZGF0YXNldEluZGV4fSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gIGNvbnN0IGtleSA9IGdldFN0YWNrS2V5KGlTY2FsZSwgdlNjYWxlLCBtZXRhKTtcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBzdGFjaztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBwYXJzZWRbaV07XG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xuICAgIGNvbnN0IGl0ZW1TdGFja3MgPSBpdGVtLl9zdGFja3MgfHwgKGl0ZW0uX3N0YWNrcyA9IHt9KTtcbiAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcblxuICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XG4gICAgc3RhY2suX2JvdHRvbSA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgZmFsc2UsIG1ldGEudHlwZSk7XG5cbiAgICBjb25zdCB2aXN1YWxWYWx1ZXMgPSBzdGFjay5fdmlzdWFsVmFsdWVzIHx8IChzdGFjay5fdmlzdWFsVmFsdWVzID0ge30pO1xuICAgIHZpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCxcbiAgICB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgZGF0YXNldDogdW5kZWZpbmVkLFxuICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgIGluZGV4LFxuICAgICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBwYXJzZWQ6IHVuZGVmaW5lZCxcbiAgICByYXc6IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50LFxuICAgIGluZGV4LFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICB0eXBlOiAnZGF0YSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIC8vIE5vdCB1c2luZyBtZXRhLmluZGV4IGhlcmUsIGJlY2F1c2UgaXQgbWlnaHQgYmUgYWxyZWFkeSB1cGRhdGVkIGlmIHRoZSBkYXRhc2V0IGNoYW5nZWQgbG9jYXRpb25cbiAgY29uc3QgZGF0YXNldEluZGV4ID0gbWV0YS5jb250cm9sbGVyLmluZGV4O1xuICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaXRlbXMgPSBpdGVtcyB8fCBtZXRhLl9wYXJzZWQ7XG4gIGZvciAoY29uc3QgcGFyc2VkIG9mIGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gcGFyc2VkLl9zdGFja3M7XG4gICAgaWYgKCFzdGFja3MgfHwgc3RhY2tzW2F4aXNdID09PSB1bmRlZmluZWQgfHwgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzICE9PSB1bmRlZmluZWQgJiYgc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcbiAgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge307XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhc2V0IChlLmcuIENoYXJ0LmVsZW1lbnQuTGluZUVsZW1lbnQpLlxuICAgKi9cbiAgc3RhdGljIGRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhIChlLmcuIENoYXJ0LmVsZW1lbnQuUG9pbnRFbGVtZW50KS5cbiAgICovXG4gIHN0YXRpYyBkYXRhRWxlbWVudFR5cGUgPSBudWxsO1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGF0YXNldEluZGV4XG5cdCAqL1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX2N0eCA9IGNoYXJ0LmN0eDtcbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gICAgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IG9iamVjdH0gKi9cbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YXNldEVsZW1lbnRUeXBlO1xuICAgIHRoaXMuZGF0YUVsZW1lbnRUeXBlID0gbmV3LnRhcmdldC5kYXRhRWxlbWVudFR5cGU7XG5cbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmxpbmtTY2FsZXMoKTtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmZpbGwgJiYgIXRoaXMuY2hhcnQuaXNQbHVnaW5FbmFibGVkKCdmaWxsZXInKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gdXNlIHRoZSAnZmlsbCcgb3B0aW9uIHdpdGhvdXQgdGhlICdGaWxsZXInIHBsdWdpbiBlbmFibGVkLiBQbGVhc2UgaW1wb3J0IGFuZCByZWdpc3RlciB0aGUgJ0ZpbGxlcicgcGx1Z2luIGFuZCBtYWtlIHN1cmUgaXQgaXMgbm90IGRpc2FibGVkIGluIHRoZSBvcHRpb25zXCIpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSBkYXRhc2V0SW5kZXgpIHtcbiAgICAgIGNsZWFyU3RhY2tzKHRoaXMuX2NhY2hlZE1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICB9XG5cbiAgbGlua1NjYWxlcygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuXG4gICAgY29uc3QgeGlkID0gbWV0YS54QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC54QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd4JykpO1xuICAgIGNvbnN0IHlpZCA9IG1ldGEueUF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueUF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneScpKTtcbiAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gbWV0YS5pbmRleEF4aXM7XG4gICAgY29uc3QgaWlkID0gbWV0YS5pQXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB4aWQsIHlpZCwgcmlkKTtcbiAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgIG1ldGEueFNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHhpZCk7XG4gICAgbWV0YS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeWlkKTtcbiAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgIG1ldGEuaVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGlpZCk7XG4gICAgbWV0YS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQodmlkKTtcbiAgfVxuXG4gIGdldERhdGFzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNjYWxlSURcblx0ICogQHJldHVybiB7U2NhbGV9XG5cdCAqL1xuICBnZXRTY2FsZUZvcklkKHNjYWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kYXRhQ2hlY2soKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICBjb25zdCBfZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAvLyBJbiBvcmRlciB0byBjb3JyZWN0bHkgaGFuZGxlIGRhdGEgYWRkaXRpb24vZGVsZXRpb24gYW5pbWF0aW9uIChhbmQgdGh1cyBzaW11bGF0ZVxuICAgIC8vIHJlYWwtdGltZSBjaGFydHMpLCB3ZSBuZWVkIHRvIG1vbml0b3IgdGhlc2UgZGF0YSBtb2RpZmljYXRpb25zIGFuZCBzeW5jaHJvbml6ZVxuICAgIC8vIHRoZSBpbnRlcm5hbCBtZXRhZGF0YSBhY2NvcmRpbmdseS5cblxuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEsIG1ldGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcbiAgICAgICAgLy8gRGlzY2FyZCBvbGQgcGFyc2VkIGRhdGEgYW5kIHN0YWNrc1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuXG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cblxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIC8vIG1ha2Ugc3VyZSBjYWNoZWQgX3N0YWNrZWQgc3RhdHVzIGlzIGN1cnJlbnRcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcblxuICAgIC8vIGRldGVjdCBjaGFuZ2UgaW4gc3RhY2sgb3B0aW9uXG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICAvLyByZW1vdmUgdmFsdWVzIGZyb20gb2xkIHN0YWNrXG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cblxuICAgIC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG4gICAgLy8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcblxuICAgIC8vIGlmIHN0YWNrIGNoYW5nZWQsIHVwZGF0ZSBzdGFjayB2YWx1ZXMgZm9yIHRoZSB3aG9sZSBkYXRhc2V0XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBNZXJnZXMgdXNlci1zdXBwbGllZCBhbmQgZGVmYXVsdCBkYXRhc2V0LWxldmVsIG9wdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldFNjb3BlS2V5cyh0aGlzLl90eXBlKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMsIHRydWUpO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLl9wYXJzaW5nID0gdGhpcy5vcHRpb25zLnBhcnNpbmc7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG5cdCAqL1xuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IG1ldGEsIF9kYXRhOiBkYXRhfSA9IHRoaXM7XG4gICAgY29uc3Qge2lTY2FsZSwgX3N0YWNrZWR9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuXG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYgPSAoKSA9PiBjdXJbaUF4aXNdID09PSBudWxsIHx8IChwcmV2ICYmIGN1cltpQXhpc10gPCBwcmV2W2lBeGlzXSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaSArIHN0YXJ0XSA9IGN1ciA9IHBhcnNlZFtpXTtcbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgIGlmIChpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldigpKSB7XG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWV0YS5fc29ydGVkID0gc29ydGVkO1xuICAgIH1cblxuICAgIGlmIChfc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgWzEsMyw0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eFNjYWxlMDogMCwgeVNjYWxlMDogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIFtpQXhpc106IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaW5kZXhdLCBpbmRleCksXG4gICAgICAgIFt2QXhpc106IHZTY2FsZS5wYXJzZShkYXRhW2luZGV4XSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIGFycmF5c1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbWzEsMl0sWzMsNF1dXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuXG5cdCAqIEV4YW1wbGU6IHt4OiAwLCB5OiAxfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShpdGVtWzBdLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShpdGVtWzFdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbe3g6MSwgeTo1fSwge3g6MiwgeToxMH1dXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuIF9jdXN0b20gaXMgb3B0aW9uYWxcblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDEsIF9jdXN0b206IHtyOiAxMCwgZm9vOiAnYmFyJ319XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB4QXhpc0tleSksIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0UGFyc2VkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YUVsZW1lbnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBhcHBseVN0YWNrKHNjYWxlLCBwYXJzZWQsIG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICB2YWx1ZXM6IHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNcbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICB9XG4gICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWluTWF4KHNjYWxlLCBjYW5TdGFjaykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgIGNvbnN0IHN0YWNrID0gY3JlYXRlU3RhY2soY2FuU3RhY2ssIG1ldGEsIHRoaXMuY2hhcnQpO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICBsZXQgaSwgcGFyc2VkO1xuXG4gICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgcmV0dXJuICFpc0Zpbml0ZShwYXJzZWRbc2NhbGUuYXhpc10pIHx8IG90aGVyTWluID4gb3RoZXJWYWx1ZSB8fCBvdGhlck1heCA8IG90aGVyVmFsdWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAvLyBpZiB0aGUgZGF0YSBpcyBzb3J0ZWQsIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZnVydGhlciBmcm9tIHRoaXMgZW5kIG9mIGFycmF5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICAvLyBpbiB0aGUgc29ydGVkIGNhc2UsIGZpbmQgZmlyc3Qgbm9uLXNraXBwZWQgdmFsdWUgZnJvbSBvdGhlciBlbmQgb2YgYXJyYXlcbiAgICAgIGZvciAoaSA9IGlsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBnZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWQ7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGksIGlsZW4sIHZhbHVlO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogaVNjYWxlID8gJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSA6ICcnLFxuICAgICAgdmFsdWU6IHZTY2FsZSA/ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSkgOiAnJ1xuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KHRoaXMub3B0aW9ucy5jbGlwLCBkZWZhdWx0Q2xpcChtZXRhLnhTY2FsZSwgbWV0YS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuXHQgKi9cbiAgdXBkYXRlKG1vZGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhY3RpdmUgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2RyYXdTdGFydCB8fCAwO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZHJhd0NvdW50IHx8IChlbGVtZW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgY29uc3QgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0aGlzLm9wdGlvbnMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3A7XG4gICAgbGV0IGk7XG5cbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSAmJiBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCkge1xuICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuZHJhdyhjdHgsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFjdGl2ZVtpXS5kcmF3KGN0eCwgYXJlYSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSBzZXQgb2YgcHJlZGVmaW5lZCBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBkYXRhc2V0XG5cdCAqIG9yIHRoZSBkYXRhIGlmIHRoZSBpbmRleCBpcyBzcGVjaWZpZWRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gZGF0YSBpbmRleFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthY3RpdmVdIC0gdHJ1ZSBpZiBob3ZlclxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IHN0eWxlIG9iamVjdFxuXHQgKi9cbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXRcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXG4gICAgICA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gdGhpcy4kY29udGV4dCB8fFxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG5cbiAgICBjb250ZXh0LmFjdGl2ZSA9ICEhYWN0aXZlO1xuICAgIGNvbnRleHQubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgbW9kZSwgaW5kZXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGVsZW1lbnRUeXBlLCBtb2RlID0gJ2RlZmF1bHQnLCBpbmRleCkge1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGNvbnN0IHNoYXJpbmcgPSB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgJiYgZGVmaW5lZChpbmRleCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNsb25lSWZOb3RTaGFyZWQoY2FjaGVkLCBzaGFyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuZWxlbWVudHNbZWxlbWVudFR5cGVdKTtcbiAgICAvLyBjb250ZXh0IGlzIHByb3ZpZGVkIGFzIGEgZnVuY3Rpb24sIGFuZCBpcyBjYWxsZWQgb25seSBpZiBuZWVkZWQsXG4gICAgLy8gc28gd2UgZG9uJ3QgY3JlYXRlIGEgY29udGV4dCBmb3IgZWFjaCBlbGVtZW50IGlmIG5vdCBuZWVkZWQuXG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG5cbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIC8vIGAkc2hhcmVkYCBpbmRpY2F0ZXMgdGhpcyBzZXQgb2Ygb3B0aW9ucyBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgZWxlbWVudHMuXG4gICAgICAvLyBTaGFyaW5nIGlzIHVzZWQgdG8gcmVkdWNlIG51bWJlciBvZiBwcm9wZXJ0aWVzIHRvIGNoYW5nZSBkdXJpbmcgYW5pbWF0aW9uLlxuICAgICAgdmFsdWVzLiRzaGFyZWQgPSBzaGFyaW5nO1xuXG4gICAgICAvLyBXZSBjYWNoZSBvcHRpb25zIGJ5IGBtb2RlYCwgd2hpY2ggY2FuIGJlICdhY3RpdmUnIGZvciBleGFtcGxlLiBUaGlzIGVuYWJsZXMgdXNcbiAgICAgIC8vIHRvIGhhdmUgdGhlICdhY3RpdmUnIGVsZW1lbnQgb3B0aW9ucyBhbmQgJ2RlZmF1bHQnIG9wdGlvbnMgdG8gc3dpdGNoIGJldHdlZW5cbiAgICAgIC8vIHdoZW4gaW50ZXJhY3RpbmcuXG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIHRyYW5zaXRpb24sIGFjdGl2ZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFuaW1hdGlvbi0ke3RyYW5zaXRpb259YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCB0cmFuc2l0aW9uKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBzaGFyZWQgYmV0d2VlbiBlbGVtZW50c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBkZXRlcm1pbmluZyBpZiBgb3B0aW9uc2Agc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSB1cGRhdGVkIHByb3BlcnRpZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0b2RvIHY0LCByZW5hbWUgdG8gZ2V0U2hhcmVkT3B0aW9ucyBhbmQgcmVtb3ZlIGV4Y2VzcyBmdW5jdGlvbnNcbiAgICovXG4gIF9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKSB7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyA9IHRoaXMuX3NoYXJlZE9wdGlvbnM7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB8fCAoc2hhcmVkT3B0aW9ucyAhPT0gcHJldmlvdXNseVNoYXJlZE9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIHJldHVybiB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIHVwZGF0aW5nIGFuIGVsZW1lbnQgd2l0aCBuZXcgcHJvcGVydGllcywgdXNpbmcgYW5pbWF0aW9ucyB3aGVuIGFwcHJvcHJpYXRlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCBwcm9wZXJ0aWVzLCBtb2RlKSB7XG4gICAgaWYgKGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUpLnVwZGF0ZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSB0byBhbmltYXRlIHRoZSBzaGFyZWQgb3B0aW9ucywgdGhhdCBhcmUgcG90ZW50aWFsbHkgYWZmZWN0aW5nIG11bHRpcGxlIGVsZW1lbnRzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgbW9kZSwgYWN0aXZlKSB7XG4gICAgZWxlbWVudC5hY3RpdmUgPSBhY3RpdmU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSk7XG4gICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUsIGFjdGl2ZSkudXBkYXRlKGVsZW1lbnQsIHtcbiAgICAgIC8vIFdoZW4gZ29pbmcgZnJvbSBhY3RpdmUgdG8gaW5hY3RpdmUsIHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBzaGFyZWQgb3B0aW9ucy5cbiAgICAgIC8vIFRoaXMgd2F5IHRoZSBvbmNlIGhvdmVyZWQgZWxlbWVudCB3aWxsIGVuZCB1cCB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNoYXJlZCBvcHRpb25zIGluc3RhbmNlLCBhZnRlciBhbmltYXRpb24uXG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgZmFsc2UpO1xuICB9XG5cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3NldERhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgLy8gQXBwbHkgY2hhbmdlcyBkZXRlY3RlZCB0aHJvdWdoIGFycmF5IGxpc3RlbmVyc1xuICAgIGZvciAoY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gb2YgdGhpcy5fc3luY0xpc3QpIHtcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcblxuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIC8vIFRPRE86IEl0IGlzIG5vdCBvcHRpbWFsIHRvIGFsd2F5cyBwYXJzZSB0aGUgb2xkIGRhdGFcbiAgICAgIC8vIFRoaXMgaXMgZG9uZSBiZWNhdXNlIHdlIGFyZSBub3QgZGV0ZWN0aW5nIGRpcmVjdCBhc3NpZ25tZW50czpcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XSA9IDEwO1xuICAgICAgLy8gY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhWzVdLnkgPSAxMDtcbiAgICAgIHRoaXMucGFyc2UoMCwgY291bnQpO1xuICAgIH1cblxuICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuICAgICAgdGhpcy5faW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEsIHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIH0gZWxzZSBpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGxldCBpO1xuXG4gICAgY29uc3QgbW92ZSA9IChhcnIpID0+IHtcbiAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XG4gICAgICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSBlbmQ7IGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaSAtIGNvdW50XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vdmUoZGF0YSk7XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIG1vdmUobWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZShzdGFydCwgY291bnQpO1xuXG4gICAgaWYgKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZGF0YSwgc3RhcnQsIGNvdW50LCAncmVzZXQnKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcbiAgICovXG4gIF9zeW5jKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgdGhpcy5fc3luY0xpc3QucHVzaChhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gPSBhcmdzO1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFt0aGlzLmluZGV4LCAuLi5hcmdzXSk7XG4gIH1cblxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50XSk7XG4gIH1cblxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCAwLCAxXSk7XG4gIH1cblxuICBfb25EYXRhU3BsaWNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBuZXdDb3VudF0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gIH1cbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtcbiAgX2FycmF5VW5pcXVlLCBpc0FycmF5LCBpc051bGxPclVuZGVmLFxuICB2YWx1ZU9yRGVmYXVsdCwgcmVzb2x2ZU9iamVjdEtleSwgc2lnbiwgZGVmaW5lZFxufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIHR5cGUpIHtcbiAgaWYgKCFzY2FsZS5fY2FjaGUuJGJhcikge1xuICAgIGNvbnN0IHZpc2libGVNZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpO1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdmlzaWJsZU1ldGFzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh2aXNpYmxlTWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpKTtcbiAgICB9XG4gICAgc2NhbGUuX2NhY2hlLiRiYXIgPSBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlLl9jYWNoZS4kYmFyO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBcIm9wdGltYWxcIiBzYW1wbGUgc2l6ZSB0byBtYWludGFpbiBiYXJzIGVxdWFsbHkgc2l6ZWQgd2hpbGUgcHJldmVudGluZyBvdmVybGFwLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSkge1xuICBjb25zdCBzY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2YWx1ZXMgPSBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgbWV0YS50eXBlKTtcbiAgbGV0IG1pbiA9IHNjYWxlLl9sZW5ndGg7XG4gIGxldCBpLCBpbGVuLCBjdXJyLCBwcmV2O1xuICBjb25zdCB1cGRhdGVNaW5BbmRQcmV2ID0gKCkgPT4ge1xuICAgIGlmIChjdXJyID09PSAzMjc2NyB8fCBjdXJyID09PSAtMzI3NjgpIHtcbiAgICAgIC8vIElnbm9yZSB0cnVuY2F0ZWQgcGl4ZWxzXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKHByZXYpKSB7XG4gICAgICAvLyBjdXJyIC0gcHJldiA9PT0gMCBpcyBpZ25vcmVkXG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xuICAgIH1cbiAgICBwcmV2ID0gY3VycjtcbiAgfTtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlc1tpXSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG5cbiAgcHJldiA9IHVuZGVmaW5lZDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHNjYWxlLnRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG5cbiAgcmV0dXJuIG1pbjtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBcImlkZWFsXCIgY2F0ZWdvcnkgYmFzZWQgb24gdGhlIGFic29sdXRlIGJhciB0aGlja25lc3Mgb3IsIGlmIHVuZGVmaW5lZCBvciBudWxsLFxuICogdXNlcyB0aGUgc21hbGxlc3QgaW50ZXJ2YWwgKHNlZSBjb21wdXRlTWluU2FtcGxlU2l6ZSkgdGhhdCBwcmV2ZW50cyBiYXIgb3ZlcmxhcHBpbmcuIFRoaXNcbiAqIG1vZGUgY3VycmVudGx5IGFsd2F5cyBnZW5lcmF0ZXMgYmFycyBlcXVhbGx5IHNpemVkICh1bnRpbCB3ZSBpbnRyb2R1Y2Ugc2NyaXB0YWJsZSBvcHRpb25zPykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHRoaWNrbmVzcyA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xuICBsZXQgc2l6ZSwgcmF0aW87XG5cbiAgaWYgKGlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xuICAgIHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICByYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIGJhciB0aGlja25lc3MgaXMgZW5mb3JjZWQsIGNhdGVnb3J5IGFuZCBiYXIgcGVyY2VudGFnZXMgYXJlIGlnbm9yZWQuXG4gICAgLy8gTm90ZShTQik6IHdlIGNvdWxkIGFkZCBzdXBwb3J0IGZvciByZWxhdGl2ZSBiYXIgdGhpY2tuZXNzIChlLmcuIGJhclRoaWNrbmVzczogJzUwJScpXG4gICAgLy8gYW5kIGRlcHJlY2F0ZSBiYXJQZXJjZW50YWdlIHNpbmNlIHRoaXMgdmFsdWUgaXMgaWdub3JlZCB3aGVuIHRoaWNrbmVzcyBpcyBhYnNvbHV0ZS5cbiAgICBzaXplID0gdGhpY2tuZXNzICogc3RhY2tDb3VudDtcbiAgICByYXRpbyA9IDE7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbyxcbiAgICBzdGFydDogcnVsZXIucGl4ZWxzW2luZGV4XSAtIChzaXplIC8gMilcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBcIm9wdGltYWxcIiBjYXRlZ29yeSB0aGF0IGdsb2JhbGx5IGFycmFuZ2VzIGJhcnMgc2lkZSBieSBzaWRlIChubyBnYXAgd2hlblxuICogcGVyY2VudGFnZSBvcHRpb25zIGFyZSAxKSwgYmFzZWQgb24gdGhlIHByZXZpb3VzIGFuZCBmb2xsb3dpbmcgY2F0ZWdvcmllcy4gVGhpcyBtb2RlXG4gKiBnZW5lcmF0ZXMgYmFycyB3aXRoIGRpZmZlcmVudCB3aWR0aHMgd2hlbiBkYXRhIGFyZSBub3QgZXZlbmx5IHNwYWNlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHBpeGVscyA9IHJ1bGVyLnBpeGVscztcbiAgY29uc3QgY3VyciA9IHBpeGVsc1tpbmRleF07XG4gIGxldCBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xuICBsZXQgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG4gIGNvbnN0IHBlcmNlbnQgPSBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcblxuICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgIC8vIGZpcnN0IGRhdGE6IGl0cyBzaXplIGlzIGRvdWJsZSBiYXNlZCBvbiB0aGUgbmV4dCBwb2ludCBvcixcbiAgICAvLyBpZiBpdCdzIGFsc28gdGhlIGxhc3QgZGF0YSwgd2UgdXNlIHRoZSBzY2FsZSBzaXplLlxuICAgIHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gbGFzdCBkYXRhOiBpdHMgc2l6ZSBpcyBhbHNvIGRvdWJsZSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcG9pbnQuXG4gICAgbmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG4gIGNvbnN0IHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcblxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxuICAgIHN0YXJ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBjb25zdCBzdGFydFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzBdLCBpKTtcbiAgY29uc3QgZW5kVmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMV0sIGkpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgbGV0IGJhclN0YXJ0ID0gbWluO1xuICBsZXQgYmFyRW5kID0gbWF4O1xuXG4gIGlmIChNYXRoLmFicyhtaW4pID4gTWF0aC5hYnMobWF4KSkge1xuICAgIGJhclN0YXJ0ID0gbWF4O1xuICAgIGJhckVuZCA9IG1pbjtcbiAgfVxuXG4gIC8vIFN0b3JlIGBiYXJFbmRgIChmdXJ0aGVzdCBhd2F5IGZyb20gb3JpZ2luKSBhcyBwYXJzZWQgdmFsdWUsXG4gIC8vIHRvIG1ha2Ugc3RhY2tpbmcgc3RyYWlnaHQgZm9yd2FyZFxuICBpdGVtW3ZTY2FsZS5heGlzXSA9IGJhckVuZDtcblxuICBpdGVtLl9jdXN0b20gPSB7XG4gICAgYmFyU3RhcnQsXG4gICAgYmFyRW5kLFxuICAgIHN0YXJ0OiBzdGFydFZhbHVlLFxuICAgIGVuZDogZW5kVmFsdWUsXG4gICAgbWluLFxuICAgIG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgaWYgKGlzQXJyYXkoZW50cnkpKSB7XG4gICAgcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtW3ZTY2FsZS5heGlzXSA9IHZTY2FsZS5wYXJzZShlbnRyeSwgaSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xuICBsZXQgaSwgaWxlbiwgaXRlbSwgZW50cnk7XG5cbiAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZW50cnkgPSBkYXRhW2ldO1xuICAgIGl0ZW0gPSB7fTtcbiAgICBpdGVtW2lTY2FsZS5heGlzXSA9IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaV0sIGkpO1xuICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXRCYXIoY3VzdG9tKSB7XG4gIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkge1xuICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgIHJldHVybiBzaWduKHNpemUpO1xuICB9XG4gIHJldHVybiAodlNjYWxlLmlzSG9yaXpvbnRhbCgpID8gMSA6IC0xKSAqICh2U2NhbGUubWluID49IGFjdHVhbEJhc2UgPyAxIDogLTEpO1xufVxuXG5mdW5jdGlvbiBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKSB7XG4gIGxldCByZXZlcnNlLCBzdGFydCwgZW5kLCB0b3AsIGJvdHRvbTtcbiAgaWYgKHByb3BlcnRpZXMuaG9yaXpvbnRhbCkge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPiBwcm9wZXJ0aWVzLng7XG4gICAgc3RhcnQgPSAnbGVmdCc7XG4gICAgZW5kID0gJ3JpZ2h0JztcbiAgfSBlbHNlIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlIDwgcHJvcGVydGllcy55O1xuICAgIHN0YXJ0ID0gJ2JvdHRvbSc7XG4gICAgZW5kID0gJ3RvcCc7XG4gIH1cbiAgaWYgKHJldmVyc2UpIHtcbiAgICB0b3AgPSAnZW5kJztcbiAgICBib3R0b20gPSAnc3RhcnQnO1xuICB9IGVsc2Uge1xuICAgIHRvcCA9ICdzdGFydCc7XG4gICAgYm90dG9tID0gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX07XG59XG5cbmZ1bmN0aW9uIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KSB7XG4gIGxldCBlZGdlID0gb3B0aW9ucy5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCByZXMgPSB7fTtcblxuICBpZiAoIWVkZ2UpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVkZ2UgPT09IHRydWUpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSB7dG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlLCBsZWZ0OiB0cnVlfTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219ID0gYm9yZGVyUHJvcHMocHJvcGVydGllcyk7XG5cbiAgaWYgKGVkZ2UgPT09ICdtaWRkbGUnICYmIHN0YWNrKSB7XG4gICAgcHJvcGVydGllcy5lbmFibGVCb3JkZXJSYWRpdXMgPSB0cnVlO1xuICAgIGlmICgoc3RhY2suX3RvcCB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfSBlbHNlIGlmICgoc3RhY2suX2JvdHRvbSB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSBib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1twYXJzZUVkZ2UoYm90dG9tLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9XG4gIH1cblxuICByZXNbcGFyc2VFZGdlKGVkZ2UsIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VFZGdlKGVkZ2UsIGEsIGIsIHJldmVyc2UpIHtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBlZGdlID0gc3dhcChlZGdlLCBhLCBiKTtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYiwgYSk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGEsIGIpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuXG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuICByZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuXG5mdW5jdGlvbiBzdGFydEVuZCh2LCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB2ID09PSAnc3RhcnQnID8gc3RhcnQgOiB2ID09PSAnZW5kJyA/IGVuZCA6IHY7XG59XG5cbmZ1bmN0aW9uIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywge2luZmxhdGVBbW91bnR9LCByYXRpbykge1xuICBwcm9wZXJ0aWVzLmluZmxhdGVBbW91bnQgPSBpbmZsYXRlQW1vdW50ID09PSAnYXV0bydcbiAgICA/IHJhdGlvID09PSAxID8gMC4zMyA6IDBcbiAgICA6IGluZmxhdGVBbW91bnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2Jhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxuXG4gICAgY2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG4gICAgYmFyUGVyY2VudGFnZTogMC45LFxuICAgIGdyb3VwZWQ6IHRydWUsXG5cbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBzY2FsZXM6IHtcbiAgICAgIF9pbmRleF86IHtcbiAgICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgICAgb2Zmc2V0OiB0cnVlLFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgb2Zmc2V0OiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdmFsdWVfOiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBwcmltaXRpdmUgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIGFycmF5IGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIG9iamVjdCBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogdmFsdWUtc2NhbGUgZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgaXRlbSwgb2JqO1xuICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb2JqID0gZGF0YVtpXTtcbiAgICAgIGl0ZW0gPSB7fTtcbiAgICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkob2JqLCBpQXhpc0tleSksIGkpO1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgdkF4aXNLZXkpLCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgaWYgKGN1c3RvbSAmJiBzY2FsZSA9PT0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUpIHtcbiAgICAgIC8vIGZsb2F0IGJhcjogb25seSBvbmUgZW5kIG9mIHRoZSBiYXIgaXMgY29uc2lkZXJlZCBieSBgc3VwZXJgXG4gICAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIGN1c3RvbS5taW4pO1xuICAgICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCBjdXN0b20ubWF4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgdmFsdWUgPSBpc0Zsb2F0QmFyKGN1c3RvbSlcbiAgICAgID8gJ1snICsgY3VzdG9tLnN0YXJ0ICsgJywgJyArIGN1c3RvbS5lbmQgKyAnXSdcbiAgICAgIDogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcblxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcblxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuc3RhY2sgPSB0aGlzLmdldERhdGFzZXQoKS5zdGFjaztcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhtZXRhLmRhdGEsIDAsIG1ldGEuZGF0YS5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYmFycywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpbmRleCwgX2NhY2hlZE1ldGE6IHt2U2NhbGV9fSA9IHRoaXM7XG4gICAgY29uc3QgYmFzZSA9IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdlNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHJ1bGVyID0gdGhpcy5fZ2V0UnVsZXIoKTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgdnBpeGVscyA9IHJlc2V0IHx8IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZTY2FsZS5heGlzXSkgPyB7YmFzZSwgaGVhZDogYmFzZX0gOiB0aGlzLl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpKTtcbiAgICAgIGNvbnN0IGlwaXhlbHMgPSB0aGlzLl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpLCBydWxlcik7XG4gICAgICBjb25zdCBzdGFjayA9IChwYXJzZWQuX3N0YWNrcyB8fCB7fSlbdlNjYWxlLmF4aXNdO1xuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICBiYXNlOiB2cGl4ZWxzLmJhc2UsXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIXN0YWNrIHx8IGlzRmxvYXRCYXIocGFyc2VkLl9jdXN0b20pIHx8IChpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSksXG4gICAgICAgIHg6IGhvcml6b250YWwgPyB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcixcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogdnBpeGVscy5oZWFkLFxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxuICAgICAgICB3aWR0aDogaG9yaXpvbnRhbCA/IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSkgOiBpcGl4ZWxzLnNpemVcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBiYXJzW2ldLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zIHx8IGJhcnNbaV0ub3B0aW9ucztcbiAgICAgIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KTtcbiAgICAgIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywgb3B0aW9ucywgcnVsZXIucmF0aW8pO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGJhcnNbaV0sIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtsYXN0XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XSAtIFRoZSBkYXRhIGluZGV4IG9mIHRoZSBydWxlclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBsaXN0IG9mIHN0YWNrIElEc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFN0YWNrcyhsYXN0LCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCB7aVNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YXNldHMgPSBpU2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModGhpcy5fdHlwZSlcbiAgICAgIC5maWx0ZXIobWV0YSA9PiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKTtcbiAgICBjb25zdCBzdGFja2VkID0gaVNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICBjb25zdCBzdGFja3MgPSBbXTtcbiAgICBjb25zdCBjdXJyZW50UGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpO1xuICAgIGNvbnN0IGlTY2FsZVZhbHVlID0gY3VycmVudFBhcnNlZCAmJiBjdXJyZW50UGFyc2VkW2lTY2FsZS5heGlzXTtcblxuICAgIGNvbnN0IHNraXBOdWxsID0gKG1ldGEpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IG1ldGEuX3BhcnNlZC5maW5kKGl0ZW0gPT4gaXRlbVtpU2NhbGUuYXhpc10gPT09IGlTY2FsZVZhbHVlKTtcbiAgICAgIGNvbnN0IHZhbCA9IHBhcnNlZCAmJiBwYXJzZWRbbWV0YS52U2NhbGUuYXhpc107XG5cbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbCkgfHwgaXNOYU4odmFsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBtZXRhIG9mIG1ldGFzZXRzKSB7XG4gICAgICBpZiAoZGF0YUluZGV4ICE9PSB1bmRlZmluZWQgJiYgc2tpcE51bGwobWV0YSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YWNrZWQgICB8IG1ldGEuc3RhY2tcbiAgICAgIC8vICAgICAgICAgICB8IGZvdW5kIHwgbm90IGZvdW5kIHwgdW5kZWZpbmVkXG4gICAgICAvLyBmYWxzZSAgICAgfCAgIHggICB8ICAgICB4ICAgICB8ICAgICB4XG4gICAgICAvLyB0cnVlICAgICAgfCAgICAgICB8ICAgICB4ICAgICB8XG4gICAgICAvLyB1bmRlZmluZWQgfCAgICAgICB8ICAgICB4ICAgICB8ICAgICB4XG4gICAgICBpZiAoc3RhY2tlZCA9PT0gZmFsc2UgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhLmluZGV4ID09PSBsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHN0YWNrcz8gdGhhdCBtZWFucyB0aGVyZSBpcyBubyB2aXNpYmxlIGRhdGEuIExldCdzIHN0aWxsIGluaXRpYWxpemUgYW4gYHVuZGVmaW5lZGBcbiAgICAvLyBzdGFjayB3aGVyZSBwb3NzaWJsZSBpbnZpc2libGUgYmFycyB3aWxsIGJlIGxvY2F0ZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzYzNjhcbiAgICBpZiAoIXN0YWNrcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgbnVtYmVyIG9mIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFN0YWNrQ291bnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKHVuZGVmaW5lZCwgaW5kZXgpLmxlbmd0aDtcbiAgfVxuXG4gIF9nZXRBeGlzQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEF4aXMoKS5sZW5ndGg7XG4gIH1cblxuICBnZXRGaXJzdFNjYWxlSWRGb3JJbmRleEF4aXMoKSB7XG4gICAgY29uc3Qgc2NhbGVzID0gdGhpcy5jaGFydC5zY2FsZXM7XG4gICAgY29uc3QgaW5kZXhTY2FsZUlkID0gdGhpcy5jaGFydC5vcHRpb25zLmluZGV4QXhpcztcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoa2V5ID0+IHNjYWxlc1trZXldLmF4aXMgPT09IGluZGV4U2NhbGVJZCkuc2hpZnQoKTtcbiAgfVxuXG4gIF9nZXRBeGlzKCkge1xuICAgIGNvbnN0IGF4aXMgPSB7fTtcbiAgICBjb25zdCBmaXJzdFNjYWxlQXhpc0lkID0gdGhpcy5nZXRGaXJzdFNjYWxlSWRGb3JJbmRleEF4aXMoKTtcbiAgICBmb3IgKGNvbnN0IGRhdGFzZXQgb2YgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzKSB7XG4gICAgICBheGlzW3ZhbHVlT3JEZWZhdWx0KFxuICAgICAgICB0aGlzLmNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzID09PSAneCcgPyBkYXRhc2V0LnhBeGlzSUQgOiBkYXRhc2V0LnlBeGlzSUQsIGZpcnN0U2NhbGVBeGlzSWRcbiAgICAgICldID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGF4aXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgLy8gYmFyIHRoaWNrbmVzcyByYXRpbyB1c2VkIGZvciBub24tZ3JvdXBlZCBiYXJzXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZCwgaW5kZXg6IGRhdGFzZXRJbmRleH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIC8vIGJhcnMgY3Jvc3Npbmcgb3JpZ2luIGFyZSBub3Qgc3RhY2tlZFxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG5cbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gbm90IHZpc2libGUsIG5vIGhlaWdodFxuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuXG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuXG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuXG4gICAgICBpZiAoX3N0YWNrZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgIC8vIHZpc3VhbCBkYXRhIGNvb3JkaW5hdGVzIGFmdGVyIGFwcGx5aW5nIG1pbkJhckxlbmd0aFxuICAgICAgICBwYXJzZWQuX3N0YWNrc1t2U2NhbGUuYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoaGVhZCkgLSB2U2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChiYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgY29uc3QgYXhpc0NvdW50ID0gdGhpcy5fZ2V0QXhpc0NvdW50KCk7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50ICogYXhpc0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQgKiBheGlzQ291bnQpO1xuICAgICAgY29uc3QgYXhpc0lEID0gdGhpcy5jaGFydC5vcHRpb25zLmluZGV4QXhpcyA9PT0gJ3gnID8gdGhpcy5nZXREYXRhc2V0KCkueEF4aXNJRCA6IHRoaXMuZ2V0RGF0YXNldCgpLnlBeGlzSUQ7XG4gICAgICBjb25zdCBheGlzTnVtYmVyID0gdGhpcy5fZ2V0QXhpcygpLmluZGV4T2YodmFsdWVPckRlZmF1bHQoYXhpc0lELCB0aGlzLmdldEZpcnN0U2NhbGVJZEZvckluZGV4QXhpcygpKSk7XG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKSArIGF4aXNOdW1iZXI7XG4gICAgICBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCByYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIG5vbi1ncm91cGVkIGJhciBjaGFydHMsIGV4YWN0IHBpeGVsIHZhbHVlcyBhcmUgdXNlZFxuICAgICAgY2VudGVyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpbmRleClbc2NhbGUuYXhpc10sIGluZGV4KTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJ1bGVyLm1pbiAqIHJ1bGVyLnJhdGlvKTtcbiAgICB9XG5cblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwgJiYgIXJlY3RzW2ldLmhpZGRlbikge1xuICAgICAgICByZWN0c1tpXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWJibGVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdidWJibGUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJ11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgeDoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgYXJyYXlzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW1bMl0sIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW0gJiYgaXRlbS5yICYmICtpdGVtLnIsIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAociA/ICcsICcgKyByIDogJycpICsgJyknXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gIXJlc2V0ICYmIHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSByZXNldCA/IGlTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10pO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFt2QXhpc10pO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuXG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21vZGVdXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xuXG4gICAgLy8gSW4gY2FzZSB2YWx1ZXMgd2VyZSBjYWNoZWQgKGFuZCB0aHVzIGZyb3plbiksIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHZhbHVlc1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7JHNoYXJlZDogZmFsc2V9KTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cbiAgICBjb25zdCByYWRpdXMgPSB2YWx1ZXMucmFkaXVzO1xuICAgIGlmIChtb2RlICE9PSAnYWN0aXZlJykge1xuICAgICAgdmFsdWVzLnJhZGl1cyA9IDA7XG4gICAgfVxuICAgIHZhbHVlcy5yYWRpdXMgKz0gdmFsdWVPckRlZmF1bHQocGFyc2VkICYmIHBhcnNlZC5fY3VzdG9tLCByYWRpdXMpO1xuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuIiwiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCByZXNvbHZlT2JqZWN0S2V5LCB0b1BlcmNlbnRhZ2UsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgVEFVLCBIQUxGX1BJLCBfYW5nbGVCZXR3ZWVufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuZnVuY3Rpb24gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCkge1xuICBsZXQgcmF0aW9YID0gMTtcbiAgbGV0IHJhdGlvWSA9IDE7XG4gIGxldCBvZmZzZXRYID0gMDtcbiAgbGV0IG9mZnNldFkgPSAwO1xuICAvLyBJZiB0aGUgY2hhcnQncyBjaXJjdW1mZXJlbmNlIGlzbid0IGEgZnVsbCBjaXJjbGUsIGNhbGN1bGF0ZSBzaXplIGFzIGEgcmF0aW8gb2YgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYXJjXG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2RvdWdobnV0JztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgRG91Z2hudXRcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuICAgICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG4gICAgY3V0b3V0OiAnNTAlJyxcblxuICAgIC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG4gICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuXG4gICAgLy8gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY2hhcnRcbiAgICByYWRpdXM6ICcxMDAlJyxcblxuICAgIC8vIFNwYWNpbmcgYmV0d2VlbiBhcmNzXG4gICAgc3BhY2luZzogMCxcblxuICAgIGluZGV4QXhpczogJ3InLFxuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2JvcmRlckRhc2gnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdob3ZlckJvcmRlckRhc2gnKSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICAvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcbiAgICBwbHVnaW5zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGUsIHRleHRBbGlnbiwgY29sb3IsIHVzZUJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogdXNlQm9yZGVyUmFkaXVzICYmIChib3JkZXJSYWRpdXMgfHwgc3R5bGUuYm9yZGVyUmFkaXVzKSxcbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcblxuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsaW5rU2NhbGVzKCkge31cblxuICAvKipcblx0ICogT3ZlcnJpZGUgZGF0YSBwYXJzaW5nLCBzaW5jZSB3ZSBhcmUgbm90IHVzaW5nIHNjYWxlc1xuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG5cbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZXR0ZXIgPSAoaSkgPT4gK2RhdGFbaV07XG5cbiAgICAgIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgY29uc3Qge2tleSA9ICd2YWx1ZSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgZ2V0dGVyID0gKGkpID0+ICtyZXNvbHZlT2JqZWN0S2V5KGRhdGFbaV0sIGtleSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpXSA9IGdldHRlcihpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5yb3RhdGlvbiAtIDkwKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBtYXhpbWFsIHJvdGF0aW9uICYgY2lyY3VtZmVyZW5jZSBleHRlbnRzXG5cdCAqIGFjcm9zcyBhbGwgdmlzaWJsZSBkYXRhc2V0cy5cblx0ICovXG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkudHlwZSA9PT0gdGhpcy5fdHlwZSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG5cbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3RhdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm90YXRpb24gKyBjaXJjdW1mZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IG1pbixcbiAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pbixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlXG5cdCAqL1xuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KChNYXRoLm1pbihjaGFydEFyZWEud2lkdGgsIGNoYXJ0QXJlYS5oZWlnaHQpIC0gc3BhY2luZykgLyAyLCAwKTtcbiAgICBjb25zdCBjdXRvdXQgPSBNYXRoLm1pbih0b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gdGhpcy5fZ2V0UmluZ1dlaWdodCh0aGlzLmluZGV4KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1heGltYWwgcm90YXRpb24gJiBjaXJjdW1mZXJlbmNlIGxpbWl0cy5cbiAgICAvLyBJZiB3ZSBvbmx5IGNvbnNpZGVyIG91ciBkYXRhc2V0LCB0aGlzIGNhbiBjYXVzZSBwcm9ibGVtcyB3aGVuIHR3byBkYXRhc2V0c1xuICAgIC8vIGFyZSBib3RoIGxlc3MgdGhhbiBhIGNpcmNsZSB3aXRoIGRpZmZlcmVudCByb3RhdGlvbnMgKHN0YXJ0aW5nIGFuZ2xlcylcbiAgICBjb25zdCB7Y2lyY3VtZmVyZW5jZSwgcm90YXRpb259ID0gdGhpcy5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgY29uc3Qge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfSA9IGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gdGhpcy5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG5cbiAgICBtZXRhLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpO1xuXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcblxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5vdXRlclJhZGl1cztcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlVG90YWwoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodmFsdWUpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgaWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gVEFVICogKE1hdGguYWJzKHZhbHVlKSAvIHRvdGFsKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBnZXRNYXhCb3JkZXJXaWR0aChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxldCBpLCBpbGVuLCBtZXRhLCBjb250cm9sbGVyLCBvcHRpb25zO1xuXG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICAvLyBGaW5kIHRoZSBvdXRtb3N0IHZpc2libGUgZGF0YXNldFxuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgIGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvcHRpb25zID0gY29udHJvbGxlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuXG4gIGdldE1heE9mZnNldChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgcmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmluZ1dlaWdodChkYXRhc2V0SW5kZXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmxlIGRhdGEgc2V0IHdlaWdodHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICB9XG59XG4iLCJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCBfc2NhbGVSYW5nZXNDaGFuZ2VkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcblxuICAgIHNob3dMaW5lOiB0cnVlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICBfaW5kZXhfOiB7XG4gICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICB9LFxuICAgICAgX3ZhbHVlXzoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgIH0sXG4gICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG5cbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcblxuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIExpbmVcbiAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgY29uc3QgcG9pbnRzQ291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG5cbiAgICAgIGlmIChpIDwgc3RhcnQgfHwgaSA+PSBlbmQpIHtcbiAgICAgICAgcHJvcGVydGllcy5za2lwID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIFBJLCBmb3JtYXROdW1iZXIsIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3BvbGFyQXJlYSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICBhbmltYXRlU2NhbGU6IHRydWVcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxuICAgICAgfSxcbiAgICB9LFxuICAgIGluZGV4QXhpczogJ3InLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgcGx1Z2luczoge1xuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGUsIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcblxuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG5cbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNjYWxlczoge1xuICAgICAgcjoge1xuICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY2lyY3VsYXI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzdGFydEFuZ2xlOiAwXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcblxuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XS5yLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0TWluTWF4KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG5cbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yO1xuXG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgaWYgKHBhcnNlZCA8IHJhbmdlLm1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IHBhcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZWQgPiByYW5nZS5tYXgpIHtcbiAgICAgICAgICByYW5nZS5tYXggPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuXG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG5cbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAocmFkaXVzTGVuZ3RoICogdGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuXG4gICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIGFuZ2xlICs9IHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICBsZXQgZW5kQW5nbGUgPSBhbmdsZSArIHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgICAgbGV0IG91dGVyUmFkaXVzID0gY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgPyBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKS5yKSA6IDA7XG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuXG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlKSB7XG4gICAgICAgICAgb3V0ZXJSYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNOYU4odGhpcy5nZXRQYXJzZWQoaW5kZXgpLnIpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxuICAgICAgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpXG4gICAgICA6IDA7XG4gIH1cbn1cbiIsImltcG9ydCBEb3VnaG51dENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyLmRvdWdobnV0LmpzJztcblxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpZUNvbnRyb2xsZXIgZXh0ZW5kcyBEb3VnaG51dENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdwaWUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cbiAgICBjdXRvdXQ6IDAsXG5cbiAgICAvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLy8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcblxuICAgIC8vIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNoYXJ0XG4gICAgcmFkaXVzOiAnMTAwJSdcbiAgfTtcbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3JhZGFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgaW5kZXhBeGlzOiAncicsXG4gICAgc2hvd0xpbmU6IHRydWUsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgZmlsbDogJ3N0YXJ0J1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICByOiB7XG4gICAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBVcGRhdGUgTGluZVxuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIC8vIEluIHJlc2l6ZSBtb2RlIG9ubHkgcG9pbnQgbG9jYXRpb25zIGNoYW5nZSwgc28gbm8gbmVlZCB0byBzZXQgdGhlIHBvaW50cyBvciBvcHRpb25zLlxuICAgIGlmIChtb2RlICE9PSAncmVzaXplJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHRoaXMuZ2V0UGFyc2VkKGkpLnIpO1xuXG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYW5nbGU6IHBvaW50UG9zaXRpb24uYW5nbGUsXG4gICAgICAgIHNraXA6IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgX3NjYWxlUmFuZ2VzQ2hhbmdlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdzY2F0dGVyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICBzaG93TGluZTogZmFsc2UsXG4gICAgZmlsbDogZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG5cbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgbW9kZTogJ3BvaW50J1xuICAgIH0sXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArICcpJ1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhOiBwb2ludHMgPSBbXX0gPSBtZXRhO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuXG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG5cbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzExMzMzXG4gICAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBfZGF0YXNldH0gPSBtZXRhO1xuXG4gICAgICAvLyBVcGRhdGUgTGluZVxuICAgICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBtb2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMTEzMzNcbiAgICAgIGRlbGV0ZSBtZXRhLmRhdGFzZXQ7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuXG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHtzaG93TGluZX0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHNob3dMaW5lKSB7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IHRoaXMuY2hhcnQucmVnaXN0cnkuZ2V0RWxlbWVudCgnbGluZScpO1xuICAgIH1cblxuICAgIHN1cGVyLmFkZEVsZW1lbnRzKCk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGxldCBtYXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuXG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG59XG4iLCIvKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAc2luY2UgMi44LjBcbiAqIEBwcml2YXRlXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0T3B0aW9uc30gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5leHBvcnQgdHlwZSBUaW1lVW5pdCA9ICdtaWxsaXNlY29uZCcgfCAnc2Vjb25kJyB8ICdtaW51dGUnIHwgJ2hvdXInIHwgJ2RheScgfCAnd2VlaycgfCAnbW9udGgnIHwgJ3F1YXJ0ZXInIHwgJ3llYXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVBZGFwdGVyPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+IHtcbiAgcmVhZG9ubHkgb3B0aW9uczogVDtcbiAgLyoqXG4gICAqIFdpbGwgY2FsbGVkIHdpdGggY2hhcnQgb3B0aW9ucyBhZnRlciBhZGFwdGVyIGNyZWF0aW9uLlxuICAgKi9cbiAgaW5pdCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgY2hhcnRPcHRpb25zOiBDaGFydE9wdGlvbnMpOiB2b2lkO1xuICAvKipcbiAgICogUmV0dXJucyBhIG1hcCBvZiB0aW1lIGZvcm1hdHMgZm9yIHRoZSBzdXBwb3J0ZWQgZm9ybWF0dGluZyB1bml0cyBkZWZpbmVkXG4gICAqIGluIFVuaXQgYXMgd2VsbCBhcyAnZGF0ZXRpbWUnIHJlcHJlc2VudGluZyBhIGRldGFpbGVkIGRhdGUvdGltZSBzdHJpbmcuXG4gICAqL1xuICBmb3JtYXRzKHRoaXM6IERhdGVBZGFwdGVyPFQ+KTogUmVjb3JkPFRpbWVVbml0IHwgJ2RhdGV0aW1lJywgc3RyaW5nPjtcbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gYHZhbHVlYCBhbmQgcmV0dXJuIHRoZSBhc3NvY2lhdGVkIHRpbWVzdGFtcC5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHBhcnNlICh1c3VhbGx5IGNvbWVzIGZyb20gdGhlIGRhdGEpXG4gICAqIEBwYXJhbSBbZm9ybWF0XSAtIHRoZSBleHBlY3RlZCBkYXRhIGZvcm1hdFxuICAgKi9cbiAgcGFyc2UodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHZhbHVlOiB1bmtub3duLCBmb3JtYXQ/OiBzdHJpbmcpOiBudW1iZXIgfCBudWxsO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZm9ybWF0dGVkIGRhdGUgaW4gdGhlIHNwZWNpZmllZCBgZm9ybWF0YCBmb3IgYSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSB0aW1lc3RhbXAgdG8gZm9ybWF0XG4gICAqIEBwYXJhbSBmb3JtYXQgLSB0aGUgZGF0ZS90aW1lIHRva2VuXG4gICAqL1xuICBmb3JtYXQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCBmb3JtYXQ6IHN0cmluZyk6IHN0cmluZztcbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGFkZCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIGFtb3VudDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBgdW5pdGAgYmV0d2VlbiB0aGUgZ2l2ZW4gdGltZXN0YW1wcy5cbiAgICogQHBhcmFtIGEgLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG4gICAqIEBwYXJhbSBiIC0gdGhlIHRpbWVzdGFtcCB0byBzdWJ0cmFjdFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgZGlmZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgYTogbnVtYmVyLCBiOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyBzdGFydCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICogQHBhcmFtIFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcbiAgICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cbiAgICovXG4gIHN0YXJ0T2YodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCB8ICdpc29XZWVrJywgd2Vla2RheT86IG51bWJlciB8IGJvb2xlYW4pOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGVuZCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGVuZE9mKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgdW5pdDogVGltZVVuaXQpOiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIGFic3RyYWN0PFQgPSB2b2lkPigpOiBUIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IENoZWNrIHRoYXQgYSBjb21wbGV0ZSBkYXRlIGFkYXB0ZXIgaXMgcHJvdmlkZWQuJyk7XG59XG5cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRGF0ZUFkYXB0ZXJCYXNlIGltcGxlbWVudHMgRGF0ZUFkYXB0ZXIge1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBkZWZhdWx0IGRhdGUgYWRhcHRlciBtZXRob2RzLlxuICAgKiBBY2NlcHRzIHR5cGUgcGFyYW1ldGVyIHRvIGRlZmluZSBvcHRpb25zIHR5cGUuXG4gICAqIEBleGFtcGxlXG4gICAqIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZS5vdmVycmlkZTx7bXlBZGFwdGVyT3B0aW9uOiBzdHJpbmd9Pih7XG4gICAqICAgaW5pdCgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKHRoaXMub3B0aW9ucy5teUFkYXB0ZXJPcHRpb24pO1xuICAgKiAgIH1cbiAgICogfSlcbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZTxUIGV4dGVuZHMgQW55T2JqZWN0ID0gQW55T2JqZWN0PihcbiAgICBtZW1iZXJzOiBQYXJ0aWFsPE9taXQ8RGF0ZUFkYXB0ZXI8VD4sICdvcHRpb25zJz4+XG4gICkge1xuICAgIE9iamVjdC5hc3NpZ24oRGF0ZUFkYXB0ZXJCYXNlLnByb3RvdHlwZSwgbWVtYmVycyk7XG4gIH1cblxuICByZWFkb25seSBvcHRpb25zOiBBbnlPYmplY3Q7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IEFueU9iamVjdCkge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGluaXQoKSB7fVxuXG4gIGZvcm1hdHMoKTogUmVjb3JkPFRpbWVVbml0IHwgJ2RhdGV0aW1lJywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBwYXJzZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGZvcm1hdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgYWRkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBkaWZmKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBzdGFydE9mKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBlbmRPZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX2RhdGU6IERhdGVBZGFwdGVyQmFzZSBhcyB7XG4gICAgbmV3IChvcHRpb25zPzogQW55T2JqZWN0KTogRGF0ZUFkYXB0ZXI7XG4gICAgb3ZlcnJpZGU8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4oXG4gICAgICBtZW1iZXJzOiBQYXJ0aWFsPE9taXQ8RGF0ZUFkYXB0ZXI8VD4sICdvcHRpb25zJz4+XG4gICAgKTogdm9pZDtcbiAgfVxufTtcbiIsImltcG9ydCB7X2xvb2t1cEJ5S2V5LCBfcmxvb2t1cEJ5S2V5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2dldFJlbGF0aXZlUG9zaXRpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfaXNQb2ludEluQXJlYSwgaXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYge3theGlzPzogc3RyaW5nLCBpbnRlcnNlY3Q/OiBib29sZWFuLCBpbmNsdWRlSW52aXNpYmxlPzogYm9vbGVhbn19IEludGVyYWN0aW9uT3B0aW9uc1xuICogQHR5cGVkZWYge3tkYXRhc2V0SW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlciwgZWxlbWVudDogaW1wb3J0KCcuL2NvcmUuZWxlbWVudC5qcycpLmRlZmF1bHR9fSBJbnRlcmFjdGlvbkl0ZW1cbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLlBvaW50IH0gUG9pbnRcbiAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBkbyBiaW5hcnkgc2VhcmNoIHdoZW4gcG9zc2libGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhc2V0IC0gdGhlIGRhdGFzZXQgbWV0YVxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBzaG91bGQgdGhlIGVsZW1lbnQgaW50ZXJzZWN0XG4gKiBAcmV0dXJucyB7e2xvOm51bWJlciwgaGk6bnVtYmVyfX0gaW5kaWNlcyB0byBzZWFyY2ggZGF0YSBhcnJheSBiZXR3ZWVuXG4gKi9cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChtZXRhc2V0LCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IHtjb250cm9sbGVyLCBkYXRhLCBfc29ydGVkfSA9IG1ldGFzZXQ7XG4gIGNvbnN0IGlTY2FsZSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGEuaVNjYWxlO1xuICBjb25zdCBzcGFuR2FwcyA9IG1ldGFzZXQuZGF0YXNldCA/IG1ldGFzZXQuZGF0YXNldC5vcHRpb25zID8gbWV0YXNldC5kYXRhc2V0Lm9wdGlvbnMuc3BhbkdhcHMgOiBudWxsIDogbnVsbDtcblxuICBpZiAoaVNjYWxlICYmIGF4aXMgPT09IGlTY2FsZS5heGlzICYmIGF4aXMgIT09ICdyJyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgbG9va3VwTWV0aG9kID0gaVNjYWxlLl9yZXZlcnNlUGl4ZWxzID8gX3Jsb29rdXBCeUtleSA6IF9sb29rdXBCeUtleTtcbiAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlKTtcbiAgICAgIGlmIChzcGFuR2Fwcykge1xuICAgICAgICBjb25zdCB7dlNjYWxlfSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IHtfcGFyc2VkfSA9IG1ldGFzZXQ7XG5cbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRMbyA9IChfcGFyc2VkXG4gICAgICAgICAgLnNsaWNlKDAsIHJlc3VsdC5sbyArIDEpXG4gICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIHJlc3VsdC5sbyAtPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZExvKTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZEhpID0gKF9wYXJzZWRcbiAgICAgICAgICAuc2xpY2UocmVzdWx0LmhpKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIHJlc3VsdC5oaSArPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZEhpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICAvLyBfc2hhcmVkT3B0aW9ucyBpbmRpY2F0ZXMgdGhhdCBlYWNoIGVsZW1lbnQgaGFzIGVxdWFsIG9wdGlvbnMgLT4gZXF1YWwgcHJvcG9ydGlvbnNcbiAgICAgIC8vIFNvIHdlIGNhbiBkbyBhIHJhbmdlZCBiaW5hcnkgc2VhcmNoIGJhc2VkIG9uIHRoZSByYW5nZSBvZiBmaXJzdCBlbGVtZW50IGFuZFxuICAgICAgLy8gYmUgY29uZmlkZW50IHRvIGdldCB0aGUgZnVsbCByYW5nZSBvZiBpbmRpY2VzIHRoYXQgY2FuIGludGVyc2VjdCB3aXRoIHRoZSB2YWx1ZS5cbiAgICAgIGNvbnN0IGVsID0gZGF0YVswXTtcbiAgICAgIGNvbnN0IHJhbmdlID0gdHlwZW9mIGVsLmdldFJhbmdlID09PSAnZnVuY3Rpb24nICYmIGVsLmdldFJhbmdlKGF4aXMpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlIC0gcmFuZ2UpO1xuICAgICAgICBjb25zdCBlbmQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgKyByYW5nZSk7XG4gICAgICAgIHJldHVybiB7bG86IHN0YXJ0LmxvLCBoaTogZW5kLmhpfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRGVmYXVsdCB0byBhbGwgZWxlbWVudHMsIHdoZW4gYmluYXJ5IHNlYXJjaCBjYW4gbm90IGJlIHVzZWQuXG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBzZWxlY3QgY2FuZGlkYXRlIGVsZW1lbnRzIGZvciBpbnRlcmFjdGlvblxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gY29uc2lkZXIgaW50ZXJzZWN0aW5nIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCB7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV07XG4gICAgY29uc3Qge2xvLCBoaX0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICBjb25zdCBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBldmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhX2lzUG9pbnRJbkFyZWEoZWxlbWVudCwgY2hhcnQuY2hhcnRBcmVhLCAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jLCB0cnVlKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGZvciBhIHJhZGlhbCBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBsZXQgaXRlbXMgPSBbXTtcblxuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlfSA9IGVsZW1lbnQuZ2V0UHJvcHMoWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZX0gPSBnZXRBbmdsZUZyb21Qb2ludChlbGVtZW50LCB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX0pO1xuXG4gICAgaWYgKF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGZvciBhIGNhcnRlc2lhbiBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGNvbnN0IGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpO1xuICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IGluUmFuZ2UgPSBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgaWYgKGludGVyc2VjdCAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgcG9pbnRJbkFyZWEgPSAhIWluY2x1ZGVJbnZpc2libGUgfHwgY2hhcnQuaXNQb2ludEluQXJlYShjZW50ZXIpO1xuICAgIGlmICghcG9pbnRJbkFyZWEgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcyA9IFt7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH1dO1xuICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgLy8gQ2FuIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgaW4gd2hpY2ggY2FzZSB3ZSBzb3J0IGJ5IHNpemVcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBjb25zaWRlcmluZyBhbGwgdmlzaWJsZSBpdGVtcyBpbiB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gYXhpcyA9PT0gJ3InICYmICFpbnRlcnNlY3RcbiAgICA/IGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXG4gICAgOiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG1hdGNoaW5nIGFsb25nIHRoZSBnaXZlbiBYIG9yIFkgYXhpc1xuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyB0byBtYXRjaFxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHJhbmdlTWV0aG9kID0gYXhpcyA9PT0gJ3gnID8gJ2luWFJhbmdlJyA6ICdpbllSYW5nZSc7XG4gIGxldCBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XG4gICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdICYmIGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSBpbnRlcnNlY3RzSXRlbSB8fCBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuICAvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG4gIGlmIChpbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBDb250YWlucyBpbnRlcmFjdGlvbiByZWxhdGVkIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8vIFBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgdG8gZmFjaWxpdGF0ZSBkZXZlbG9wZXJzIGNyZWF0aW5nIHRoZWlyIG93biBtb2Rlc1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMsXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcbiAgbW9kZXM6IHtcbiAgICAvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgbW9kZSBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4IGFzIHRoYXQgaXRlbVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgaW5kZXgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICAvLyBEZWZhdWx0IGF4aXMgZm9yIGluZGV4IG1vZGUgaXMgJ3gnIHRvIG1hdGNoIG9sZCBiZWhhdmlvdXJcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpXG4gICAgICAgIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcblxuICAgICAgICAvLyBkb24ndCBjb3VudCBpdGVtcyB0aGF0IGFyZSBza2lwcGVkIChudWxsIGRhdGEpXG4gICAgICAgIGlmIChlbGVtZW50ICYmICFlbGVtZW50LnNraXApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXgsIGluZGV4fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgaW4gdGhlIHNhbWUgZGF0YXNldC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgaW4gdGhhdCBkYXRhc2V0XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgZGF0YXNldChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkgOlxuICAgICAgICBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IGl0ZW1zWzBdLmRhdGFzZXRJbmRleDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuZGF0YTtcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudDogZGF0YVtpXSwgZGF0YXNldEluZGV4LCBpbmRleDogaX0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIG9mIHRoZSBldmVudFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgcG9pbnQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIHggbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHggY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3gnLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIHkgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHkgY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy55XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3knLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHtkZWZpbmVkLCBlYWNoLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1BhZGRpbmd9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcblxuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG4vKipcbiAqIHN0b3JlIGRpbWVuc2lvbnMgdXNlZCBpbnN0ZWFkIG9mIGF2YWlsYWJsZSBjaGFydEFyZWEgaW4gZml0Qm94ZXNcbiAqKi9cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgLy8gZHluYW1pY2FsbHkgcGxhY2VkIGJveGVzIHNpemUgaXMgbm90IGNvbnNpZGVyZWRcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICAvLyB0aGlzIGxheW91dCB3YXMgYWxyZWFkeSBjb3VudGVkIGZvciwgbGV0cyBmaXJzdCByZWR1Y2Ugb2xkIHNpemVcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cblxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG5cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuXG4gIC8vIHJldHVybiBib29sZWFucyBvbiB0aGUgY2hhbmdlcyBwZXIgZGlyZWN0aW9uXG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG5cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuXG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuXG4gICAgLy8gRGltZW5zaW9ucyBjaGFuZ2VkIGFuZCB0aGVyZSB3ZXJlIG5vbiBmdWxsIHdpZHRoIGJveGVzIGJlZm9yZSB0aGlzXG4gICAgLy8gLT4gd2UgaGF2ZSB0byByZWZpdCB0aG9zZVxuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG5cbiAgICAvLyBDaGFydCBhcmVhIGNoYW5nZWQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuXG4gICAgaWYgKCFib3guZnVsbFNpemUpIHsgLy8gZnVsbFNpemUgYm94ZXMgZG9uJ3QgbmVlZCB0byBiZSByZS1maXR0ZWQgaW4gYW55IGNhc2VcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuXG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cblxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuXG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTGF5b3V0SXRlbVxuICogQHR5cGVkZWYge29iamVjdH0gTGF5b3V0SXRlbVxuICogQHByb3Age3N0cmluZ30gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNoYXJ0IGxheW91dC4gUG9zc2libGUgdmFsdWVzIGFyZVxuICogJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsIGFuZCAnY2hhcnRBcmVhJ1xuICogQHByb3Age251bWJlcn0gd2VpZ2h0IC0gVGhlIHdlaWdodCB1c2VkIHRvIHNvcnQgdGhlIGl0ZW0uIEhpZ2hlciB3ZWlnaHRzIGFyZSBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuICogQHByb3Age2Jvb2xlYW59IGZ1bGxTaXplIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBkcmF3IC0gRHJhd3MgdGhlIGVsZW1lbnRcbiAqIEBwcm9wIHtmdW5jdGlvbn0gW2dldFBhZGRpbmddIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGFkZCB0byBiZSBsYWlkIG91dFxuXHQgKi9cbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH07XG5cbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuXG4gIC8qKlxuXHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0ICovXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG5cdCAqIFNldHMgKG9yIHVwZGF0ZXMpIG9wdGlvbnMgb24gdGhlIGdpdmVuIGBpdGVtYC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXG5cdCAqL1xuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblBhZGRpbmcgLSBtaW5pbXVtIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGVhY2ggc2lkZSBvZiBjaGFydCBhcmVhXG5cdCAqL1xuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG5cbiAgICAvLyBCZWZvcmUgYW55IGNoYW5nZXMgYXJlIG1hZGUsIG5vdGlmeSBib3hlcyB0aGF0IGFuIHVwZGF0ZSBpcyBhYm91dCB0byBiZWluZ1xuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBjbGVhciBhbnkgY2FjaGVkIGRhdGEgKGUuZy4gc2NhbGUgbGltaXRzKVxuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxuICAgIC8vIE91ciBjYW52YXMgbG9va3MgbGlrZSB0aGUgZm9sbG93aW5nLlxuICAgIC8vIFRoZSBhcmVhcyBMMSBhbmQgTDIgYXJlIHRoZSBsZWZ0IGF4ZXMuIFIxIGlzIHRoZSByaWdodCBheGlzLCBUMSBpcyB0aGUgdG9wIGF4aXMgYW5kXG4gICAgLy8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXG4gICAgLy8gVGhlcmUgYXJlIGFsc28gNCBxdWFkcmFudC1saWtlIGxvY2F0aW9ucyAobGVmdCB0byByaWdodCBpbnN0ZWFkIG9mIGNsb2Nrd2lzZSkgcmVzZXJ2ZWQgZm9yIGNoYXJ0IG92ZXJsYXlzXG4gICAgLy8gVGhlc2UgbG9jYXRpb25zIGFyZSBzaW5nbGUtYm94IGxvY2F0aW9ucyBvbmx5LCB3aGVuIHRyeWluZyB0byByZWdpc3RlciBhIGNoYXJ0QXJlYSBsb2NhdGlvbiB0aGF0IGlzIGFscmVhZHkgdGFrZW4sXG4gICAgLy8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgLy9cbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgVDIgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCBDMSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDMiB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8IEwxIHwgTDIgfCAgICAgICAgICAgQ2hhcnRBcmVhIChDMCkgICAgICAgICAgICB8IFIxIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCBDMyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDNCB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgQjIgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvL1xuXG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgb3V0ZXJXaWR0aDogd2lkdGgsXG4gICAgICBvdXRlckhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZyxcbiAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCB0b1BhZGRpbmcobWluUGFkZGluZykpO1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4UGFkZGluZyxcbiAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgeTogcGFkZGluZy50b3BcbiAgICB9LCBwYWRkaW5nKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcblxuICAgIC8vIEZpcnN0IGZpdCB0aGUgZnVsbFNpemUgYm94ZXMsIHRvIHJlZHVjZSBwcm9iYWJpbGl0eSBvZiByZS1maXR0aW5nLlxuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIFRoZW4gZml0IHZlcnRpY2FsIGJveGVzXG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCBob3Jpem9udGFsIGJveGVzXG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIC8vIGlmIHRoZSBhcmVhIGNoYW5nZWQsIHJlLWZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuXG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuXG4gICAgLy8gRmluYWxseSBwbGFjZSB0aGUgYm94ZXMgdG8gY29ycmVjdCBjb29yZGluYXRlc1xuICAgIHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBNb3ZlIHRvIG9wcG9zaXRlIHNpZGUgb2YgY2hhcnRcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcblxuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgIHdpZHRoOiBjaGFydEFyZWEudyxcbiAgICB9O1xuXG4gICAgLy8gRmluYWxseSB1cGRhdGUgYm94ZXMgaW4gY2hhcnRBcmVhIChyYWRpYWwgc2NhbGUgZm9yIGV4YW1wbGUpXG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IGFsbG93cyBhYnN0cmFjdGluZyBwbGF0Zm9ybSBkZXBlbmRlbmNpZXMgYXdheSBmcm9tIHRoZSBjaGFydC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiAgLyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcblx0ICogdGhlIFtXM0MgQ2FudmFzIDJEIENvbnRleHQgQVBJIHN0YW5kYXJkXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L30uXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgZnJvbSB3aGljaCB0byBhY3F1aXJlIGNvbnRleHQgKHBsYXRmb3JtIHNwZWNpZmljKVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIFRoZSBjaGFydCBvcHRpb25zXG5cdCAqL1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBkZXN0cnVjdGlvbiB0aW1lLCByZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFzc29jaWF0ZWQgdG8gdGhlIGNvbnRleHRcblx0ICogcHJldmlvdXNseSByZXR1cm5lZCBieSB0aGUgYWNxdWlyZUNvbnRleHQoKSBtZXRob2QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNvbnRleHQyZCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWV0aG9kIHN1Y2NlZWRlZCwgZWxzZSBmYWxzZVxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIG9uIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIGxpc3RlbiBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBDaGFydEV2ZW50fSkgdHlwZSB0byBsaXN0ZW4gZm9yXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gUmVjZWl2ZXMgYSBub3RpZmljYXRpb24gKGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHNcblx0ICogdGhlIHtAbGluayBDaGFydEV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cblx0ICovXG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIENoYXJ0RXZlbnR9KSB0eXBlIHRvIHJlbW92ZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQHJldHVybnMge251bWJlcn0gdGhlIGN1cnJlbnQgZGV2aWNlUGl4ZWxSYXRpbyBvZiB0aGUgZGV2aWNlIHRoaXMgcGxhdGZvcm0gaXMgY29ubmVjdGVkIHRvLlxuXHQgKi9cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHNpemUgaW4gcGl4ZWxzIG9mIGdpdmVuIGNhbnZhcyBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIC0gY29udGVudCB3aWR0aCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gLSBjb250ZW50IGhlaWdodCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIGFzcGVjdCByYXRpbyB0byBtYWludGFpblxuXHQgKi9cbiAgZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIGlzIGF0dGFjaGVkIHRvIHRoZSBwbGF0Zm9ybSwgZmFsc2UgaWYgbm90LlxuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY29uZmlnIHdpdGggcGxhdGZvcm0gc3BlY2lmaWMgcmVxdWlyZW1lbnRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb3JlL2NvcmUuY29uZmlnLmpzJykuZGVmYXVsdH0gY29uZmlnXG4gICAqL1xuICB1cGRhdGVDb25maWcoY29uZmlnKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyBuby1vcFxuICB9XG59XG4iLCIvKipcbiAqIFBsYXRmb3JtIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIChtaW5pbWFsKS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTkxI2lzc3VlY29tbWVudC0zMTk1NzU5MzlcbiAqL1xuXG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5cbi8qKlxuICogUGxhdGZvcm0gY2xhc3MgZm9yIGNoYXJ0cyB3aXRob3V0IGFjY2VzcyB0byB0aGUgRE9NIG9yIHRvIG1hbnkgZWxlbWVudCBwcm9wZXJ0aWVzXG4gKiBUaGlzIHBsYXRmb3JtIGlzIHVzZWQgYnkgZGVmYXVsdCBmb3IgYW55IGNoYXJ0IHBhc3NlZCBhbiBPZmZzY3JlZW5DYW52YXMuXG4gKiBAZXh0ZW5kcyBCYXNlUGxhdGZvcm1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGl0ZW0pIHtcbiAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG4gICAgLy8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgIHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnLm9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG4gIH1cbn1cbiIsIi8qKlxuICogQ2hhcnQuUGxhdGZvcm0gaW1wbGVtZW50YXRpb24gZm9yIHRhcmdldGluZyBhIHdlYiBicm93c2VyXG4gKi9cblxuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuaW1wb3J0IHtfZ2V0UGFyZW50Tm9kZSwgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgcmVhZFVzZWRTaXplLCBnZXRNYXhpbXVtU2l6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge3Rocm90dGxlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5cbi8qKlxuICogRE9NIGV2ZW50IHR5cGVzIC0+IENoYXJ0LmpzIGV2ZW50IHR5cGVzLlxuICogTm90ZTogb25seSBldmVudHMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgYXJlIG1hcHBlZC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXG4gKi9cbmNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG4gIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb11cbiAqL1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG4gIC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcbiAgLy8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cbiAgY29uc3QgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcblxuICAvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBGb3JjZSBjYW52YXMgdG8gZGlzcGxheSBhcyBibG9jayB0byBhdm9pZCBleHRyYSBzcGFjZSBjYXVzZWQgYnkgaW5saW5lXG4gIC8vIGVsZW1lbnRzLCB3aGljaCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgcmVzcG9uc2l2ZSByZXNpemUgcHJvY2Vzcy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1MzhcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgLy8gSW5jbHVkZSBwb3NzaWJsZSBib3JkZXJzIGluIHRoZSBzaXplXG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgLy8gSWYgbm8gZXhwbGljaXQgcmVuZGVyIGhlaWdodCBhbmQgc3R5bGUgaGVpZ2h0LCBsZXQncyBhcHBseSB0aGUgYXNwZWN0IHJhdGlvLFxuICAgICAgLy8gd2hpY2ggb25lIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgYnV0IGFsc28gYnkgY2hhcnRzIGFzIGRlZmF1bHQgb3B0aW9uXG4gICAgICAvLyAoaS5lLiBvcHRpb25zLmFzcGVjdFJhdGlvKS4gSWYgbm90IHNwZWNpZmllZCwgdXNlIGNhbnZhcyBhc3BlY3QgcmF0aW8gb2YgMi5cbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYW52YXM7XG59XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKGNoYXJ0ICYmIGNoYXJ0LmNhbnZhcykge1xuICAgIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgY2hhcnQsXG4gICAgbmF0aXZlOiBldmVudCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuXG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuXG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzaXplIHNocmFuayBkdXJpbmcgY2hhcnQgcmVzaXplLCBsZXQncyBhc3N1bWVcbiAgICAgIC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cbiAgICAgIC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cbiAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIGluc2lkZSBgdGhyb3R0bGVkYCwgYW5kIGN1cnJlbnRseSBgdGlja2luZ2AsIHNjcm9sbFxuICAgICAgLy8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXG4gICAgICAvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG4gICAgICAvLyB0d2ljZSBpbiBhIGZyYW1lIChwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaXNzdWUpXG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcblxuICAvLyBAdHMtaWdub3JlIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzc4NjEgaW1wbGVtZW50ZWRcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIC8vIFdoZW4gaXRzIGNvbnRhaW5lcidzIGRpc3BsYXkgaXMgc2V0IHRvICdub25lJyB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gICAgLy8gc2l6ZSBvZiAoMCwgMCksIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGNoYXJ0IHRvIGxvc2UgaXRzIG9yaWdpbmFsIGhlaWdodCwgc28gc2tpcFxuICAgIC8vIHJlc2l6aW5nIGluIHN1Y2ggY2FzZS5cbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG5cbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGNhc2UgY2FuIG9jY3VyIGlmIHRoZSBjaGFydCBpcyBkZXN0cm95ZWQgd2hpbGUgd2FpdGluZ1xuICAgIC8vIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHRvIG9jY3VyLiBXZSBwcmV2ZW50IGNyYXNoZXMgYnkgY2hlY2tpbmdcbiAgICAvLyBmb3IgYSBkZXN0cm95ZWQgY2hhcnRcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCk7XG5cbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vKipcbiAqIFBsYXRmb3JtIGNsYXNzIGZvciBjaGFydHMgdGhhdCBjYW4gYWNjZXNzIHRoZSBET00gYW5kIGdsb2JhbCB3aW5kb3cvZG9jdW1lbnQgcHJvcGVydGllc1xuICogQGV4dGVuZHMgQmFzZVBsYXRmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG5cdCAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfVxuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIGBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50L0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgZmFpbHMgd2hlbiB0aGUgY2FudmFzIGlzXG4gICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciB3aGVuIHJ1bm5pbmcgaW4gYSBwcm90ZWN0ZWQgZW52aXJvbm1lbnQuIFdlIGNvdWxkIGd1ZXNzIHRoZVxuICAgIC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXG4gICAgLy8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgY2FudmFzIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgY2FudmFzIGFzIGBjYW52YXNgLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE1MlxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvXG4gICAgICAvLyBpbXBvcnQgdGhlIGxpYnJhcnkgYmVmb3JlIHNldHRpbmcgcGxhdGZvcm0gb3B0aW9ucy5cbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxuICAgIC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuICAgIC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxuXHQgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBDYW4gaGF2ZSBvbmx5IG9uZSBsaXN0ZW5lciBwZXIgdHlwZSwgc28gbWFrZSBzdXJlIHByZXZpb3VzIGlzIHJlbW92ZWRcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuXG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuXG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gLSBjb250ZW50IHdpZHRoIG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSAtIGNvbnRlbnQgaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gYXNwZWN0IHJhdGlvIHRvIG1haW50YWluXG5cdCAqL1xuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICByZXR1cm4gISEoY29udGFpbmVyICYmIGNvbnRhaW5lci5pc0Nvbm5lY3RlZCk7XG4gIH1cbn1cbiIsImltcG9ydCB7X2lzRG9tU3VwcG9ydGVkfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCBCYXNpY1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzaWMuanMnO1xuaW1wb3J0IERvbVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uZG9tLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuZXhwb3J0IHtCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIERvbVBsYXRmb3JtfTtcbiIsImltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcbmltcG9ydCB0eXBlIHtBbmltYXRpb259IGZyb20gJy4uL3R5cGVzL2FuaW1hdGlvbi5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnQ8VCA9IEFueU9iamVjdCwgTyA9IEFueU9iamVjdD4ge1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHt9O1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHVuZGVmaW5lZDtcblxuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgYWN0aXZlID0gZmFsc2U7XG4gIG9wdGlvbnM6IE87XG4gICRhbmltYXRpb25zOiBSZWNvcmQ8a2V5b2YgVCwgQW5pbWF0aW9uPjtcblxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbik6IFBvaW50IHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX0gYXMgUG9pbnQ7XG4gIH1cblxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGhpcy54KSAmJiBpc051bWJlcih0aGlzLnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgb3IgZmluYWwgdmFsdWUgb2YgZWFjaCBwcm9wLiBDYW4gcmV0dXJuIGV4dHJhIHByb3BlcnRpZXMgKHdob2xlIG9iamVjdCkuXG4gICAqIEBwYXJhbSBwcm9wcyAtIHByb3BlcnRpZXMgdG8gZ2V0XG4gICAqIEBwYXJhbSBbZmluYWxdIC0gZ2V0IHRoZSBmaW5hbCB2YWx1ZSAoYW5pbWF0aW9uIHRhcmdldClcbiAgICovXG4gIGdldFByb3BzPFAgZXh0ZW5kcyAoa2V5b2YgVClbXT4ocHJvcHM6IFAsIGZpbmFsPzogYm9vbGVhbik6IFBpY2s8VCwgUFtudW1iZXJdPjtcbiAgZ2V0UHJvcHM8UCBleHRlbmRzIHN0cmluZz4ocHJvcHM6IFBbXSwgZmluYWw/OiBib29sZWFuKTogUGFydGlhbDxSZWNvcmQ8UCwgdW5rbm93bj4+O1xuICBnZXRQcm9wcyhwcm9wczogc3RyaW5nW10sIGZpbmFsPzogYm9vbGVhbik6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+IHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgaWYgKCFmaW5hbCB8fCAhYW5pbXMpIHtcbiAgICAgIC8vIGxldCdzIG5vdCBjcmVhdGUgYW4gb2JqZWN0LCBpZiBub3QgbmVlZGVkXG4gICAgICByZXR1cm4gdGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICB9XG4gICAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIHJldFtwcm9wXSA9IGFuaW1zW3Byb3BdICYmIGFuaW1zW3Byb3BdLmFjdGl2ZSgpID8gYW5pbXNbcHJvcF0uX3RvIDogdGhpc1twcm9wIGFzIHN0cmluZ107XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuIiwiaW1wb3J0IHtpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtfZmFjdG9yaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHt7dmFsdWU6bnVtYmVyIHwgc3RyaW5nLCBsYWJlbD86c3RyaW5nLCBtYWpvcj86Ym9vbGVhbiwgJGNvbnRleHQ/OmFueX19IFRpY2tcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGlja3MgdG8gYmUgcGxvdHRlZCB0byBhdm9pZCBvdmVybGFwcGluZyBsYWJlbHMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdH0gc2NhbGVcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHJldHVybiB7VGlja1tdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9Ta2lwKHNjYWxlLCB0aWNrcykge1xuICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XG4gIGNvbnN0IGRldGVybWluZWRNYXhUaWNrcyA9IGRldGVybWluZU1heFRpY2tzKHNjYWxlKTtcbiAgY29uc3QgdGlja3NMaW1pdCA9IE1hdGgubWluKHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lZE1heFRpY2tzLCBkZXRlcm1pbmVkTWF4VGlja3MpO1xuICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcbiAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgY29uc3QgbmV3VGlja3MgPSBbXTtcblxuICAvLyBJZiB0aGVyZSBhcmUgdG9vIG1hbnkgbWFqb3IgdGlja3MgdG8gZGlzcGxheSB0aGVtIGFsbFxuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuXG4gIGNvbnN0IHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpO1xuXG4gIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgcmV0dXJuIG5ld1RpY2tzO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgY29uc3QgdGlja0xlbmd0aCA9IHNjYWxlLl90aWNrU2l6ZSgpO1xuICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4obWF4U2NhbGUsIG1heENoYXJ0KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gbWFqb3JJbmRpY2VzXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrc0xpbWl0XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCkge1xuICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcbiAgY29uc3Qgc3BhY2luZyA9IHRpY2tzLmxlbmd0aCAvIHRpY2tzTGltaXQ7XG5cbiAgLy8gSWYgdGhlIG1ham9yIHRpY2tzIGFyZSBldmVubHkgc3BhY2VkIGFwYXJ0LCBwbGFjZSB0aGUgbWlub3IgdGlja3NcbiAgLy8gc28gdGhhdCB0aGV5IGRpdmlkZSB0aGUgbWFqb3IgdGlja3MgaW50byBldmVuIGNodW5rc1xuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gIH1cblxuICBjb25zdCBmYWN0b3JzID0gX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSBmYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XG4gICAgICByZXR1cm4gZmFjdG9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKi9cbmZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubWFqb3IpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtUaWNrW119IG5ld1RpY2tzXG4gKiBAcGFyYW0ge251bWJlcltdfSBtYWpvckluZGljZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGFjaW5nXG4gKi9cbmZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IG5leHQgPSBtYWpvckluZGljZXNbMF07XG4gIGxldCBpO1xuXG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge1RpY2tbXX0gbmV3VGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGFjaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gW21ham9yU3RhcnRdXG4gKiBAcGFyYW0ge251bWJlcn0gW21ham9yRW5kXVxuICovXG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZU9yRGVmYXVsdChtYWpvclN0YXJ0LCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBsZW5ndGgsIGksIG5leHQ7XG5cbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgaWYgKG1ham9yRW5kKSB7XG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xuICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICB9XG5cbiAgbmV4dCA9IHN0YXJ0O1xuXG4gIHdoaWxlIChuZXh0IDwgMCkge1xuICAgIGNvdW50Kys7XG4gICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICB9XG5cbiAgZm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSwgZGlmZjtcblxuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuIiwiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYWxpZ25QaXhlbCwgX21lYXN1cmVUZXh0LCByZW5kZXJUZXh0LCBjbGlwQXJlYSwgdW5jbGlwQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGVhY2gsIGZpbml0ZU9yRGVmYXVsdCwgaXNBcnJheSwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0RlZ3JlZXMsIHRvUmFkaWFucywgX2ludDE2UmFuZ2UsIF9saW1pdFZhbHVlLCBIQUxGX1BJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCB0b0ZvbnQsIHRvUGFkZGluZywgX2FkZEdyYWNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2F1dG9Ta2lwfSBmcm9tICcuL2NvcmUuc2NhbGUuYXV0b3NraXAuanMnO1xuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5jb25zdCBnZXRUaWNrc0xpbWl0ID0gKHRpY2tzTGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSA9PiBNYXRoLm1pbihtYXhUaWNrc0xpbWl0IHx8IHRpY2tzTGVuZ3RoLCB0aWNrc0xlbmd0aCk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIG51bUl0ZW1zIGZyb20gYXJyXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1JdGVtc1xuICovXG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb2Zmc2V0R3JpZExpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuXG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuXG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjYWNoZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuXG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIC8qKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqL1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG5cbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovXG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIC8qKiBAdHlwZSB7Q2hhcnR9ICovXG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcblxuICAgIC8vIGltcGxlbWVudHMgYm94XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHNjYWxlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyPX0gKi9cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtUaWNrW119ICovXG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0W118bnVsbH0gKi9cbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3R8bnVsbH0gKi9cbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gb3B0aW9uc1xuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzO1xuXG4gICAgLy8gcGFyc2UgbWluL21heCB2YWx1ZSwgc28gd2UgY2FuIHByb3Blcmx5IGRldGVybWluZSBtaW4vbWF4IGZvciBvdGhlciBzY2FsZXNcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGEgc3VwcG9ydGVkIGlucHV0IHZhbHVlIHRvIGludGVybmFsIHJlcHJlc2VudGF0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhd1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gcmF3O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXIsIG1pbkRlZmluZWQ6IGJvb2xlYW4sIG1heERlZmluZWQ6IGJvb2xlYW59fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuU3RhY2tcblx0ICogQHJldHVybiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgcmFuZ2U7XG5cbiAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcmFuZ2UgPSBtZXRhc1tpXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCBjYW5TdGFjayk7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByYW5nZS5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgbWluIDw9IG1heCB3aGVuIG9ubHkgbWluIG9yIG1heCBpcyBkZWZpbmVkIGJ5IHVzZXIgYW5kIHRoZSBkYXRhIGlzIG91dHNpZGUgdGhhdCByYW5nZVxuICAgIG1pbiA9IG1heERlZmluZWQgJiYgbWluID4gbWF4ID8gbWF4IDogbWluO1xuICAgIG1heCA9IG1pbkRlZmluZWQgJiYgbWluID4gbWF4ID8gbWluIDogbWF4O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KG1pbiwgZmluaXRlT3JEZWZhdWx0KG1heCwgbWluKSksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChtYXgsIGZpbml0ZU9yRGVmYXVsdChtaW4sIG1heCkpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgdGhlIHBhZGRpbmcgbmVlZGVkIGZvciB0aGUgc2NhbGVcblx0ICogQHJldHVybiB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCByaWdodDogbnVtYmVyfX0gdGhlIG5lY2Vzc2FyeSBwYWRkaW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnBhZGRpbmdMZWZ0IHx8IDAsXG4gICAgICB0b3A6IHRoaXMucGFkZGluZ1RvcCB8fCAwLFxuICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICBib3R0b206IHRoaXMucGFkZGluZ0JvdHRvbSB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzY2FsZSB0aWNrIG9iamVjdHNcblx0ICogQHJldHVybiB7VGlja1tdfVxuXHQgKiBAc2luY2UgMi43XG5cdCAqL1xuICBnZXRUaWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtzdHJpbmdbXX1cblx0ICovXG4gIGdldExhYmVscygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuTGFiZWxJdGVtW119XG4gICAqL1xuICBnZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSA9IHRoaXMuY2hhcnQuY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgLy8gV2hlbiBhIG5ldyBsYXlvdXQgaXMgY3JlYXRlZCwgcmVzZXQgdGhlIGRhdGEgbGltaXRzIGNhY2hlXG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5Y2xlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG4gIC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBzY2FsZSB0eXBlcy5cbiAgLy8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxuXG4gIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFdpZHRoIC0gdGhlIG1heCB3aWR0aCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIHRoZSBtYXggaGVpZ2h0IGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IG1hcmdpbnMgLSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgZWRnZSBvZiB0aGUgb3RoZXIgc2NhbGVzIGFuZCBlZGdlIG9mIHRoZSBjaGFydFxuXHQgKiAgIFRoaXMgc3BhY2UgY29tZXMgZnJvbSB0d28gc291cmNlczpcblx0ICogICAgIC0gcGFkZGluZyAtIHNwYWNlIHRoYXQncyByZXF1aXJlZCB0byBzaG93IHRoZSBsYWJlbHMgYXQgdGhlIGVkZ2VzIG9mIHRoZSBzY2FsZVxuXHQgKiAgICAgLSB0aGlja25lc3Mgb2Ygc2NhbGVzIG9yIGxlZ2VuZHMgaW4gYW5vdGhlciBvcmllbnRhdGlvblxuXHQgKi9cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm8sIGdyYWNlLCB0aWNrczogdGlja09wdHN9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xuXG4gICAgLy8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgLy8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCBtYXJnaW5zKTtcblxuICAgIHRoaXMudGlja3MgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuXG4gICAgLy8gRGltZW5zaW9uc1xuICAgIHRoaXMuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cbiAgICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IHRoaXMud2lkdGggKyBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0XG4gICAgICA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcblxuICAgIC8vIERhdGEgbWluL21heFxuICAgIGlmICghdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCkge1xuICAgICAgdGhpcy5iZWZvcmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmRldGVybWluZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLl9yYW5nZSA9IF9hZGRHcmFjZSh0aGlzLCBncmFjZSwgYmVnaW5BdFplcm8pO1xuICAgICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5iZWZvcmVCdWlsZFRpY2tzKCk7XG5cbiAgICB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW107XG5cbiAgICAvLyBBbGxvdyBtb2RpZmljYXRpb24gb2YgdGlja3MgaW4gY2FsbGJhY2suXG4gICAgdGhpcy5hZnRlckJ1aWxkVGlja3MoKTtcblxuICAgIC8vIENvbXB1dGUgdGljayByb3RhdGlvbiBhbmQgZml0IHVzaW5nIGEgc2FtcGxlZCBzdWJzZXQgb2YgbGFiZWxzXG4gICAgLy8gV2UgZ2VuZXJhbGx5IGRvbid0IG5lZWQgdG8gY29tcHV0ZSB0aGUgc2l6ZSBvZiBldmVyeSBzaW5nbGUgbGFiZWwgZm9yIGRldGVybWluaW5nIHNjYWxlIHNpemVcbiAgICBjb25zdCBzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKHRoaXMudGlja3MsIHNhbXBsZVNpemUpIDogdGhpcy50aWNrcyk7XG5cbiAgICAvLyBjb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGhlcmUsIG9uY2UgZnJvbSBjb3JlLmNvbnRyb2xsZXIudXBkYXRlTGF5b3V0LlxuICAgIC8vIEhlcmUgd2UgaGF2ZW4ndCBiZWVuIHBvc2l0aW9uZWQgeWV0LCBidXQgZGltZW5zaW9ucyBhcmUgY29ycmVjdC5cbiAgICAvLyBWYXJpYWJsZXMgc2V0IGluIGNvbmZpZ3VyZSBhcmUgbmVlZGVkIGZvciBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBhbmRcbiAgICAvLyBpdCdzIG9rIHRoYXQgY29vcmRpbmF0ZXMgYXJlIG5vdCBjb3JyZWN0IHRoZXJlLCBvbmx5IGRpbWVuc2lvbnMgbWF0dGVyLlxuICAgIHRoaXMuY29uZmlndXJlKCk7XG5cbiAgICAvLyBUaWNrIFJvdGF0aW9uXG4gICAgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7IC8vIFByZWNvbmRpdGlvbnM6IG51bWJlciBvZiB0aWNrcyBhbmQgc2l6ZXMgb2YgbGFyZ2VzdCBsYWJlbHMgbXVzdCBiZSBjYWxjdWxhdGVkIGJlZm9yZWhhbmRcbiAgICB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuXG4gICAgLy8gQXV0by1za2lwXG4gICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgKHRpY2tPcHRzLmF1dG9Ta2lwIHx8IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2F1dG8nKSkge1xuICAgICAgdGhpcy50aWNrcyA9IGF1dG9Ta2lwKHRoaXMsIHRoaXMudGlja3MpO1xuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgICB0aGlzLmFmdGVyQXV0b1NraXAoKTtcbiAgICB9XG5cbiAgICBpZiAoc2FtcGxpbmdFbmFibGVkKSB7XG4gICAgICAvLyBHZW5lcmF0ZSBsYWJlbHMgdXNpbmcgYWxsIG5vbi1za2lwcGVkIHRpY2tzXG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKTtcbiAgICB9XG5cbiAgICB0aGlzLmJlZm9yZUZpdCgpO1xuICAgIHRoaXMuZml0KCk7IC8vIFByZWNvbmRpdGlvbnM6IGxhYmVsIHJvdGF0aW9uIGFuZCBsYWJlbCBzaXplcyBtdXN0IGJlIGNhbGN1bGF0ZWQgYmVmb3JlaGFuZFxuICAgIHRoaXMuYWZ0ZXJGaXQoKTtcblxuICAgIC8vIElNUE9SVEFOVDogYWZ0ZXIgdGhpcyBwb2ludCwgd2UgY29uc2lkZXIgdGhhdCBgdGhpcy50aWNrc2Agd2lsbCBORVZFUiBjaGFuZ2UhXG5cbiAgICB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGxldCByZXZlcnNlUGl4ZWxzID0gdGhpcy5vcHRpb25zLnJldmVyc2U7XG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLmxlZnQ7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLnRvcDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5ib3R0b207XG4gICAgICAvLyBieSBkZWZhdWx0IHZlcnRpY2FsIHNjYWxlcyBhcmUgZnJvbSBib3R0b20gdG8gdG9wLCBzbyBwaXhlbHMgYXJlIHJldmVyc2VkXG4gICAgICByZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gZW5kUGl4ZWw7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IHJldmVyc2VQaXhlbHM7XG4gICAgdGhpcy5fbGVuZ3RoID0gZW5kUGl4ZWwgLSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2FsaWduVG9QaXhlbHMgPSB0aGlzLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcbiAgfVxuXG4gIGFmdGVyVXBkYXRlKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG5cbiAgLy9cblxuICBiZWZvcmVTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICAvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuXG4gICAgICAvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cbiAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgcGFkZGluZ1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSAwO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSAwO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gIH1cbiAgYWZ0ZXJTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuXG4gIF9jYWxsSG9va3MobmFtZSkge1xuICAgIHRoaXMuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnNbbmFtZV0sIFt0aGlzXSk7XG4gIH1cblxuICAvLyBEYXRhIGxpbWl0c1xuICBiZWZvcmVEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlRGF0YUxpbWl0cycpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7fVxuICBhZnRlckRhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckRhdGFMaW1pdHMnKTtcbiAgfVxuXG4gIC8vXG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gIH1cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfSB0aGUgdGlja3Ncblx0ICovXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGFmdGVyQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyQnVpbGRUaWNrcycpO1xuICB9XG5cbiAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICAvKipcblx0ICogQ29udmVydCB0aWNrcyB0byBsYWJlbCBzdHJpbmdzXG5cdCAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuXHQgKi9cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IGNhbGwodGlja09wdHMuY2FsbGJhY2ssIFt0aWNrLnZhbHVlLCBpLCB0aWNrc10sIHRoaXMpO1xuICAgIH1cbiAgfVxuICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vXG5cbiAgYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgbnVtVGlja3MgPSBnZXRUaWNrc0xpbWl0KHRoaXMudGlja3MubGVuZ3RoLCBvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgIGxldCBsYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhdGlja09wdHMuZGlzcGxheSB8fCBtaW5Sb3RhdGlvbiA+PSBtYXhSb3RhdGlvbiB8fCBudW1UaWNrcyA8PSAxIHx8ICF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQ7XG5cbiAgICAvLyBFc3RpbWF0ZSB0aGUgd2lkdGggb2YgZWFjaCBncmlkIGJhc2VkIG9uIHRoZSBjYW52YXMgd2lkdGgsIHRoZSBtYXhpbXVtXG4gICAgLy8gbGFiZWwgd2lkdGggYW5kIHRoZSBudW1iZXIgb2YgdGljayBpbnRlcnZhbHNcbiAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKHRoaXMuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG5cbiAgICAvLyBBbGxvdyAzIHBpeGVscyB4MiBwYWRkaW5nIGVpdGhlciBzaWRlIGZvciBsYWJlbCByZWFkYWJpbGl0eVxuICAgIGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuICAgICAgdGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG4gICAgICBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZClcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucy50aXRsZSwgdGhpcy5jaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgbWF4TGFiZWxEaWFnb25hbCA9IE1hdGguc3FydChtYXhMYWJlbFdpZHRoICogbWF4TGFiZWxXaWR0aCArIG1heExhYmVsSGVpZ2h0ICogbWF4TGFiZWxIZWlnaHQpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IHRvRGVncmVlcyhNYXRoLm1pbihcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKChsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyB0aWNrV2lkdGgsIC0xLCAxKSksXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpIC0gTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heExhYmVsSGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKVxuICAgICAgKSk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7fVxuXG4gIC8vXG5cbiAgYmVmb3JlRml0KCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgLy8gUmVzZXRcbiAgICBjb25zdCBtaW5TaXplID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuXG4gICAgY29uc3Qge2NoYXJ0LCBvcHRpb25zOiB7dGlja3M6IHRpY2tPcHRzLCB0aXRsZTogdGl0bGVPcHRzLCBncmlkOiBncmlkT3B0c319ID0gdGhpcztcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5faXNWaXNpYmxlKCk7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcblxuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICBjb25zdCB0aXRsZUhlaWdodCA9IGdldFRpdGxlSGVpZ2h0KHRpdGxlT3B0cywgY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG4gICAgICAgIG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgYm90aGVyIGZpdHRpbmcgdGhlIHRpY2tzIGlmIHdlIGFyZSBub3Qgc2hvd2luZyB0aGUgbGFiZWxzXG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdH0gPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgLy8gQSBob3Jpem9udGFsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgaGVpZ2h0LlxuICAgICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja09wdHMubWlycm9yID8gMCA6IHNpbiAqIHdpZGVzdC53aWR0aCArIGNvcyAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgdmVydGljYWwgYXhpcyBpcyBtb3JlIGNvbnN0cmFpbmVkIGJ5IHRoZSB3aWR0aC4gTGFiZWxzIGFyZSB0aGVcbiAgICAgICAgLy8gZG9taW5hbnQgZmFjdG9yIGhlcmUsIHNvIGdldCB0aGF0IGxlbmd0aCBmaXJzdCBhbmQgYWNjb3VudCBmb3IgcGFkZGluZ1xuICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogY29zICogd2lkZXN0LndpZHRoICsgc2luICogaGlnaGVzdC5oZWlnaHQ7XG5cbiAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGggKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2hhbmRsZU1hcmdpbnMoKTtcblxuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9sZW5ndGggPSBjaGFydC53aWR0aCAtIHRoaXMuX21hcmdpbnMubGVmdCAtIHRoaXMuX21hcmdpbnMucmlnaHQ7XG4gICAgICB0aGlzLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gbWluU2l6ZS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQuaGVpZ2h0IC0gdGhpcy5fbWFyZ2lucy50b3AgLSB0aGlzLl9tYXJnaW5zLmJvdHRvbTtcbiAgICB9XG4gIH1cblxuICBfY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpIHtcbiAgICBjb25zdCB7dGlja3M6IHthbGlnbiwgcGFkZGluZ30sIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLmxhYmVsUm90YXRpb24gIT09IDA7XG4gICAgY29uc3QgbGFiZWxzQmVsb3dUaWNrcyA9IHBvc2l0aW9uICE9PSAndG9wJyAmJiB0aGlzLmF4aXMgPT09ICd4JztcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuXG4gICAgICAvLyBFbnN1cmUgdGhhdCBvdXIgdGlja3MgYXJlIGFsd2F5cyBpbnNpZGUgdGhlIGNhbnZhcy4gV2hlbiByb3RhdGVkLCB0aWNrcyBhcmUgcmlnaHQgYWxpZ25lZFxuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XG4gICAgICBpZiAoaXNSb3RhdGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNCZWxvd1RpY2tzKSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBjb3MgKiBmaXJzdC53aWR0aDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBzaW4gKiBsYXN0LmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IHNpbiAqIGZpcnN0LmhlaWdodDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBjb3MgKiBsYXN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoIC8gMjtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aCAvIDI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkanVzdCBwYWRkaW5nIHRha2luZyBpbnRvIGFjY291bnQgY2hhbmdlcyBpbiBvZmZzZXRzXG4gICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApO1xuICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldFJpZ2h0KSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQgLyAyO1xuICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQgLyAyO1xuXG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wICsgcGFkZGluZztcbiAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgbWFyZ2lucyBhbmQgcGFkZGluZyBpbnRlcmFjdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9oYW5kbGVNYXJnaW5zKCkge1xuICAgIGlmICh0aGlzLl9tYXJnaW5zKSB7XG4gICAgICB0aGlzLl9tYXJnaW5zLmxlZnQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdMZWZ0LCB0aGlzLl9tYXJnaW5zLmxlZnQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy50b3AgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdUb3AsIHRoaXMuX21hcmdpbnMudG9wKTtcbiAgICAgIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0JvdHRvbSwgdGhpcy5fbWFyZ2lucy5ib3R0b20pO1xuICAgIH1cbiAgfVxuXG4gIGFmdGVyRml0KCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuICB9XG5cbiAgLy8gU2hhcmVkIE1ldGhvZHNcbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3Qge2F4aXMsIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBheGlzID09PSAneCc7XG4gIH1cbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBpc0Z1bGxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHtcbiAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG4gICAgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpO1xuXG4gICAgLy8gVGlja3Mgc2hvdWxkIGJlIHNraXBwZWQgd2hlbiBjYWxsYmFjayByZXR1cm5zIG51bGwgb3IgdW5kZWYsIHNvIGxldHMgcmVtb3ZlIHRob3NlLlxuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHRpY2tzW2ldLmxhYmVsKSkge1xuICAgICAgICB0aWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlsZW4tLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHt7IGZpcnN0OiBvYmplY3QsIGxhc3Q6IG9iamVjdCwgd2lkZXN0OiBvYmplY3QsIGhpZ2hlc3Q6IG9iamVjdCwgd2lkdGhzOiBBcnJheSwgaGVpZ2h0czogYXJyYXkgfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbFNpemVzKCkge1xuICAgIGxldCBsYWJlbFNpemVzID0gdGhpcy5fbGFiZWxTaXplcztcblxuICAgIGlmICghbGFiZWxTaXplcykge1xuICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IGxhYmVsU2l6ZXMgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgdGlja3MubGVuZ3RoLCB0aGlzLm9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsU2l6ZXM7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB7d2lkdGgsIGhlaWdodCwgb2Zmc2V0fSBvYmplY3RzIGZvciB0aGUgZmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdCB0aWNrXG5cdCAqIGxhYmVscyB3aGVyZSBvZmZzZXQgaW5kaWNhdGVzIHRoZSBhbmNob3IgcG9pbnQgb2Zmc2V0IGZyb20gdGhlIHRvcCBpbiBwaXhlbHMuXG5cdCAqIEByZXR1cm4ge3sgZmlyc3Q6IG9iamVjdCwgbGFzdDogb2JqZWN0LCB3aWRlc3Q6IG9iamVjdCwgaGlnaGVzdDogb2JqZWN0LCB3aWR0aHM6IEFycmF5LCBoZWlnaHRzOiBhcnJheSB9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCBsZW5ndGgsIG1heFRpY2tzTGltaXQpIHtcbiAgICBjb25zdCB7Y3R4LCBfbG9uZ2VzdFRleHRDYWNoZTogY2FjaGVzfSA9IHRoaXM7XG4gICAgY29uc3Qgd2lkdGhzID0gW107XG4gICAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICAgIGNvbnN0IGluY3JlbWVudCA9IE1hdGguZmxvb3IobGVuZ3RoIC8gZ2V0VGlja3NMaW1pdChsZW5ndGgsIG1heFRpY2tzTGltaXQpKTtcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICAgIGxhYmVsID0gdGlja3NbaV0ubGFiZWw7XG4gICAgICB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICBjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7ZGF0YToge30sIGdjOiBbXX07XG4gICAgICBsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ID0gMDtcbiAgICAgIC8vIFVuZGVmaW5lZCBsYWJlbHMgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xuICAgICAgICBoZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICAvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXQncyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbmVzdGVkTGFiZWwgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGxhYmVsW2pdKTtcbiAgICAgICAgICAvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aWR0aHMucHVzaCh3aWR0aCk7XG4gICAgICBoZWlnaHRzLnB1c2goaGVpZ2h0KTtcbiAgICAgIHdpZGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCB3aWRlc3RMYWJlbFNpemUpO1xuICAgICAgaGlnaGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KGhlaWdodCwgaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgfVxuICAgIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKTtcblxuICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgaGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcblxuICAgIGNvbnN0IHZhbHVlQXQgPSAoaWR4KSA9PiAoe3dpZHRoOiB3aWR0aHNbaWR4XSB8fCAwLCBoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3Q6IHZhbHVlQXQoMCksXG4gICAgICBsYXN0OiB2YWx1ZUF0KGxlbmd0aCAtIDEpLFxuICAgICAgd2lkZXN0OiB2YWx1ZUF0KHdpZGVzdCksXG4gICAgICBoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpLFxuICAgICAgd2lkdGhzLFxuICAgICAgaGVpZ2h0cyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBsYWJlbCB0byBkaXNwbGF5IGluIHRoZSB0b29sdGlwIGZvciB0aGUgZ2l2ZW4gdmFsdWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHBvaW50LiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBkYXRhIHZhbHVlIGZyb20gYSBnaXZlbiBwaXhlbC4gVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBnZXRQaXhlbEZvclZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIHRpY2sgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIGEgcGVyY2VudGFnZSBvZiBzY2FsZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpIHtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZVBpeGVscykge1xuICAgICAgZGVjaW1hbCA9IDEgLSBkZWNpbWFsO1xuICAgIH1cblxuICAgIGNvbnN0IHBpeGVsID0gdGhpcy5fc3RhcnRQaXhlbCArIGRlY2ltYWwgKiB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIF9pbnQxNlJhbmdlKHRoaXMuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbCh0aGlzLmNoYXJ0LCBwaXhlbCwgMCkgOiBwaXhlbCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZVBpeGVscyA/IDEgLSBkZWNpbWFsIDogZGVjaW1hbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwaXhlbCBmb3IgdGhlIG1pbmltdW0gY2hhcnQgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldEJhc2VWYWx1ZSgpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcblxuICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuICAgICAgbWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcbiAgICAgIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcblxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRpY2suJGNvbnRleHQgfHxcblx0XHRcdFx0KHRpY2suJGNvbnRleHQgPSBjcmVhdGVUaWNrQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHRpY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlU2NhbGVDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3RpY2tTaXplKCkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBieSBsYWJlbCBpbiBheGlzIGRpcmVjdGlvbi5cbiAgICBjb25zdCByb3QgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcblxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuICAgIGNvbnN0IHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcbiAgICBjb25zdCBoID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcblxuICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgZm9yIDEgdGljayBpbiBheGlzIGRpcmVjdGlvbi5cbiAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG4gICAgICA6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuXG4gICAgaWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuICEhZGlzcGxheTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtncmlkLCBwb3NpdGlvbiwgYm9yZGVyfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZ3JpZC5vZmZzZXQ7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgdGlja3NMZW5ndGggPSB0aWNrcy5sZW5ndGggKyAob2Zmc2V0ID8gMSA6IDApO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZCk7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcblxuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyT3B0cy5kaXNwbGF5ID8gYm9yZGVyT3B0cy53aWR0aCA6IDA7XG4gICAgY29uc3QgYXhpc0hhbGZXaWR0aCA9IGF4aXNXaWR0aCAvIDI7XG4gICAgY29uc3QgYWxpZ25Cb3JkZXJWYWx1ZSA9IGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICByZXR1cm4gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCBheGlzV2lkdGgpO1xuICAgIH07XG4gICAgbGV0IGJvcmRlclZhbHVlLCBpLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XG4gICAgbGV0IHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTI7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5ib3R0b20pO1xuICAgICAgdHkxID0gdGhpcy5ib3R0b20gLSB0bDtcbiAgICAgIHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEudG9wKSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnRvcCk7XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmJvdHRvbSkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdGhpcy50b3AgKyB0bDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnJpZ2h0KTtcbiAgICAgIHR4MSA9IHRoaXMucmlnaHQgLSB0bDtcbiAgICAgIHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMubGVmdCk7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdGhpcy5sZWZ0ICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyICsgMC41KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHR5MSArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0eDEgLSB0bDtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9XG5cbiAgICBjb25zdCBsaW1pdCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCwgdGlja3NMZW5ndGgpO1xuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGkpO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleEJvcmRlciA9IGJvcmRlci5zZXRDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoIHx8IFtdO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4Qm9yZGVyLmRhc2hPZmZzZXQ7XG5cbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcbiAgICAgIGNvbnN0IHRpY2tDb2xvciA9IG9wdHNBdEluZGV4LnRpY2tDb2xvcjtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKHRoaXMsIGksIG9mZnNldCk7XG5cbiAgICAgIC8vIFNraXAgaWYgdGhlIHBpeGVsIGlzIG91dCBvZiB0aGUgcmFuZ2VcbiAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgdHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHR4MSxcbiAgICAgICAgdHkxLFxuICAgICAgICB0eDIsXG4gICAgICAgIHR5MixcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTIsXG4gICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgIGJvcmRlckRhc2gsXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgIHRpY2tXaWR0aCxcbiAgICAgICAgdGlja0NvbG9yLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IHRpY2tzTGVuZ3RoO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczogb3B0aW9uVGlja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB7YWxpZ24sIGNyb3NzQWxpZ24sIHBhZGRpbmcsIG1pcnJvcn0gPSBvcHRpb25UaWNrcztcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3QgaFRpY2tBbmRQYWRkaW5nID0gbWlycm9yID8gLXBhZGRpbmcgOiB0aWNrQW5kUGFkZGluZztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHkgPSB0aGlzLmJvdHRvbSAtIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgeSA9IHRoaXMudG9wICsgaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB5ID0gKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB5ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeCA9ICgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMikgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeCA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpLnRleHRBbGlnbjtcbiAgICB9XG5cbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIGxhYmVsID0gdGljay5sYWJlbDtcblxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBvcHRpb25UaWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBwaXhlbCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKGkpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG4gICAgICBmb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XG4gICAgICBsaW5lQ291bnQgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBoYWxmQ291bnQgPSBsaW5lQ291bnQgLyAyO1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICBsZXQgdGlja1RleHRBbGlnbiA9IHRleHRBbGlnbjtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB4ID0gcGl4ZWw7XG5cbiAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZWx5LWlmXG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgIHRleHRPZmZzZXQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdGF0aW9uICE9PSAwICYmICFvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICAgIHggKz0gKGxpbmVIZWlnaHQgLyAyKSAqIE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHBpeGVsO1xuICAgICAgICB0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XG4gICAgICB9XG5cbiAgICAgIGxldCBiYWNrZHJvcDtcblxuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsYWJlbFNpemVzLmhlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XG5cbiAgICAgICAgbGV0IHRvcCA9IHRleHRPZmZzZXQgLSBsYWJlbFBhZGRpbmcudG9wO1xuICAgICAgICBsZXQgbGVmdCA9IDAgLSBsYWJlbFBhZGRpbmcubGVmdDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5uZXInOlxuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBiYWNrZHJvcCA9IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyBsYWJlbFBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuXG4gICAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3IsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgZm9udCxcbiAgICAgICAgdGV4dE9mZnNldCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIHRleHRBbGlnbjogdGlja1RleHRBbGlnbixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgdHJhbnNsYXRpb246IFt4LCB5XSxcbiAgICAgICAgICBiYWNrZHJvcCxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrc30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG5cbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cblxuICAgIGxldCBhbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgaWYgKHRpY2tzLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnZW5kJykge1xuICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgIGFsaWduID0gJ2lubmVyJztcbiAgICB9XG5cbiAgICByZXR1cm4gYWxpZ247XG4gIH1cblxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IHtjcm9zc0FsaWduLCBtaXJyb3IsIHBhZGRpbmd9fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuXG4gICAgbGV0IHRleHRBbGlnbjtcbiAgICBsZXQgeDtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0ICsgcGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ICs9IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4ID0gdGhpcy5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgcGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4IC09IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHRpY2tBbmRQYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9IHdpZGVzdCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ID0gdGhpcy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIH1cblxuICAgIHJldHVybiB7dGV4dEFsaWduLCB4fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IHRoaXMubGVmdCwgYm90dG9tOiBjaGFydC5oZWlnaHQsIHJpZ2h0OiB0aGlzLnJpZ2h0fTtcbiAgICB9IGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4ge3RvcDogdGhpcy50b3AsIGxlZnQ6IDAsIGJvdHRvbTogdGhpcy5ib3R0b20sIHJpZ2h0OiBjaGFydC53aWR0aH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtiYWNrZ3JvdW5kQ29sb3J9LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFncmlkLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgaW5kZXggPSB0aWNrcy5maW5kSW5kZXgodCA9PiB0LnZhbHVlID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGNvbnN0IGRyYXdMaW5lID0gKHAxLCBwMiwgc3R5bGUpID0+IHtcbiAgICAgIGlmICghc3R5bGUud2lkdGggfHwgIXN0eWxlLmNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgaWYgKGdyaWQuZHJhd09uQ2hhcnRBcmVhKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS54MSwgeTogaXRlbS55MX0sXG4gICAgICAgICAgICB7eDogaXRlbS54MiwgeTogaXRlbS55Mn0sXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmlkLmRyYXdUaWNrcykge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0udHgxLCB5OiBpdGVtLnR5MX0sXG4gICAgICAgICAgICB7eDogaXRlbS50eDIsIHk6IGl0ZW0udHkyfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29sb3I6IGl0ZW0udGlja0NvbG9yLFxuICAgICAgICAgICAgICB3aWR0aDogaXRlbS50aWNrV2lkdGgsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2g6IGl0ZW0udGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IGl0ZW0udGlja0JvcmRlckRhc2hPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCb3JkZXIoKSB7XG4gICAgY29uc3Qge2NoYXJ0LCBjdHgsIG9wdGlvbnM6IHtib3JkZXIsIGdyaWR9fSA9IHRoaXM7XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGJvcmRlci5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXIuZGlzcGxheSA/IGJvcmRlck9wdHMud2lkdGggOiAwO1xuICAgIGlmICghYXhpc1dpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMaW5lV2lkdGggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KDApKS5saW5lV2lkdGg7XG4gICAgY29uc3QgYm9yZGVyVmFsdWUgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICBsZXQgeDEsIHgyLCB5MSwgeTI7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMudG9wLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHkyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLndpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlck9wdHMuY29sb3I7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdMYWJlbHMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cbiAgICBpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcblxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmdldExhYmVsSXRlbXMoY2hhcnRBcmVhKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRleHRPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSBpdGVtLmZvbnQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGl0ZW0ubGFiZWw7XG4gICAgICBjb25zdCB5ID0gaXRlbS50ZXh0T2Zmc2V0O1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxhYmVsLCAwLCB5LCB0aWNrRm9udCwgcmVuZGVyVGV4dE9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChhcmVhKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9zaXRpb24sIHRpdGxlLCByZXZlcnNlfX0gPSB0aGlzO1xuXG4gICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlLnBhZGRpbmcpO1xuICAgIGNvbnN0IGFsaWduID0gdGl0bGUuYWxpZ247XG4gICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nIHx8IHBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLmJvdHRvbTtcbiAgICAgIGlmIChpc0FycmF5KHRpdGxlLnRleHQpKSB7XG4gICAgICAgIG9mZnNldCArPSBmb250LmxpbmVIZWlnaHQgKiAodGl0bGUudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcudG9wO1xuICAgIH1cblxuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRpdGxlQXJncyh0aGlzLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbik7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGUudGV4dCwgMCwgMCwgZm9udCwge1xuICAgICAgY29sb3I6IHRpdGxlLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG5cbiAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2xheWVycygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcbiAgICBjb25zdCBneiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZ3JpZCAmJiBvcHRzLmdyaWQueiwgLTEpO1xuICAgIGNvbnN0IGJ6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ib3JkZXIgJiYgb3B0cy5ib3JkZXIueiwgMCk7XG5cbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8IHRoaXMuZHJhdyAhPT0gU2NhbGUucHJvdG90eXBlLmRyYXcpIHtcbiAgICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGRyYXcgaGFzIGJlZW4gb3ZlcnJpZGRlbiBieSBjdXN0b20gc2NhbGVcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiB0eixcbiAgICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICAgIHRoaXMuZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3tcbiAgICAgIHo6IGd6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiBieixcbiAgICAgIGRyYXc6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogdHosXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1dO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdmlzaWJsZSBkYXRhc2V0IG1ldGFzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIHRoaXMgc2NhbGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIGlmIHNwZWNpZmllZCwgYWxzbyBmaWx0ZXIgYnkgZGF0YXNldCB0eXBlXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5jaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXhpc0lEID0gdGhpcy5heGlzICsgJ0F4aXNJRCc7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgICBpZiAobWV0YVtheGlzSURdID09PSB0aGlzLmlkICYmICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuICBfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpbmRleCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICByZXR1cm4gdG9Gb250KG9wdHMuZm9udCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX21heERpZ2l0cygpIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICByZXR1cm4gKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQpIC8gZm9udFNpemU7XG4gIH1cbn1cbiIsImltcG9ydCB7bWVyZ2V9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7aWQ6IHN0cmluZywgZGVmYXVsdHM6IGFueSwgb3ZlcnJpZGVzPzogYW55LCBkZWZhdWx0Um91dGVzOiBhbnl9fSBJQ2hhcnRDb21wb25lbnRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeXBlZFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgaXNGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SUNoYXJ0Q29tcG9uZW50fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzY29wZSB3aGVyZSBpdGVtcyBkZWZhdWx0cyB3ZXJlIHJlZ2lzdGVyZWQgdG8uXG5cdCAqL1xuICByZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaXRlbSk7XG4gICAgbGV0IHBhcmVudFNjb3BlO1xuXG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXJlbnQgaXMgcmVnaXN0ZXJlZCBhbmQgbm90ZSB0aGUgc2NvcGUgd2hlcmUgaXRzIGRlZmF1bHRzIGFyZS5cbiAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcblxuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogJyArIGl0ZW0pO1xuICAgIH1cblxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuXG4gICAgaXRlbXNbaWRdID0gaXRlbTtcbiAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgIGRlZmF1bHRzLm92ZXJyaWRlKGl0ZW0uaWQsIGl0ZW0ub3ZlcnJpZGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHtvYmplY3Q/fVxuXHQgKi9cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SUNoYXJ0Q29tcG9uZW50fSBpdGVtXG5cdCAqL1xuICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgZGVsZXRlIGl0ZW1zW2lkXTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkZWZhdWx0cyBhbmQga2VlcCBleGlzdGluZyBkZWZhdWx0c1xuICBjb25zdCBpdGVtRGVmYXVsdHMgPSBtZXJnZShPYmplY3QuY3JlYXRlKG51bGwpLCBbXG4gICAgcGFyZW50U2NvcGUgPyBkZWZhdWx0cy5nZXQocGFyZW50U2NvcGUpIDoge30sXG4gICAgZGVmYXVsdHMuZ2V0KHNjb3BlKSxcbiAgICBpdGVtLmRlZmF1bHRzXG4gIF0pO1xuXG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcblxuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuXG4gIGlmIChpdGVtLmRlc2NyaXB0b3JzKSB7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoc2NvcGUsIGl0ZW0uZGVzY3JpcHRvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJvdXRlRGVmYXVsdHMoc2NvcGUsIHJvdXRlcykge1xuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5UGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBwcm9wZXJ0eVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgIGNvbnN0IHBhcnRzID0gcm91dGVzW3Byb3BlcnR5XS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICBkZWZhdWx0cy5yb3V0ZShzb3VyY2VTY29wZSwgc291cmNlTmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4vY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgVHlwZWRSZWdpc3RyeSBmcm9tICcuL2NvcmUudHlwZWRSZWdpc3RyeS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGwsIF9jYXBpdGFsaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KE9iamVjdCwgJ3BsdWdpbnMnKTtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBTY2FsZSBoYXMgRWxlbWVudCBpbiBwcm90b3R5cGUgY2hhaW4sXG4gICAgLy8gc28gU2NhbGVzIG11c3QgYmUgYmVmb3JlIEVsZW1lbnRzLiBQbHVnaW5zIGFyZSBhIGZhbGxiYWNrLCBzbyBub3QgbGlzdGVkIGhlcmUuXG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgYWRkQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIEVsZW1lbnR9IGFyZ3Ncblx0ICovXG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn1cblx0ICovXG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIEVsZW1lbnR9XG5cdCAqL1xuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIFNjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIERhdGFzZXRDb250cm9sbGVyfSBhcmdzXG5cdCAqL1xuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICByZW1vdmVFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIFNjYWxlfSBhcmdzXG5cdCAqL1xuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgbG9vcGFibGUgYXJnc1xuICAgICAgICAvLyBVc2UgY2FzZTpcbiAgICAgICAgLy8gIGltcG9ydCAqIGFzIHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zLmpzJztcbiAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHBsdWdpbnMpO1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1peGVkIHR5cGVzIGluIHRoZSBsb29wYWJsZSwgbWFrZSBzdXJlIHRob3NlIGFyZVxuICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgaW4gY29ycmVjdCByZWdpc3RyeVxuICAgICAgICAgIC8vIFVzZSBjYXNlOiAodHJlZW1hcCBleHBvcnRpbmcgY29udHJvbGxlciwgZWxlbWVudHMgZXRjKVxuICAgICAgICAgIC8vICBpbXBvcnQgKiBhcyB0cmVlbWFwIGZyb20gJ2NoYXJ0anMtY2hhcnQtdHJlZW1hcC5qcyc7XG4gICAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHRyZWVtYXApO1xuXG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGJlZm9yZVJlZ2lzdGVyIC8gYmVmb3JlVW5yZWdpc3RlclxuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTsgLy8gYWZ0ZXJSZWdpc3RlciAvIGFmdGVyVW5yZWdpc3RlclxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcGx1Z2lucyBpcyB0aGUgZmFsbGJhY2sgcmVnaXN0cnlcbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBSZWdpc3RyeSgpO1xuIiwiaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgaXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vcGx1Z2lucy9wbHVnaW4udG9vbHRpcC5qcycpLmRlZmF1bHQgfSBUb29sdGlwXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZmlsdGVyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7e3BsdWdpbjogb2JqZWN0LCBvcHRpb25zOiBvYmplY3R9fSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAqIEBwYXJhbSB7YXJyYXl9IFthcnJheV1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ11cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbHVnaW5TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5pdCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgZm9yIGBjaGFydGAgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UgZm9yIHdoaWNoIHBsdWdpbnMgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuICAgKiBAcGFyYW0ge2ZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbml0ID09PSB1bmRlZmluZWQpIHsgLy8gRG8gbm90IHRyaWdnZXIgZXZlbnRzIGJlZm9yZSBpbnN0YWxsXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWx0ZXIgPyB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCkuZmlsdGVyKGZpbHRlcikgOiB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncyk7XG5cbiAgICBpZiAoaG9vayA9PT0gJ2FmdGVyRGVzdHJveScpIHtcbiAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICAgIHRoaXMuX2luaXQgPSB1bmRlZmluZWQ7IC8vIERvIG5vdCB0cmlnZ2VyIGV2ZW50cyBhZnRlciB1bmluc3RhbGxcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpIHtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuICAgICAgY29uc3QgbWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuICAgICAgY29uc3QgcGFyYW1zID0gW2NoYXJ0LCBhcmdzLCBkZXNjcmlwdG9yLm9wdGlvbnNdO1xuICAgICAgaWYgKGNhbGxDYWxsYmFjayhtZXRob2QsIHBhcmFtcywgcGx1Z2luKSA9PT0gZmFsc2UgJiYgYXJncy5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGludmFsaWRhdGUoKSB7XG4gICAgLy8gV2hlbiBwbHVnaW5zIGFyZSByZWdpc3RlcmVkLCB0aGVyZSBpcyB0aGUgcG9zc2liaWxpdHkgb2YgYSBkb3VibGVcbiAgICAvLyBpbnZhbGlkYXRlIHNpdHVhdGlvbi4gSW4gdGhpcyBjYXNlLCB3ZSBvbmx5IHdhbnQgdG8gaW52YWxpZGF0ZSBvbmNlLlxuICAgIC8vIElmIHdlIGludmFsaWRhdGUgbXVsdGlwbGUgdGltZXMsIHRoZSBgX29sZENhY2hlYCBpcyBsb3N0IGFuZCBhbGwgb2YgdGhlXG4gICAgLy8gcGx1Z2lucyBhcmUgcmVzdGFydGVkIHdpdGhvdXQgYmVpbmcgY29ycmVjdGx5IHN0b3BwZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy84MTQ3XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xuICAgICAgdGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc2NyaXB0b3JzKGNoYXJ0KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcblxuICAgIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH1cblxuICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgLy8gb3B0aW9ucyA9PT0gZmFsc2UgPT4gYWxsIHBsdWdpbnMgYXJlIGRpc2FibGVkXG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IGZhbHNlICYmICFhbGwgPyBbXSA6IGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KSB7XG4gICAgY29uc3QgcHJldmlvdXNEZXNjcmlwdG9ycyA9IHRoaXMuX29sZENhY2hlIHx8IFtdO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGU7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LnBsdWdpbi5pZCA9PT0geS5wbHVnaW4uaWQpKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihwcmV2aW91c0Rlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RvcCcpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKGRlc2NyaXB0b3JzLCBwcmV2aW91c0Rlc2NyaXB0b3JzKSwgY2hhcnQsICdzdGFydCcpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5jb25maWcuanMnKS5kZWZhdWx0fSBjb25maWdcbiAqL1xuZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgY29uc3QgbG9jYWxJZHMgPSB7fTtcbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHBsdWdpbnMucHVzaChyZWdpc3RyeS5nZXRQbHVnaW4oa2V5c1tpXSkpO1xuICB9XG5cbiAgY29uc3QgbG9jYWwgPSBjb25maWcucGx1Z2lucyB8fCBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsdWdpbiA9IGxvY2FsW2ldO1xuXG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICBsb2NhbElkc1twbHVnaW4uaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3BsdWdpbnMsIGxvY2FsSWRzfTtcbn1cblxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcbiAgaWYgKCFhbGwgJiYgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHtwbHVnaW5zLCBsb2NhbElkc30sIG9wdGlvbnMsIGFsbCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGNoYXJ0LmdldENvbnRleHQoKTtcblxuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBwbHVnaW4sXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywge3BsdWdpbiwgbG9jYWw6IGxvY2FsSWRzW2lkXX0sIG9wdHMsIGNvbnRleHQpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwbHVnaW5PcHRzKGNvbmZpZywge3BsdWdpbiwgbG9jYWx9LCBvcHRzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XG4gIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXMob3B0cywga2V5cyk7XG4gIGlmIChsb2NhbCAmJiBwbHVnaW4uZGVmYXVsdHMpIHtcbiAgICAvLyBtYWtlIHN1cmUgcGx1Z2luIGRlZmF1bHRzIGFyZSBpbiBzY29wZXMgZm9yIGxvY2FsIChub3QgcmVnaXN0ZXJlZCkgcGx1Z2luc1xuICAgIHNjb3Blcy5wdXNoKHBsdWdpbi5kZWZhdWx0cyk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFsnJ10sIHtcbiAgICAvLyBUaGVzZSBhcmUganVzdCBkZWZhdWx0cyB0aGF0IHBsdWdpbnMgY2FuIG92ZXJyaWRlXG4gICAgc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBhbGxLZXlzOiB0cnVlXG4gIH0pO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzLCBkZXNjcmlwdG9yc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7bWVyZ2VJZiwgcmVzb2x2ZU9iamVjdEtleSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgdmFsdWVPckRlZmF1bHQsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge19hdHRhY2hDb250ZXh0LCBfY3JlYXRlUmVzb2x2ZXIsIF9kZXNjcmlwdG9yc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbmZpZy5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fTtcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gIHJldHVybiBkYXRhc2V0T3B0aW9ucy5pbmRleEF4aXMgfHwgb3B0aW9ucy5pbmRleEF4aXMgfHwgZGF0YXNldERlZmF1bHRzLmluZGV4QXhpcyB8fCAneCc7XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoaWQsIGluZGV4QXhpcykge1xuICBsZXQgYXhpcyA9IGlkO1xuICBpZiAoaWQgPT09ICdfaW5kZXhfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXM7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICdfdmFsdWVfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgfVxuICByZXR1cm4gYXhpcztcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cblxuZnVuY3Rpb24gaWRNYXRjaGVzQXhpcyhpZCkge1xuICBpZiAoaWQgPT09ICd4JyB8fCBpZCA9PT0gJ3knIHx8IGlkID09PSAncicpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVBeGlzKGlkLCAuLi5zY2FsZU9wdGlvbnMpIHtcbiAgaWYgKGlkTWF0Y2hlc0F4aXMoaWQpKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGZvciAoY29uc3Qgb3B0cyBvZiBzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBheGlzID0gb3B0cy5heGlzXG4gICAgICB8fCBheGlzRnJvbVBvc2l0aW9uKG9wdHMucG9zaXRpb24pXG4gICAgICB8fCBpZC5sZW5ndGggPiAxICYmIGlkTWF0Y2hlc0F4aXMoaWRbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKGF4aXMpIHtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkZXRlcm1pbmUgdHlwZSBvZiAnJHtpZH0nIGF4aXMuIFBsZWFzZSBwcm92aWRlICdheGlzJyBvciAncG9zaXRpb24nIG9wdGlvbi5gKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCBheGlzLCBkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gPT09IGlkKSB7XG4gICAgcmV0dXJuIHtheGlzfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMoaWQsIGNvbmZpZykge1xuICBpZiAoY29uZmlnLmRhdGEgJiYgY29uZmlnLmRhdGEuZGF0YXNldHMpIHtcbiAgICBjb25zdCBib3VuZERzID0gY29uZmlnLmRhdGEuZGF0YXNldHMuZmlsdGVyKChkKSA9PiBkLnhBeGlzSUQgPT09IGlkIHx8IGQueUF4aXNJRCA9PT0gaWQpO1xuICAgIGlmIChib3VuZERzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGdldEF4aXNGcm9tRGF0YXNldChpZCwgJ3gnLCBib3VuZERzWzBdKSB8fCBnZXRBeGlzRnJvbURhdGFzZXQoaWQsICd5JywgYm91bmREc1swXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xuICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgY29uc3QgY2hhcnRJbmRleEF4aXMgPSBnZXRJbmRleEF4aXMoY29uZmlnLnR5cGUsIG9wdGlvbnMpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIEZpcnN0IGZpZ3VyZSBvdXQgZmlyc3Qgc2NhbGUgaWQncyBwZXIgYXhpcy5cbiAgT2JqZWN0LmtleXMoY29uZmlnU2NhbGVzKS5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBzY2FsZUNvbmYgPSBjb25maWdTY2FsZXNbaWRdO1xuICAgIGlmICghaXNPYmplY3Qoc2NhbGVDb25mKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2NhbGUgY29uZmlndXJhdGlvbiBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZUNvbmYsIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSwgZGVmYXVsdHMuc2NhbGVzW3NjYWxlQ29uZi50eXBlXSk7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIHNjYWxlc1tpZF0gPSBtZXJnZUlmKE9iamVjdC5jcmVhdGUobnVsbCksIFt7YXhpc30sIHNjYWxlQ29uZiwgZGVmYXVsdFNjYWxlT3B0aW9uc1theGlzXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SWRdXSk7XG4gIH0pO1xuXG4gIC8vIFRoZW4gbWVyZ2UgZGF0YXNldCBkZWZhdWx0cyB0byBzY2FsZSBjb25maWdzXG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYXBwbHkgc2NhbGUgZGVmYXVsdHMsIGlmIG5vdCBvdmVycmlkZGVuIGJ5IGRhdGFzZXQgZGVmYXVsdHNcbiAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xuICB9KTtcblxuICByZXR1cm4gc2NhbGVzO1xufVxuXG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcblxuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgb3B0aW9ucy5zY2FsZXMgPSBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhKGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEgfHwge307XG4gIGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuICBkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcblxuICBpbml0T3B0aW9ucyhjb25maWcpO1xuXG4gIHJldHVybiBjb25maWc7XG59XG5cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gY2FjaGVkS2V5cyhjYWNoZUtleSwgZ2VuZXJhdGUpIHtcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gZ2VuZXJhdGUoKTtcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xuICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5jb25zdCBhZGRJZkZvdW5kID0gKHNldCwgb2JqLCBrZXkpID0+IHtcbiAgY29uc3Qgb3B0cyA9IHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpO1xuICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0LmFkZChvcHRzKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGdldCBwbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICB9XG5cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgfVxuXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9jb25maWcuZGF0YSA9IGluaXREYXRhKGRhdGEpO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuXG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGRhdGFzZXQgb3B0aW9ucy5cbiAgICogVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXQgaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGRhdGFzZXQgYW5pbWF0aW9uIG9wdGlvbnMuXG4gICAqIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0IGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zaXRpb25cbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbi4ke3RyYW5zaXRpb259YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgICBgdHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlIHVzZWQgZm9yIGxvb2tpbmcgdXAgdGhlIGBhbmltYXRpb25zYCBhbmQgYGFuaW1hdGlvbmAga2V5c1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBlbGVtZW50IG9wdGlvbnMgdGhhdCBiZWxvbmdcbiAgICogdG8gYW4gZGF0YXNldC4gVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXRcbiAgICogaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudFR5cGVcbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKGRhdGFzZXRUeXBlLCBlbGVtZW50VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS0ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0uZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIHBsdWdpbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3tpZDogc3RyaW5nLCBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzPzogc3RyaW5nW119fSBwbHVnaW5cbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdLFxuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIG9iamVjdHMgZnJvbSBvcHRpb25zIGFuZCBkZWZhdWx0cyBmb3Igb3B0aW9uIHZhbHVlIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYWluU2NvcGUgLSBUaGUgbWFpbiBzY29wZSBvYmplY3QgZm9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmdbXVtdfSBrZXlMaXN0cyAtIFRoZSBhcnJheXMgb2Yga2V5cyBpbiByZXNvbHV0aW9uIG9yZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0Q2FjaGVdIC0gcmVzZXQgdGhlIGNhY2hlIGZvciB0aGlzIG1haW5TY29wZVxuICAgKi9cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBTZXQoKTtcblxuICAgIGtleUxpc3RzLmZvckVhY2goa2V5cyA9PiB7XG4gICAgICBpZiAobWFpblNjb3BlKSB7XG4gICAgICAgIHNjb3Blcy5hZGQobWFpblNjb3BlKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgbWFpblNjb3BlLCBrZXkpKTtcbiAgICAgIH1cbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG9wdGlvbnMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlZmF1bHRzLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlc2NyaXB0b3JzLCBrZXkpKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlcyBmb3IgcmVzb2x2aW5nIGNoYXJ0IG9wdGlvbnNcbiAgICogQHJldHVybiB7b2JqZWN0W119XG4gICAqL1xuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvdmVycmlkZXNbdHlwZV0gfHwge30sXG4gICAgICBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fSwgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzg1MzFcbiAgICAgIHt0eXBlfSxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgZGVzY3JpcHRvcnNcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjb3Blc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBuYW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdH0gY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbcHJlZml4ZXNdXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG4gIHJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyRzaGFyZWQ6IHRydWV9O1xuICAgIGNvbnN0IHtyZXNvbHZlciwgc3ViUHJlZml4ZXN9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgbGV0IG9wdGlvbnMgPSByZXNvbHZlcjtcbiAgICBpZiAobmVlZENvbnRleHQocmVzb2x2ZXIsIG5hbWVzKSkge1xuICAgICAgcmVzdWx0LiRzaGFyZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQgPSBpc0Z1bmN0aW9uKGNvbnRleHQpID8gY29udGV4dCgpIDogY29udGV4dDtcbiAgICAgIC8vIHN1YlJlc29sdmVyIGlzIHBhc3NlZCB0byBzY3JpcHRhYmxlIG9wdGlvbnMuIEl0IHNob3VsZCBub3QgcmVzb2x2ZSB0byBob3ZlciBvcHRpb25zLlxuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjb3Blc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtwcmVmaXhlc11cbiAgICogQHBhcmFtIHt7c2NyaXB0YWJsZTogYm9vbGVhbiwgaW5kZXhhYmxlOiBib29sZWFuLCBhbGxLZXlzPzogYm9vbGVhbn19IFtkZXNjcmlwdG9yRGVmYXVsdHNdXG4gICAqL1xuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHJlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpIHtcbiAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJlc29sdmVyQ2FjaGUuc2V0KHNjb3BlcywgY2FjaGUpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJlZml4ZXMuam9pbigpO1xuICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFjYWNoZWQpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzKTtcbiAgICBjYWNoZWQgPSB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1YlByZWZpeGVzOiBwcmVmaXhlcy5maWx0ZXIocCA9PiAhcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdob3ZlcicpKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5cbmNvbnN0IGhhc0Z1bmN0aW9uID0gdmFsdWUgPT4gaXNPYmplY3QodmFsdWUpXG4gICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5zb21lKChrZXkpID0+IGlzRnVuY3Rpb24odmFsdWVba2V5XSkpO1xuXG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICBjb25zdCBzY3JpcHRhYmxlID0gaXNTY3JpcHRhYmxlKHByb3ApO1xuICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgIGNvbnN0IHZhbHVlID0gKGluZGV4YWJsZSB8fCBzY3JpcHRhYmxlKSAmJiBwcm94eVtwcm9wXTtcbiAgICBpZiAoKHNjcmlwdGFibGUgJiYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGhhc0Z1bmN0aW9uKHZhbHVlKSkpXG4gICAgICB8fCAoaW5kZXhhYmxlICYmIGlzQXJyYXkodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vY29yZS5pbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge19kZXRlY3RQbGF0Zm9ybX0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IFBsdWdpblNlcnZpY2UgZnJvbSAnLi9jb3JlLnBsdWdpbnMuanMnO1xuaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQgQ29uZmlnLCB7ZGV0ZXJtaW5lQXhpcywgZ2V0SW5kZXhBeGlzfSBmcm9tICcuL2NvcmUuY29uZmlnLmpzJztcbmltcG9ydCB7ZWFjaCwgY2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCB1aWQsIHZhbHVlT3JEZWZhdWx0LCBfZWxlbWVudHNFcXVhbCwgaXNOdWxsT3JVbmRlZiwgc2V0c0VxdWFsLCBkZWZpbmVkLCBpc0Z1bmN0aW9uLCBfaXNDbGlja0V2ZW50fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2NsZWFyQ2FudmFzLCBjbGlwQXJlYSwgY3JlYXRlQ29udGV4dCwgdW5jbGlwQXJlYSwgX2lzUG9pbnRJbkFyZWEsIF9pc0RvbVN1cHBvcnRlZCwgcmV0aW5hU2NhbGUsIGdldERhdGFzZXRDbGlwQXJlYX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge3ZlcnNpb259IGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQge2RlYm91bmNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuUG9pbnQgfSBQb2ludFxuICovXG5cbmNvbnN0IEtOT1dOX1BPU0lUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NoYXJ0QXJlYSddO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZTJMZXZlbChsMSwgbDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYVtsMV0gPT09IGJbbDFdXG4gICAgICA/IGFbbDJdIC0gYltsMl1cbiAgICAgIDogYVtsMV0gLSBiW2wxXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BbmltYXRpb25zQ29tcGxldGUoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcblxuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICBjYWxsQ2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuXG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNhbGxDYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcywgW2NvbnRleHRdLCBjaGFydCk7XG59XG5cbi8qKlxuICogQ2hhcnQuanMgY2FuIHRha2UgYSBzdHJpbmcgaWQgb2YgYSBjYW52YXMgZWxlbWVudCwgYSAyZCBjb250ZXh0LCBvciBhIGNhbnZhcyBlbGVtZW50IGl0c2VsZi5cbiAqIEF0dGVtcHQgdG8gdW53cmFwIHRoZSBpdGVtIHBhc3NlZCBpbnRvIHRoZSBjaGFydCBjb25zdHJ1Y3RvciBzbyB0aGF0IGl0IGlzIGEgY2FudmFzIGVsZW1lbnQgKGlmIHBvc3NpYmxlKS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpICYmIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0ubGVuZ3RoKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG4gICAgaXRlbSA9IGl0ZW1bMF07XG4gIH1cblxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuICAgIC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxuICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuY29uc3QgaW5zdGFuY2VzID0ge307XG5jb25zdCBnZXRDaGFydCA9IChrZXkpID0+IHtcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZmlsdGVyKChjKSA9PiBjLmNhbnZhcyA9PT0gY2FudmFzKS5wb3AoKTtcbn07XG5cbmZ1bmN0aW9uIG1vdmVOdW1lcmljS2V5cyhvYmosIHN0YXJ0LCBtb3ZlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgaW50S2V5ID0gK2tleTtcbiAgICBpZiAoaW50S2V5ID49IHN0YXJ0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgaWYgKG1vdmUgPiAwIHx8IGludEtleSA+IHN0YXJ0KSB7XG4gICAgICAgIG9ialtpbnRLZXkgKyBtb3ZlXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZVxuICogQHBhcmFtIHtDaGFydEV2ZW50fG51bGx9IGxhc3RFdmVudFxuICogQHBhcmFtIHtib29sZWFufSBpbkNoYXJ0QXJlYVxuICogQHBhcmFtIHtib29sZWFufSBpc0NsaWNrXG4gKiBAcmV0dXJucyB7Q2hhcnRFdmVudHxudWxsfVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICBpZiAoIWluQ2hhcnRBcmVhIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0NsaWNrKSB7XG4gICAgcmV0dXJuIGxhc3RFdmVudDtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuY2xhc3MgQ2hhcnQge1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IGRlZmF1bHRzO1xuICBzdGF0aWMgaW5zdGFuY2VzID0gaW5zdGFuY2VzO1xuICBzdGF0aWMgb3ZlcnJpZGVzID0gb3ZlcnJpZGVzO1xuICBzdGF0aWMgcmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgc3RhdGljIHZlcnNpb24gPSB2ZXJzaW9uO1xuICBzdGF0aWMgZ2V0Q2hhcnQgPSBnZXRDaGFydDtcblxuICBzdGF0aWMgcmVnaXN0ZXIoLi4uaXRlbXMpIHtcbiAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xuICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gIH1cblxuICBzdGF0aWMgdW5yZWdpc3RlciguLi5pdGVtcykge1xuICAgIHJlZ2lzdHJ5LnJlbW92ZSguLi5pdGVtcyk7XG4gICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihpdGVtLCB1c2VyQ29uZmlnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IGluaXRpYWxDYW52YXMgPSBnZXRDYW52YXMoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdDaGFydCA9IGdldENoYXJ0KGluaXRpYWxDYW52YXMpO1xuICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW52YXMgaXMgYWxyZWFkeSBpbiB1c2UuIENoYXJ0IHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuaWQgKyAnXFwnJyArXG5cdFx0XHRcdCcgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5jYW52YXMuaWQgKyAnXFwnIGNhbiBiZSByZXVzZWQuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG5cbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IChjb25maWcucGxhdGZvcm0gfHwgX2RldGVjdFBsYXRmb3JtKGluaXRpYWxDYW52YXMpKSgpO1xuICAgIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKGNvbmZpZyk7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpbml0aWFsQ2FudmFzLCBvcHRpb25zLmFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcblxuICAgIHRoaXMuaWQgPSB1aWQoKTtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIFN0b3JlIHRoZSBwcmV2aW91c2x5IHVzZWQgYXNwZWN0IHJhdGlvIHRvIGRldGVybWluZSBpZiBhIHJlc2l6ZVxuICAgIC8vIGlzIG5lZWRlZCBkdXJpbmcgdXBkYXRlcy4gRG8gdGhpcyBhZnRlciBfb3B0aW9ucyBpcyBzZXQgc2luY2VcbiAgICAvLyBhc3BlY3RSYXRpbyB1c2VzIGEgZ2V0dGVyXG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIHRoaXMuX21ldGFzZXRzID0gW107XG4gICAgdGhpcy5fc3RhY2tzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm94ZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnRBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAvKiogQHR5cGUgez97YXR0YWNoPzogZnVuY3Rpb24sIGRldGFjaD86IGZ1bmN0aW9uLCByZXNpemU/OiBmdW5jdGlvbn19ICovXG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5fcGx1Z2lucyA9IG5ldyBQbHVnaW5TZXJ2aWNlKCk7XG4gICAgdGhpcy4kcHJveGllcyA9IHt9O1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXMgPSB7fTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9SZXNpemUgPSBkZWJvdW5jZShtb2RlID0+IHRoaXMudXBkYXRlKG1vZGUpLCBvcHRpb25zLnJlc2l6ZURlbGF5IHx8IDApO1xuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG5cbiAgICAvLyBBZGQgdGhlIGNoYXJ0IGluc3RhbmNlIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG4gICAgaW5zdGFuY2VzW3RoaXMuaWRdID0gdGhpcztcblxuICAgIGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG4gICAgICAvLyBUaGUgZ2l2ZW4gaXRlbSBpcyBub3QgYSBjb21wYXRpYmxlIGNvbnRleHQyZCBlbGVtZW50LCBsZXQncyByZXR1cm4gYmVmb3JlIGZpbmFsaXppbmdcbiAgICAgIC8vIHRoZSBjaGFydCBpbml0aWFsaXphdGlvbiBidXQgYWZ0ZXIgc2V0dGluZyBiYXNpYyBjaGFydCAvIGNvbnRyb2xsZXIgcHJvcGVydGllcyB0aGF0XG4gICAgICAvLyBjYW4gaGVscCB0byBmaWd1cmUgb3V0IHRoYXQgdGhlIGNoYXJ0IGlzIG5vdCB2YWxpZCAoZS5nIGNoYXJ0LmNhbnZhcyAhPT0gbnVsbCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAnY29tcGxldGUnLCBvbkFuaW1hdGlvbnNDb21wbGV0ZSk7XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdwcm9ncmVzcycsIG9uQW5pbWF0aW9uUHJvZ3Jlc3MpO1xuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICBjb25zdCB7b3B0aW9uczoge2FzcGVjdFJhdGlvLCBtYWludGFpbkFzcGVjdFJhdGlvfSwgd2lkdGgsIGhlaWdodCwgX2FzcGVjdFJhdGlvfSA9IHRoaXM7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xuICAgICAgLy8gSWYgYXNwZWN0UmF0aW8gaXMgZGVmaW5lZCBpbiBvcHRpb25zLCB1c2UgdGhhdC5cbiAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcbiAgICAgIC8vIElmIG1haW50YWluQXNwZWN0UmF0aW8gaXMgdHJ1dGhseSBhbmQgd2UgaGFkIHByZXZpb3VzbHkgZGV0ZXJtaW5lZCBfYXNwZWN0UmF0aW8sIHVzZSB0aGF0XG4gICAgICByZXR1cm4gX2FzcGVjdFJhdGlvO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZVxuICAgIHJldHVybiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG4gIH1cblxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YTtcbiAgfVxuXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLmNvbmZpZy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZ2V0IHJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiByZWdpc3RyeTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgLy8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlSW5pdCcpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRpbmFTY2FsZSh0aGlzLCB0aGlzLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfVxuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG5cbiAgICAvLyBBZnRlciBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBjbGVhckNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBhbmltYXRvci5zdG9wKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc2l6ZSB0aGUgY2hhcnQgdG8gaXRzIGNvbnRhaW5lciBvciB0byBleHBsaWNpdCBkaW1lbnNpb25zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF1cblx0ICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7d2lkdGgsIGhlaWdodH07XG4gICAgfVxuICB9XG5cbiAgX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IG5ld1JhdGlvID0gb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvIHx8IHRoaXMucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLndpZHRoID8gJ3Jlc2l6ZScgOiAnYXR0YWNoJztcblxuICAgIHRoaXMud2lkdGggPSBuZXdTaXplLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGlmICghcmV0aW5hU2NhbGUodGhpcywgbmV3UmF0aW8sIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNpemUnLCB7c2l6ZTogbmV3U2l6ZX0pO1xuXG4gICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25SZXNpemUsIFt0aGlzLCBuZXdTaXplXSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKHRoaXMuX2RvUmVzaXplKG1vZGUpKSB7XG4gICAgICAgIC8vIFRoZSByZXNpemUgdXBkYXRlIGlzIGRlbGF5ZWQsIG9ubHkgZHJhdyB3aXRob3V0IHVwZGF0aW5nLlxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG5cbiAgICBlYWNoKHNjYWxlc09wdGlvbnMsIChheGlzT3B0aW9ucywgYXhpc0lEKSA9PiB7XG4gICAgICBheGlzT3B0aW9ucy5pZCA9IGF4aXNJRDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBCdWlsZHMgYSBtYXAgb2Ygc2NhbGUgSUQgdG8gc2NhbGUgb2JqZWN0IGZvciBmdXR1cmUgbG9va3VwLlxuXHQgKi9cbiAgYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlT3B0cyA9IG9wdGlvbnMuc2NhbGVzO1xuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZSgob2JqLCBpZCkgPT4ge1xuICAgICAgb2JqW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgbGV0IGl0ZW1zID0gW107XG5cbiAgICBpZiAoc2NhbGVPcHRzKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc2NhbGVPcHRzKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGVPcHRzW2lkXTtcbiAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICBjb25zdCBpc1JhZGlhbCA9IGF4aXMgPT09ICdyJztcbiAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRwb3NpdGlvbjogaXNSYWRpYWwgPyAnY2hhcnRBcmVhJyA6IGlzSG9yaXpvbnRhbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBlYWNoKGl0ZW1zLCAoaXRlbSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG4gICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNjYWxlVHlwZSA9IHZhbHVlT3JEZWZhdWx0KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcblxuICAgICAgaWYgKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiwgYXhpcykgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlZFtpZF0gPSB0cnVlO1xuICAgICAgbGV0IHNjYWxlID0gbnVsbDtcbiAgICAgIGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZXNbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XG4gICAgICAgIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcbiAgICAgICAgICBjdHg6IHRoaXMuY3R4LFxuICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlLmluaXQoc2NhbGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICAvLyBjbGVhciB1cCBkaXNjYXJkZWQgc2NhbGVzXG4gICAgZWFjaCh1cGRhdGVkLCAoaGFzVXBkYXRlZCwgaWQpID0+IHtcbiAgICAgIGlmICghaGFzVXBkYXRlZCkge1xuICAgICAgICBkZWxldGUgc2NhbGVzW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMuY29uZmlndXJlKHRoaXMsIHNjYWxlLCBzY2FsZS5vcHRpb25zKTtcbiAgICAgIGxheW91dHMuYWRkQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZU1ldGFzZXRzKCkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgY29uc3QgbnVtRGF0YSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtTWV0YSA9IG1ldGFzZXRzLmxlbmd0aDtcblxuICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcbiAgICBpZiAobnVtTWV0YSA+IG51bURhdGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSBudW1EYXRhOyBpIDwgbnVtTWV0YTsgKytpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGFzZXRzLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gbWV0YXNldHMuc2xpY2UoMCkuc29ydChjb21wYXJlMkxldmVsKCdvcmRlcicsICdpbmRleCcpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCkge1xuICAgIGNvbnN0IHtfbWV0YXNldHM6IG1ldGFzZXRzLCBkYXRhOiB7ZGF0YXNldHN9fSA9IHRoaXM7XG4gICAgaWYgKG1ldGFzZXRzLmxlbmd0aCA+IGRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0YWNrcztcbiAgICB9XG4gICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXRhc2V0cy5maWx0ZXIoeCA9PiB4ID09PSBtZXRhLl9kYXRhc2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpIHtcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRzID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgdGhpcy5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcbiAgICAgIGxldCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgdGhpcy5jb25maWcudHlwZTtcblxuICAgICAgaWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGEudHlwZSA9IHR5cGU7XG4gICAgICBtZXRhLmluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgbWV0YS5vcmRlciA9IGRhdGFzZXQub3JkZXIgfHwgMDtcbiAgICAgIG1ldGEuaW5kZXggPSBpO1xuICAgICAgbWV0YS5sYWJlbCA9ICcnICsgZGF0YXNldC5sYWJlbDtcbiAgICAgIG1ldGEudmlzaWJsZSA9IHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKTtcblxuICAgICAgaWYgKG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgICAgICBjb25zdCB7ZGF0YXNldEVsZW1lbnRUeXBlLCBkYXRhRWxlbWVudFR5cGV9ID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oQ29udHJvbGxlckNsYXNzLCB7XG4gICAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFFbGVtZW50VHlwZSksXG4gICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBkYXRhc2V0RWxlbWVudFR5cGUgJiYgcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhc2V0RWxlbWVudFR5cGUpXG4gICAgICAgIH0pO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMsIGkpO1xuICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlTWV0YXNldHMoKTtcbiAgICByZXR1cm4gbmV3Q29udHJvbGxlcnM7XG4gIH1cblxuICAvKipcblx0ICogUmVzZXQgdGhlIGVsZW1lbnRzIG9mIGFsbCBkYXRhc2V0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgZWFjaCh0aGlzLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICAvKipcblx0KiBSZXNldHMgdGhlIGNoYXJ0IGJhY2sgdG8gaXRzIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbCBhbmltYXRpb25cblx0Ki9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICBjb25maWcudXBkYXRlKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhbmltc0Rpc2FibGVkID0gdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gIW9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gICAgdGhpcy5fdXBkYXRlU2NhbGVzKCk7XG4gICAgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCk7XG4gICAgdGhpcy5fdXBkYXRlSGlkZGVuSW5kaWNlcygpO1xuXG4gICAgLy8gcGx1Z2lucyBvcHRpb25zIHJlZmVyZW5jZXMgbWlnaHQgaGF2ZSBjaGFuZ2UsIGxldCdzIGludmFsaWRhdGUgdGhlIGNhY2hlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUxMTEjaXNzdWVjb21tZW50LTM1NTkzNDE2N1xuICAgIHRoaXMuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgZGF0YXNldCBjb250cm9sbGVycyBhcmUgdXBkYXRlZCBhbmQgbmV3IGNvbnRyb2xsZXJzIGFyZSByZXNldFxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRWxlbWVudHNVcGRhdGUnKTtcblxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgZGF0YXNldCBjb250cm9sbGVycyBoYXZlIGNvcnJlY3QgbWV0YSBkYXRhIGNvdW50c1xuICAgIGxldCBtaW5QYWRkaW5nID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHtjb250cm9sbGVyfSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCByZXNldCA9ICFhbmltc0Rpc2FibGVkICYmIG5ld0NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPT09IC0xO1xuICAgICAgLy8gTmV3IGNvbnRyb2xsZXJzIHdpbGwgYmUgcmVzZXQgYWZ0ZXIgdGhlIGxheW91dCBwYXNzLCBzbyB3ZSBvbmx5IHdhbnQgdG8gbW9kaWZ5XG4gICAgICAvLyBlbGVtZW50cyBhZGRlZCB0byBuZXcgZGF0YXNldHNcbiAgICAgIGNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0KTtcbiAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1heCgrY29udHJvbGxlci5nZXRNYXhPdmVyZmxvdygpLCBtaW5QYWRkaW5nKTtcbiAgICB9XG4gICAgbWluUGFkZGluZyA9IHRoaXMuX21pblBhZGRpbmcgPSBvcHRpb25zLmxheW91dC5hdXRvUGFkZGluZyA/IG1pblBhZGRpbmcgOiAwO1xuICAgIHRoaXMuX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKTtcblxuICAgIC8vIE9ubHkgcmVzZXQgdGhlIGNvbnRyb2xsZXJzIGlmIHdlIGhhdmUgYW5pbWF0aW9uc1xuICAgIGlmICghYW5pbXNEaXNhYmxlZCkge1xuICAgICAgLy8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXG4gICAgICAvLyBSZXNldCBpcyBkb25lIHRvIGdldCB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBpbml0aWFsIGFuaW1hdGlvblxuICAgICAgZWFjaChuZXdDb250cm9sbGVycywgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlRGF0YXNldHMobW9kZSk7XG5cbiAgICAvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlclVwZGF0ZScsIHttb2RlfSk7XG5cbiAgICB0aGlzLl9sYXllcnMuc29ydChjb21wYXJlMkxldmVsKCd6JywgJ19pZHgnKSk7XG5cbiAgICAvLyBSZXBsYXkgbGFzdCBldmVudCBmcm9tIGJlZm9yZSB1cGRhdGUsIG9yIHNldCBob3ZlciBzdHlsZXMgb24gYWN0aXZlIGVsZW1lbnRzXG4gICAgY29uc3Qge19hY3RpdmUsIF9sYXN0RXZlbnR9ID0gdGhpcztcbiAgICBpZiAoX2xhc3RFdmVudCkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKF9sYXN0RXZlbnQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoX2FjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKF9hY3RpdmUsIF9hY3RpdmUsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgZWFjaCh0aGlzLnNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLnJlbW92ZUJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcbiAgICB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrRXZlbnRCaW5kaW5ncygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLl9saXN0ZW5lcnMpKTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBuZXcgU2V0KG9wdGlvbnMuZXZlbnRzKTtcblxuICAgIGlmICghc2V0c0VxdWFsKGV4aXN0aW5nRXZlbnRzLCBuZXdFdmVudHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gb3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICAvLyBUaGUgY29uZmlndXJlZCBldmVudHMgaGF2ZSBjaGFuZ2VkLiBSZWJpbmQuXG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICBjb25zdCB7X2hpZGRlbkluZGljZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgZm9yIChjb25zdCB7bWV0aG9kLCBzdGFydCwgY291bnR9IG9mIGNoYW5nZXMpIHtcbiAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XG4gICAgICBtb3ZlTnVtZXJpY0tleXMoX2hpZGRlbkluZGljZXMsIHN0YXJ0LCBtb3ZlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB7XG4gICAgY29uc3QgX2RhdGFDaGFuZ2VzID0gdGhpcy5fZGF0YUNoYW5nZXM7XG4gICAgaWYgKCFfZGF0YUNoYW5nZXMgfHwgIV9kYXRhQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRDb3VudCA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbWFrZVNldCA9IChpZHgpID0+IG5ldyBTZXQoXG4gICAgICBfZGF0YUNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGNbMF0gPT09IGlkeClcbiAgICAgICAgLm1hcCgoYywgaSkgPT4gaSArICcsJyArIGMuc3BsaWNlKDEpLmpvaW4oJywnKSlcbiAgICApO1xuXG4gICAgY29uc3QgY2hhbmdlU2V0ID0gbWFrZVNldCgwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGFzZXRDb3VudDsgaSsrKSB7XG4gICAgICBpZiAoIXNldHNFcXVhbChjaGFuZ2VTZXQsIG1ha2VTZXQoaSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbmdlU2V0KVxuICAgICAgLm1hcChjID0+IGMuc3BsaXQoJywnKSlcbiAgICAgIC5tYXAoYSA9PiAoe21ldGhvZDogYVsxXSwgc3RhcnQ6ICthWzJdLCBjb3VudDogK2FbM119KSk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyB0aGUgY2hhcnQgbGF5b3V0IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVMYXlvdXRgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckxheW91dGAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVMYXlvdXQnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcblxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBub0FyZWEgPSBhcmVhLndpZHRoIDw9IDAgfHwgYXJlYS5oZWlnaHQgPD0gMDtcblxuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIGVhY2godGhpcy5ib3hlcywgKGJveCkgPT4ge1xuICAgICAgaWYgKG5vQXJlYSAmJiBib3gucG9zaXRpb24gPT09ICdjaGFydEFyZWEnKSB7XG4gICAgICAgIC8vIFNraXAgZHJhd2luZyBhbmQgY29uZmlndXJpbmcgY2hhcnRBcmVhIGJveGVzIHdoZW4gY2hhcnRBcmVhIGlzIHplcm8gb3IgbmVnYXRpdmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGluIGNvcmUuc2NhbGUudXBkYXRlIGFuZCBvbmNlIGhlcmUuXG4gICAgICAvLyBIZXJlIHRoZSBib3hlcyBhcmUgZnVsbHkgdXBkYXRlZCBhbmQgYXQgdGhlaXIgZmluYWwgcG9zaXRpb25zLlxuICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2goLi4uYm94Ll9sYXllcnMoKSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGl0ZW0uX2lkeCA9IGluZGV4O1xuICAgIH0pO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckxheW91dCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEYXRhc2V0KGksIGlzRnVuY3Rpb24obW9kZSkgPyBtb2RlKHtkYXRhc2V0SW5kZXg6IGl9KSA6IG1vZGUpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0VXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0VXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVEYXRhc2V0KGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgIGNvbnN0IGFyZ3MgPSB7bWV0YSwgaW5kZXgsIG1vZGUsIGNhbmNlbGFibGU6IHRydWV9O1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1ldGEuY29udHJvbGxlci5fdXBkYXRlKG1vZGUpO1xuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRVcGRhdGUnLCBhcmdzKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRvci5oYXModGhpcykpIHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICAgIG9uQW5pbWF0aW9uc0NvbXBsZXRlKHtjaGFydDogdGhpc30pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXc7XG4gICAgICAvLyBVbnNldCBwZW5kaW5nIHJlc2l6ZSByZXF1ZXN0IG5vdyB0byBhdm9pZCBwb3NzaWJsZSByZWN1cnNpb24gd2l0aGluIF9yZXNpemVcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCZWNhdXNlIG9mIHBsdWdpbiBob29rcyAoYmVmb3JlL2FmdGVyRGF0YXNldHNEcmF3KSwgZGF0YXNldHMgY2FuJ3RcbiAgICAvLyBjdXJyZW50bHkgYmUgcGFydCBvZiBsYXllcnMuIEluc3RlYWQsIHdlIGRyYXdcbiAgICAvLyBsYXllcnMgPD0gMCBiZWZvcmUoZGVmYXVsdCwgYmFja3dhcmQgY29tcGF0KSwgYW5kIHRoZSByZXN0IGFmdGVyXG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYXdEYXRhc2V0cygpO1xuXG4gICAgLy8gUmVzdCBvZiBsYXllcnNcbiAgICBmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fc29ydGVkTWV0YXNldHM7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgdmlzaWJsZSBkYXRhc2V0IG1ldGFzIGluIGRyYXdpbmcgb3JkZXJcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogRHJhd3MgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c0RyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzRHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRoaXMuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNEcmF3Jyk7XG4gIH1cblxuICAvKipcblx0ICogRHJhd3MgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldERyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXREcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBjbGlwID0gZ2V0RGF0YXNldENsaXBBcmVhKHRoaXMsIG1ldGEpO1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBjbGlwKTtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuXG4gICAgaWYgKGNsaXApIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW4gdGhlIGNoYXJ0IGFyZWEuXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXMgKHNlZSwgZS5nLiwgZ2V0UmVsYXRpdmVQb3NpdGlvbilcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BvaW50SW5BcmVhKHBvaW50KSB7XG4gICAgcmV0dXJuIF9pc1BvaW50SW5BcmVhKHBvaW50LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XG4gIH1cblxuICBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG1vZGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcih4ID0+IHggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XG5cbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIG1ldGEgPSB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBkYXRhc2V0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgICBoaWRkZW46IG51bGwsXHRcdFx0Ly8gU2VlIGlzRGF0YXNldFZpc2libGUoKSBjb21tZW50XG4gICAgICAgIHhBeGlzSUQ6IG51bGwsXG4gICAgICAgIHlBeGlzSUQ6IG51bGwsXG4gICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcbiAgICAgICAgaW5kZXg6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgX2RhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICBfc29ydGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIG1ldGFzZXRzLnB1c2gobWV0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cblxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsLCB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KSk7XG4gIH1cblxuICBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gIH1cblxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgLy8gbWV0YS5oaWRkZW4gaXMgYSBwZXIgY2hhcnQgZGF0YXNldCBoaWRkZW4gZmxhZyBvdmVycmlkZSB3aXRoIDMgc3RhdGVzOiBpZiB0cnVlIG9yIGZhbHNlLFxuICAgIC8vIHRoZSBkYXRhc2V0LmhpZGRlbiB2YWx1ZSBpcyBpZ25vcmVkLCBlbHNlIGlmIG51bGwsIHRoZSBkYXRhc2V0IGhpZGRlbiBzdGF0ZSBpcyByZXR1cm5lZC5cbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cblxuICBzZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIG1ldGEuaGlkZGVuID0gIXZpc2libGU7XG4gIH1cblxuICB0b2dnbGVEYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG5cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1vZGUgPSB2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgY29uc3QgYW5pbXMgPSBtZXRhLmNvbnRyb2xsZXIuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSk7XG5cbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKTtcbiAgICAgIC8vIEFuaW1hdGUgdmlzaWJsZSBzdGF0ZSwgc28gaGlkZSBhbmltYXRpb24gY2FuIGJlIHNlZW4uIFRoaXMgY291bGQgYmUgaGFuZGxlZCBiZXR0ZXIgaWYgdXBkYXRlIC8gdXBkYXRlRGF0YXNldCByZXR1cm5lZCBhIFByb21pc2UuXG4gICAgICBhbmltcy51cGRhdGUobWV0YSwge3Zpc2libGV9KTtcbiAgICAgIHRoaXMudXBkYXRlKChjdHgpID0+IGN0eC5kYXRhc2V0SW5kZXggPT09IGRhdGFzZXRJbmRleCA/IG1vZGUgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cblxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gIH1cblxuICBfc3RvcCgpIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBhbmltYXRvci5yZW1vdmUodGhpcyk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XG5cbiAgICB0aGlzLl9zdG9wKCk7XG4gICAgdGhpcy5jb25maWcuY2xlYXJDYWNoZSgpO1xuXG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRlc3Ryb3knKTtcbiAgfVxuXG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5iaW5kVXNlckV2ZW50cygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5iaW5kUmVzcG9uc2l2ZUV2ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG5cbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KSA9PiB7XG4gICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcbiAgICB9O1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMuZXZlbnRzLCAodHlwZSkgPT4gX2FkZCh0eXBlLCBsaXN0ZW5lcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiaW5kUmVzcG9uc2l2ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG5cbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZSA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgZGV0YWNoZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgY29uc3QgYXR0YWNoZWQgPSAoKSA9PiB7XG4gICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG5cbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgX2FkZCgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnZGV0YWNoJywgZGV0YWNoZWQpO1xuICAgIH07XG5cbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcblxuICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBTdG9wIGFuaW1hdGluZyBhbmQgcmVtb3ZlIG1ldGFzZXRzLCBzbyB3aGVuIHJlLWF0dGFjaGVkLCB0aGUgYW5pbWF0aW9ucyBzdGFydCBmcm9tIGJlZ2lubmluZy5cbiAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZSgwLCAwKTtcblxuICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgIH07XG5cbiAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykpIHtcbiAgICAgIGF0dGFjaGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFjaGVkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgZWFjaCh0aGlzLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuICAgIGVhY2godGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGVIb3ZlclN0eWxlKGl0ZW1zLCBtb2RlLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG5cbiAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShpdGVtLmVsZW1lbnQsIGl0ZW0uZGF0YXNldEluZGV4LCBpdGVtLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogR2V0IGFjdGl2ZSAoaG92ZXJlZCkgZWxlbWVudHNcblx0ICogQHJldHVybnMgYXJyYXlcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSAoaG92ZXJlZCkgZWxlbWVudHNcblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlRWxlbWVudHMgTmV3IGFjdGl2ZSBkYXRhIHBvaW50c1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCB1c2UgdGhlIHByZXZpb3VzIG1vdXNlIGV2ZW50IHRvIG92ZXJyaWRlIHRoZSBhY3RpdmUgZWxlbWVudHMgaW4gdXBkYXRlLlxuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgYXMgc29vbiBhcyBhIHBsdWdpbiBleHBsaWNpdGx5IHJldHVybnMgZmFsc2UuIFRoZVxuXHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaG9vayAtIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gbWV0aG9kIHRvIGNhbGwgKGUuZy4gJ2JlZm9yZVVwZGF0ZScpLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUucGx1Z2lucy5qcycpLmZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5UGx1Z2lucyhob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHBsdWdpbiB3aXRoIHRoZSBzcGVjaWZpYyBJRCBpcyByZWdpc3RlcmVkIGFuZCBlbmFibGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbHVnaW5JZCAtIFRoZSBJRCBvZiB0aGUgcGx1Z2luIG9mIHdoaWNoIHRvIGNoZWNrIGlmIGl0IGlzIGVuYWJsZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BsdWdpbkVuYWJsZWQocGx1Z2luSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5fY2FjaGUuZmlsdGVyKHAgPT4gcC5wbHVnaW4uaWQgPT09IHBsdWdpbklkKS5sZW5ndGggPT09IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSkge1xuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHguZGF0YXNldEluZGV4ID09PSB5LmRhdGFzZXRJbmRleCAmJiB4LmluZGV4ID09PSB5LmluZGV4KSk7XG4gICAgY29uc3QgZGVhY3RpdmF0ZWQgPSBkaWZmKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgYWN0aXZhdGVkID0gcmVwbGF5ID8gYWN0aXZlIDogZGlmZihhY3RpdmUsIGxhc3RBY3RpdmUpO1xuXG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBldmVudDogZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBpbkNoYXJ0QXJlYTogdGhpcy5pc1BvaW50SW5BcmVhKGUpXG4gICAgfTtcbiAgICBjb25zdCBldmVudEZpbHRlciA9IChwbHVnaW4pID0+IChwbHVnaW4ub3B0aW9ucy5ldmVudHMgfHwgdGhpcy5vcHRpb25zLmV2ZW50cykuaW5jbHVkZXMoZS5uYXRpdmUudHlwZSk7XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBhcmdzLmluQ2hhcnRBcmVhKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IGFyZ3MuY2hhbmdlZCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIHRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIHRydWUgaWYgdGhlIGV2ZW50IHdhcyByZXBsYXllZCBieSBgdXBkYXRlYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSB0cnVlIGlmIHRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNoYXJ0IG5lZWRzIHRvIHJlLXJlbmRlclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCB7X2FjdGl2ZTogbGFzdEFjdGl2ZSA9IFtdLCBvcHRpb25zfSA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwbGF5ZWQgZnJvbSBgdXBkYXRlYCwgd2Ugc2hvdWxkIGV2YWx1YXRlIHdpdGggdGhlIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAvL1xuICAgIC8vIFRoZSBgcmVwbGF5YDpcbiAgICAvLyBJdCdzIHRoZSBsYXN0IGV2ZW50IChleGNsdWRpbmcgY2xpY2spIHRoYXQgaGFzIG9jY3VycmVkIGJlZm9yZSBgdXBkYXRlYC5cbiAgICAvLyBTbyBtb3VzZSBoYXMgbm90IG1vdmVkLiBJdCdzIGFsc28gb3ZlciB0aGUgY2hhcnQsIGJlY2F1c2UgdGhlcmUgaXMgYSBgcmVwbGF5YC5cbiAgICAvL1xuICAgIC8vIFRoZSB3aHk6XG4gICAgLy8gSWYgYW5pbWF0aW9ucyBhcmUgYWN0aXZlLCB0aGUgZWxlbWVudHMgaGF2ZW4ndCBtb3ZlZCB5ZXQgY29tcGFyZWQgdG8gc3RhdGUgYmVmb3JlIHVwZGF0ZS5cbiAgICAvLyBCdXQgaWYgdGhleSB3aWxsLCB3ZSBhcmUgYWN0aXZhdGluZyB0aGUgZWxlbWVudHMgdGhhdCB3b3VsZCBiZSBhY3RpdmUsIGlmIHRoaXMgY2hlY2tcbiAgICAvLyB3YXMgZG9uZSBhZnRlciB0aGUgYW5pbWF0aW9ucyBoYXZlIGNvbXBsZXRlZC4gPT4gXCJmaW5hbCBwb3NpdGlvbnNcIi5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbmltYXRpb25zLCB0aGUgXCJmaW5hbFwiIGFuZCBcImN1cnJlbnRcIiBwb3NpdGlvbnMgYXJlIGVxdWFsLlxuICAgIC8vIFRoaXMgaXMgZG9uZSBzbyB3ZSBkbyBub3QgaGF2ZSB0byBldmFsdWF0ZSB0aGUgYWN0aXZlIGVsZW1lbnRzIGVhY2ggYW5pbWF0aW9uIGZyYW1lXG4gICAgLy8gLSBpdCB3b3VsZCBiZSBleHBlbnNpdmUuXG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgaXNDbGljayA9IF9pc0NsaWNrRXZlbnQoZSk7XG4gICAgY29uc3QgbGFzdEV2ZW50ID0gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIHRoaXMuX2xhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spO1xuXG4gICAgaWYgKGluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBTZXQgX2xhc3RFdmVudCB0byBudWxsIHdoaWxlIHdlIGFyZSBwcm9jZXNzaW5nIHRoZSBldmVudCBoYW5kbGVycy5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgcmVjdXJzaW9uIGlmIHRoZSBoYW5kbGVyIGNhbGxzIGNoYXJ0LnVwZGF0ZSgpXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gICAgICAvLyBJbnZva2Ugb25Ib3ZlciBob29rXG4gICAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG5cbiAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnRbXX0gbGFzdEFjdGl2ZSAtIFByZXZpb3VzbHkgYWN0aXZlIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5DaGFydEFyZWEgLSBJcyB0aGUgZXZlbnQgaW5zaWRlIGNoYXJ0QXJlYVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUZpbmFsUG9zaXRpb24gLSBTaG91bGQgdGhlIGV2YWx1YXRpb24gYmUgZG9uZSB3aXRoIGN1cnJlbnQgb3IgZmluYWwgKGFmdGVyIGFuaW1hdGlvbikgZWxlbWVudCBwb3NpdGlvbnNcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50W119IC0gVGhlIGFjdGl2ZSBlbGVtZW50c1xuICAgKiBAcHJhdmF0ZVxuICAgKi9cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIExldCB1c2VyIGNvbnRyb2wgdGhlIGFjdGl2ZSBlbGVtZW50cyBvdXRzaWRlIGNoYXJ0QXJlYS4gRWcuIHVzaW5nIExlZ2VuZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGludmFsaWRhdGVQbHVnaW5zKCkge1xuICByZXR1cm4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCkgPT4gY2hhcnQuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iLCJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19hbmdsZUJldHdlZW4sIGdldEFuZ2xlRnJvbVBvaW50LCBUQVUsIEhBTEZfUEksIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7UEksIF9hbmdsZURpZmYsIF9ub3JtYWxpemVBbmdsZSwgX2lzQmV0d2VlbiwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X3JlYWRWYWx1ZVRvUHJvcHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB0eXBlIHtBcmNPcHRpb25zLCBQb2ludH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBjbGlwU2VsZihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZWxlbWVudDogQXJjRWxlbWVudCwgZW5kQW5nbGU6IG51bWJlcikge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBvcHRpb25zfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IHtib3JkZXJXaWR0aCwgYm9yZGVySm9pblN0eWxlfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG91dGVyQW5nbGVDbGlwID0gTWF0aC5taW4oYm9yZGVyV2lkdGggLyBvdXRlclJhZGl1cywgX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMgLSBib3JkZXJXaWR0aCAvIDIsIHN0YXJ0QW5nbGUgKyBvdXRlckFuZ2xlQ2xpcCAvIDIsIGVuZEFuZ2xlIC0gb3V0ZXJBbmdsZUNsaXAgLyAyKTtcblxuICBpZiAoaW5uZXJSYWRpdXMgPiAwKSB7XG4gICAgY29uc3QgaW5uZXJBbmdsZUNsaXAgPSBNYXRoLm1pbihib3JkZXJXaWR0aCAvIGlubmVyUmFkaXVzLCBfbm9ybWFsaXplQW5nbGUoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSk7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cyArIGJvcmRlcldpZHRoIC8gMiwgZW5kQW5nbGUgLSBpbm5lckFuZ2xlQ2xpcCAvIDIsIHN0YXJ0QW5nbGUgKyBpbm5lckFuZ2xlQ2xpcCAvIDIsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNsaXBXaWR0aCA9IE1hdGgubWluKGJvcmRlcldpZHRoIC8gMiwgb3V0ZXJSYWRpdXMgKiBfbm9ybWFsaXplQW5nbGUoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSk7XG5cbiAgICBpZiAoYm9yZGVySm9pblN0eWxlID09PSAncm91bmQnKSB7XG4gICAgICBjdHguYXJjKHgsIHksIGNsaXBXaWR0aCwgZW5kQW5nbGUgLSBQSSAvIDIsIHN0YXJ0QW5nbGUgKyBQSSAvIDIsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoYm9yZGVySm9pblN0eWxlID09PSAnYmV2ZWwnKSB7XG4gICAgICBjb25zdCByID0gMiAqIGNsaXBXaWR0aCAqIGNsaXBXaWR0aDtcbiAgICAgIGNvbnN0IGVuZFggPSAtciAqIE1hdGguY29zKGVuZEFuZ2xlICsgUEkgLyAyKSArIHg7XG4gICAgICBjb25zdCBlbmRZID0gLXIgKiBNYXRoLnNpbihlbmRBbmdsZSArIFBJIC8gMikgKyB5O1xuICAgICAgY29uc3Qgc3RhcnRYID0gciAqIE1hdGguY29zKHN0YXJ0QW5nbGUgKyBQSSAvIDIpICsgeDtcbiAgICAgIGNvbnN0IHN0YXJ0WSA9IHIgKiBNYXRoLnNpbihzdGFydEFuZ2xlICsgUEkgLyAyKSArIHk7XG4gICAgICBjdHgubGluZVRvKGVuZFgsIGVuZFkpO1xuICAgICAgY3R4LmxpbmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgfVxuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcblxuICBjdHgubW92ZVRvKDAsIDApO1xuICBjdHgucmVjdCgwLCAwLCBjdHguY2FudmFzLndpZHRoLCBjdHguY2FudmFzLmhlaWdodCk7XG5cbiAgY3R4LmNsaXAoJ2V2ZW5vZGQnKTtcbn1cblxuXG5mdW5jdGlvbiBjbGlwQXJjKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBlbGVtZW50OiBBcmNFbGVtZW50LCBlbmRBbmdsZTogbnVtYmVyKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzfSA9IGVsZW1lbnQ7XG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XG5cbiAgLy8gRHJhdyBhbiBpbm5lciBib3JkZXIgYnkgY2xpcHBpbmcgdGhlIGFyYyBhbmQgZHJhd2luZyBhIGRvdWJsZS13aWR0aCBib3JkZXJcbiAgLy8gRW5sYXJnZSB0aGUgY2xpcHBpbmcgYXJjIGJ5IDAuMzMgcGl4ZWxzIHRvIGVsaW1pbmF0ZSBnbGl0Y2hlcyBiZXR3ZWVuIGJvcmRlcnNcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4pO1xuICBpZiAoaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuICAgIGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBpbm5lclJhZGl1cztcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5hcmMoeCwgeSwgcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgSEFMRl9QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gdG9SYWRpdXNDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWydvdXRlclN0YXJ0JywgJ291dGVyRW5kJywgJ2lubmVyU3RhcnQnLCAnaW5uZXJFbmQnXSk7XG59XG5cbi8qKlxuICogUGFyc2UgYm9yZGVyIHJhZGl1cyBmcm9tIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGFyYzogQXJjRWxlbWVudCwgaW5uZXJSYWRpdXM6IG51bWJlciwgb3V0ZXJSYWRpdXM6IG51bWJlciwgYW5nbGVEZWx0YTogbnVtYmVyKSB7XG4gIGNvbnN0IG8gPSB0b1JhZGl1c0Nvcm5lcnMoYXJjLm9wdGlvbnMuYm9yZGVyUmFkaXVzKTtcbiAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XG4gIGNvbnN0IGlubmVyTGltaXQgPSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBhbmdsZURlbHRhICogaW5uZXJSYWRpdXMgLyAyKTtcblxuICAvLyBPdXRlciBsaW1pdHMgYXJlIGNvbXBsaWNhdGVkLiBXZSB3YW50IHRvIGNvbXB1dGUgdGhlIGF2YWlsYWJsZSBhbmd1bGFyIGRpc3RhbmNlIGF0XG4gIC8vIGEgcmFkaXVzIG9mIG91dGVyUmFkaXVzIC0gYm9yZGVyUmFkaXVzIGJlY2F1c2UgZm9yIHNtYWxsIGFuZ3VsYXIgZGlzdGFuY2VzLCB0aGlzIHRlcm0gbGltaXRzLlxuICAvLyBXZSBjb21wdXRlIGF0IHIgPSBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIHRoaXMgY2lyY2xlIGRlZmluZXMgdGhlIGNlbnRlciBvZiB0aGUgYm9yZGVyIGNvcm5lcnMuXG4gIC8vXG4gIC8vIElmIHRoZSBib3JkZXJSYWRpdXMgaXMgbGFyZ2UsIHRoYXQgdmFsdWUgY2FuIGJlY29tZSBuZWdhdGl2ZS5cbiAgLy8gVGhpcyBjYXVzZXMgdGhlIG91dGVyIGJvcmRlcnMgdG8gbG9zZSB0aGVpciByYWRpdXMgZW50aXJlbHksIHdoaWNoIGlzIHJhdGhlciB1bmV4cGVjdGVkLiBUbyBzb2x2ZSB0aGF0LCBpZiBib3JkZXJSYWRpdXMgPiBvdXRlclJhZGl1c1xuICAvLyB3ZSBrbm93IHRoYXQgdGhlIHRoaWNrbmVzcyB0ZXJtIHdpbGwgZG9taW5hdGUgYW5kIGNvbXB1dGUgdGhlIGxpbWl0cyBhdCB0aGF0IHBvaW50XG4gIGNvbnN0IGNvbXB1dGVPdXRlckxpbWl0ID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG91dGVyQXJjTGltaXQgPSAob3V0ZXJSYWRpdXMgLSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCB2YWwpKSAqIGFuZ2xlRGVsdGEgLyAyO1xuICAgIHJldHVybiBfbGltaXRWYWx1ZSh2YWwsIDAsIE1hdGgubWluKGhhbGZUaGlja25lc3MsIG91dGVyQXJjTGltaXQpKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG91dGVyU3RhcnQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJTdGFydCksXG4gICAgb3V0ZXJFbmQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXG4gICAgaW5uZXJFbmQ6IF9saW1pdFZhbHVlKG8uaW5uZXJFbmQsIDAsIGlubmVyTGltaXQpLFxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgKHIsIPCdnIMpIHRvICh4LCB5KVxuICovXG5mdW5jdGlvbiByVGhldGFUb1hZKHI6IG51bWJlciwgdGhldGE6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICB5OiB5ICsgciAqIE1hdGguc2luKHRoZXRhKSxcbiAgfTtcbn1cblxuXG4vKipcbiAqIFBhdGggdGhlIGFyYywgcmVzcGVjdGluZyBib3JkZXIgcmFkaXVzIGJ5IHNlcGFyYXRpbmcgaW50byBsZWZ0IGFuZCByaWdodCBoYWx2ZXMuXG4gKlxuICogICBTdGFydCAgICAgIEVuZFxuICpcbiAqICAgIDEtLS0+YS0tLT4yICAgIE91dGVyXG4gKiAgIC8gICAgICAgICAgIFxcXG4gKiAgIDggICAgICAgICAgIDNcbiAqICAgfCAgICAgICAgICAgfFxuICogICB8ICAgICAgICAgICB8XG4gKiAgIDcgICAgICAgICAgIDRcbiAqICAgXFwgICAgICAgICAgIC9cbiAqICAgIDY8LS0tYjwtLS01ICAgIElubmVyXG4gKi9cbmZ1bmN0aW9uIHBhdGhBcmMoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBlbmQ6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGU6IHN0YXJ0LCBwaXhlbE1hcmdpbiwgaW5uZXJSYWRpdXM6IGlubmVyUn0gPSBlbGVtZW50O1xuXG4gIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiArIHNwYWNpbmcgKyBvZmZzZXQgKyBwaXhlbE1hcmdpbiA6IDA7XG5cbiAgbGV0IHNwYWNpbmdPZmZzZXQgPSAwO1xuICBjb25zdCBhbHBoYSA9IGVuZCAtIHN0YXJ0O1xuXG4gIGlmIChzcGFjaW5nKSB7XG4gICAgLy8gV2hlbiBzcGFjaW5nIGlzIHByZXNlbnQsIGl0IGlzIHRoZSBzYW1lIGZvciBhbGwgaXRlbXNcbiAgICAvLyBTbyB3ZSBhZGp1c3QgdGhlIHN0YXJ0IGFuZCBlbmQgYW5nbGUgb2YgdGhlIGFyYyBzdWNoIHRoYXRcbiAgICAvLyB0aGUgZGlzdGFuY2UgaXMgdGhlIHNhbWUgYXMgaXQgd291bGQgYmUgd2l0aG91dCB0aGUgc3BhY2luZ1xuICAgIGNvbnN0IG5vU3BhY2luZ0lubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBhdk5vZ1NwYWNpbmdSYWRpdXMgPSAobm9TcGFjaW5nSW5uZXJSYWRpdXMgKyBub1NwYWNpbmdPdXRlclJhZGl1cykgLyAyO1xuICAgIGNvbnN0IGFkanVzdGVkQW5nbGUgPSBhdk5vZ1NwYWNpbmdSYWRpdXMgIT09IDAgPyAoYWxwaGEgKiBhdk5vZ1NwYWNpbmdSYWRpdXMpIC8gKGF2Tm9nU3BhY2luZ1JhZGl1cyArIHNwYWNpbmcpIDogYWxwaGE7XG4gICAgc3BhY2luZ09mZnNldCA9IChhbHBoYSAtIGFkanVzdGVkQW5nbGUpIC8gMjtcbiAgfVxuXG4gIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgY29uc3Qge291dGVyU3RhcnQsIG91dGVyRW5kLCBpbm5lclN0YXJ0LCBpbm5lckVuZH0gPSBwYXJzZUJvcmRlclJhZGl1cyhlbGVtZW50LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG5cbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XG5cbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lclN0YXJ0O1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lckVuZDtcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgaW5uZXJTdGFydCAvIGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBpbm5lckVuZCAvIGlubmVyRW5kQWRqdXN0ZWRSYWRpdXM7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIGlmIChjaXJjdWxhcikge1xuICAgIC8vIFRoZSBmaXJzdCBhcmMgc2VnbWVudHMgZnJvbSBwb2ludCAxIHRvIHBvaW50IGEgdG8gcG9pbnQgMlxuICAgIGNvbnN0IG91dGVyTWlkQWRqdXN0ZWRBbmdsZSA9IChvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSArIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgLyAyO1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlck1pZEFkanVzdGVkQW5nbGUpO1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyTWlkQWRqdXN0ZWRBbmdsZSwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDIgdG8gcG9pbnQgM1xuICAgIGlmIChvdXRlckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgMyB0byBwb2ludCA0XG4gICAgY29uc3QgcDQgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGVuZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA0LngsIHA0LnkpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNCB0byBwb2ludCA1XG4gICAgaWYgKGlubmVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBpbm5lciBhcmMgZnJvbSBwb2ludCA1IHRvIHBvaW50IGIgdG8gcG9pbnQgNlxuICAgIGNvbnN0IGlubmVyTWlkQWRqdXN0ZWRBbmdsZSA9ICgoZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cykpICsgKHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSkpIC8gMjtcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSwgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlLCB0cnVlKTtcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBpbm5lck1pZEFkanVzdGVkQW5nbGUsIHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSwgdHJ1ZSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA2IHRvIHBvaW50IDdcbiAgICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cywgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGxpbmUgZnJvbSBwb2ludCA3IHRvIHBvaW50IDhcbiAgICBjb25zdCBwOCA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBzdGFydEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA4LngsIHA4LnkpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgOCB0byBwb2ludCAxXG4gICAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG5cbiAgICBjb25zdCBvdXRlclN0YXJ0WCA9IE1hdGguY29zKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlclN0YXJ0WSA9IE1hdGguc2luKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyU3RhcnRYLCBvdXRlclN0YXJ0WSk7XG5cbiAgICBjb25zdCBvdXRlckVuZFggPSBNYXRoLmNvcyhvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyRW5kWSA9IE1hdGguc2luKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlckVuZFgsIG91dGVyRW5kWSk7XG4gIH1cblxuICBjdHguY2xvc2VQYXRoKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdBcmMoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2V9ID0gZWxlbWVudDtcbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChjaXJjdW1mZXJlbmNlICUgVEFVIHx8IFRBVSk7XG4gICAgfVxuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gIGN0eC5maWxsKCk7XG4gIHJldHVybiBlbmRBbmdsZTtcbn1cblxuZnVuY3Rpb24gZHJhd0JvcmRlcihcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGVsZW1lbnQ6IEFyY0VsZW1lbnQsXG4gIG9mZnNldDogbnVtYmVyLFxuICBzcGFjaW5nOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZSwgb3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCB7Ym9yZGVyV2lkdGgsIGJvcmRlckpvaW5TdHlsZSwgYm9yZGVyRGFzaCwgYm9yZGVyRGFzaE9mZnNldCwgYm9yZGVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlubmVyID0gb3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJztcblxuICBpZiAoIWJvcmRlcldpZHRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LnNldExpbmVEYXNoKGJvcmRlckRhc2ggfHwgW10pO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSBib3JkZXJEYXNoT2Zmc2V0O1xuXG4gIGlmIChpbm5lcikge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAqIDI7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdyb3VuZCc7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAnYmV2ZWwnO1xuICB9XG5cbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGNpcmN1bWZlcmVuY2UgJSBUQVUgfHwgVEFVKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuc2VsZkpvaW4gJiYgZW5kQW5nbGUgLSBzdGFydEFuZ2xlID49IFBJICYmIGJvcmRlclJhZGl1cyA9PT0gMCAmJiBib3JkZXJKb2luU3R5bGUgIT09ICdtaXRlcicpIHtcbiAgICBjbGlwU2VsZihjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmICghZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFyY1Byb3BzIGV4dGVuZHMgUG9pbnQge1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG4gIGVuZEFuZ2xlOiBudW1iZXI7XG4gIGlubmVyUmFkaXVzOiBudW1iZXI7XG4gIG91dGVyUmFkaXVzOiBudW1iZXI7XG4gIGNpcmN1bWZlcmVuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ8QXJjUHJvcHMsIEFyY09wdGlvbnM+IHtcblxuICBzdGF0aWMgaWQgPSAnYXJjJztcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyQWxpZ246ICdjZW50ZXInLFxuICAgIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgICBib3JkZXJKb2luU3R5bGU6IHVuZGVmaW5lZCxcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHNwYWNpbmc6IDAsXG4gICAgYW5nbGU6IHVuZGVmaW5lZCxcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBzZWxmSm9pbjogZmFsc2UsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnXG4gIH07XG5cbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBmdWxsQ2lyY2xlczogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBwaXhlbE1hcmdpbjogbnVtYmVyO1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGluUmFuZ2UoY2hhcnRYOiBudW1iZXIsIGNoYXJ0WTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9ICh0aGlzLm9wdGlvbnMuc3BhY2luZyArIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCkgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBub25aZXJvQmV0d2VlbiA9IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSAmJiBzdGFydEFuZ2xlICE9PSBlbmRBbmdsZTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IG5vblplcm9CZXR3ZWVuO1xuICAgIGNvbnN0IHdpdGhpblJhZGl1cyA9IF9pc0JldHdlZW4oZGlzdGFuY2UsIGlubmVyUmFkaXVzICsgckFkanVzdCwgb3V0ZXJSYWRpdXMgKyByQWRqdXN0KTtcblxuICAgIHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3gnLFxuICAgICAgJ3knLFxuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge29mZnNldCwgc3BhY2luZ30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xuICAgIGNvbnN0IGhhbGZSYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzXG4gICAgfTtcbiAgfVxuXG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcztcbiAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5vZmZzZXQgfHwgMCkgLyA0O1xuICAgIGNvbnN0IHNwYWNpbmcgPSAob3B0aW9ucy5zcGFjaW5nIHx8IDApIC8gMjtcbiAgICBjb25zdCBjaXJjdWxhciA9IG9wdGlvbnMuY2lyY3VsYXI7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IChvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSBjaXJjdW1mZXJlbmNlID4gVEFVID8gTWF0aC5mbG9vcihjaXJjdW1mZXJlbmNlIC8gVEFVKSA6IDA7XG5cbiAgICBpZiAoY2lyY3VtZmVyZW5jZSA9PT0gMCB8fCB0aGlzLmlubmVyUmFkaXVzIDwgMCB8fCB0aGlzLm91dGVyUmFkaXVzIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBjb25zdCBoYWxmQW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICsgdGhpcy5lbmRBbmdsZSkgLyAyO1xuICAgIGN0eC50cmFuc2xhdGUoTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIG9mZnNldCwgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIG9mZnNldCk7XG4gICAgY29uc3QgZml4ID0gMSAtIE1hdGguc2luKE1hdGgubWluKFBJLCBjaXJjdW1mZXJlbmNlIHx8IDApKTtcbiAgICBjb25zdCByYWRpdXNPZmZzZXQgPSBvZmZzZXQgKiBmaXg7XG5cbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcblxuICAgIGRyYXdBcmMoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcbiAgICBkcmF3Qm9yZGVyKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG4iLCJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19iZXppZXJJbnRlcnBvbGF0aW9uLCBfcG9pbnRJbkxpbmUsIF9zdGVwcGVkSW50ZXJwb2xhdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24uanMnO1xuaW1wb3J0IHtfY29tcHV0ZVNlZ21lbnRzLCBfYm91bmRTZWdtZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMnO1xuaW1wb3J0IHtfc3RlcHBlZExpbmVUbywgX2JlemllckN1cnZlVG99IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmN1cnZlLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cblxuZnVuY3Rpb24gbGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCkge1xuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cblxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVyQ3VydmVUbztcbiAgfVxuXG4gIHJldHVybiBsaW5lVG87XG59XG5cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBjb3VudCxcbiAgICBzdGFydCxcbiAgICBsb29wOiBzZWdtZW50Lmxvb3AsXG4gICAgaWxlbjogZW5kIDwgc3RhcnQgJiYgIW91dHNpZGUgPyBjb3VudCArIGVuZCAtIHN0YXJ0IDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGkgOiBpKSkgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBza2lwcGVkIHBvaW50IGluc2lkZSBhIHNlZ21lbnQsIHNwYW5HYXBzIG11c3QgYmUgdHJ1ZVxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuXG4gICAgcHJldiA9IHBvaW50O1xuICB9XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gOiAwKSkgJSBjb3VudF07XG4gICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICB9XG5cbiAgcmV0dXJuICEhbG9vcDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG5cbiAgY29uc3QgcG9pbnRJbmRleCA9IChpbmRleCkgPT4gKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaW5kZXggOiBpbmRleCkpICUgY291bnQ7XG4gIGNvbnN0IGRyYXdYID0gKCkgPT4ge1xuICAgIGlmIChtaW5ZICE9PSBtYXhZKSB7XG4gICAgICAvLyBEcmF3IGxpbmUgdG8gbWF4WSBhbmQgbWluWSwgdXNpbmcgdGhlIGF2ZXJhZ2UgeC1jb29yZGluYXRlXG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcbiAgICAgIC8vIExpbmUgdG8geS12YWx1ZSBvZiBsYXN0IHBvaW50IGluIGdyb3VwLiBTbyB0aGUgbGluZSBjb250aW51ZXNcbiAgICAgIC8vIGZyb20gY29ycmVjdCBwb3NpdGlvbi4gTm90IHVzaW5nIG1vdmUsIHRvIGhhdmUgc29saWQgcGF0aC5cbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbGFzdFkpO1xuICAgIH1cbiAgfTtcblxuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2tpcHBlZCBwb2ludCBpbnNpZGUgYSBzZWdtZW50LCBzcGFuR2FwcyBtdXN0IGJlIHRydWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwOyAvLyB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgLy8gRHJhdyBsaW5lIHRvIG5leHQgeC1wb3NpdGlvbiwgdXNpbmcgdGhlIGZpcnN0IChvciBvbmx5KVxuICAgICAgLy8geS12YWx1ZSBpbiB0aGF0IGdyb3VwXG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgeS12YWx1ZSBpbiBncm91cFxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmUgLSB0aGUgbGluZVxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cblxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuXG5mdW5jdGlvbiBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGxldCBwYXRoID0gbGluZS5fcGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcGF0aCA9IGxpbmUuX3BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGxpbmUucGF0aChwYXRoLCBzdGFydCwgY291bnQpKSB7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XG4gIGN0eC5zdHJva2UocGF0aCk7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICBzdGF0aWMgaWQgPSAnbGluZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgICBib3JkZXJXaWR0aDogMyxcbiAgICBjYXBCZXppZXJQb2ludHM6IHRydWUsXG4gICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICAgIGZpbGw6IGZhbHNlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgICBzdGVwcGVkOiBmYWxzZSxcbiAgICB0ZW5zaW9uOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnLFxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHBvaW50cyhwb2ludHMpIHtcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgZGVsZXRlIHRoaXMuX3NlZ21lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9wYXRoO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgfVxuXG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZpcnN0IG5vbi1za2lwcGVkIHBvaW50IG9uIHRoaXMgbGluZVxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cblxuICAvKipcblx0ICogTGFzdCBub24tc2tpcHBlZCBwb2ludCBvbiB0aGlzIGxpbmVcblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBsYXN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gY291bnQgJiYgcG9pbnRzW3NlZ21lbnRzW2NvdW50IC0gMV0uZW5kXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBJbnRlcnBvbGF0ZSBhIHBvaW50IGluIHRoaXMgbGluZSBhdCB0aGUgc2FtZSB2YWx1ZSBvbiBgcHJvcGVydHlgIGFzXG5cdCAqIHRoZSByZWZlcmVuY2UgYHBvaW50YCBwcm92aWRlZFxuXHQgKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gcG9pbnQgLSB0aGUgcmVmZXJlbmNlIHBvaW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSB0byBtYXRjaCBvblxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuXG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50c1tpXTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRzW3N0YXJ0XTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRzW2VuZF07XG4gICAgICBpZiAocDEgPT09IHAyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKHZhbHVlIC0gcDFbcHJvcGVydHldKSAvIChwMltwcm9wZXJ0eV0gLSBwMVtwcm9wZXJ0eV0pKTtcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZCA9IF9pbnRlcnBvbGF0ZShwMSwgcDIsIHQsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xuICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2xhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGEgc2VnbWVudCBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuXHQgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBzZWdtZW50IGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGFsbCBzZWdtZW50cyBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IC0gdHJ1ZSBpZiBsaW5lIGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG5cbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgY291bnQgPSBjb3VudCB8fCAodGhpcy5wb2ludHMubGVuZ3RoIC0gc3RhcnQpO1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QXJlYVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKi9cbiAgZHJhdyhjdHgsIGNoYXJ0QXJlYSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cyB8fCBbXTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoICYmIG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICAvLyBXaGVuIGxpbmUgaXMgYW5pbWF0ZWQsIHRoZSBjb250cm9sIHBvaW50cyBhbmQgcGF0aCBhcmUgbm90IGNhY2hlZC5cbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2RyYXdQb2ludCwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge1xuICBDYXJ0ZXNpYW5QYXJzZWREYXRhLFxuICBDaGFydEFyZWEsXG4gIFBvaW50LFxuICBQb2ludEhvdmVyT3B0aW9ucyxcbiAgUG9pbnRPcHRpb25zLFxufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGluUmFuZ2UoZWw6IFBvaW50RWxlbWVudCwgcG9zOiBudW1iZXIsIGF4aXM6ICd4JyB8ICd5JywgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gIGNvbnN0IHtbYXhpc106IHZhbHVlfSA9IGVsLmdldFByb3BzKFtheGlzXSwgdXNlRmluYWxQb3NpdGlvbik7XG5cbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cblxuZXhwb3J0IHR5cGUgUG9pbnRQcm9wcyA9IFBvaW50XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ8UG9pbnRQcm9wcywgUG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+IHtcblxuICBzdGF0aWMgaWQgPSAncG9pbnQnO1xuXG4gIHBhcnNlZDogQ2FydGVzaWFuUGFyc2VkRGF0YTtcbiAgc2tpcD86IGJvb2xlYW47XG4gIHN0b3A/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlcldpZHRoOiAxLFxuICAgIGhpdFJhZGl1czogMSxcbiAgICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICAgIGhvdmVyUmFkaXVzOiA0LFxuICAgIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICAgIHJhZGl1czogMyxcbiAgICByb3RhdGlvbjogMFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5za2lwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RvcCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWDogbnVtYmVyLCBtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuICgoTWF0aC5wb3cobW91c2VYIC0geCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB5LCAyKSkgPCBNYXRoLnBvdyhvcHRpb25zLmhpdFJhZGl1cyArIG9wdGlvbnMucmFkaXVzLCAyKSk7XG4gIH1cblxuICBpblhSYW5nZShtb3VzZVg6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsICd4JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpbllSYW5nZShtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVksICd5JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuXG4gIHNpemUob3B0aW9ucz86IFBhcnRpYWw8UG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFyZWE6IENoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAodGhpcy5za2lwIHx8IG9wdGlvbnMucmFkaXVzIDwgMC4xIHx8ICFfaXNQb2ludEluQXJlYSh0aGlzLCBhcmVhLCB0aGlzLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuXG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBGYWxsYmFja3Mgc2hvdWxkIG5ldmVyIGJlIGhpdCBpbiBwcmFjdGljZVxuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG4iLCJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCBfaXNCZXR3ZWVuLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge3RvVFJCTCwgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG4vKiogQHR5cGVkZWYge3sgeDogbnVtYmVyLCB5OiBudW1iZXIsIGJhc2U6IG51bWJlciwgaG9yaXpvbnRhbDogYm9vbGVhbiwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gQmFyUHJvcHMgKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIGJhciByZWdhcmRsZXNzIG9mIHRoZSBvcmllbnRhdGlvblxuICogQHBhcmFtIHtCYXJFbGVtZW50fSBiYXIgdGhlIGJhclxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl1cbiAqIEByZXR1cm4ge29iamVjdH0gYm91bmRzIG9mIHRoZSBiYXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qge3gsIHksIGJhc2UsIHdpZHRoLCBoZWlnaHR9ID0gLyoqIEB0eXBlIHtCYXJQcm9wc30gKi8gKGJhci5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddLCB1c2VGaW5hbFBvc2l0aW9uKSk7XG5cbiAgbGV0IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgaGFsZjtcblxuICBpZiAoYmFyLmhvcml6b250YWwpIHtcbiAgICBoYWxmID0gaGVpZ2h0IC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XG4gICAgcmlnaHQgPSBNYXRoLm1heCh4LCBiYXNlKTtcbiAgICB0b3AgPSB5IC0gaGFsZjtcbiAgICBib3R0b20gPSB5ICsgaGFsZjtcbiAgfSBlbHNlIHtcbiAgICBoYWxmID0gd2lkdGggLyAyO1xuICAgIGxlZnQgPSB4IC0gaGFsZjtcbiAgICByaWdodCA9IHggKyBoYWxmO1xuICAgIHRvcCA9IE1hdGgubWluKHksIGJhc2UpO1xuICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xuICB9XG5cbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219O1xufVxuXG5mdW5jdGlvbiBza2lwT3JMaW1pdChza2lwLCB2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHNraXAgPyAwIDogX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aChiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBvID0gdG9UUkJMKHZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIHQ6IHNraXBPckxpbWl0KHNraXAudG9wLCBvLnRvcCwgMCwgbWF4SCksXG4gICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXG4gICAgYjogc2tpcE9yTGltaXQoc2tpcC5ib3R0b20sIG8uYm90dG9tLCAwLCBtYXhIKSxcbiAgICBsOiBza2lwT3JMaW1pdChza2lwLmxlZnQsIG8ubGVmdCwgMCwgbWF4VylcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHtlbmFibGVCb3JkZXJSYWRpdXN9ID0gYmFyLmdldFByb3BzKFsnZW5hYmxlQm9yZGVyUmFkaXVzJ10pO1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlclJhZGl1cztcbiAgY29uc3QgbyA9IHRvVFJCTENvcm5lcnModmFsdWUpO1xuICBjb25zdCBtYXhSID0gTWF0aC5taW4obWF4VywgbWF4SCk7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcblxuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LCBhc3N1bWUgdGhlIHVzZXIga25vd3Mgd2hhdCB0aGV5IGFyZSBkb2luZ1xuICAvLyBhbmQgYXBwbHkgYXMgZGlyZWN0ZWQuXG4gIGNvbnN0IGVuYWJsZUJvcmRlciA9IGVuYWJsZUJvcmRlclJhZGl1cyB8fCBpc09iamVjdCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3BMZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAubGVmdCwgby50b3BMZWZ0LCAwLCBtYXhSKSxcbiAgICB0b3BSaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLnJpZ2h0LCBvLnRvcFJpZ2h0LCAwLCBtYXhSKSxcbiAgICBib3R0b21MZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAubGVmdCwgby5ib3R0b21MZWZ0LCAwLCBtYXhSKSxcbiAgICBib3R0b21SaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCBtYXhSKVxuICB9O1xufVxuXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKGJhcikge1xuICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcbiAgY29uc3Qgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG4gIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICBjb25zdCByYWRpdXMgPSBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICB5OiBib3VuZHMudG9wLFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHQsXG4gICAgICByYWRpdXNcbiAgICB9LFxuICAgIGlubmVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuICAgICAgeTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuICAgICAgdzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuICAgICAgaDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYixcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxuICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcFJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5yKSksXG4gICAgICAgIGJvdHRvbUxlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21MZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5sKSksXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluUmFuZ2UoYmFyLCB4LCB5LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHNraXBYID0geCA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcFkgPSB5ID09PSBudWxsO1xuICBjb25zdCBza2lwQm90aCA9IHNraXBYICYmIHNraXBZO1xuICBjb25zdCBib3VuZHMgPSBiYXIgJiYgIXNraXBCb3RoICYmIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pO1xuXG4gIHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgX2lzQmV0d2Vlbih4LCBib3VuZHMubGVmdCwgYm91bmRzLnJpZ2h0KSlcblx0XHQmJiAoc2tpcFkgfHwgX2lzQmV0d2Vlbih5LCBib3VuZHMudG9wLCBib3VuZHMuYm90dG9tKSk7XG59XG5cbmZ1bmN0aW9uIGhhc1JhZGl1cyhyYWRpdXMpIHtcbiAgcmV0dXJuIHJhZGl1cy50b3BMZWZ0IHx8IHJhZGl1cy50b3BSaWdodCB8fCByYWRpdXMuYm90dG9tTGVmdCB8fCByYWRpdXMuYm90dG9tUmlnaHQ7XG59XG5cbi8qKlxuICogQWRkIGEgcGF0aCBvZiBhIHJlY3RhbmdsZSB0byB0aGUgY3VycmVudCBzdWItcGF0aFxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0XG4gKiBAcGFyYW0geyp9IHJlY3QgQm91bmRpbmcgcmVjdFxuICovXG5mdW5jdGlvbiBhZGROb3JtYWxSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlY3QocmVjdCwgYW1vdW50LCByZWZSZWN0ID0ge30pIHtcbiAgY29uc3QgeCA9IHJlY3QueCAhPT0gcmVmUmVjdC54ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHkgPSByZWN0LnkgIT09IHJlZlJlY3QueSA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB3ID0gKHJlY3QueCArIHJlY3QudyAhPT0gcmVmUmVjdC54ICsgcmVmUmVjdC53ID8gYW1vdW50IDogMCkgLSB4O1xuICBjb25zdCBoID0gKHJlY3QueSArIHJlY3QuaCAhPT0gcmVmUmVjdC55ICsgcmVmUmVjdC5oID8gYW1vdW50IDogMCkgLSB5O1xuICByZXR1cm4ge1xuICAgIHg6IHJlY3QueCArIHgsXG4gICAgeTogcmVjdC55ICsgeSxcbiAgICB3OiByZWN0LncgKyB3LFxuICAgIGg6IHJlY3QuaCArIGgsXG4gICAgcmFkaXVzOiByZWN0LnJhZGl1c1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgc3RhdGljIGlkID0gJ2Jhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyU2tpcHBlZDogJ3N0YXJ0JyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgaW5mbGF0ZUFtb3VudDogJ2F1dG8nLFxuICAgIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5mbGF0ZUFtb3VudCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtpbmZsYXRlQW1vdW50LCBvcHRpb25zOiB7Ym9yZGVyQ29sb3IsIGJhY2tncm91bmRDb2xvcn19ID0gdGhpcztcbiAgICBjb25zdCB7aW5uZXIsIG91dGVyfSA9IGJvdW5kaW5nUmVjdHModGhpcyk7XG4gICAgY29uc3QgYWRkUmVjdFBhdGggPSBoYXNSYWRpdXMob3V0ZXIucmFkaXVzKSA/IGFkZFJvdW5kZWRSZWN0UGF0aCA6IGFkZE5vcm1hbFJlY3RQYXRoO1xuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGlmIChvdXRlci53ICE9PSBpbm5lci53IHx8IG91dGVyLmggIT09IGlubmVyLmgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3Qob3V0ZXIsIGluZmxhdGVBbW91bnQsIGlubmVyKSk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgLWluZmxhdGVBbW91bnQsIG91dGVyKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgIH1cblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCBpbmZsYXRlQW1vdW50KSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG51bGwsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgYmFzZSwgaG9yaXpvbnRhbH0gPSAvKiogQHR5cGUge0JhclByb3BzfSAqLyAodGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbikpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxuICAgICAgeTogaG9yaXpvbnRhbCA/IHkgOiAoeSArIGJhc2UpIC8gMlxuICAgIH07XG4gIH1cblxuICBnZXRSYW5nZShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG4iLCJpbXBvcnQge0RvdWdobnV0Q29udHJvbGxlciwgUG9sYXJBcmVhQ29udHJvbGxlciwgZGVmYXVsdHN9IGZyb20gJy4uL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtDaGFydCwgQ2hhcnREYXRhc2V0fSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JzUGx1Z2luT3B0aW9ucyB7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICBmb3JjZU92ZXJyaWRlPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIENvbG9yc0Rlc2NyaXB0b3Ige1xuICBiYWNrZ3JvdW5kQ29sb3I/OiB1bmtub3duO1xuICBib3JkZXJDb2xvcj86IHVua25vd247XG59XG5cbmNvbnN0IEJPUkRFUl9DT0xPUlMgPSBbXG4gICdyZ2IoNTQsIDE2MiwgMjM1KScsIC8vIGJsdWVcbiAgJ3JnYigyNTUsIDk5LCAxMzIpJywgLy8gcmVkXG4gICdyZ2IoMjU1LCAxNTksIDY0KScsIC8vIG9yYW5nZVxuICAncmdiKDI1NSwgMjA1LCA4NiknLCAvLyB5ZWxsb3dcbiAgJ3JnYig3NSwgMTkyLCAxOTIpJywgLy8gZ3JlZW5cbiAgJ3JnYigxNTMsIDEwMiwgMjU1KScsIC8vIHB1cnBsZVxuICAncmdiKDIwMSwgMjAzLCAyMDcpJyAvLyBncmV5XG5dO1xuXG4vLyBCb3JkZXIgY29sb3JzIHdpdGggNTAlIHRyYW5zcGFyZW5jeVxuY29uc3QgQkFDS0dST1VORF9DT0xPUlMgPSAvKiAjX19QVVJFX18gKi8gQk9SREVSX0NPTE9SUy5tYXAoY29sb3IgPT4gY29sb3IucmVwbGFjZSgncmdiKCcsICdyZ2JhKCcpLnJlcGxhY2UoJyknLCAnLCAwLjUpJykpO1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJDb2xvcihpOiBudW1iZXIpIHtcbiAgcmV0dXJuIEJPUkRFUl9DT0xPUlNbaSAlIEJPUkRFUl9DT0xPUlMubGVuZ3RoXTtcbn1cblxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZENvbG9yKGk6IG51bWJlcikge1xuICByZXR1cm4gQkFDS0dST1VORF9DT0xPUlNbaSAlIEJBQ0tHUk9VTkRfQ09MT1JTLmxlbmd0aF07XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplRGVmYXVsdERhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5ib3JkZXJDb2xvciA9IGdldEJvcmRlckNvbG9yKGkpO1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGdldEJhY2tncm91bmRDb2xvcihpKTtcblxuICByZXR1cm4gKytpO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZURvdWdobnV0RGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuZGF0YS5tYXAoKCkgPT4gZ2V0Qm9yZGVyQ29sb3IoaSsrKSk7XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuZGF0YS5tYXAoKCkgPT4gZ2V0QmFja2dyb3VuZENvbG9yKGkrKykpO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBnZXRDb2xvcml6ZXIoY2hhcnQ6IENoYXJ0KSB7XG4gIGxldCBpID0gMDtcblxuICByZXR1cm4gKGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgZGF0YXNldEluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBEb3VnaG51dENvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZURvdWdobnV0RGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBQb2xhckFyZWFDb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVQb2xhckFyZWFEYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplRGVmYXVsdERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKFxuICBkZXNjcmlwdG9yczogQ29sb3JzRGVzY3JpcHRvcltdIHwgUmVjb3JkPHN0cmluZywgQ29sb3JzRGVzY3JpcHRvcj5cbikge1xuICBsZXQgazogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIGZvciAoayBpbiBkZXNjcmlwdG9ycykge1xuICAgIGlmIChkZXNjcmlwdG9yc1trXS5ib3JkZXJDb2xvciB8fCBkZXNjcmlwdG9yc1trXS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKFxuICBkZXNjcmlwdG9yOiBDb2xvcnNEZXNjcmlwdG9yXG4pIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgKGRlc2NyaXB0b3IuYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvci5iYWNrZ3JvdW5kQ29sb3IpO1xufVxuXG5mdW5jdGlvbiBjb250YWluc0RlZmF1bHRDb2xvcnNEZWZlbml0aW9ucygpIHtcbiAgcmV0dXJuIGRlZmF1bHRzLmJvcmRlckNvbG9yICE9PSAncmdiYSgwLDAsMCwwLjEpJyB8fCBkZWZhdWx0cy5iYWNrZ3JvdW5kQ29sb3IgIT09ICdyZ2JhKDAsMCwwLDAuMSknO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnY29sb3JzJyxcblxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm9yY2VPdmVycmlkZTogZmFsc2VcbiAgfSBhcyBDb2xvcnNQbHVnaW5PcHRpb25zLFxuXG4gIGJlZm9yZUxheW91dChjaGFydDogQ2hhcnQsIF9hcmdzLCBvcHRpb25zOiBDb2xvcnNQbHVnaW5PcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7ZGF0YXNldHN9LFxuICAgICAgb3B0aW9uczogY2hhcnRPcHRpb25zXG4gICAgfSA9IGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCB7ZWxlbWVudHN9ID0gY2hhcnRPcHRpb25zO1xuXG4gICAgY29uc3QgY29udGFpbnNDb2xvckRlZmVuaXRpb24gPSAoXG4gICAgICBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGRhdGFzZXRzKSB8fFxuICAgICAgY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKGNoYXJ0T3B0aW9ucykgfHxcbiAgICAgIChlbGVtZW50cyAmJiBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGVsZW1lbnRzKSkgfHxcbiAgICAgIGNvbnRhaW5zRGVmYXVsdENvbG9yc0RlZmVuaXRpb25zKCkpO1xuXG4gICAgaWYgKCFvcHRpb25zLmZvcmNlT3ZlcnJpZGUgJiYgY29udGFpbnNDb2xvckRlZmVuaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb2xvcml6ZXIgPSBnZXRDb2xvcml6ZXIoY2hhcnQpO1xuXG4gICAgZGF0YXNldHMuZm9yRWFjaChjb2xvcml6ZXIpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtfbGltaXRWYWx1ZSwgX2xvb2t1cEJ5S2V5LCBpc051bGxPclVuZGVmLCByZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIExhcmdlc3QgVHJpYW5nbGUgVGhyZWUgQnVja2V0cyBhbGdvcml0aG0uXG4gICAqXG4gICAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGJ5IFN2ZWlubiBTdGVpbmFyc3NvblxuICAgKiBpbiBodHRwczovL2dpdGh1Yi5jb20vc3ZlaW5uLXN0ZWluYXJzc29uL2Zsb3QtZG93bnNhbXBsZS9ibG9iL21hc3Rlci9qcXVlcnkuZmxvdC5kb3duc2FtcGxlLmpzXG4gICAqXG4gICAqIFRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBpcyBNSVQgbGljZW5zZWQuXG4gICAqL1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICAvLyBUaGVyZSBhcmUgbGVzcyBwb2ludHMgdGhhbiB0aGUgdGhyZXNob2xkLCByZXR1cm5pbmcgdGhlIHdob2xlIGFycmF5XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG5cbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG5cbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICAvLyBTdGFydGluZyBmcm9tIG9mZnNldFxuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcblxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKykge1xuICAgIGxldCBhdmdYID0gMDtcbiAgICBsZXQgYXZnWSA9IDA7XG4gICAgbGV0IGo7XG5cbiAgICAvLyBBZGRpbmcgb2Zmc2V0XG4gICAgY29uc3QgYXZnUmFuZ2VTdGFydCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUVuZCA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAyKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xuXG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuXG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGNoYW5nZWQgZnJvbSB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIHdoaWNoIGluaXRpYWxpemVzIHRoZXNlXG4gICAgLy8gdmFsdWVzIHRvIDEuIFRoZSByZWFzb24gZm9yIHRoaXMgY2hhbmdlIGlzIHRoYXQgaWYgdGhlIGFyZWEgaXMgc21hbGwsIG5leHRBXG4gICAgLy8gd291bGQgbmV2ZXIgYmUgc2V0IGFuZCB0aHVzIGEgY3Jhc2ggd291bGQgb2NjdXIgaW4gdGhlIG5leHQgbG9vcCBhcyBgYWAgd291bGQgYmVjb21lXG4gICAgLy8gYHVuZGVmaW5lZGAuIFNpbmNlIHRoZSBhcmVhIGlzIGFsd2F5cyBwb3NpdGl2ZSwgYnV0IGNvdWxkIGJlIDAgaW4gdGhlIGNhc2Ugb2YgYSBmbGF0IHRyYWNlLFxuICAgIC8vIGluaXRpYWxpemluZyB3aXRoIGEgbmVnYXRpdmUgbnVtYmVyIGlzIHRoZSBjb3JyZWN0IHNvbHV0aW9uLlxuICAgIG1heEFyZWEgPSBhcmVhID0gLTE7XG5cbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG5cbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBtYXhBcmVhUG9pbnQ7XG4gICAgYSA9IG5leHRBO1xuICB9XG5cbiAgLy8gSW5jbHVkZSB0aGUgbGFzdCBwb2ludFxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG5cbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuXG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgcG9pbnQgPSBkYXRhW2ldO1xuICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcbiAgICB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcblxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgYG1pbllgIC8gYG1heFlgIGFuZCBgYXZnWGAgd2hpbGUgd2Ugc3RheSB3aXRoaW4gc2FtZSB4LXBvc2l0aW9uXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICAvLyBVc2UgcG9pbnQueCBoZXJlIGJlY2F1c2Ugd2UncmUgY29tcHV0aW5nIHRoZSBhdmVyYWdlIGRhdGEgYHhgIHZhbHVlXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyBwb2ludC54KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQdXNoIHVwIHRvIDQgcG9pbnRzLCAzIGZvciB0aGUgbGFzdCBpbnRlcnZhbCBhbmQgdGhlIGZpcnN0IHBvaW50IGZvciB0aGlzIGludGVydmFsXG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBpIC0gMTtcblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgLy8gVGhlIGludGVydmFsIGlzIGRlZmluZWQgYnkgNCBwb2ludHM6IHN0YXJ0LCBtaW4sIG1heCwgZW5kLlxuICAgICAgICAvLyBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgYWxyZWFkeSBjb25zaWRlcmVkIGF0IHRoaXMgcG9pbnQsIHNvIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgIC8vIG9mIHRoZSBvdGhlciBwb2ludHMgdG8gYWRkLiBXZSBuZWVkIHRvIHNvcnQgdGhlc2UgcG9pbnRzIHRvIGVuc3VyZSB0aGUgZGVjaW1hdGVkIGRhdGFcbiAgICAgICAgLy8gaXMgc3RpbGwgc29ydGVkIGFuZCB0aGVuIGVuc3VyZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlcy5cbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcblxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxhc3RJbmRleCA9PT0gc3RhcnRJbmRleCB3aWxsIG9jY3VyIHdoZW4gYSByYW5nZSBoYXMgb25seSAxIHBvaW50IHdoaWNoIGNvdWxkXG4gICAgICAvLyBoYXBwZW4gd2l0aCB2ZXJ5IHVuZXZlbiBkYXRhXG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIC8vIExhc3QgcG9pbnQgaW4gdGhlIHByZXZpb3VzIGludGVydmFsXG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IG9mIHRoZSBuZXcgaW50ZXJ2YWxcbiAgICAgIGRlY2ltYXRlZC5wdXNoKHBvaW50KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICAgIG1pbkluZGV4ID0gbWF4SW5kZXggPSBzdGFydEluZGV4ID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpIHtcbiAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcblxuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnZGVjaW1hdGlvbicsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcblxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIC8vIFRoZSBkZWNpbWF0aW9uIHBsdWdpbiBtYXkgaGF2ZSBiZWVuIHByZXZpb3VzbHkgZW5hYmxlZC4gTmVlZCB0byByZW1vdmUgb2xkIGBkYXRhc2V0Ll9kYXRhYCBoYW5kbGVyc1xuICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBc3N1bWUgdGhlIGVudGlyZSBjaGFydCBpcyBhdmFpbGFibGUgdG8gc2hvdyBhIGZldyBtb3JlIHBvaW50cyB0aGFuIG5lZWRlZFxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG5cbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qge19kYXRhLCBpbmRleEF4aXN9ID0gZGF0YXNldDtcbiAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgY29uc3QgZGF0YSA9IF9kYXRhIHx8IGRhdGFzZXQuZGF0YTtcblxuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIC8vIERlY2ltYXRpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIGxpbmVzIHRoYXQgaGF2ZSBhbiBYIGluZGV4QXhpc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0YS5jb250cm9sbGVyLnN1cHBvcnRzRGVjaW1hdGlvbikge1xuICAgICAgICAvLyBPbmx5IGxpbmUgZGF0YXNldHMgYXJlIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIC8vIE9ubHkgbGluZWFyIGludGVycG9sYXRpb24gaXMgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMucGFyc2luZykge1xuICAgICAgICAvLyBQbHVnaW4gb25seSBzdXBwb3J0cyBkYXRhIHRoYXQgZG9lcyBub3QgbmVlZCBwYXJzaW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIC8vIE5vIGRlY2ltYXRpb24gaXMgcmVxdWlyZWQgdW50aWwgd2UgYXJlIGFib3ZlIHRoaXMgdGhyZXNob2xkXG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZihfZGF0YSkpIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSBhcmUgc2VlaW5nIHRoaXMgZGF0YXNldFxuICAgICAgICAvLyBXZSBvdmVycmlkZSB0aGUgJ2RhdGEnIHByb3BlcnR5IHdpdGggYSBzZXR0ZXIgdGhhdCBzdG9yZXMgdGhlXG4gICAgICAgIC8vIHJhdyBkYXRhIGluIF9kYXRhLCBidXQgcmVhZHMgdGhlIGRlY2ltYXRlZCBkYXRhIGZyb20gX2RlY2ltYXRlZFxuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQb2ludCB0aGUgY2hhcnQgdG8gdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuXG4gICAgICBkYXRhc2V0Ll9kZWNpbWF0ZWQgPSBkZWNpbWF0ZWQ7XG4gICAgfSk7XG4gIH0sXG5cbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge19ib3VuZFNlZ21lbnQsIF9ib3VuZFNlZ21lbnRzLCBfbm9ybWFsaXplQW5nbGV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgdHBvaW50cyA9IHRhcmdldC5wb2ludHM7XG4gIGNvbnN0IHBhcnRzID0gW107XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgbGV0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyk7XG5cbiAgICBjb25zdCBib3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCBwb2ludHNbc3RhcnRdLCBwb2ludHNbZW5kXSwgc2VnbWVudC5sb29wKTtcblxuICAgIGlmICghdGFyZ2V0LnNlZ21lbnRzKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGJvdW5kYXJ5IG5vdCBzdXBwb3J0aW5nIGBzZWdtZW50c2AgKHNpbXBsZUFyYylcbiAgICAgIC8vIEJvdW5kcyBhcmUgcHJvdmlkZWQgYXMgYHRhcmdldGAgZm9yIHBhcnRpYWwgY2lyY2xlLCBvciB1bmRlZmluZWQgZm9yIGZ1bGwgY2lyY2xlXG4gICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgc291cmNlOiBzZWdtZW50LFxuICAgICAgICB0YXJnZXQ6IGJvdW5kcyxcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tzdGFydF0sXG4gICAgICAgIGVuZDogcG9pbnRzW2VuZF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gR2V0IGFsbCBzZWdtZW50cyBmcm9tIGB0YXJnZXRgIHRoYXQgaW50ZXJzZWN0IHRoZSBib3VuZHMgb2YgY3VycmVudCBzZWdtZW50IG9mIGBsaW5lYFxuICAgIGNvbnN0IHRhcmdldFNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGFyZ2V0LCBib3VuZHMpO1xuXG4gICAgZm9yIChjb25zdCB0Z3Qgb2YgdGFyZ2V0U2VnbWVudHMpIHtcbiAgICAgIGNvbnN0IHN1YkJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHRwb2ludHNbdGd0LnN0YXJ0XSwgdHBvaW50c1t0Z3QuZW5kXSwgdGd0Lmxvb3ApO1xuICAgICAgY29uc3QgZmlsbFNvdXJjZXMgPSBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgc3ViQm91bmRzKTtcblxuICAgICAgZm9yIChjb25zdCBmaWxsU291cmNlIG9mIGZpbGxTb3VyY2VzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogZmlsbFNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCb3VuZHMocHJvcGVydHksIGZpcnN0LCBsYXN0LCBsb29wKSB7XG4gIGlmIChsb29wKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcbiAgbGV0IGVuZCA9IGxhc3RbcHJvcGVydHldO1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHN0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgfVxuICByZXR1cm4ge3Byb3BlcnR5LCBzdGFydCwgZW5kfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpIHtcbiAgY29uc3Qge3ggPSBudWxsLCB5ID0gbnVsbH0gPSBib3VuZGFyeSB8fCB7fTtcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgbGluZS5zZWdtZW50cy5mb3JFYWNoKCh7c3RhcnQsIGVuZH0pID0+IHtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eDogZmlyc3QueCwgeX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGxhc3QueCwgeX0pO1xuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGZpcnN0Lnl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBsYXN0Lnl9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cykge1xuICBmb3IgKDtlbmQgPiBzdGFydDsgZW5kLS0pIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xuICAgIGlmICghaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZDtcbn1cblxuZnVuY3Rpb24gX2dldEVkZ2UoYSwgYiwgcHJvcCwgZm4pIHtcbiAgaWYgKGEgJiYgYikge1xuICAgIHJldHVybiBmbihhW3Byb3BdLCBiW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gYSA/IGFbcHJvcF0gOiBiID8gYltwcm9wXSA6IDA7XG59XG4iLCIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X3BvaW50c0Zyb21TZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXSB8IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IH19IGJvdW5kYXJ5XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudD99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG5cbiAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgX2xvb3AgPSB0cnVlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuZmlsbCAhPT0gZmFsc2U7XG59XG4iLCJpbXBvcnQge2lzT2JqZWN0LCBpc0Zpbml0ZSwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uLy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJykuZGVmYXVsdCB9IExpbmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvaW5kZXguanMnKS5GaWxsVGFyZ2V0IH0gRmlsbFRhcmdldFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuQ29tcGxleEZpbGxUYXJnZXQgfSBDb21wbGV4RmlsbFRhcmdldFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcblxuICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgIHJldHVybiBmaWxsO1xuICB9XG5cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCB7dmFsdWU6IG51bWJlcn19ICovXG4gIGNvbnN0IGZpbGwgPSBwYXJzZUZpbGxPcHRpb24obGluZSk7XG5cbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG5cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG5cbiAgaWYgKGlzRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gZGVjb2RlVGFyZ2V0SW5kZXgoZmlsbFswXSwgaW5kZXgsIHRhcmdldCwgY291bnQpO1xuICB9XG5cbiAgcmV0dXJuIFsnb3JpZ2luJywgJ3N0YXJ0JywgJ2VuZCcsICdzdGFjaycsICdzaGFwZSddLmluZGV4T2YoZmlsbCkgPj0gMCAmJiBmaWxsO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xuICBpZiAoZmlyc3RDaCA9PT0gJy0nIHx8IGZpcnN0Q2ggPT09ICcrJykge1xuICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICB9XG5cbiAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmlsbFRhcmdldCB8IENvbXBsZXhGaWxsVGFyZ2V0fSBmaWxsXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpIHtcbiAgbGV0IHBpeGVsID0gbnVsbDtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHBpeGVsID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBpeGVsID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICB9XG4gIHJldHVybiBwaXhlbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydFZhbHVlKSB7XG4gIGxldCB2YWx1ZTtcblxuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHZhbHVlID0gc2NhbGUub3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmlsbE9wdGlvbihsaW5lKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBvcHRpb25zLmZpbGw7XG4gIGxldCBmaWxsID0gdmFsdWVPckRlZmF1bHQoZmlsbE9wdGlvbiAmJiBmaWxsT3B0aW9uLnRhcmdldCwgZmlsbE9wdGlvbik7XG5cbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnb3JpZ2luJztcbiAgfVxuICByZXR1cm4gZmlsbDtcbn1cbiIsIi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5pbXBvcnQge0xpbmVFbGVtZW50fSBmcm9tICcuLi8uLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQge19pc0JldHdlZW59IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfY3JlYXRlQm91bmRhcnlMaW5lfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7eyBjaGFydDogQ2hhcnQ7IHNjYWxlOiBTY2FsZTsgaW5kZXg6IG51bWJlcjsgbGluZTogTGluZUVsZW1lbnQ7IH19IHNvdXJjZVxuICogQHJldHVybiB7TGluZUVsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgaW5kZXgsIGxpbmV9ID0gc291cmNlO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBzb3VyY2VQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgbGluZXNCZWxvdyA9IGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KTtcbiAgbGluZXNCZWxvdy5wdXNoKF9jcmVhdGVCb3VuZGFyeUxpbmUoe3g6IG51bGwsIHk6IHNjYWxlLmJvdHRvbX0sIGxpbmUpKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGZvciAobGV0IGogPSBzZWdtZW50LnN0YXJ0OyBqIDw9IHNlZ21lbnQuZW5kOyBqKyspIHtcbiAgICAgIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnRzW2pdLCBsaW5lc0JlbG93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMaW5lRWxlbWVudCh7cG9pbnRzLCBvcHRpb25zOiB7fX0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50W119XG4gKi9cbmZ1bmN0aW9uIGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KSB7XG4gIGNvbnN0IGJlbG93ID0gW107XG4gIGNvbnN0IG1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2xpbmUnKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbWV0YS5oaWRkZW4pIHtcbiAgICAgIGJlbG93LnVuc2hpZnQobWV0YS5kYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlbG93O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHNvdXJjZVBvaW50XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50W119IGxpbmVzQmVsb3dcbiAqL1xuZnVuY3Rpb24gYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludCwgbGluZXNCZWxvdykge1xuICBjb25zdCBwb3N0cG9uZWQgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lc0JlbG93Lmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzQmVsb3dbal07XG4gICAgY29uc3Qge2ZpcnN0LCBsYXN0LCBwb2ludH0gPSBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsICd4Jyk7XG5cbiAgICBpZiAoIXBvaW50IHx8IChmaXJzdCAmJiBsYXN0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmaXJzdCkge1xuICAgICAgLy8gRmlyc3QgcG9pbnQgb2YgYSBzZWdtZW50IC0+IG5lZWQgdG8gYWRkIGFub3RoZXIgcG9pbnQgYmVmb3JlIHRoaXMsXG4gICAgICBwb3N0cG9uZWQudW5zaGlmdChwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAvLyBJbiB0aGUgbWlkZGxlIG9mIGEgc2VnbWVudCwgbm8gbmVlZCB0byBhZGQgbW9yZSBwb2ludHMuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludHMucHVzaCguLi5wb3N0cG9uZWQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBzb3VyY2VQb2ludFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7e3BvaW50PzogUG9pbnRFbGVtZW50LCBmaXJzdD86IGJvb2xlYW4sIGxhc3Q/OiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwb2ludCA9IGxpbmUuaW50ZXJwb2xhdGUoc291cmNlUG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKCFwb2ludCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IHBvaW50VmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LnN0YXJ0XVtwcm9wZXJ0eV07XG4gICAgY29uc3QgbGFzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LmVuZF1bcHJvcGVydHldO1xuICAgIGlmIChfaXNCZXR3ZWVuKHBvaW50VmFsdWUsIGZpcnN0VmFsdWUsIGxhc3RWYWx1ZSkpIHtcbiAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcbiAgICAgIGxhc3QgPSBwb2ludFZhbHVlID09PSBsYXN0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtmaXJzdCwgbGFzdCwgcG9pbnR9O1xufVxuIiwiaW1wb3J0IHtUQVV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vLyBUT0RPOiB1c2UgZWxlbWVudHMuQXJjRWxlbWVudCBpbnN0ZWFkXG5leHBvcnQgY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuXG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG5cbiAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7aXNGaW5pdGV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfY3JlYXRlQm91bmRhcnlMaW5lfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuaW1wb3J0IHtfZ2V0VGFyZ2V0UGl4ZWwsIF9nZXRUYXJnZXRWYWx1ZX0gZnJvbSAnLi9maWxsZXIub3B0aW9ucy5qcyc7XG5pbXBvcnQge19idWlsZFN0YWNrTGluZX0gZnJvbSAnLi9maWxsZXIudGFyZ2V0LnN0YWNrLmpzJztcbmltcG9ydCB7c2ltcGxlQXJjfSBmcm9tICcuL3NpbXBsZUFyYy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldChzb3VyY2UpIHtcbiAgY29uc3Qge2NoYXJ0LCBmaWxsLCBsaW5lfSA9IHNvdXJjZTtcblxuICBpZiAoaXNGaW5pdGUoZmlsbCkpIHtcbiAgICByZXR1cm4gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGZpbGwpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcbiAgICByZXR1cm4gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSk7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gJ3NoYXBlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcblxuICBpZiAoYm91bmRhcnkgaW5zdGFuY2VvZiBzaW1wbGVBcmMpIHtcbiAgICByZXR1cm4gYm91bmRhcnk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5mdW5jdGlvbiBnZXRMaW5lQnlJbmRleChjaGFydCwgaW5kZXgpIHtcbiAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgY29uc3QgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XG4gIHJldHVybiB2aXNpYmxlID8gbWV0YS5kYXRhc2V0IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCBzY2FsZSA9IHNvdXJjZS5zY2FsZSB8fCB7fTtcblxuICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlID0ge30sIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBwaXhlbCA9IF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSk7XG5cbiAgaWYgKGlzRmluaXRlKHBpeGVsKSkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gcGl4ZWwgOiBudWxsLFxuICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiBwaXhlbFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICBjb25zdCB2YWx1ZSA9IF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnQpO1xuICBjb25zdCB0YXJnZXQgPSBbXTtcblxuICBpZiAob3B0aW9ucy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgY29uc3QgY2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcbiAgICByZXR1cm4gbmV3IHNpbXBsZUFyYyh7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55LFxuICAgICAgcmFkaXVzOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSlcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0YXJnZXQucHVzaChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4iLCJpbXBvcnQge2NsaXBBcmVhLCB1bmNsaXBBcmVhLCBnZXREYXRhc2V0Q2xpcEFyZWF9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfZmluZFNlZ21lbnRFbmQsIF9nZXRCb3VuZHMsIF9zZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5pbXBvcnQge19nZXRUYXJnZXR9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7Y2hhcnQsIGluZGV4LCBsaW5lLCBzY2FsZSwgYXhpc30gPSBzb3VyY2U7XG4gIGNvbnN0IGxpbmVPcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgY29uc3QgY29sb3IgPSBsaW5lT3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGNvbnN0IHthYm92ZSA9IGNvbG9yLCBiZWxvdyA9IGNvbG9yfSA9IGZpbGxPcHRpb24gfHwge307XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IGNsaXAgPSBnZXREYXRhc2V0Q2xpcEFyZWEoY2hhcnQsIG1ldGEpO1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpcywgY2xpcH0pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgY2xpcH0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcblxuICBjdHguc2F2ZSgpO1xuXG4gIGxldCBmaWxsQ29sb3IgPSBiZWxvdztcbiAgaWYgKGJlbG93ICE9PSBhYm92ZSkge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEudG9wKTtcbiAgICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eSwgY2xpcH0pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAneScpIHtcbiAgICAgIGNsaXBIb3Jpem9udGFsKGN0eCwgdGFyZ2V0LCBhcmVhLmxlZnQpO1xuICAgICAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBiZWxvdywgc2NhbGUsIHByb3BlcnR5LCBjbGlwfSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNsaXBIb3Jpem9udGFsKGN0eCwgdGFyZ2V0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIGZpbGxDb2xvciA9IGFib3ZlO1xuICAgIH1cbiAgfVxuICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGZpbGxDb2xvciwgc2NhbGUsIHByb3BlcnR5LCBjbGlwfSk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICBjb25zdCB7c2VnbWVudHMsIHBvaW50c30gPSB0YXJnZXQ7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgY2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgfVxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcbiAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhsYXN0UG9pbnQueCwgY2xpcFkpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIGNsaXBIb3Jpem9udGFsKGN0eCwgdGFyZ2V0LCBjbGlwWCkge1xuICBjb25zdCB7c2VnbWVudHMsIHBvaW50c30gPSB0YXJnZXQ7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGNsaXBYLCBmaXJzdFBvaW50LnkpO1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgfVxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcbiAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhjbGlwWCwgbGFzdFBvaW50LnkpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5saW5lVG8oY2xpcFgsIHRhcmdldC5maXJzdCgpLnkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIGZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgcHJvcGVydHksIGNvbG9yLCBzY2FsZSwgY2xpcH0gPSBjZmc7XG4gIGNvbnN0IHNlZ21lbnRzID0gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpO1xuXG4gIGZvciAoY29uc3Qge3NvdXJjZTogc3JjLCB0YXJnZXQ6IHRndCwgc3RhcnQsIGVuZH0gb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3R5bGU6IHtiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcn0gPSB7fX0gPSBzcmM7XG4gICAgY29uc3Qgbm90U2hhcGUgPSB0YXJnZXQgIT09IHRydWU7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGNsaXAsIG5vdFNoYXBlICYmIF9nZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGNvbnN0IGxpbmVMb29wID0gISFsaW5lLnBhdGhTZWdtZW50KGN0eCwgc3JjKTtcblxuICAgIGxldCBsb29wO1xuICAgIGlmIChub3RTaGFwZSkge1xuICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgZW5kLCBwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge21vdmU6IGxpbmVMb29wLCByZXZlcnNlOiB0cnVlfSk7XG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKGxvb3AgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGNsaXAsIGJvdW5kcykge1xuICBjb25zdCBjaGFydEFyZWEgPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG5cbiAgaWYgKHByb3BlcnR5ID09PSAneCcgfHwgcHJvcGVydHkgPT09ICd5Jykge1xuICAgIGxldCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b207XG5cbiAgICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgICAgbGVmdCA9IHN0YXJ0O1xuICAgICAgdG9wID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHJpZ2h0ID0gZW5kO1xuICAgICAgYm90dG9tID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgdG9wID0gc3RhcnQ7XG4gICAgICByaWdodCA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICAgIGJvdHRvbSA9IGVuZDtcbiAgICB9XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIGNsaXAubGVmdCk7XG4gICAgICByaWdodCA9IE1hdGgubWluKHJpZ2h0LCBjbGlwLnJpZ2h0KTtcbiAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgY2xpcC50b3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCBjbGlwLmJvdHRvbSk7XG4gICAgfVxuXG4gICAgY3R4LnJlY3QobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBpbnRlcnBvbGF0ZWRQb2ludCA9IHRhcmdldC5pbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpO1xuICBpZiAoaW50ZXJwb2xhdGVkUG9pbnQpIHtcbiAgICBjdHgubGluZVRvKGludGVycG9sYXRlZFBvaW50LngsIGludGVycG9sYXRlZFBvaW50LnkpO1xuICB9XG59XG5cbiIsIi8qKlxuICogUGx1Z2luIGJhc2VkIG9uIGRpc2N1c3Npb24gZnJvbSB0aGUgZm9sbG93aW5nIENoYXJ0LmpzIGlzc3VlczpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIzODAjaXNzdWVjb21tZW50LTI3OTk2MTU2OVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjQ0MCNpc3N1ZWNvbW1lbnQtMjU2NDYxODk3XG4gKi9cblxuaW1wb3J0IExpbmVFbGVtZW50IGZyb20gJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyc7XG5pbXBvcnQge19kcmF3ZmlsbH0gZnJvbSAnLi9maWxsZXIuZHJhd2luZy5qcyc7XG5pbXBvcnQge19zaG91bGRBcHBseUZpbGx9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5pbXBvcnQge19kZWNvZGVGaWxsLCBfcmVzb2x2ZVRhcmdldH0gZnJvbSAnLi9maWxsZXIub3B0aW9ucy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdmaWxsZXInLFxuXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuXG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IF9kZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UuZmlsbCA9IF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcgJiYgc291cmNlLmZpbGwpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcblxuICAgICAgaWYgKF9zaG91bGRBcHBseUZpbGwoc291cmNlKSkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG5cbiAgICBpZiAoIV9zaG91bGRBcHBseUZpbGwoc291cmNlKSB8fCBvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldERyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG4iLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRoLCBkcmF3UG9pbnRMZWdlbmQsIHJlbmRlclRleHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtcbiAgX2lzQmV0d2VlbixcbiAgY2FsbGJhY2sgYXMgY2FsbCxcbiAgY2xpcEFyZWEsXG4gIGdldFJ0bEFkYXB0ZXIsXG4gIG92ZXJyaWRlVGV4dERpcmVjdGlvbixcbiAgcmVzdG9yZVRleHREaXJlY3Rpb24sXG4gIHRvRm9udCxcbiAgdG9QYWRkaW5nLFxuICB1bmNsaXBBcmVhLFxuICB2YWx1ZU9yRGVmYXVsdCxcbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdGV4dFgsIF90b0xlZnRSaWdodENlbnRlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge3RvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICovXG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcblxuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuXG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcblxuZXhwb3J0IGNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3sgY3R4OiBhbnk7IG9wdGlvbnM6IGFueTsgY2hhcnQ6IGFueTsgfX0gY29uZmlnXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcblxuICAgIC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuICAgIC8qKlxuIFx0XHQgKiBAcHJpdmF0ZVxuIFx0XHQgKi9cbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG5cbiAgICAvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnM7XG5cbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgdGhpcy5maXQoKTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cblxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCBsYWJlbE9wdHMgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgIGxldCBsZWdlbmRJdGVtcyA9IGNhbGwobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuXG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5zb3J0KChhLCBiKSA9PiBsYWJlbE9wdHMuc29ydChhLCBiLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cblxuICBmaXQoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSB0aGlzO1xuXG4gICAgLy8gVGhlIGxlZ2VuZCBtYXkgbm90IGJlIGRpc3BsYXllZCBmb3IgYSB2YXJpZXR5IG9mIHJlYXNvbnMgaW5jbHVkaW5nXG4gICAgLy8gdGhlIGZhY3QgdGhhdCB0aGUgZGVmYXVsdHMgZ290IHNldCB0byBgZmFsc2VgLlxuICAgIC8vIFdoZW4gdGhlIGxlZ2VuZCBpcyBub3QgZGlzcGxheWVkLCB0aGVyZSBhcmUgbm8gZ3VhcmFudGVlcyB0aGF0IHRoZSBvcHRpb25zXG4gICAgLy8gYXJlIGNvcnJlY3RseSBmb3JtYXR0ZWQgc28gd2UgbmVlZCB0byBiYWlsIG91dCBhcyBlYXJseSBhcyBwb3NzaWJsZS5cbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbE9wdHMgPSBvcHRpb25zLmxhYmVscztcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5tYXhXaWR0aDsgLy8gZmlsbCBhbGwgdGhlIHdpZHRoXG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG4gICAgICB3aWR0aCA9IHRoaXMuX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHdpZHRoLCBvcHRpb25zLm1heFdpZHRoIHx8IHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuXG4gICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0OiAwLCB0b3AsIHJvdywgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cblxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgbGFiZWxGb250LCBib3hXaWR0aCwgX2l0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuXG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcblxuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgY29sID0gMDtcblxuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3Qge2l0ZW1XaWR0aCwgaXRlbUhlaWdodH0gPSBjYWxjdWxhdGVJdGVtU2l6ZShib3hXaWR0aCwgbGFiZWxGb250LCBjdHgsIGxlZ2VuZEl0ZW0sIF9pdGVtSGVpZ2h0KTtcblxuICAgICAgLy8gSWYgdG9vIHRhbGwsIGdvIHRvIG5ldyBjb2x1bW5cbiAgICAgIGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCArIDIgKiBwYWRkaW5nID4gaGVpZ2h0TGltaXQpIHtcbiAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcbiAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2wrKztcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0LCB0b3A6IGN1cnJlbnRDb2xIZWlnaHQsIGNvbCwgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgLy8gR2V0IG1heCB3aWR0aFxuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcblxuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pOyAvLyBwcmV2aW91cyBjb2x1bW4gc2l6ZVxuXG4gICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gIH1cblxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSB0aGlzO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChoaXRib3gubGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGNsaXBBcmVhKGN0eCwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2RyYXcoKTtcblxuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXcoKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHtwYWRkaW5nfSA9IGxhYmVsT3B0cztcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcbiAgICBsZXQgY3Vyc29yO1xuXG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcblxuICAgICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2gsIFtdKSk7XG5cbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICAvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3RpbmdcbiAgICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveEhlaWdodCAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgIHBvaW50U3R5bGU6IGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcbiAgICAgICAgICBib3JkZXJXaWR0aDogbGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyBoYWxmRm9udFNpemU7XG5cbiAgICAgICAgLy8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgZHJhd1BvaW50TGVnZW5kKGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclksIGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggJiYgYm94V2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxuICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb24gd2hlbiBib3hIZWlnaHQgPCBmb250U2l6ZSAod2FudCBpdCBjZW50ZXJlZClcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICB4OiB4Qm94TGVmdCxcbiAgICAgICAgICAgIHk6IHlCb3hUb3AsXG4gICAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5yZWN0KHhCb3hMZWZ0LCB5Qm94VG9wLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGVnZW5kSXRlbS50ZXh0LCB4LCB5ICsgKGl0ZW1IZWlnaHQgLyAyKSwgbGFiZWxGb250LCB7XG4gICAgICAgIHN0cmlrZXRocm91Z2g6IGxlZ2VuZEl0ZW0uaGlkZGVuLFxuICAgICAgICB0ZXh0QWxpZ246IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gSG9yaXpvbnRhbFxuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXG4gICAgICAgIHk6IHRoaXMudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IHRoaXMubGVmdCArIHBhZGRpbmcsXG4gICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yOyAvLyBmb3Igc3RyaWtldGhyb3VnaCBlZmZlY3RcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cbiAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbiB8fCAobGVnZW5kSXRlbS50ZXh0QWxpZ24gPSBsYWJlbE9wdHMudGV4dEFsaWduKSk7XG4gICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xuICAgICAgbGV0IHggPSBjdXJzb3IueDtcbiAgICAgIGxldCB5ID0gY3Vyc29yLnk7XG5cbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcblxuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcblxuICAgICAgLy8gRmlsbCB0aGUgYWN0dWFsIGxhYmVsXG4gICAgICBmaWxsVGV4dChydGxIZWxwZXIueCh4KSwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBmb250TGluZUhlaWdodCA9IGxhYmVsRm9udC5saW5lSGVpZ2h0O1xuICAgICAgICBjdXJzb3IueSArPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gb3B0cy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG5cbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRpdGxlT3B0cy5wb3NpdGlvbjtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgIGxldCB5O1xuXG4gICAgLy8gVGhlc2UgZGVmYXVsdHMgYXJlIHVzZWQgd2hlbiB0aGUgbGVnZW5kIGlzIHZlcnRpY2FsLlxuICAgIC8vIFdoZW4gaG9yaXpvbnRhbCwgdGhleSBhcmUgY29tcHV0ZWQgYmVsb3cuXG4gICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gdGhpcy53aWR0aDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBNb3ZlIGxlZnQgLyByaWdodCBzbyB0aGF0IHRoZSB0aXRsZSBpcyBhYm92ZSB0aGUgbGVnZW5kIGxpbmVzXG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGRvd24gc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBzdGFjayBpbiBldmVyeSBhbGlnbm1lbnRcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGUgbGVmdCBlZGdlIG9mIHRoZSBpbm5lciBsZWdlbmQgYm94LCBjb21wdXRlIHRoZSBjb3JyZWN0XG4gICAgLy8gWCBjb29yZGluYXRlIGZyb20gdGhlIHRpdGxlIGFsaWdubWVudFxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICBsZXQgaSwgaGl0Qm94LCBsaDtcblxuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcbiAgICAgICYmIF9pc0JldHdlZW4oeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgLy8gU2VlIGlmIHdlIGFyZSB0b3VjaGluZyBvbmUgb2YgdGhlIGRhdGFzZXQgYm94ZXNcbiAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBoaXRCb3ggPSBsaFtpXTtcblxuICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcbiAgICAgICAgICAvLyBUb3VjaGluZyBhbiBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsKG9wdHMub25MZWF2ZSwgW2UsIHByZXZpb3VzLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG5cbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0pIHtcbiAgICAgIGNhbGwob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCkge1xuICBjb25zdCBpdGVtV2lkdGggPSBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KTtcbiAgY29uc3QgaXRlbUhlaWdodCA9IGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGxhYmVsRm9udC5saW5lSGVpZ2h0KTtcbiAgcmV0dXJuIHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KSB7XG4gIGxldCBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW0udGV4dDtcbiAgaWYgKGxlZ2VuZEl0ZW1UZXh0ICYmIHR5cGVvZiBsZWdlbmRJdGVtVGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW1UZXh0LnJlZHVjZSgoYSwgYikgPT4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiKTtcbiAgfVxuICByZXR1cm4gYm94V2lkdGggKyAobGFiZWxGb250LnNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtVGV4dCkud2lkdGg7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSB7XG4gIGxldCBpdGVtSGVpZ2h0ID0gX2l0ZW1IZWlnaHQ7XG4gIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gaXRlbUhlaWdodDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBjb25zdCBsYWJlbEhlaWdodCA9IGxlZ2VuZEl0ZW0udGV4dCA/IGxlZ2VuZEl0ZW0udGV4dC5sZW5ndGggOiAwO1xuICByZXR1cm4gZm9udExpbmVIZWlnaHQgKiBsYWJlbEhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICgodHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgdHlwZSA9PT0gJ21vdXNlb3V0JykgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnbGVnZW5kJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogTGVnZW5kLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe2N0eDogY2hhcnQuY3R4LCBvcHRpb25zLCBjaGFydH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICB9LFxuXG4gIC8vIER1cmluZyB0aGUgYmVmb3JlVXBkYXRlIHN0ZXAsIHRoZSBsYXlvdXQgY29uZmlndXJhdGlvbiBuZWVkcyB0byBydW5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgaWYgdGhlIGxlZ2VuZCBwb3NpdGlvbiBjaGFuZ2VzICh2aWEgYW4gb3B0aW9uIHVwZGF0ZSlcbiAgLy8gdGhlIGxheW91dCBzeXN0ZW0gcmVzcGVjdHMgdGhlIGNoYW5nZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy83NTI3XG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIC8vIFRoZSBsYWJlbHMgbmVlZCB0byBiZSBidWlsdCBhZnRlciBkYXRhc2V0cyBhcmUgdXBkYXRlZCB0byBlbnN1cmUgdGhhdCBjb2xvcnNcbiAgLy8gYW5kIG90aGVyIHN0eWxpbmcgYXJlIGNvcnJlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjk2OFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcblxuXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MucmVwbGF5KSB7XG4gICAgICBjaGFydC5sZWdlbmQuaGFuZGxlRXZlbnQoYXJncy5ldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcblxuICAgIC8vIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGhhbmRsZVxuICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XG4gICAgICBpZiAoY2kuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpLnNob3coaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG5cbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgLy8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG4gICAgICAvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcbiAgICAgIC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgIC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG4gICAgICAvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuICAgICAgLy8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuICAgICAgLy8gbGluZURhc2hcbiAgICAgIC8vIGxpbmVEYXNoT2Zmc2V0IDpcbiAgICAgIC8vIGxpbmVKb2luIDpcbiAgICAgIC8vIGxpbmVXaWR0aCA6XG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGNvbnN0IHtsYWJlbHM6IHt1c2VQb2ludFN0eWxlLCBwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yLCB1c2VCb3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1c319ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHVzZUJvcmRlclJhZGl1cyAmJiAoYm9yZGVyUmFkaXVzIHx8IHN0eWxlLmJvcmRlclJhZGl1cyksXG5cbiAgICAgICAgICAgIC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxuICAgIH1cbiAgfSxcbn07XG4iLCJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge1BJLCBpc0FycmF5LCB0b1BhZGRpbmcsIHRvRm9udH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge190b0xlZnRSaWdodENlbnRlciwgX2FsaWduU3RhcnRFbmR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtyZW5kZXJUZXh0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcblxuZXhwb3J0IGNsYXNzIFRpdGxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIC8qKlxuXHQgKiBAcGFyYW0ge3sgY3R4OiBhbnk7IG9wdGlvbnM6IGFueTsgY2hhcnQ6IGFueTsgfX0gY29uZmlnXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5fcGFkZGluZyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuXG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgPSBtYXhXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gbWF4SGVpZ2h0O1xuXG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0ZXh0U2l6ZTtcbiAgICB9XG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG4gIH1cblxuICBfZHJhd0FyZ3Mob2Zmc2V0KSB7XG4gICAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgIHRpdGxlWSA9IHRvcCArIG9mZnNldDtcbiAgICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRpdGxlWCA9IGxlZnQgKyBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAtMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGVYID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0b3AsIGJvdHRvbSk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAwLjU7XG4gICAgICB9XG4gICAgICBtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcbiAgICB9XG4gICAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZm9udE9wdHMgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIHRoaXMuX3BhZGRpbmcudG9wO1xuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRoaXMuX2RyYXdBcmdzKG9mZnNldCk7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgb3B0cy50ZXh0LCAwLCAwLCBmb250T3B0cywge1xuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiBfdG9MZWZ0UmlnaHRDZW50ZXIob3B0cy5hbGlnbiksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgY3R4OiBjaGFydC5jdHgsXG4gICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgIGNoYXJ0XG4gIH0pO1xuXG4gIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcbiAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgY2hhcnQudGl0bGVCbG9jayA9IHRpdGxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAndGl0bGUnLFxuXG4gIC8qKlxuXHQgKiBGb3IgdGVzdHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lbGVtZW50OiBUaXRsZSxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjcmVhdGVUaXRsZShjaGFydCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAyMDAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSB0byBiZSBhYm92ZVxuICB9LFxuXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuIiwiaW1wb3J0IHtUaXRsZX0gZnJvbSAnLi9wbHVnaW4udGl0bGUuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnc3VidGl0bGUnLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG5cbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gICAgbWFwLnNldChjaGFydCwgdGl0bGUpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMTUwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgYW5kIHNtYWxsZXIgdGhhbiB0aXRsZSAoMjAwMClcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsImltcG9ydCBBbmltYXRpb25zIGZyb20gJy4uL2NvcmUvY29yZS5hbmltYXRpb25zLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRofSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7ZWFjaCwgbm9vcCwgaXNOdWxsT3JVbmRlZiwgaXNBcnJheSwgX2VsZW1lbnRzRXF1YWwsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2dldFJ0bEFkYXB0ZXIsIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgcmVzdG9yZVRleHREaXJlY3Rpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5ydGwuanMnO1xuaW1wb3J0IHtkaXN0YW5jZUJldHdlZW5Qb2ludHMsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIGRyYXdQb2ludH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMnKS5DaGFydCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudCB9IEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuaW50ZXJhY3Rpb24uanMnKS5JbnRlcmFjdGlvbkl0ZW0gfSBJbnRlcmFjdGlvbkl0ZW1cbiAqL1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgLyoqXG5cdCAqIEF2ZXJhZ2UgbW9kZSBwbGFjZXMgdGhlIHRvb2x0aXAgYXQgdGhlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRzIHNob3duXG5cdCAqL1xuICBhdmVyYWdlKGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4U2V0ID0gbmV3IFNldCgpO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICB4U2V0LmFkZChwb3MueCk7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gdmlzaWJsZSBpdGVtcyB3aGVyZSBmb3VuZCwgcmV0dXJuIGZhbHNlIHNvIHdlIGRvbid0IGhhdmUgdG8gZGl2aWRlIGJ5IDAgd2hpY2ggcmVkdWNlcyBpbiBOYU5cbiAgICBpZiAoY291bnQgPT09IDAgfHwgeFNldC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgeEF2ZXJhZ2UgPSBbLi4ueFNldF0ucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyB4U2V0LnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeEF2ZXJhZ2UsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cblx0ICovXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCB4ID0gZXZlbnRQb3NpdGlvbi54O1xuICAgIGxldCB5ID0gZXZlbnRQb3NpdGlvbi55O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG5cbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgeCA9IHRwLng7XG4gICAgICB5ID0gdHAueTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICAvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UucHVzaCh0b1B1c2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2Ygc3RyaW5ncyBzcGxpdCBieSBuZXdsaW5lXG4gKiBAcGFyYW0geyp9IHN0ciAtIFRoZSB2YWx1ZSB0byBzcGxpdCBieSBuZXdsaW5lLlxuICogQHJldHVybnMge3N0cmluZ3xzdHJpbmdbXX0gdmFsdWUgaWYgbmV3bGluZSBwcmVzZW50IC0gUmV0dXJuZWQgZnJvbSBTdHJpbmcgc3BsaXQoKSBtZXRob2RcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gY3JlYXRlIGEgdG9vbHRpcCBpdGVtIG1vZGVsXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtBY3RpdmVFbGVtZW50fSBpdGVtIC0ge2VsZW1lbnQsIGluZGV4LCBkYXRhc2V0SW5kZXh9IHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcblxuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0b29sdGlwXG4gKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XG4gIGNvbnN0IHtib2R5LCBmb290ZXIsIHRpdGxlfSA9IHRvb2x0aXA7XG4gIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICBjb25zdCBmb290ZXJMaW5lQ291bnQgPSBmb290ZXIubGVuZ3RoO1xuICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuXG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuXG4gIC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG5cbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZ1xuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICB9XG4gIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgaGVpZ2h0IGRlcGVuZGluZyBvbiBib3hIZWlnaHRcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSBib2R5TGluZUl0ZW1Db3VudCkgKiBib2R5Rm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gIH1cbiAgaWYgKGZvb3RlckxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxuXHRcdFx0KyBmb290ZXJMaW5lQ291bnQgKiBmb290ZXJGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICB9XG5cbiAgLy8gVGl0bGUgd2lkdGhcbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gIGNvbnN0IG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICB9O1xuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSB3aWR0aFxuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcblxuICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgd2lkdGggZHVlIHRvIHRoZSBjb2xvciBib3hcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgYmFjayB0byAwXG4gIHdpZHRoUGFkZGluZyA9IDA7XG5cbiAgLy8gRm9vdGVyIHdpZHRoXG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICAvLyBBZGQgcGFkZGluZ1xuICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSkge1xuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XG5cbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9IGVsc2UgaWYgKHkgPiAoY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH1cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHt3aWR0aDogY2hhcnRXaWR0aCwgY2hhcnRBcmVhOiB7bGVmdCwgcmlnaHR9fSA9IGNoYXJ0O1xuICBsZXQgeEFsaWduID0gJ2NlbnRlcic7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuXG4gIGlmIChkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpKSB7XG4gICAgeEFsaWduID0gJ2NlbnRlcic7XG4gIH1cblxuICByZXR1cm4geEFsaWduO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHlBbGlnbiA9IHNpemUueUFsaWduIHx8IG9wdGlvbnMueUFsaWduIHx8IGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICBjb25zdCB7Y2FyZXRTaXplLCBjYXJldFBhZGRpbmcsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gYWxpZ25tZW50O1xuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG5cbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcblxuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSArIGNhcmV0U2l6ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogX2xpbWl0VmFsdWUoeCwgMCwgY2hhcnQud2lkdGggLSBzaXplLndpZHRoKSxcbiAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuXG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGJ1aWxkIGJlZm9yZSBhbmQgYWZ0ZXIgYm9keSBsaW5lc1xuICovXG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRvb2x0aXAsXG4gICAgdG9vbHRpcEl0ZW1zLFxuICAgIHR5cGU6ICd0b29sdGlwJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuXG5jb25zdCBkZWZhdWx0Q2FsbGJhY2tzID0ge1xuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uZGF0YUluZGV4IDwgbGFiZWxDb3VudCkge1xuICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIGFmdGVyVGl0bGU6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcbiAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBsYWJlbCArPSAnOiAnO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWw7XG4gIH0sXG4gIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIH07XG4gIH0sXG4gIGxhYmVsVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICB9LFxuICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgIH07XG4gIH0sXG4gIGFmdGVyTGFiZWw6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGFmdGVyQm9keTogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlRm9vdGVyOiBub29wLFxuICBmb290ZXI6IG5vb3AsXG4gIGFmdGVyRm9vdGVyOiBub29wXG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayBmcm9tIG9iamVjdCB3aXRoIGNvbnRleHQgYW5kIGFyZ3VtZW50cy5cbiAqIElmIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZW4gd2lsbCBiZSBpbnZva2VkIGRlZmF1bHQgY2FsbGJhY2suXG4gKiBAcGFyYW0ge1JlY29yZDxrZXlvZiB0eXBlb2YgZGVmYXVsdENhbGxiYWNrcywgRnVuY3Rpb24+fSBjYWxsYmFja3NcbiAqIEBwYXJhbSB7a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3N9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gY3R4XG4gKiBAcGFyYW0geyp9IGFyZ1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCBuYW1lLCBjdHgsIGFyZykge1xuICBjb25zdCByZXN1bHQgPSBjYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG5cbiAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRDYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcbiAgICovXG4gIHN0YXRpYyBwb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xuICAgIC8vIFRPRE86IFY0LCBtYWtlIHRoaXMgcHJpdmF0ZSwgcmVuYW1lIHRvIGBfbGFiZWxTdHlsZXNgLCBhbmQgY29tYmluZSB3aXRoIGBsYWJlbFBvaW50U3R5bGVzYFxuICAgIC8vIGFuZCBgbGFiZWxUZXh0Q29sb3JzYCB0byBjcmVhdGUgYSBzaW5nbGUgdmFyaWFibGVcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG5cbiAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICBjb25zdCB0aXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ3RpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2FmdGVyVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcblxuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYmVmb3JlQm9keScsIHRoaXMsIHRvb2x0aXBJdGVtcylcbiAgICApO1xuICB9XG5cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG5cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2JlZm9yZUxhYmVsJywgdGhpcywgY29udGV4dCkpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWwnLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnYWZ0ZXJMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG5cbiAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cblxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKFxuICAgICAgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2sob3B0aW9ucy5jYWxsYmFja3MsICdhZnRlckJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdiZWZvcmVGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2Zvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlckZvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbSh0aGlzLmNoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBsYWJlbENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsQ29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxQb2ludFN0eWxlJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxUZXh0Q29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbGFiZWxQb2ludFN0eWxlcztcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuXG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG5cbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG5cbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIHRoaXMuY2hhcnQpO1xuXG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcztcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcblxuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG5cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7Y2FyZXRTaXplLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCB7eDogcHRYLCB5OiBwdFl9ID0gdG9vbHRpcFBvaW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG5cbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG5cbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBMZWZ0IGRyYXdzIGJvdHRvbSAtPiB0b3AsIHRoaXMgeTEgaXMgb24gdGhlIGJvdHRvbVxuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgeDIgPSB4MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBSaWdodCBkcmF3cyB0b3AgLT4gYm90dG9tLCB0aHVzIHkxIGlzIG9uIHRoZSB0b3BcbiAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgIH1cblxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cblxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gVG9wIGRyYXdzIGxlZnQgLT4gcmlnaHQsIHRodXMgeDEgaXMgb24gdGhlIGxlZnRcbiAgICAgICAgeDEgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIEJvdHRvbSBkcmF3cyByaWdodCAtPiBsZWZ0LCB0aHVzIHgxIGlzIG9uIHRoZSByaWdodFxuICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeTMgPSB5MTtcbiAgICB9XG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcbiAgfVxuXG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcbiAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG5cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxDb2xvciA9IHRoaXMubGFiZWxDb2xvcnNbaV07XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRofSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG5cbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihib3hXaWR0aCwgYm94SGVpZ2h0KSAvIDIsIC8vIGZpdCB0aGUgY2lyY2xlIGluIHRoZSBib3hcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcblxuICAgICAgLy8gRmlsbCB0aGUgcG9pbnQgd2l0aCB3aGl0ZSBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG5cbiAgICAgIC8vIERyYXcgdGhlIHBvaW50XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9yLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3JkZXJcbiAgICAgIGN0eC5saW5lV2lkdGggPSBpc09iamVjdChsYWJlbENvbG9yLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkpIDogKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGggfHwgMSk7IC8vIFRPRE8sIHY0IHJlbW92ZSBmYWxsYmFja1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9yLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvci5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG5cbiAgICAgIC8vIEZpbGwgYSB3aGl0ZSByZWN0IHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG4gICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKTtcbiAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIDIpO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9yLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gSW5uZXIgc3F1YXJlXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSArIDEsXG4gICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIHJlY3RcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSBmaWxsU3R5bGVcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gIH1cblxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcbiAgICBjb25zdCB7Ym9keVNwYWNpbmcsIGJvZHlBbGlnbiwgZGlzcGxheUNvbG9ycywgYm94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG5cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG5cbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG5cbiAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcblxuICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG5cbiAgICAvLyBCZWZvcmUgYm9keSBsaW5lc1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgeExpbmVQYWRkaW5nID0gZGlzcGxheUNvbG9ycyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuICAgICAgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcpIDogKGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcpXG4gICAgICA6IDA7XG5cbiAgICAvLyBEcmF3IGJvZHkgbGluZXMgbm93XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG5cbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICAvLyBEcmF3IExlZ2VuZC1saWtlIGJveGVzIGlmIG5lZWRlZFxuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICAvLyBSZXNldCBmb3IgYW55IGxpbmVzIHRoYXQgZG9uJ3QgaW5jbHVkZSBjb2xvcmJveFxuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBiYWNrIHRvIDAgZm9yIGFmdGVyIGJvZHlcbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcblxuICAgIC8vIEFmdGVyIGJvZHkgbGluZXNcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgcHQueSAtPSBib2R5U3BhY2luZzsgLy8gUmVtb3ZlIGxhc3QgYm9keSBzcGFjaW5nXG4gIH1cblxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeX0gPSBwdDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgeC95IGFuaW1hdGlvbiB0YXJnZXRzIHdoZW4gX2FjdGl2ZSBlbGVtZW50cyBhcmUgYW5pbWF0aW5nIHRvb1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHRvb2x0aXAgd2lsbCBkcmF3IGFueXRoaW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0b29sdGlwIHdpbGwgcmVuZGVyXG4gICAqL1xuICBfd2lsbFJlbmRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG5cbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuXG4gICAgLy8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICAgIC8vIFRydXRoeS9mYWxzZXkgdmFsdWUgZm9yIGVtcHR5IHRvb2x0aXBcbiAgICBjb25zdCBoYXNUb29sdGlwQ29udGVudCA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuXG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cbiAgICAgIC8vIERyYXcgQmFja2dyb3VuZFxuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG5cbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG5cbiAgICAgIC8vIFRpdGxlc1xuICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEJvZHlcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEZvb3RlclxuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEdldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSBhY3RpdmUgaW4gdGhlIHRvb2x0aXBcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSBlbGVtZW50cyBpbiB0aGUgdG9vbHRpcFxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBBcnJheSBvZiBhY3RpdmUgZGF0YXNldEluZGV4L2luZGV4IHBhaXJzLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQb3NpdGlvbiBTeW50aGV0aWMgZXZlbnQgcG9zaXRpb24gdXNlZCBpbiBwb3NpdGlvbmluZ1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuICBoYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhID0gdHJ1ZSkge1xuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgc2hvd24sIGJ1dCB0aGUgdG9vbHRpcCBwb3NpdGlvbiBpcyBuZWFyZXN0IG1vZGVcbiAgICAvLyBhbiB1cGRhdGUgbWF5IG5lZWQgdG8gYmUgbWFkZSBiZWNhdXNlIG91ciBwb3NpdGlvbiBtYXkgaGF2ZSBjaGFuZ2VkIGV2ZW4gdGhvdWdoXG4gICAgLy8gdGhlIGl0ZW1zIGFyZSB0aGUgc2FtZSBhcyBiZWZvcmUuXG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG5cbiAgICAvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcbiAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcblxuICAgIC8vIE9ubHkgaGFuZGxlIHRhcmdldCBldmVudCBvbiB0b29sdGlwIGNoYW5nZVxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG5cbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICB5OiBlLnlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhlbHBlciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGFjdGl2ZSBlbGVtZW50cyBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uSXRlbVtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIFRoaXMgaXMgYSByZXBsYXllZCBldmVudCAoZnJvbSB1cGRhdGUpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIFRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm5zIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBMZXQgdXNlciBjb250cm9sIHRoZSBhY3RpdmUgZWxlbWVudHMgb3V0c2lkZSBjaGFydEFyZWEuIEVnLiB1c2luZyBMZWdlbmQuXG4gICAgICAvLyBCdXQgbWFrZSBzdXJlIHRoYXQgYWN0aXZlIGVsZW1lbnRzIGFyZSBzdGlsbCB2YWxpZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlLmZpbHRlcihpID0+XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tpLmRhdGFzZXRJbmRleF0gJiZcbiAgICAgICAgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpLmRhdGFzZXRJbmRleCkuY29udHJvbGxlci5nZXRQYXJzZWQoaS5pbmRleCkgIT09IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgdG9vbHRpcHNcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG5cbiAgLyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgYWN0aXZlIGVsZW1lbnRzICsgZXZlbnQgY29tYmluYXRpb24gY2hhbmdlcyB0aGVcblx0ICogdG9vbHRpcCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmUgLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gRXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIHBvc2l0aW9uIGNoYW5nZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcG9zaXRpb24gaGFzIGNoYW5nZWRcblx0ICovXG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3Rvb2x0aXAnLFxuICBfZWxlbWVudDogVG9vbHRpcCxcbiAgcG9zaXRpb25lcnMsXG5cbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe2NoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICByZXNldChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcblxuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgdG9vbHRpcFxuICAgICAgfTtcblxuICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3Jywgey4uLmFyZ3MsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcblxuICAgICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgLy8gbm90aWZ5IGNoYXJ0IGFib3V0IHRoZSBjaGFuZ2UsIHNvIGl0IHdpbGwgcmVuZGVyXG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdjYXJldFgnLCAnY2FyZXRZJ10sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IGRlZmF1bHRDYWxsYmFja3NcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6ICdmb250JyxcbiAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgdGl0bGVGb250OiAnZm9udCdcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmVzb2x2ZSBhZGRpdGlvbmFsbHkgZnJvbSBgaW50ZXJhY3Rpb25gIG9wdGlvbnMgYW5kIGRlZmF1bHRzLlxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJ2ludGVyYWN0aW9uJ11cbn07XG4iLCJpbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHQsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuY29uc3QgYWRkSWZTdHJpbmcgPSAobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykgPT4ge1xuICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICBpbmRleCA9IGxhYmVscy5wdXNoKHJhdykgLSAxO1xuICAgIGFkZGVkTGFiZWxzLnVuc2hpZnQoe2luZGV4LCBsYWJlbDogcmF3fSk7XG4gIH0gZWxzZSBpZiAoaXNOYU4ocmF3KSkge1xuICAgIGluZGV4ID0gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSB7XG4gIGNvbnN0IGZpcnN0ID0gbGFiZWxzLmluZGV4T2YocmF3KTtcbiAgaWYgKGZpcnN0ID09PSAtMSkge1xuICAgIHJldHVybiBhZGRJZlN0cmluZyhsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKTtcbiAgfVxuICBjb25zdCBsYXN0ID0gbGFiZWxzLmxhc3RJbmRleE9mKHJhdyk7XG4gIHJldHVybiBmaXJzdCAhPT0gbGFzdCA/IGluZGV4IDogZmlyc3Q7XG59XG5cbmNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXgsIG1heCkgPT4gaW5kZXggPT09IG51bGwgPyBudWxsIDogX2xpbWl0VmFsdWUoTWF0aC5yb3VuZChpbmRleCksIDAsIG1heCk7XG5cbmZ1bmN0aW9uIF9nZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cbiAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPCBsYWJlbHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxhYmVsc1t2YWx1ZV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXRlZ29yeVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICdjYXRlZ29yeSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBfZ2V0TGFiZWxGb3JWYWx1ZVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICB9XG5cbiAgaW5pdChzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBhZGRlZCA9IHRoaXMuX2FkZGVkTGFiZWxzO1xuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICBmb3IgKGNvbnN0IHtpbmRleCwgbGFiZWx9IG9mIGFkZGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNbaW5kZXhdID09PSBsYWJlbCkge1xuICAgICAgICAgIGxhYmVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICAgIH1cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0aW9ucyk7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXhcbiAgICAgIDogZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIHZhbHVlT3JEZWZhdWx0KGluZGV4LCByYXcpLCB0aGlzLl9hZGRlZExhYmVscyk7XG4gICAgcmV0dXJuIHZhbGlkSW5kZXgoaW5kZXgsIGxhYmVscy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQ7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcblxuICAgIC8vIElmIHdlIGFyZSB2aWV3aW5nIHNvbWUgc3Vic2V0IG9mIGxhYmVscywgc2xpY2UgdGhlIG9yaWdpbmFsIGFycmF5XG4gICAgbGFiZWxzID0gKG1pbiA9PT0gMCAmJiBtYXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xuXG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KGxhYmVscy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5taW4gLSAob2Zmc2V0ID8gMC41IDogMCk7XG5cbiAgICBmb3IgKGxldCB2YWx1ZSA9IG1pbjsgdmFsdWUgPD0gbWF4OyB2YWx1ZSsrKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9nZXRMYWJlbEZvclZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHZlcnRpY2FsIGNhdGVnb3J5IHNjYWxlIHJldmVyc2UgaXMgaW52ZXJ0ZWQuXG4gICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gIXRoaXMuX3JldmVyc2VQaXhlbHM7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICAvLyBNdXN0IG92ZXJyaWRlIGJhc2UgaW1wbGVtZW50YXRpb24gYmVjYXVzZSBpdCBjYWxscyBnZXRQaXhlbEZvclZhbHVlXG4gIC8vIGFuZCBjYXRlZ29yeSBzY2FsZSBjYW4gaGF2ZSBkdXBsaWNhdGUgdmFsdWVzXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG59XG4iLCJpbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7YWxtb3N0RXF1YWxzLCBhbG1vc3RXaG9sZSwgbmljZU51bSwgX2RlY2ltYWxQbGFjZXMsIF9zZXRNaW5BbmRNYXhCeUtleSwgc2lnbiwgdG9SYWRpYW5zfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbGluZWFyIHRpY2tzIGZvciBhbiBheGlzXG4gKiAxLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5taW4sIGdlbmVyYXRpb25PcHRpb25zLm1heCwgYW5kIGdlbmVyYXRpb25PcHRpb25zLnN0ZXAgYXJlIGRlZmluZWQ6XG4gKiAgICBpZiAobWF4IC0gbWluKSAvIHN0ZXAgaXMgYW4gaW50ZWdlciwgdGlja3MgYXJlIGdlbmVyYXRlZCBhcyBbbWluLCBtaW4gKyBzdGVwLCAuLi4sIG1heF1cbiAqICAgIE5vdGUgdGhhdCB0aGUgZ2VuZXJhdGlvbk9wdGlvbnMubWF4Q291bnQgc2V0dGluZyBpcyByZXNwZWN0ZWQgaW4gdGhpcyBzY2VuYXJpb1xuICpcbiAqIDIuIElmIGdlbmVyYXRpb25PcHRpb25zLm1pbiwgZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCBhbmQgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gY291bnRcbiAqICAgIFRpY2tzIGFyZSBnZW5lcmF0ZWQgYXMgW21pbiwgbWluICsgc3BhY2luZywgLi4uLCBtYXhdXG4gKlxuICogMy4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBjb3VudFxuICpcbiAqIDQuIENvbXB1dGUgb3B0aW1hbCBzcGFjaW5nIG9mIHRpY2tzIHVzaW5nIG5pY2VOdW0gYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdFtdfSBhcnJheSBvZiB0aWNrIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8vIFRvIGdldCBhIFwibmljZVwiIHZhbHVlIGZvciB0aGUgdGljayBzcGFjaW5nLCB3ZSB3aWxsIHVzZSB0aGUgYXBwcm9wcmlhdGVseSBuYW1lZFxuICAvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNjg4MS9uaWNlLWxhYmVsLWFsZ29yaXRobS1mb3ItY2hhcnRzLXdpdGgtbWluaW11bS10aWNrc1xuICAvLyBmb3IgZGV0YWlscy5cblxuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuICBjb25zdCB7Ym91bmRzLCBzdGVwLCBtaW4sIG1heCwgcHJlY2lzaW9uLCBjb3VudCwgbWF4VGlja3MsIG1heERpZ2l0cywgaW5jbHVkZUJvdW5kc30gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgY29uc3QgdW5pdCA9IHN0ZXAgfHwgMTtcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICBjb25zdCB7bWluOiBybWluLCBtYXg6IHJtYXh9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XG4gIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG5cbiAgLy8gQmV5b25kIE1JTl9TUEFDSU5HIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYmVpbmcgdG8gbG9zZSBwcmVjaXNpb25cbiAgLy8gc3VjaCB0aGF0IHdlIGNhbid0IGRvIHRoZSBtYXRoIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aWNrc1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuXG4gIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgIC8vIElmIHRoZSBjYWxjdWxhdGVkIG51bSBvZiBzcGFjZXMgZXhjZWVkcyBtYXhOdW1TcGFjZXMsIHJlY2FsY3VsYXRlIGl0XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgcHJlY2lzaW9uLCByb3VuZCB0byB0aGF0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cblxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cblxuICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAvLyBDYXNlIDE6IElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBhcmUgc2V0IGFuZCB0aGV5IG1ha2UgYW4gZXZlbmx5IHNwYWNlZCBzY2FsZSB1c2UgaXQuXG4gICAgLy8gc3BhY2luZyA9IHN0ZXA7XG4gICAgLy8gbnVtU3BhY2VzID0gKG1heCAtIG1pbikgLyBzcGFjaW5nO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSByb3VuZCBoZXJlIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbG1vc3RXaG9sZSB0cmFuc2xhdGVkIGFuIEZQIGVycm9yXG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICAvLyBDYXNlcyAyICYgMywgd2UgaGF2ZSBhIGNvdW50IHNwZWNpZmllZC4gSGFuZGxlIG9wdGlvbmFsIHVzZXIgZGVmaW5lZCBlZGdlcyB0byB0aGUgcmFuZ2UuXG4gICAgLy8gU29tZXRpbWVzIHRoZXNlIGFyZSBuby1vcHMsIGJ1dCBpdCBtYWtlcyB0aGUgY29kZSBhIGxvdCBjbGVhcmVyXG4gICAgLy8gYW5kIHdoZW4gYSB1c2VyIGRlZmluZWQgcmFuZ2UgaXMgc3BlY2lmaWVkLCB3ZSB3YW50IHRoZSBjb3JyZWN0IHRpY2tzXG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZSA0XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG5cbiAgICAvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciByb3VuZGVkIHZhbHVlLCB1c2UgaXQuXG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBzcGFjaW5nIHdpbGwgaGF2ZSBjaGFuZ2VkIGluIGNhc2VzIDEsIDIsIGFuZCAzIHNvIHRoZSBmYWN0b3IgY2Fubm90IGJlIGNvbXB1dGVkXG4gIC8vIHVudGlsIHRoaXMgcG9pbnRcbiAgY29uc3QgZGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KFxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxuICAgIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pXG4gICk7XG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcblxuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrOyAvLyBTa2lwIG5pY2VNaW5cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBuZXh0IG5pY2UgdGljayBpcyBjbG9zZSB0byBtaW4sIHNraXAgaXRcbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgY29uc3QgdGlja1ZhbHVlID0gTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgaWYgKG1heERlZmluZWQgJiYgdGlja1ZhbHVlID4gbWF4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWx1ZX0pO1xuICB9XG5cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgdGljayBpcyB0b28gY2xvc2UgdG8gbWF4LCByZXBsYWNlIGl0IHdpdGggbWF4LCBlbHNlIGFkZCBtYXhcbiAgICBpZiAodGlja3MubGVuZ3RoICYmIGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cblxuICByZXR1cm4gdGlja3M7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XG4gIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihyYWQpIDogTWF0aC5jb3MocmFkKSkgfHwgMC4wMDE7XG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuICtyYXc7XG4gIH1cblxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG5cbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGxldCBvZmZzZXQgPSBtYXggPT09IDAgPyAxIDogTWF0aC5hYnMobWF4ICogMC4wNSk7XG5cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuXG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttYXhUaWNrc0xpbWl0LCBzdGVwU2l6ZX0gPSB0aWNrT3B0cztcbiAgICBsZXQgbWF4VGlja3M7XG5cbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHN0ZXBTaXplKSArIDE7XG4gICAgICBpZiAobWF4VGlja3MgPiAxMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG5cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heFRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgICAvLyBGaWd1cmUgb3V0IHdoYXQgdGhlIG1heCBudW1iZXIgb2YgdGlja3Mgd2UgY2FuIHN1cHBvcnQgaXQgaXMgYmFzZWQgb24gdGhlIHNpemUgb2ZcbiAgICAvLyB0aGUgYXhpcyBhcmVhLiBGb3Igbm93LCB3ZSBzYXkgdGhhdCB0aGUgbWluaW11bSB0aWNrIHNwYWNpbmcgaW4gcGl4ZWxzIG11c3QgYmUgNDBcbiAgICAvLyBXZSBhbHNvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byAxMSB3aGljaCBnaXZlcyBhIG5pY2UgMTAgc3F1YXJlcyBvblxuICAgIC8vIHRoZSBncmFwaC4gTWFrZSBzdXJlIHdlIGFsd2F5cyBoYXZlIGF0IGxlYXN0IDIgdGlja3NcbiAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICBtYXhUaWNrcyxcbiAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICBtaW46IG9wdHMubWluLFxuICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IHRoaXMuX3JhbmdlIHx8IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgfVxuXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3RvUmFkaWFuc30gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcblxuICBzdGF0aWMgaWQgPSAnbGluZWFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgIH1cbiAgfTtcblxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBtYXggOiAxO1xuXG4gICAgLy8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIG1pbiwgbWF4LCBiZWdpbkF0WmVyb1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pO1xuICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuXG4gIC8vIFV0aWxzXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuIiwiaW1wb3J0IHtmaW5pdGVPckRlZmF1bHQsIGlzRmluaXRlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHtfc2V0TWluQW5kTWF4QnlLZXksIGxvZzEwfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuXG5jb25zdCBsb2cxMEZsb29yID0gdiA9PiBNYXRoLmZsb29yKGxvZzEwKHYpKTtcbmNvbnN0IGNoYW5nZUV4cG9uZW50ID0gKHYsIG0pID0+IE1hdGgucG93KDEwLCBsb2cxMEZsb29yKHYpICsgbSk7XG5cbmZ1bmN0aW9uIGlzTWFqb3IodGlja1ZhbCkge1xuICBjb25zdCByZW1haW4gPSB0aWNrVmFsIC8gKE1hdGgucG93KDEwLCBsb2cxMEZsb29yKHRpY2tWYWwpKSk7XG4gIHJldHVybiByZW1haW4gPT09IDE7XG59XG5cbmZ1bmN0aW9uIHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkge1xuICBjb25zdCByYW5nZVN0ZXAgPSBNYXRoLnBvdygxMCwgcmFuZ2VFeHApO1xuICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IobWluIC8gcmFuZ2VTdGVwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5jZWlsKG1heCAvIHJhbmdlU3RlcCk7XG4gIHJldHVybiBlbmQgLSBzdGFydDtcbn1cblxuZnVuY3Rpb24gc3RhcnRFeHAobWluLCBtYXgpIHtcbiAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XG4gIGxldCByYW5nZUV4cCA9IGxvZzEwRmxvb3IocmFuZ2UpO1xuICB3aGlsZSAoc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSA+IDEwKSB7XG4gICAgcmFuZ2VFeHArKztcbiAgfVxuICB3aGlsZSAoc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSA8IDEwKSB7XG4gICAgcmFuZ2VFeHAtLTtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4ocmFuZ2VFeHAsIGxvZzEwRmxvb3IobWluKSk7XG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsb2dhcml0aG1pYyB0aWNrc1xuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdFtdfSBhcnJheSBvZiB0aWNrIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywge21pbiwgbWF4fSkge1xuICBtaW4gPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBtaW4pO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBtaW5FeHAgPSBsb2cxMEZsb29yKG1pbik7XG4gIGxldCBleHAgPSBzdGFydEV4cChtaW4sIG1heCk7XG4gIGxldCBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcbiAgY29uc3Qgc3RlcFNpemUgPSBNYXRoLnBvdygxMCwgZXhwKTtcbiAgY29uc3QgYmFzZSA9IG1pbkV4cCA+IGV4cCA/IE1hdGgucG93KDEwLCBtaW5FeHApIDogMDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLnJvdW5kKChtaW4gLSBiYXNlKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIGNvbnN0IG9mZnNldCA9IE1hdGguZmxvb3IoKG1pbiAtIGJhc2UpIC8gc3RlcFNpemUgLyAxMCkgKiBzdGVwU2l6ZSAqIDEwO1xuICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKChzdGFydCAtIG9mZnNldCkgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG4gIGxldCB2YWx1ZSA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucm91bmQoKGJhc2UgKyBvZmZzZXQgKyBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24pO1xuICB3aGlsZSAodmFsdWUgPCBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZSwgbWFqb3I6IGlzTWFqb3IodmFsdWUpLCBzaWduaWZpY2FuZH0pO1xuICAgIGlmIChzaWduaWZpY2FuZCA+PSAxMCkge1xuICAgICAgc2lnbmlmaWNhbmQgPSBzaWduaWZpY2FuZCA8IDE1ID8gMTUgOiAyMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmlmaWNhbmQrKztcbiAgICB9XG4gICAgaWYgKHNpZ25pZmljYW5kID49IDIwKSB7XG4gICAgICBleHArKztcbiAgICAgIHNpZ25pZmljYW5kID0gMjtcbiAgICAgIHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcbiAgICB9XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKChiYXNlICsgb2Zmc2V0ICsgc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9XG4gIGNvbnN0IGxhc3RUaWNrID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1heCwgdmFsdWUpO1xuICB0aWNrcy5wdXNoKHt2YWx1ZTogbGFzdFRpY2ssIG1ham9yOiBpc01ham9yKGxhc3RUaWNrKSwgc2lnbmlmaWNhbmR9KTtcblxuICByZXR1cm4gdGlja3M7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ2xvZ2FyaXRobWljJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWMsXG4gICAgICBtYWpvcjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3JhdywgaW5kZXhdKTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSA/IE1hdGgubWF4KDAsIG1pbikgOiBudWxsO1xuICAgIHRoaXMubWF4ID0gaXNGaW5pdGUobWF4KSA/IE1hdGgubWF4KDAsIG1heCkgOiBudWxsO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybykge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gaWYgZGF0YSBoYXMgYDBgIGluIGl0IG9yIGBiZWdpbkF0WmVyb2AgaXMgdHJ1ZSwgbWluIChub24gemVybykgdmFsdWUgaXMgYXQgYm90dG9tXG4gICAgLy8gb2Ygc2NhbGUsIGFuZCBpdCBkb2VzIG5vdCBlcXVhbCBzdWdnZXN0ZWRNaW4sIGxvd2VyIHRoZSBtaW4gYm91bmQgYnkgb25lIGV4cC5cbiAgICBpZiAodGhpcy5femVybyAmJiB0aGlzLm1pbiAhPT0gdGhpcy5fc3VnZ2VzdGVkTWluICYmICFpc0Zpbml0ZSh0aGlzLl91c2VyTWluKSkge1xuICAgICAgdGhpcy5taW4gPSBtaW4gPT09IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAwKSA/IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAtMSkgOiBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cblxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCBtaW4gPSB0aGlzLm1pbjtcbiAgICBsZXQgbWF4ID0gdGhpcy5tYXg7XG5cbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuXG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBpZiAobWluIDw9IDApIHsgLy8gaW5jbHVkZXMgbnVsbFxuICAgICAgICBzZXRNaW4oMSk7XG4gICAgICAgIHNldE1heCgxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWluLCAtMSkpO1xuICAgICAgICBzZXRNYXgoY2hhbmdlRXhwb25lbnQobWF4LCArMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluIDw9IDApIHtcbiAgICAgIHNldE1pbihjaGFuZ2VFeHBvbmVudChtYXgsIC0xKSk7XG4gICAgfVxuICAgIGlmIChtYXggPD0gMCkge1xuXG4gICAgICBzZXRNYXgoY2hhbmdlRXhwb25lbnQobWluLCArMSkpO1xuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBtaW46IHRoaXMuX3VzZXJNaW4sXG4gICAgICBtYXg6IHRoaXMuX3VzZXJNYXhcbiAgICB9O1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgdGhpcyk7XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzLFxuICAgIC8vIHNpbmNlIHdlIHByb2JhYmx5IGhhdmUgZXhwYW5kZWQgdGhlIHJhbmdlIG9mIHRoZSBzY2FsZVxuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJzAnXG4gICAgICA6IGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5taW47XG5cbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGxvZzEwKHRoaXMubWF4KSAtIGxvZzEwKHN0YXJ0KTtcbiAgfVxuXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKHZhbHVlID09PSB0aGlzLm1pblxuICAgICAgPyAwXG4gICAgICA6IChsb2cxMCh2YWx1ZSkgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGFydFZhbHVlICsgZGVjaW1hbCAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7X2xvbmdlc3RUZXh0LCBhZGRSb3VuZGVkUmVjdFBhdGgsIHJlbmRlclRleHQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7SEFMRl9QSSwgVEFVLCB0b0RlZ3JlZXMsIHRvUmFkaWFucywgX25vcm1hbGl6ZUFuZ2xlLCBQSX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0LCBpc0FycmF5LCBpc0Zpbml0ZSwgY2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCBpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHRvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xuICByZXR1cm4ge1xuICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIHBvaW50IGxhYmVsc1xuICovXG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcblxuICAvLyBSaWdodCwgdGhpcyBpcyByZWFsbHkgY29uZnVzaW5nIGFuZCB0aGVyZSBpcyBhIGxvdCBvZiBtYXRocyBnb2luZyBvbiBoZXJlXG4gIC8vIFRoZSBnaXN0IG9mIHRoZSBwcm9ibGVtIGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25ubmljay82OTZjYzljNTVmNGIwYmViOGZlOVxuICAvL1xuICAvLyBSZWFjdGlvbjogaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMvdG9vbXVjaHNjaWVuY2UuZ2lmXG4gIC8vXG4gIC8vIFNvbHV0aW9uOlxuICAvL1xuICAvLyBXZSBhc3N1bWUgdGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbiBpcyBoYWxmIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgYXQgZmlyc3RcbiAgLy8gYXQgZWFjaCBpbmRleCB3ZSBjaGVjayBpZiB0aGUgdGV4dCBvdmVybGFwcy5cbiAgLy9cbiAgLy8gV2hlcmUgaXQgZG9lcywgd2Ugc3RvcmUgdGhhdCBhbmdsZSBhbmQgdGhhdCBpbmRleC5cbiAgLy9cbiAgLy8gQWZ0ZXIgZmluZGluZyB0aGUgbGFyZ2VzdCBpbmRleCBhbmQgYW5nbGUgd2UgY2FsY3VsYXRlIGhvdyBtdWNoIHdlIG5lZWQgdG8gcmVtb3ZlXG4gIC8vIGZyb20gdGhlIHNoYXBlIHJhZGl1cyB0byBtb3ZlIHRoZSBwb2ludCBpbndhcmRzIGJ5IHRoYXQgeC5cbiAgLy9cbiAgLy8gV2UgYXZlcmFnZSB0aGUgbGVmdCBhbmQgcmlnaHQgZGlzdGFuY2VzIHRvIGdldCB0aGUgbWF4aW11bSBzaGFwZSByYWRpdXMgdGhhdCBjYW4gZml0IGluIHRoZSBib3hcbiAgLy8gYWxvbmcgd2l0aCBsYWJlbHMuXG4gIC8vXG4gIC8vIE9uY2Ugd2UgaGF2ZSB0aGF0LCB3ZSBjYW4gZmluZCB0aGUgY2VudHJlIHBvaW50IGZvciB0aGUgY2hhcnQsIGJ5IHRha2luZyB0aGUgeCB0ZXh0IHByb3RydXNpb25cbiAgLy8gb24gZWFjaCBzaWRlLCByZW1vdmluZyB0aGF0IGZyb20gdGhlIHNpemUsIGhhbHZpbmcgaXQgYW5kIGFkZGluZyB0aGUgbGVmdCB4IHByb3RydXNpb24gd2lkdGguXG4gIC8vXG4gIC8vIFRoaXMgd2lsbCBtZWFuIHdlIGhhdmUgYSBzaGFwZSBmaXR0ZWQgdG8gdGhlIGNhbnZhcywgYXMgbGFyZ2UgYXMgaXQgY2FuIGJlIHdpdGggdGhlIGxhYmVsc1xuICAvLyBhbmQgcG9zaXRpb24gaXQgaW4gdGhlIG1vc3Qgc3BhY2UgZWZmaWNpZW50IG1hbm5lclxuICAvL1xuICAvLyBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My95ZWFoc2NpZW5jZS5naWZcblxuICAvLyBHZXQgbWF4aW11bSByYWRpdXMgb2YgdGhlIHBvbHlnb24uIEVpdGhlciBoYWxmIHRoZSBoZWlnaHQgKG1pbnVzIHRoZSB0ZXh0IHdpZHRoKSBvciBoYWxmIHRoZSB3aWR0aC5cbiAgLy8gVXNlIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgKyBjaGFuZ2UuIC0gTWFrZSBzdXJlIEwvUiBwcm90cnVzaW9uIGlzIGF0IGxlYXN0IDAgdG8gc3RvcCBpc3N1ZXMgd2l0aCBjZW50cmUgcG9pbnRzXG4gIGNvbnN0IG9yaWcgPSB7XG4gICAgbDogc2NhbGUubGVmdCArIHNjYWxlLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgYjogc2NhbGUuYm90dG9tIC0gc2NhbGUuX3BhZGRpbmcuYm90dG9tXG4gIH07XG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IHBvaW50TGFiZWxPcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBfbm9ybWFsaXplQW5nbGUoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSArIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpKTtcbiAgICBjb25zdCBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG4gICAgY29uc3QgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcbiAgICB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZVJhZGlhbnMsIGhMaW1pdHMsIHZMaW1pdHMpO1xuICB9XG5cbiAgc2NhbGUuc2V0Q2VudGVyUG9pbnQoXG4gICAgb3JpZy5sIC0gbGltaXRzLmwsXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXG4gICAgb3JpZy50IC0gbGltaXRzLnQsXG4gICAgbGltaXRzLmIgLSBvcmlnLmJcbiAgKTtcblxuICAvLyBOb3cgdGhhdCB0ZXh0IHNpemUgaXMgZGV0ZXJtaW5lZCwgY29tcHV0ZSB0aGUgZnVsbCBwb3NpdGlvbnNcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcbiAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgeCA9IChvcmlnLmwgLSBoTGltaXRzLnN0YXJ0KSAvIHNpbjtcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgfSBlbHNlIGlmIChoTGltaXRzLmVuZCA+IG9yaWcucikge1xuICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICB9XG4gIGlmICh2TGltaXRzLnN0YXJ0IDwgb3JpZy50KSB7XG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgIGxpbWl0cy5iID0gTWF0aC5tYXgobGltaXRzLmIsIG9yaWcuYiArIHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxJdGVtKHNjYWxlLCBpbmRleCwgaXRlbU9wdHMpIHtcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICBjb25zdCB7ZXh0cmEsIGFkZGl0aW9uYWxBbmdsZSwgcGFkZGluZywgc2l6ZX0gPSBpdGVtT3B0cztcbiAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgcGFkZGluZywgYWRkaXRpb25hbEFuZ2xlKTtcbiAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gIGNvbnN0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBpZiB0byBkcmF3IG9yIG92ZXJsYXBwZWRcbiAgICB2aXNpYmxlOiB0cnVlLFxuXG4gICAgLy8gVGV4dCBwb3NpdGlvblxuICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgIHksXG5cbiAgICAvLyBUZXh0IHJlbmRlcmluZyBkYXRhXG4gICAgdGV4dEFsaWduLFxuXG4gICAgLy8gQm91bmRpbmcgYm94XG4gICAgbGVmdCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgYm90dG9tOiB5ICsgc2l6ZS5oXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKSB7XG4gIGlmICghYXJlYSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gaXRlbTtcbiAgY29uc3QgYXBleGVzSW5BcmVhID0gX2lzUG9pbnRJbkFyZWEoe3g6IGxlZnQsIHk6IHRvcH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHt4OiBsZWZ0LCB5OiBib3R0b219LCBhcmVhKSB8fFxuICAgIF9pc1BvaW50SW5BcmVhKHt4OiByaWdodCwgeTogdG9wfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe3g6IHJpZ2h0LCB5OiBib3R0b219LCBhcmVhKTtcbiAgcmV0dXJuICFhcGV4ZXNJbkFyZWE7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3Qge2NlbnRlclBvaW50TGFiZWxzLCBkaXNwbGF5fSA9IG9wdHMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGl0ZW1PcHRzID0ge1xuICAgIGV4dHJhOiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykgLyAyLFxuICAgIGFkZGl0aW9uYWxBbmdsZTogY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwXG4gIH07XG4gIGxldCBhcmVhO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgaXRlbU9wdHMucGFkZGluZyA9IHBhZGRpbmdbaV07XG4gICAgaXRlbU9wdHMuc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG5cbiAgICBjb25zdCBpdGVtID0gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGksIGl0ZW1PcHRzKTtcbiAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgIGlmIChkaXNwbGF5ID09PSAnYXV0bycpIHtcbiAgICAgIGl0ZW0udmlzaWJsZSA9IGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKTtcbiAgICAgIGlmIChpdGVtLnZpc2libGUpIHtcbiAgICAgICAgYXJlYSA9IGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcbiAgICByZXR1cm4gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9XG5cbiAgcmV0dXJuICdyaWdodCc7XG59XG5cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuICAgIHkgLT0gKGggLyAyKTtcbiAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG4gICAgeSAtPSBoO1xuICB9XG4gIHJldHVybiB5O1xufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHMsIGl0ZW0pIHtcbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBpdGVtO1xuICBjb25zdCB7YmFja2Ryb3BDb2xvcn0gPSBvcHRzO1xuXG4gIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMob3B0cy5ib3JkZXJSYWRpdXMpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcENvbG9yO1xuXG4gICAgY29uc3QgYmFja2Ryb3BMZWZ0ID0gbGVmdCAtIHBhZGRpbmcubGVmdDtcbiAgICBjb25zdCBiYWNrZHJvcFRvcCA9IHRvcCAtIHBhZGRpbmcudG9wO1xuICAgIGNvbnN0IGJhY2tkcm9wV2lkdGggPSByaWdodCAtIGxlZnQgKyBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGJhY2tkcm9wSGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQ7XG5cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICB4OiBiYWNrZHJvcExlZnQsXG4gICAgICAgIHk6IGJhY2tkcm9wVG9wLFxuICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxuICAgICAgICBoOiBiYWNrZHJvcEhlaWdodCxcbiAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICB9KTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuXG4gIGZvciAobGV0IGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBpdGVtID0gc2NhbGUuX3BvaW50TGFiZWxJdGVtc1tpXTtcbiAgICBpZiAoIWl0ZW0udmlzaWJsZSkge1xuICAgICAgLy8gb3ZlcmxhcHBpbmdcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvcHRzQXRJbmRleCA9IHBvaW50TGFiZWxzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0c0F0SW5kZXgsIGl0ZW0pO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICBjb25zdCB7eCwgeSwgdGV4dEFsaWdufSA9IGl0ZW07XG5cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eH0gPSBzY2FsZTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgLy8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIC8vIERyYXcgc3RyYWlnaHQgbGluZXMgY29ubmVjdGluZyBlYWNoIGluZGV4XG4gICAgbGV0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQsIGJvcmRlck9wdHMpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcblxuICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBncmlkTGluZU9wdHM7XG5cbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGJvcmRlck9wdHMuZGFzaCB8fCBbXSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlck9wdHMuZGFzaE9mZnNldDtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuXG4gIHN0YXRpYyBpZCA9ICdyYWRpYWxMaW5lYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHNjYWxpbmcgdGhlIGNoYXJ0IGZyb20gdGhlIGNlbnRyZVxuICAgIGFuaW1hdGU6IHRydWUsXG4gICAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxuXG4gICAgYW5nbGVMaW5lczoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIGJvcmRlckRhc2g6IFtdLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gICAgfSxcblxuICAgIGdyaWQ6IHtcbiAgICAgIGNpcmN1bGFyOiBmYWxzZVxuICAgIH0sXG5cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLy8gbGFiZWwgc2V0dGluZ3NcbiAgICB0aWNrczoge1xuICAgICAgLy8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAgfSxcblxuICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG5cbiAgICAgIC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIGFib3ZlICYgYmVsb3cgdGhlIGxhYmVsIGluIHBpeGVsc1xuICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuXG4gICAgICAvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgc2hvdyBwb2ludCBsYWJlbHNcbiAgICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAgIC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgc2l6ZTogMTBcbiAgICAgIH0sXG5cbiAgICAgIC8vIEZ1bmN0aW9uIC0gVXNlZCB0byBjb252ZXJ0IHBvaW50IGxhYmVsc1xuICAgICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSxcblxuICAgICAgLy8gTnVtYmVyIC0gQWRkaXRpb25sIHBhZGRpbmcgYmV0d2VlbiBzY2FsZSBhbmQgcG9pbnRMYWJlbFxuICAgICAgcGFkZGluZzogNSxcblxuICAgICAgLy8gQm9vbGVhbiAtIGlmIHRydWUsIGNlbnRlciBwb2ludCBsYWJlbHMgdG8gc2xpY2VzIGluIHBvbGFyIGNoYXJ0XG4gICAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgJ2FuZ2xlTGluZXMuY29sb3InOiAnYm9yZGVyQ29sb3InLFxuICAgICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBhbmdsZUxpbmVzOiB7XG4gICAgICBfZmFsbGJhY2s6ICdncmlkJ1xuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgaCAvIDIgKyBwYWRkaW5nLnRvcCk7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuICB9XG5cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0aWNrcyk7XG5cbiAgICAvLyBQb2ludCBsYWJlbHNcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKClcbiAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNhbGxDYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2LCBpKSA9PiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgfVxuXG4gIGZpdCgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cblxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMueUNlbnRlciArPSBNYXRoLmZsb29yKCh0b3BNb3ZlbWVudCAtIGJvdHRvbU1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gIH1cblxuICBnZXRJbmRleEFuZ2xlKGluZGV4KSB7XG4gICAgY29uc3QgYW5nbGVNdWx0aXBsaWVyID0gVEFVIC8gKHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCB8fCAxKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcblxuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG5cbiAgZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvICh0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcblxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyLCBhZGRpdGlvbmFsQW5nbGUgPSAwKSB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcbiAgfVxuXG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2JhY2tncm91bmRDb2xvciwgZ3JpZDoge2NpcmN1bGFyfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkLCBib3JkZXJ9ID0gb3B0cztcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuXG4gICAgbGV0IGksIG9mZnNldCwgcG9zaXRpb247XG5cbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDAgfHwgKGluZGV4ID09PSAwICYmIHRoaXMubWluIDwgMCkpIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG5cbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50LCBvcHRzQXRJbmRleEJvcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGZvciAoaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICAgICAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gb3B0c0F0SW5kZXg7XG5cbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcblxuICAgICAgICBjdHguc2V0TGluZURhc2gob3B0c0F0SW5kZXguYm9yZGVyRGFzaCk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge31cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgIGlmICgoaW5kZXggPT09IDAgJiYgdGhpcy5taW4gPj0gMCkgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XS52YWx1ZSk7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgLW9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gcGFkZGluZy50b3AsXG4gICAgICAgICAgd2lkdGggKyBwYWRkaW5nLndpZHRoLFxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcjogb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHt9XG59XG4iLCJpbXBvcnQgYWRhcHRlcnMgZnJvbSAnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbCwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIG1lcmdlSWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgaXNOdW1iZXIsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7X2FycmF5VW5pcXVlLCBfZmlsdGVyQmV0d2VlbiwgX2xvb2t1cH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5UaW1lVW5pdCB9IFVuaXRcbiAqIEB0eXBlZGVmIHt7Y29tbW9uOiBib29sZWFuLCBzaXplOiBudW1iZXIsIHN0ZXBzPzogbnVtYmVyfX0gSW50ZXJ2YWxcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5EYXRlQWRhcHRlciB9IERhdGVBZGFwdGVyXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PFVuaXQsIEludGVydmFsPn1cbiAqL1xuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcblxuLyoqXG4gKiBAdHlwZSB7VW5pdFtdfVxuICovXG5jb25zdCBVTklUUyA9IC8qKiBAdHlwZSBVbml0W10gKi8gLyogI19fUFVSRV9fICovIChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqL1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHsqfSBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG5cbiAgLy8gT25seSBwYXJzZSBpZiBpdCdzIG5vdCBhIHRpbWVzdGFtcCBhbHJlYWR5XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBwYXJzZXIpXG4gICAgICA6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocm91bmQpIHtcbiAgICB2YWx1ZSA9IHJvdW5kID09PSAnd2VlaycgJiYgKGlzTnVtYmVyKGlzb1dlZWtkYXkpIHx8IGlzb1dlZWtkYXkgPT09IHRydWUpXG4gICAgICA/IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgJ2lzb1dlZWsnLCBpc29XZWVrZGF5KVxuICAgICAgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgfVxuXG4gIHJldHVybiArdmFsdWU7XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHJlc3VsdHMgaW4gYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGF1dG8tZ2VuZXJhdGVkIHRpY2tzXG4gKiBAcGFyYW0ge1VuaXR9IG1pblVuaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuICAgIGNvbnN0IGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcbiAgICBjb25zdCBmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgICBpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCB0byBmb3JtYXQgYSBzZXQgb2YgdGlja3Mgd2l0aFxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtVGlja3NcbiAqIEBwYXJhbSB7VW5pdH0gbWluVW5pdFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHJldHVybiB7VW5pdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgaWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VuaXR9IHVuaXRcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHRpY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICogQHBhcmFtIHtudW1iZXJbXX0gW3RpbWVzdGFtcHNdIC0gaWYgZGVmaW5lZCwgc25hcCB0byB0aGVzZSB0aW1lc3RhbXBzXG4gKi9cbmZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbbG9dID49IHRpbWUgPyB0aW1lc3RhbXBzW2xvXSA6IHRpbWVzdGFtcHNbaGldO1xuICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuICogQHBhcmFtIHtvYmplY3R9IG1hcFxuICogQHBhcmFtIHtVbml0fSBtYWpvclVuaXRcbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XG4gIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgbGV0IG1ham9yLCBpbmRleDtcblxuICBmb3IgKG1ham9yID0gZmlyc3Q7IG1ham9yIDw9IGxhc3Q7IG1ham9yID0gK2FkYXB0ZXIuYWRkKG1ham9yLCAxLCBtYWpvclVuaXQpKSB7XG4gICAgaW5kZXggPSBtYXBbbWFqb3JdO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aWNrc1tpbmRleF0ubWFqb3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7VW5pdHx1bmRlZmluZWR9IFttYWpvclVuaXRdXG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgLyoqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLG9iamVjdD59ICovXG4gIGNvbnN0IG1hcCA9IHt9O1xuICBjb25zdCBpbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgbGV0IGksIHZhbHVlO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBtYXBbdmFsdWVdID0gaTtcblxuICAgIHRpY2tzLnB1c2goe1xuICAgICAgdmFsdWUsXG4gICAgICBtYWpvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdlIHNldCB0aGUgbWFqb3IgdGlja3Mgc2VwYXJhdGVseSBmcm9tIHRoZSBhYm92ZSBsb29wIGJlY2F1c2UgY2FsbGluZyBzdGFydE9mIGZvciBldmVyeSB0aWNrXG4gIC8vIGlzIGV4cGVuc2l2ZSB3aGVuIHRoZXJlIGlzIGEgbGFyZ2UgbnVtYmVyIG9mIHRpY2tzXG4gIHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICd0aW1lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICdkYXRhJyxcblxuICAgIGFkYXB0ZXJzOiB7fSxcbiAgICB0aW1lOiB7XG4gICAgICBwYXJzZXI6IGZhbHNlLCAvLyBmYWxzZSA9PSBhIHBhdHRlcm4gc3RyaW5nIGZyb20gb3IgYSBjdXN0b20gY2FsbGJhY2sgdGhhdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gYSB0aW1lc3RhbXBcbiAgICAgIHVuaXQ6IGZhbHNlLCAvLyBmYWxzZSA9PSBhdXRvbWF0aWMgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuICAgICAgcm91bmQ6IGZhbHNlLCAvLyBub25lLCBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXG4gICAgICBpc29XZWVrZGF5OiBmYWxzZSwgLy8gb3ZlcnJpZGUgd2VlayBzdGFydCBkYXlcbiAgICAgIG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG4gICAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgICB9LFxuICAgIHRpY2tzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRpY2tzIGdlbmVyYXRpb24gaW5wdXQgdmFsdWVzOlxuICAgICAgICogLSAnYXV0byc6IGdlbmVyYXRlcyBcIm9wdGltYWxcIiB0aWNrcyBiYXNlZCBvbiBzY2FsZSBzaXplIGFuZCB0aW1lIG9wdGlvbnMuXG4gICAgICAgKiAtICdkYXRhJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gZGF0YSAoaW5jbHVkaW5nIGxhYmVscyBmcm9tIGRhdGEge3R8eHx5fSBvYmplY3RzKS5cbiAgICAgICAqIC0gJ2xhYmVscyc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIHVzZXIgZ2l2ZW4gYGRhdGEubGFiZWxzYCB2YWx1ZXMgT05MWS5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTA3XG4gICAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgICAqL1xuICAgICAgc291cmNlOiAnYXV0bycsXG5cbiAgICAgIGNhbGxiYWNrOiBmYWxzZSxcblxuICAgICAgbWFqb3I6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuXHQgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAvKiogQHR5cGUge3tkYXRhOiBudW1iZXJbXSwgbGFiZWxzOiBudW1iZXJbXSwgYWxsOiBudW1iZXJbXX19ICovXG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcblxuICAgIC8qKiBAdHlwZSB7VW5pdH0gKi9cbiAgICB0aGlzLl91bml0ID0gJ2RheSc7XG4gICAgLyoqIEB0eXBlIHtVbml0PX0gKi9cbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHt9O1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpbml0KHNjYWxlT3B0cywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdGltZSA9IHNjYWxlT3B0cy50aW1lIHx8IChzY2FsZU9wdHMudGltZSA9IHt9KTtcbiAgICAvKiogQHR5cGUge0RhdGVBZGFwdGVyfSAqL1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyID0gbmV3IGFkYXB0ZXJzLl9kYXRlKHNjYWxlT3B0cy5hZGFwdGVycy5kYXRlKTtcblxuICAgIGFkYXB0ZXIuaW5pdChvcHRzKTtcblxuICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGJlZm9yZSBpbnRyb2R1Y2luZyBhZGFwdGVyLCBgZGlzcGxheUZvcm1hdHNgIHdhc1xuICAgIC8vIHN1cHBvc2VkIHRvIGNvbnRhaW4gKmFsbCogdW5pdC9zdHJpbmcgcGFpcnMgYnV0IHRoaXMgY2FuJ3QgYmUgcmVzb2x2ZWRcbiAgICAvLyB3aGVuIGxvYWRpbmcgdGhlIHNjYWxlIChhZGFwdGVycyBhcmUgbG9hZGVkIGFmdGVyd2FyZCksIHNvIGxldCdzIHBvcHVsYXRlXG4gICAgLy8gbWlzc2luZyBmb3JtYXRzIG9uIHVwZGF0ZVxuICAgIG1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xuXG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgcGFyc2VyOiB0aW1lLnBhcnNlcixcbiAgICAgIHJvdW5kOiB0aW1lLnJvdW5kLFxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XG4gICAgfTtcblxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRzKTtcblxuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBvcHRzLm5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHsqfSByYXdcblx0ICogQHBhcmFtIHtudW1iZXI/fSBbaW5kZXhdXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIHBhcnNlKHJhdywgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmIChyYXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZSh0aGlzLCByYXcpO1xuICB9XG5cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdW5pdCA9IG9wdGlvbnMudGltZS51bml0IHx8ICdkYXknO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuXG4gICAgLyoqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGJvdW5kc1xuXHRcdCAqL1xuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1pbikpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBib3VuZHMubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1heCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHVzZXIgcHJvdmlkZWQgYG1pbmAgYW5kIGBtYXhgIGxhYmVscyAvIGRhdGEgYm91bmRzIGNhbiBiZSBpZ25vcmVkXG4gICAgaWYgKCFtaW5EZWZpbmVkIHx8ICFtYXhEZWZpbmVkKSB7XG4gICAgICAvLyBMYWJlbHMgYXJlIGFsd2F5cyBjb25zaWRlcmVkLCB3aGVuIHVzZXIgZGlkIG5vdCBmb3JjZSBib3VuZHNcbiAgICAgIF9hcHBseUJvdW5kcyh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKTtcblxuICAgICAgLy8gSWYgYGJvdW5kc2AgaXMgYCd0aWNrcydgIGFuZCBgdGlja3Muc291cmNlYCBpcyBgJ2xhYmVscydgLFxuICAgICAgLy8gZGF0YSBib3VuZHMgYXJlIGlnbm9yZWQgKGFuZCBkb24ndCBuZWVkIHRvIGJlIGRldGVybWluZWQpXG4gICAgICBpZiAob3B0aW9ucy5ib3VuZHMgIT09ICd0aWNrcycgfHwgb3B0aW9ucy50aWNrcy5zb3VyY2UgIT09ICdsYWJlbHMnKSB7XG4gICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLmdldE1pbk1heChmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1pbiA9IGlzRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpO1xuICAgIG1heCA9IGlzRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDE7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgdGltZXNlcmllcyBsb29rdXAgdGFibGUpXG4gICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xuICAgIHRoaXMubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsQm91bmRzKCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiB7bWluLCBtYXh9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGlja09wdHMuc291cmNlID09PSAnbGFiZWxzJyA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1pbiA9IHRoaXMuX3VzZXJNaW4gfHwgdGltZXN0YW1wc1swXTtcbiAgICAgIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG5cbiAgICBjb25zdCB0aWNrcyA9IF9maWx0ZXJCZXR3ZWVuKHRpbWVzdGFtcHMsIG1pbiwgbWF4KTtcblxuICAgIC8vIFBSSVZBVEVcbiAgICAvLyBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyByZWxpZXMgb24gdGhlIG51bWJlciBvZiB0aWNrcyBzbyB3ZSBkb24ndCB1c2UgaXQgd2hlblxuICAgIC8vIGF1dG9Ta2lwIGlzIGVuYWJsZWQgYmVjYXVzZSB3ZSBkb24ndCB5ZXQga25vdyB3aGF0IHRoZSBmaW5hbCBudW1iZXIgb2YgdGlja3Mgd2lsbCBiZVxuICAgIHRoaXMuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8ICh0aWNrT3B0cy5hdXRvU2tpcFxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxuICAgICAgOiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyh0aGlzLCB0aWNrcy5sZW5ndGgsIHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZFxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQodGhpcy5fdW5pdCk7XG4gICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcblxuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCB0aWNrcywgdGhpcy5fbWFqb3JVbml0KTtcbiAgfVxuXG4gIGFmdGVyQXV0b1NraXAoKSB7XG4gICAgLy8gT2Zmc2V0cyBmb3IgYmFyIGNoYXJ0cyBuZWVkIHRvIGJlIGhhbmRsZWQgd2l0aCB0aGUgYXV0byBza2lwcGVkXG4gICAgLy8gdGlja3MuIE9uY2UgdGlja3MgaGF2ZSBiZWVuIHNraXBwZWQsIHdlIHJlLWNvbXB1dGUgdGhlIG9mZnNldHMuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXRBZnRlckF1dG9za2lwKSB7XG4gICAgICB0aGlzLmluaXRPZmZzZXRzKHRoaXMudGlja3MubWFwKHRpY2sgPT4gK3RpY2sudmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBvZmZzZXRzIGZyb20gZWRnZXMgaW4gdGhlIGZvcm0gb2Yge3N0YXJ0LCBlbmR9XG5cdCAqIHdoZXJlIGVhY2ggdmFsdWUgaXMgYSByZWxhdGl2ZSB3aWR0aCB0byB0aGUgc2NhbGUgYW5kIHJhbmdlcyBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cblx0ICogT2Zmc2V0cyBhcmUgYWRkZWQgd2hlbiB0aGUgYG9mZnNldGAgb3B0aW9uIGlzIHRydWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5pdE9mZnNldHModGltZXN0YW1wcyA9IFtdKSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBsZXQgZmlyc3QsIGxhc3Q7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IDEgLSBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMV0pIC0gZmlyc3QpIC8gMjtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSAobGFzdCAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB0aW1lc3RhbXBzLmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIGxpbWl0KTtcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcblxuICAgIHRoaXMuX29mZnNldHMgPSB7c3RhcnQsIGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdlbmVyYXRlcyBhIG1heGltdW0gb2YgYGNhcGFjaXR5YCB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHJvdW5kZWQgdG8gdGhlXG5cdCAqIGBtaW5vcmAgdW5pdCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXG5cdCAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcblx0ICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSk7XG4gICAgY29uc3Qgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLnN0ZXBTaXplLCAxKTtcbiAgICBjb25zdCB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcbiAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICBjb25zdCB0aWNrcyA9IHt9O1xuICAgIGxldCBmaXJzdCA9IG1pbjtcbiAgICBsZXQgdGltZSwgY291bnQ7XG5cbiAgICAvLyBGb3IgJ3dlZWsnIHVuaXQsIGhhbmRsZSB0aGUgZmlyc3QgZGF5IG9mIHdlZWsgb3B0aW9uXG4gICAgaWYgKGhhc1dlZWtkYXkpIHtcbiAgICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcbiAgICB9XG5cbiAgICAvLyBBbGlnbiBmaXJzdCB0aWNrcyBvbiB1bml0XG4gICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cbiAgICAvLyBQcmV2ZW50IGJyb3dzZXIgZnJvbSBmcmVlemluZyBpbiBjYXNlIHVzZXIgb3B0aW9ucyByZXF1ZXN0IG1pbGxpb25zIG9mIG1pbGxpc2Vjb25kc1xuICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcik7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWUgPT09IG1heCB8fCBvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyB8fCBjb3VudCA9PT0gMSkge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aWNrcykuc29ydChzb3J0ZXIpLm1hcCh4ID0+ICt4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG5cbiAgICBpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuICAgICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZm9ybWF0XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGZvcm1hdCh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IGZtdCA9IGZvcm1hdCB8fCBmb3JtYXRzW3VuaXRdO1xuICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh2YWx1ZSwgZm10KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBGdW5jdGlvbiB0byBmb3JtYXQgYW4gaW5kaXZpZHVhbCB0aWNrIG1hcmtcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gW2Zvcm1hdF1cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gb3B0aW9ucy50aWNrcy5jYWxsYmFjaztcblxuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiBjYWxsKGZvcm1hdHRlciwgW3RpbWUsIGluZGV4LCB0aWNrc10sIHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgbWFqb3JVbml0ID0gdGhpcy5fbWFqb3JVbml0O1xuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xuICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcblxuICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgfHwgKG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG5cdCAqL1xuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24odGljay52YWx1ZSwgaSwgdGlja3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgob2Zmc2V0cy5zdGFydCArIHBvcykgKiBvZmZzZXRzLmZhY3Rvcik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiB0aGlzLm1pbiArIHBvcyAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcblx0ICogQHJldHVybiB7e3c6bnVtYmVyLCBoOm51bWJlcn19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxTaXplKGxhYmVsKSB7XG4gICAgY29uc3QgdGlja3NPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tMYWJlbFdpZHRoID0gdGhpcy5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIGNvbnN0IGFuZ2xlID0gdG9SYWRpYW5zKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aWNrc09wdHMubWF4Um90YXRpb24gOiB0aWNrc09wdHMubWluUm90YXRpb24pO1xuICAgIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHRpY2tGb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkuc2l6ZTtcblxuICAgIHJldHVybiB7XG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxuICAgICAgaDogKHRpY2tMYWJlbFdpZHRoICogc2luUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uKVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGV4YW1wbGVUaW1lXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbENhcGFjaXR5KGV4YW1wbGVUaW1lKSB7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBjb25zdCBkaXNwbGF5Rm9ybWF0cyA9IHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzO1xuXG4gICAgLy8gcGljayB0aGUgbG9uZ2VzdCBmb3JtYXQgKG1pbGxpc2Vjb25kcykgZm9yIGd1ZXNzdGltYXRpb25cbiAgICBjb25zdCBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcbiAgICBjb25zdCBleGFtcGxlTGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgW2V4YW1wbGVUaW1lXSwgdGhpcy5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0TGFiZWxTaXplKGV4YW1wbGVMYWJlbCk7XG4gICAgLy8gc3VidHJhY3QgMSAtIGlmIG9mZnNldCB0aGVuIHRoZXJlJ3Mgb25lIGxlc3MgbGFiZWwgdGhhbiB0aWNrXG4gICAgLy8gaWYgbm90IG9mZnNldCB0aGVuIG9uZSBoYWxmIGxhYmVsIHBhZGRpbmcgaXMgYWRkZWQgdG8gZWFjaCBlbmQgbGVhdmluZyByb29tIGZvciBvbmUgbGVzcyBsYWJlbFxuICAgIGNvbnN0IGNhcGFjaXR5ID0gTWF0aC5mbG9vcih0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCAvIHNpemUudyA6IHRoaXMuaGVpZ2h0IC8gc2l6ZS5oKSAtIDE7XG4gICAgcmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmRhdGEgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuXG4gICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuY29uY2F0KG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxUaW1lc3RhbXBzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5sYWJlbHMgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChwYXJzZSh0aGlzLCBsYWJlbHNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHZhbHVlc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBub3JtYWxpemUodmFsdWVzKSB7XG4gICAgLy8gSXQgc2VlbXMgdG8gYmUgc29tZXdoYXQgZmFzdGVyIHRvIGRvIHNvcnRpbmcgZmlyc3RcbiAgICByZXR1cm4gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KHNvcnRlcikpO1xuICB9XG59XG4iLCJpbXBvcnQgVGltZVNjYWxlIGZyb20gJy4vc2NhbGUudGltZS5qcyc7XG5pbXBvcnQge19sb29rdXBCeUtleX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlcyB0aGUgZ2l2ZW4gc291cmNlIGB2YWxgIHVzaW5nIHRoZSB0YWJsZS4gSWYgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcywgdmFsdWVzXG4gKiBhdCBlZGdlcyBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIGxvb2t1cCB0aW1lIGJhc2VkIG9uIHBvc2l0aW9uIGluc3RlYWQgb2YgdmljZSB2ZXJzYVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0YWJsZSwgdmFsLCByZXZlcnNlKSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2U291cmNlLCBuZXh0U291cmNlLCBwcmV2VGFyZ2V0LCBuZXh0VGFyZ2V0O1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgfVxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHtwb3M6IG5leHRTb3VyY2UsIHRpbWU6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgIH1cbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7dGltZTogbmV4dFNvdXJjZSwgcG9zOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH1cblxuICBjb25zdCBzcGFuID0gbmV4dFNvdXJjZSAtIHByZXZTb3VyY2U7XG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cblxuY2xhc3MgVGltZVNlcmllc1NjYWxlIGV4dGVuZHMgVGltZVNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZXNlcmllcyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuXHQgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAvKiogQHR5cGUge29iamVjdFtdfSAqL1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fdGFibGUgPSB0aGlzLmJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcyk7XG4gICAgdGhpcy5fbWluUG9zID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWluKTtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICBzdXBlci5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxuXHQgKiAoYHBvc2ApIG9uIHRoZSBzY2FsZSwgYnkgc2VhcmNoaW5nIGVudHJpZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgcmVxdWVzdGVkIHZhbHVlLiBgcG9zYCBpc1xuXHQgKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcblx0ICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XG5cdCAqIHN0b3JlIHByZS1jb21wdXRlZCBwaXhlbHMsIGJ1dCB0aGUgc2NhbGUgZGltZW5zaW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgYXQgdGhlIHRpbWUgd2UgbmVlZFxuXHQgKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgbGV0IGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuICAgICAgaWYgKGN1cnIgPj0gbWluICYmIGN1cnIgPD0gbWF4KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbGVzcyB0aGF0IDIgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCB0aGUgc2NhbGUgaXMgZGVmaW5lZCBieSBtaW4gYW5kIG1heFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3RpbWU6IG1pbiwgcG9zOiAwfSxcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxuICAgICAgXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBuZXh0ID0gaXRlbXNbaSArIDFdO1xuICAgICAgcHJldiA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgIGN1cnIgPSBpdGVtc1tpXTtcblxuICAgICAgLy8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcbiAgICAgIGlmIChNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuICAgICAgICB0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgICogR2VuZXJhdGVzIGFsbCB0aW1lc3RhbXBzIGRlZmluZWQgaW4gdGhlIGRhdGEuXG4gICAgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG4gICAgKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGxldCB0aW1lc3RhbXBzID0gc3VwZXIuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBpZiAoIXRpbWVzdGFtcHMuaW5jbHVkZXMobWluKSB8fCAhdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRpbWVzdGFtcHMuc3BsaWNlKDAsIDAsIG1pbik7XG4gICAgfVxuICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtYXgpIHx8IHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gobWF4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYWxsIHRpbWVzdGFtcHNcblx0ICogQHJldHVybiB7bnVtYmVyW119XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsIHx8IFtdO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICAvLyBJZiBjb21iaW5pbmcgbGFiZWxzIGFuZCBkYXRhIChkYXRhIG1pZ2h0IG5vdCBjb250YWluIGFsbCBsYWJlbHMpLFxuICAgICAgLy8gd2UgbmVlZCB0byByZWNoZWNrIHVuaXF1ZW5lc3MgYW5kIHNvcnRcbiAgICAgIHRpbWVzdGFtcHMgPSB0aGlzLm5vcm1hbGl6ZShkYXRhLmNvbmNhdChsYWJlbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lc3RhbXBzID0gZGF0YS5sZW5ndGggPyBkYXRhIDogbGFiZWw7XG4gICAgfVxuICAgIHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgPSB0aW1lc3RhbXBzO1xuXG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIHZhbHVlKSAtIHRoaXMuX21pblBvcykgLyB0aGlzLl90YWJsZVJhbmdlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCBkZWNpbWFsICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgdHJ1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZVNlcmllc1NjYWxlO1xuIiwiZXhwb3J0ICogZnJvbSAnLi9jb250cm9sbGVycy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsYXRmb3JtL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NjYWxlcy9pbmRleC5qcyc7XG5cbmltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBzY2FsZXMgZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5leHBvcnQge1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlcmFibGVzID0gW1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbl07XG4iXSwibmFtZXMiOlsiQW5pbWF0b3IiLCJjb25zdHJ1Y3RvciIsIl9yZXF1ZXN0IiwiX2NoYXJ0cyIsIk1hcCIsIl9ydW5uaW5nIiwiX2xhc3REYXRlIiwidW5kZWZpbmVkIiwiX25vdGlmeSIsImNoYXJ0IiwiYW5pbXMiLCJkYXRlIiwidHlwZSIsImNhbGxiYWNrcyIsImxpc3RlbmVycyIsIm51bVN0ZXBzIiwiZHVyYXRpb24iLCJmb3JFYWNoIiwiZm4iLCJpbml0aWFsIiwiY3VycmVudFN0ZXAiLCJNYXRoIiwibWluIiwic3RhcnQiLCJfcmVmcmVzaCIsInJlcXVlc3RBbmltRnJhbWUiLCJjYWxsIiwid2luZG93IiwiX3VwZGF0ZSIsIkRhdGUiLCJub3ciLCJyZW1haW5pbmciLCJydW5uaW5nIiwiaXRlbXMiLCJsZW5ndGgiLCJpIiwiZHJhdyIsIml0ZW0iLCJfYWN0aXZlIiwiX3RvdGFsIiwidGljayIsInBvcCIsIl9nZXRBbmltcyIsImNoYXJ0cyIsImdldCIsImNvbXBsZXRlIiwicHJvZ3Jlc3MiLCJzZXQiLCJsaXN0ZW4iLCJldmVudCIsImNiIiwicHVzaCIsImFkZCIsImhhcyIsInJlZHVjZSIsImFjYyIsImN1ciIsIm1heCIsIl9kdXJhdGlvbiIsInN0b3AiLCJjYW5jZWwiLCJyZW1vdmUiLCJkZWxldGUiLCJhbmltYXRvciIsInRyYW5zcGFyZW50IiwiaW50ZXJwb2xhdG9ycyIsImJvb2xlYW4iLCJmcm9tIiwidG8iLCJmYWN0b3IiLCJjb2xvciIsImMwIiwiaGVscGVyc0NvbG9yIiwiYzEiLCJ2YWxpZCIsIm1peCIsImhleFN0cmluZyIsIm51bWJlciIsIkFuaW1hdGlvbiIsImNmZyIsInRhcmdldCIsInByb3AiLCJjdXJyZW50VmFsdWUiLCJyZXNvbHZlIiwiX2ZuIiwiX2Vhc2luZyIsImVmZmVjdHMiLCJlYXNpbmciLCJsaW5lYXIiLCJfc3RhcnQiLCJmbG9vciIsImRlbGF5IiwiX2xvb3AiLCJsb29wIiwiX3RhcmdldCIsIl9wcm9wIiwiX2Zyb20iLCJfdG8iLCJfcHJvbWlzZXMiLCJhY3RpdmUiLCJ1cGRhdGUiLCJlbGFwc2VkIiwicmVtYWluIiwid2FpdCIsInByb21pc2VzIiwiUHJvbWlzZSIsInJlcyIsInJlaiIsInJlc29sdmVkIiwibWV0aG9kIiwiQW5pbWF0aW9ucyIsImNvbmZpZyIsIl9jaGFydCIsIl9wcm9wZXJ0aWVzIiwiY29uZmlndXJlIiwiaXNPYmplY3QiLCJhbmltYXRpb25PcHRpb25zIiwiT2JqZWN0Iiwia2V5cyIsImRlZmF1bHRzIiwiYW5pbWF0aW9uIiwiYW5pbWF0ZWRQcm9wcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJrZXkiLCJvcHRpb24iLCJpc0FycmF5IiwicHJvcGVydGllcyIsIl9hbmltYXRlT3B0aW9ucyIsInZhbHVlcyIsIm5ld09wdGlvbnMiLCJvcHRpb25zIiwicmVzb2x2ZVRhcmdldE9wdGlvbnMiLCJhbmltYXRpb25zIiwiX2NyZWF0ZUFuaW1hdGlvbnMiLCIkc2hhcmVkIiwiYXdhaXRBbGwiLCIkYW5pbWF0aW9ucyIsInRoZW4iLCJwcm9wcyIsImNoYXJBdCIsInZhbHVlIiwic2l6ZSIsImFzc2lnbiIsImFuaW0iLCJhbGwiLCJzY2FsZUNsaXAiLCJzY2FsZSIsImFsbG93ZWRPdmVyZmxvdyIsIm9wdHMiLCJyZXZlcnNlIiwiZW5kIiwiZGVmYXVsdENsaXAiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ4IiwieSIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInRvQ2xpcCIsInQiLCJyIiwiYiIsImwiLCJkaXNhYmxlZCIsImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwiZmlsdGVyVmlzaWJsZSIsIm1ldGFzZXRzIiwiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsImlsZW4iLCJpbmRleCIsImFwcGx5U3RhY2siLCJzdGFjayIsImRzSW5kZXgiLCJzaW5nbGVNb2RlIiwibW9kZSIsImRhdGFzZXRJbmRleCIsIm90aGVyVmFsdWUiLCJmb3VuZCIsImlzRmluaXRlIiwic2lnbiIsImNvbnZlcnRPYmplY3REYXRhVG9BcnJheSIsImRhdGEiLCJtZXRhIiwiaVNjYWxlIiwidlNjYWxlIiwiaUF4aXNLZXkiLCJheGlzIiwidkF4aXNLZXkiLCJhZGF0YSIsIkFycmF5IiwiaXNTdGFja2VkIiwic3RhY2tlZCIsImdldFN0YWNrS2V5IiwiaW5kZXhTY2FsZSIsInZhbHVlU2NhbGUiLCJpZCIsImdldFVzZXJCb3VuZHMiLCJtaW5EZWZpbmVkIiwibWF4RGVmaW5lZCIsIk51bWJlciIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJnZXRPckNyZWF0ZVN0YWNrIiwic3RhY2tzIiwic3RhY2tLZXkiLCJpbmRleFZhbHVlIiwic3ViU3RhY2siLCJnZXRMYXN0SW5kZXhJblN0YWNrIiwicG9zaXRpdmUiLCJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsInVwZGF0ZVN0YWNrcyIsImNvbnRyb2xsZXIiLCJwYXJzZWQiLCJfY2FjaGVkTWV0YSIsIl9zdGFja3MiLCJpQXhpcyIsInZBeGlzIiwiaXRlbVN0YWNrcyIsIl90b3AiLCJfYm90dG9tIiwidmlzdWFsVmFsdWVzIiwiX3Zpc3VhbFZhbHVlcyIsImdldEZpcnN0U2NhbGVJZCIsInNjYWxlcyIsImZpbHRlciIsInNoaWZ0IiwiY3JlYXRlRGF0YXNldENvbnRleHQiLCJwYXJlbnQiLCJjcmVhdGVDb250ZXh0IiwiZGF0YXNldCIsImNyZWF0ZURhdGFDb250ZXh0IiwiZWxlbWVudCIsImRhdGFJbmRleCIsInJhdyIsImNsZWFyU3RhY2tzIiwiX3BhcnNlZCIsImlzRGlyZWN0VXBkYXRlTW9kZSIsImNsb25lSWZOb3RTaGFyZWQiLCJjYWNoZWQiLCJzaGFyZWQiLCJjcmVhdGVTdGFjayIsImNhblN0YWNrIiwiaGlkZGVuIiwiX3N0YWNrZWQiLCJEYXRhc2V0Q29udHJvbGxlciIsImRhdGFzZXRFbGVtZW50VHlwZSIsImRhdGFFbGVtZW50VHlwZSIsIl9jdHgiLCJjdHgiLCJfY2FjaGVkRGF0YU9wdHMiLCJnZXRNZXRhIiwiX3R5cGUiLCJfcGFyc2luZyIsIl9kYXRhIiwiX29iamVjdERhdGEiLCJfc2hhcmVkT3B0aW9ucyIsIl9kcmF3U3RhcnQiLCJfZHJhd0NvdW50IiwiZW5hYmxlT3B0aW9uU2hhcmluZyIsInN1cHBvcnRzRGVjaW1hdGlvbiIsIiRjb250ZXh0IiwiX3N5bmNMaXN0IiwiaW5pdGlhbGl6ZSIsImxpbmtTY2FsZXMiLCJhZGRFbGVtZW50cyIsImZpbGwiLCJpc1BsdWdpbkVuYWJsZWQiLCJjb25zb2xlIiwid2FybiIsInVwZGF0ZUluZGV4IiwiZ2V0RGF0YXNldCIsImNob29zZUlkIiwieGlkIiwieEF4aXNJRCIsInZhbHVlT3JEZWZhdWx0IiwieWlkIiwieUF4aXNJRCIsInJpZCIsInJBeGlzSUQiLCJpbmRleEF4aXMiLCJpaWQiLCJpQXhpc0lEIiwidmlkIiwidkF4aXNJRCIsImdldFNjYWxlRm9ySWQiLCJyU2NhbGUiLCJkYXRhc2V0cyIsImdldERhdGFzZXRNZXRhIiwic2NhbGVJRCIsIl9nZXRPdGhlclNjYWxlIiwicmVzZXQiLCJfZGVzdHJveSIsInVubGlzdGVuQXJyYXlFdmVudHMiLCJfZGF0YUNoZWNrIiwiaXNFeHRlbnNpYmxlIiwibGlzdGVuQXJyYXlFdmVudHMiLCJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCJyZXNldE5ld0VsZW1lbnRzIiwic3RhY2tDaGFuZ2VkIiwib2xkU3RhY2tlZCIsIl9yZXN5bmNFbGVtZW50cyIsInNjb3BlS2V5cyIsImRhdGFzZXRTY29wZUtleXMiLCJzY29wZXMiLCJnZXRPcHRpb25TY29wZXMiLCJjcmVhdGVSZXNvbHZlciIsImdldENvbnRleHQiLCJwYXJzaW5nIiwicGFyc2UiLCJjb3VudCIsInNvcnRlZCIsIl9zb3J0ZWQiLCJwcmV2IiwicGFyc2VBcnJheURhdGEiLCJwYXJzZU9iamVjdERhdGEiLCJwYXJzZVByaW1pdGl2ZURhdGEiLCJpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiIsImxhYmVscyIsImdldExhYmVscyIsInNpbmdsZVNjYWxlIiwieEF4aXNLZXkiLCJ5QXhpc0tleSIsInJlc29sdmVPYmplY3RLZXkiLCJnZXRQYXJzZWQiLCJnZXREYXRhRWxlbWVudCIsInVwZGF0ZVJhbmdlRnJvbVBhcnNlZCIsInJhbmdlIiwicGFyc2VkVmFsdWUiLCJOYU4iLCJnZXRNaW5NYXgiLCJvdGhlclNjYWxlIiwib3RoZXJNaW4iLCJvdGhlck1heCIsIl9za2lwIiwiZ2V0QWxsUGFyc2VkVmFsdWVzIiwiZ2V0TWF4T3ZlcmZsb3ciLCJnZXRMYWJlbEFuZFZhbHVlIiwibGFiZWwiLCJnZXRMYWJlbEZvclZhbHVlIiwiX2NsaXAiLCJjbGlwIiwiZWxlbWVudHMiLCJhcmVhIiwiY2hhcnRBcmVhIiwiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCJnZXRTdHlsZSIsInJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMiLCJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwiY29udGV4dCIsIl9yZXNvbHZlRWxlbWVudE9wdGlvbnMiLCJlbGVtZW50VHlwZSIsImNhY2hlIiwiY2FjaGVLZXkiLCJzaGFyaW5nIiwiZGVmaW5lZCIsImRhdGFzZXRFbGVtZW50U2NvcGVLZXlzIiwicHJlZml4ZXMiLCJuYW1lcyIsInJlc29sdmVOYW1lZE9wdGlvbnMiLCJmcmVlemUiLCJfcmVzb2x2ZUFuaW1hdGlvbnMiLCJ0cmFuc2l0aW9uIiwiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsIl9jYWNoZWFibGUiLCJnZXRTaGFyZWRPcHRpb25zIiwiaW5jbHVkZU9wdGlvbnMiLCJzaGFyZWRPcHRpb25zIiwiX2FuaW1hdGlvbnNEaXNhYmxlZCIsIl9nZXRTaGFyZWRPcHRpb25zIiwiZmlyc3RPcHRzIiwicHJldmlvdXNseVNoYXJlZE9wdGlvbnMiLCJ1cGRhdGVTaGFyZWRPcHRpb25zIiwidXBkYXRlRWxlbWVudCIsIl9zZXRTdHlsZSIsInJlbW92ZUhvdmVyU3R5bGUiLCJzZXRIb3ZlclN0eWxlIiwiX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlIiwiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwiYXJnMSIsImFyZzIiLCJudW1NZXRhIiwibnVtRGF0YSIsIl9pbnNlcnRFbGVtZW50cyIsIl9yZW1vdmVFbGVtZW50cyIsIm1vdmUiLCJhcnIiLCJ1cGRhdGVFbGVtZW50cyIsInJlbW92ZWQiLCJzcGxpY2UiLCJfc3luYyIsImFyZ3MiLCJfZGF0YUNoYW5nZXMiLCJfb25EYXRhUHVzaCIsImFyZ3VtZW50cyIsIl9vbkRhdGFQb3AiLCJfb25EYXRhU2hpZnQiLCJfb25EYXRhU3BsaWNlIiwibmV3Q291bnQiLCJfb25EYXRhVW5zaGlmdCIsImdldEFsbFNjYWxlVmFsdWVzIiwiX2NhY2hlIiwiJGJhciIsInZpc2libGVNZXRhcyIsImNvbmNhdCIsIl9hcnJheVVuaXF1ZSIsInNvcnQiLCJhIiwiY29tcHV0ZU1pblNhbXBsZVNpemUiLCJfbGVuZ3RoIiwiY3VyciIsInVwZGF0ZU1pbkFuZFByZXYiLCJhYnMiLCJnZXRQaXhlbEZvclZhbHVlIiwidGlja3MiLCJnZXRQaXhlbEZvclRpY2siLCJjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMiLCJydWxlciIsInN0YWNrQ291bnQiLCJ0aGlja25lc3MiLCJiYXJUaGlja25lc3MiLCJyYXRpbyIsImlzTnVsbE9yVW5kZWYiLCJjYXRlZ29yeVBlcmNlbnRhZ2UiLCJiYXJQZXJjZW50YWdlIiwiY2h1bmsiLCJwaXhlbHMiLCJjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzIiwibmV4dCIsInBlcmNlbnQiLCJwYXJzZUZsb2F0QmFyIiwiZW50cnkiLCJzdGFydFZhbHVlIiwiZW5kVmFsdWUiLCJiYXJTdGFydCIsImJhckVuZCIsIl9jdXN0b20iLCJwYXJzZVZhbHVlIiwicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwiaXNGbG9hdEJhciIsImN1c3RvbSIsImJhclNpZ24iLCJhY3R1YWxCYXNlIiwiaXNIb3Jpem9udGFsIiwiYm9yZGVyUHJvcHMiLCJob3Jpem9udGFsIiwiYmFzZSIsInNldEJvcmRlclNraXBwZWQiLCJlZGdlIiwiYm9yZGVyU2tpcHBlZCIsImVuYWJsZUJvcmRlclJhZGl1cyIsInBhcnNlRWRnZSIsInN3YXAiLCJzdGFydEVuZCIsIm9yaWciLCJ2MSIsInYyIiwidiIsInNldEluZmxhdGVBbW91bnQiLCJpbmZsYXRlQW1vdW50IiwiQmFyQ29udHJvbGxlciIsImdyb3VwZWQiLCJudW1iZXJzIiwib3ZlcnJpZGVzIiwiX2luZGV4XyIsIm9mZnNldCIsImdyaWQiLCJfdmFsdWVfIiwiYmVnaW5BdFplcm8iLCJvYmoiLCJiYXJzIiwiZ2V0QmFzZVBpeGVsIiwiX2dldFJ1bGVyIiwidnBpeGVscyIsImhlYWQiLCJfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMiLCJpcGl4ZWxzIiwiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwiY2VudGVyIiwiaGVpZ2h0Iiwid2lkdGgiLCJfZ2V0U3RhY2tzIiwibGFzdCIsImN1cnJlbnRQYXJzZWQiLCJpU2NhbGVWYWx1ZSIsInNraXBOdWxsIiwiZmluZCIsInZhbCIsImlzTmFOIiwiaW5kZXhPZiIsIl9nZXRTdGFja0NvdW50IiwiX2dldEF4aXNDb3VudCIsIl9nZXRBeGlzIiwiZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzIiwiaW5kZXhTY2FsZUlkIiwiZmlyc3RTY2FsZUF4aXNJZCIsIl9nZXRTdGFja0luZGV4IiwibmFtZSIsIl9zdGFydFBpeGVsIiwiX2VuZFBpeGVsIiwiYmFzZVZhbHVlIiwibWluQmFyTGVuZ3RoIiwiZmxvYXRpbmciLCJnZXREYXRhVmlzaWJpbGl0eSIsInN0YXJ0UGl4ZWwiLCJnZXRQaXhlbEZvckRlY2ltYWwiLCJlbmRQaXhlbCIsImdldFZhbHVlRm9yUGl4ZWwiLCJoYWxmR3JpZCIsImdldExpbmVXaWR0aEZvclZhbHVlIiwibWF4QmFyVGhpY2tuZXNzIiwiSW5maW5pdHkiLCJheGlzQ291bnQiLCJheGlzSUQiLCJheGlzTnVtYmVyIiwic3RhY2tJbmRleCIsInJlY3RzIiwiQnViYmxlQ29udHJvbGxlciIsInJhZGl1cyIsInBvaW50cyIsInBvaW50IiwiaVBpeGVsIiwidlBpeGVsIiwic2tpcCIsImdldFJhdGlvQW5kT2Zmc2V0Iiwicm90YXRpb24iLCJjaXJjdW1mZXJlbmNlIiwiY3V0b3V0IiwicmF0aW9YIiwicmF0aW9ZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJUQVUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJzdGFydFgiLCJjb3MiLCJzdGFydFkiLCJzaW4iLCJlbmRYIiwiZW5kWSIsImNhbGNNYXgiLCJhbmdsZSIsIl9hbmdsZUJldHdlZW4iLCJjYWxjTWluIiwibWF4WCIsIm1heFkiLCJIQUxGX1BJIiwibWluWCIsIlBJIiwibWluWSIsIkRvdWdobnV0Q29udHJvbGxlciIsImFuaW1hdGVSb3RhdGUiLCJhbmltYXRlU2NhbGUiLCJzcGFjaW5nIiwiZGVzY3JpcHRvcnMiLCJfc2NyaXB0YWJsZSIsIl9pbmRleGFibGUiLCJzdGFydHNXaXRoIiwiYXNwZWN0UmF0aW8iLCJwbHVnaW5zIiwibGVnZW5kIiwiZ2VuZXJhdGVMYWJlbHMiLCJwb2ludFN0eWxlIiwidGV4dEFsaWduIiwidXNlQm9yZGVyUmFkaXVzIiwiYm9yZGVyUmFkaXVzIiwibWFwIiwic3R5bGUiLCJ0ZXh0IiwiZmlsbFN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwiZm9udENvbG9yIiwibGluZURhc2giLCJib3JkZXJEYXNoIiwibGluZURhc2hPZmZzZXQiLCJib3JkZXJEYXNoT2Zmc2V0IiwibGluZUpvaW4iLCJib3JkZXJKb2luU3R5bGUiLCJsaW5lV2lkdGgiLCJib3JkZXJXaWR0aCIsInN0cm9rZVN0eWxlIiwiYm9yZGVyQ29sb3IiLCJvbkNsaWNrIiwiZSIsImxlZ2VuZEl0ZW0iLCJ0b2dnbGVEYXRhVmlzaWJpbGl0eSIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJnZXR0ZXIiLCJfZ2V0Um90YXRpb24iLCJ0b1JhZGlhbnMiLCJfZ2V0Q2lyY3VtZmVyZW5jZSIsIl9nZXRSb3RhdGlvbkV4dGVudHMiLCJpc0RhdGFzZXRWaXNpYmxlIiwiYXJjcyIsImdldE1heEJvcmRlcldpZHRoIiwiZ2V0TWF4T2Zmc2V0IiwibWF4U2l6ZSIsInRvUGVyY2VudGFnZSIsImNoYXJ0V2VpZ2h0IiwiX2dldFJpbmdXZWlnaHQiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1heFJhZGl1cyIsInRvRGltZW5zaW9uIiwicmFkaXVzTGVuZ3RoIiwiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCJ0b3RhbCIsImNhbGN1bGF0ZVRvdGFsIiwiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCJfY2lyY3VtZmVyZW5jZSIsImNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UiLCJhbmltYXRpb25PcHRzIiwiY2VudGVyWCIsImNlbnRlclkiLCJhcmMiLCJtZXRhRGF0YSIsImZvcm1hdE51bWJlciIsImxvY2FsZSIsImJvcmRlckFsaWduIiwiaG92ZXJCb3JkZXJXaWR0aCIsImhvdmVyT2Zmc2V0IiwicmluZ1dlaWdodE9mZnNldCIsIndlaWdodCIsIkxpbmVDb250cm9sbGVyIiwic2hvd0xpbmUiLCJzcGFuR2FwcyIsImxpbmUiLCJfZGF0YXNldCIsImFuaW1hdGlvbnNEaXNhYmxlZCIsIl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIiwiX3NjYWxlUmFuZ2VzQ2hhbmdlZCIsIl9kYXRhc2V0SW5kZXgiLCJfZGVjaW1hdGVkIiwic2VnbWVudCIsImFuaW1hdGVkIiwibWF4R2FwTGVuZ3RoIiwiaXNOdW1iZXIiLCJkaXJlY3RVcGRhdGUiLCJwb2ludHNDb3VudCIsInByZXZQYXJzZWQiLCJudWxsRGF0YSIsImJvcmRlciIsImZpcnN0UG9pbnQiLCJsYXN0UG9pbnQiLCJ1cGRhdGVDb250cm9sUG9pbnRzIiwiUG9sYXJBcmVhQ29udHJvbGxlciIsImFuZ2xlTGluZXMiLCJkaXNwbGF5IiwiY2lyY3VsYXIiLCJwb2ludExhYmVscyIsIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsImJpbmQiLCJfdXBkYXRlUmFkaXVzIiwibWluU2l6ZSIsImN1dG91dFBlcmNlbnRhZ2UiLCJnZXRWaXNpYmxlRGF0YXNldENvdW50IiwieENlbnRlciIsInlDZW50ZXIiLCJkYXRhc2V0U3RhcnRBbmdsZSIsImdldEluZGV4QW5nbGUiLCJkZWZhdWx0QW5nbGUiLCJjb3VudFZpc2libGVFbGVtZW50cyIsIl9jb21wdXRlQW5nbGUiLCJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsIlBpZUNvbnRyb2xsZXIiLCJSYWRhckNvbnRyb2xsZXIiLCJfZnVsbExvb3AiLCJwb2ludFBvc2l0aW9uIiwiZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlIiwiU2NhdHRlckNvbnRyb2xsZXIiLCJpbnRlcmFjdGlvbiIsInJlZ2lzdHJ5IiwiZ2V0RWxlbWVudCIsImFic3RyYWN0IiwiRXJyb3IiLCJEYXRlQWRhcHRlckJhc2UiLCJvdmVycmlkZSIsIm1lbWJlcnMiLCJwcm90b3R5cGUiLCJpbml0IiwiZm9ybWF0cyIsImZvcm1hdCIsImRpZmYiLCJzdGFydE9mIiwiZW5kT2YiLCJhZGFwdGVycyIsIl9kYXRlIiwiYmluYXJ5U2VhcmNoIiwibWV0YXNldCIsImludGVyc2VjdCIsImxvb2t1cE1ldGhvZCIsIl9yZXZlcnNlUGl4ZWxzIiwiX3Jsb29rdXBCeUtleSIsIl9sb29rdXBCeUtleSIsInJlc3VsdCIsImRpc3RhbmNlVG9EZWZpbmVkTG8iLCJzbGljZSIsImxvIiwiZmluZEluZGV4IiwiZGlzdGFuY2VUb0RlZmluZWRIaSIsImhpIiwiZWwiLCJnZXRSYW5nZSIsImV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyIsInBvc2l0aW9uIiwiaGFuZGxlciIsImdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMiLCJqIiwiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwidXNlWCIsInVzZVkiLCJwdDEiLCJwdDIiLCJkZWx0YVgiLCJkZWx0YVkiLCJzcXJ0IiwicG93IiwiZ2V0SW50ZXJzZWN0SXRlbXMiLCJ1c2VGaW5hbFBvc2l0aW9uIiwiaW5jbHVkZUludmlzaWJsZSIsImlzUG9pbnRJbkFyZWEiLCJldmFsdWF0aW9uRnVuYyIsIl9pc1BvaW50SW5BcmVhIiwiaW5SYW5nZSIsImdldE5lYXJlc3RSYWRpYWxJdGVtcyIsImdldFByb3BzIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMiLCJkaXN0YW5jZU1ldHJpYyIsIm1pbkRpc3RhbmNlIiwiZ2V0Q2VudGVyUG9pbnQiLCJwb2ludEluQXJlYSIsImRpc3RhbmNlIiwiZ2V0TmVhcmVzdEl0ZW1zIiwiZ2V0QXhpc0l0ZW1zIiwicmFuZ2VNZXRob2QiLCJpbnRlcnNlY3RzSXRlbSIsIkludGVyYWN0aW9uIiwibW9kZXMiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwibmVhcmVzdCIsIlNUQVRJQ19QT1NJVElPTlMiLCJmaWx0ZXJCeVBvc2l0aW9uIiwiYXJyYXkiLCJwb3MiLCJmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMiLCJib3giLCJzb3J0QnlXZWlnaHQiLCJ2MCIsIndyYXBCb3hlcyIsImJveGVzIiwibGF5b3V0Qm94ZXMiLCJzdGFja1dlaWdodCIsImJ1aWxkU3RhY2tzIiwibGF5b3V0cyIsIndyYXAiLCJpbmNsdWRlcyIsIl9zdGFjayIsInBsYWNlZCIsInNldExheW91dERpbXMiLCJwYXJhbXMiLCJ2Qm94TWF4V2lkdGgiLCJoQm94TWF4SGVpZ2h0IiwibGF5b3V0IiwiZnVsbFNpemUiLCJhdmFpbGFibGVXaWR0aCIsImF2YWlsYWJsZUhlaWdodCIsImJ1aWxkTGF5b3V0Qm94ZXMiLCJjZW50ZXJIb3Jpem9udGFsIiwiY2VudGVyVmVydGljYWwiLCJsZWZ0QW5kVG9wIiwicmlnaHRBbmRCb3R0b20iLCJ2ZXJ0aWNhbCIsImdldENvbWJpbmVkTWF4IiwibWF4UGFkZGluZyIsInVwZGF0ZU1heFBhZGRpbmciLCJib3hQYWRkaW5nIiwidXBkYXRlRGltcyIsImdldFBhZGRpbmciLCJuZXdXaWR0aCIsIm91dGVyV2lkdGgiLCJuZXdIZWlnaHQiLCJvdXRlckhlaWdodCIsIndpZHRoQ2hhbmdlZCIsInciLCJoZWlnaHRDaGFuZ2VkIiwiaCIsInNhbWUiLCJvdGhlciIsImhhbmRsZU1heFBhZGRpbmciLCJ1cGRhdGVQb3MiLCJjaGFuZ2UiLCJnZXRNYXJnaW5zIiwibWFyZ2luRm9yUG9zaXRpb25zIiwicG9zaXRpb25zIiwibWFyZ2luIiwiZml0Qm94ZXMiLCJyZWZpdEJveGVzIiwicmVmaXQiLCJjaGFuZ2VkIiwic2V0Qm94RGltcyIsInBsYWNlQm94ZXMiLCJ1c2VyUGFkZGluZyIsInBhZGRpbmciLCJhZGRCb3giLCJfbGF5ZXJzIiwieiIsInJlbW92ZUJveCIsImxheW91dEl0ZW0iLCJtaW5QYWRkaW5nIiwidG9QYWRkaW5nIiwidmVydGljYWxCb3hlcyIsImhvcml6b250YWxCb3hlcyIsImVhY2giLCJiZWZvcmVMYXlvdXQiLCJ2aXNpYmxlVmVydGljYWxCb3hDb3VudCIsIkJhc2VQbGF0Zm9ybSIsImFjcXVpcmVDb250ZXh0IiwiY2FudmFzIiwicmVsZWFzZUNvbnRleHQiLCJhZGRFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImdldE1heGltdW1TaXplIiwiaXNBdHRhY2hlZCIsInVwZGF0ZUNvbmZpZyIsIkJhc2ljUGxhdGZvcm0iLCJFWFBBTkRPX0tFWSIsIkVWRU5UX1RZUEVTIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJvdXQiLCJpc051bGxPckVtcHR5IiwiaW5pdENhbnZhcyIsInJlbmRlckhlaWdodCIsImdldEF0dHJpYnV0ZSIsInJlbmRlcldpZHRoIiwiYm94U2l6aW5nIiwiZGlzcGxheVdpZHRoIiwicmVhZFVzZWRTaXplIiwiZGlzcGxheUhlaWdodCIsImV2ZW50TGlzdGVuZXJPcHRpb25zIiwic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsInBhc3NpdmUiLCJhZGRMaXN0ZW5lciIsIm5vZGUiLCJyZW1vdmVMaXN0ZW5lciIsImZyb21OYXRpdmVFdmVudCIsIm5hdGl2ZSIsIm5vZGVMaXN0Q29udGFpbnMiLCJub2RlTGlzdCIsImNvbnRhaW5zIiwiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwidHJpZ2dlciIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJvYnNlcnZlIiwiZG9jdW1lbnQiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiY3JlYXRlRGV0YWNoT2JzZXJ2ZXIiLCJkcnBMaXN0ZW5pbmdDaGFydHMiLCJvbGREZXZpY2VQaXhlbFJhdGlvIiwib25XaW5kb3dSZXNpemUiLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwicmVzaXplIiwiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCJsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsInVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCJjcmVhdGVSZXNpemVPYnNlcnZlciIsImNvbnRhaW5lciIsIl9nZXRQYXJlbnROb2RlIiwidGhyb3R0bGVkIiwiY2xpZW50V2lkdGgiLCJSZXNpemVPYnNlcnZlciIsImNvbnRlbnRSZWN0IiwicmVsZWFzZU9ic2VydmVyIiwiZGlzY29ubmVjdCIsImNyZWF0ZVByb3h5QW5kTGlzdGVuIiwicHJveHkiLCJEb21QbGF0Zm9ybSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInByb3hpZXMiLCIkcHJveGllcyIsImhhbmRsZXJzIiwiYXR0YWNoIiwiZGV0YWNoIiwiaXNDb25uZWN0ZWQiLCJfZGV0ZWN0UGxhdGZvcm0iLCJfaXNEb21TdXBwb3J0ZWQiLCJPZmZzY3JlZW5DYW52YXMiLCJFbGVtZW50IiwiZGVmYXVsdFJvdXRlcyIsInRvb2x0aXBQb3NpdGlvbiIsImhhc1ZhbHVlIiwiZmluYWwiLCJyZXQiLCJhdXRvU2tpcCIsInRpY2tPcHRzIiwiZGV0ZXJtaW5lZE1heFRpY2tzIiwiZGV0ZXJtaW5lTWF4VGlja3MiLCJ0aWNrc0xpbWl0IiwibWF4VGlja3NMaW1pdCIsIm1ham9ySW5kaWNlcyIsIm1ham9yIiwiZW5hYmxlZCIsImdldE1ham9ySW5kaWNlcyIsIm51bU1ham9ySW5kaWNlcyIsImZpcnN0IiwibmV3VGlja3MiLCJza2lwTWFqb3JzIiwiY2FsY3VsYXRlU3BhY2luZyIsImF2Z01ham9yU3BhY2luZyIsInJvdW5kIiwidGlja0xlbmd0aCIsIl90aWNrU2l6ZSIsIm1heFNjYWxlIiwibWF4Q2hhcnQiLCJfbWF4TGVuZ3RoIiwiZXZlbk1ham9yU3BhY2luZyIsImdldEV2ZW5TcGFjaW5nIiwiZmFjdG9ycyIsIl9mYWN0b3JpemUiLCJjZWlsIiwibWFqb3JTdGFydCIsIm1ham9yRW5kIiwibGVuIiwicmV2ZXJzZUFsaWduIiwiYWxpZ24iLCJvZmZzZXRGcm9tRWRnZSIsImdldFRpY2tzTGltaXQiLCJ0aWNrc0xlbmd0aCIsInNhbXBsZSIsIm51bUl0ZW1zIiwiaW5jcmVtZW50IiwiZ2V0UGl4ZWxGb3JHcmlkTGluZSIsIm9mZnNldEdyaWRMaW5lcyIsInZhbGlkSW5kZXgiLCJlcHNpbG9uIiwibGluZVZhbHVlIiwiZ2FyYmFnZUNvbGxlY3QiLCJjYWNoZXMiLCJnYyIsImdjTGVuIiwiZ2V0VGlja01hcmtMZW5ndGgiLCJkcmF3VGlja3MiLCJnZXRUaXRsZUhlaWdodCIsImZhbGxiYWNrIiwiZm9udCIsInRvRm9udCIsImxpbmVzIiwibGluZUhlaWdodCIsImNyZWF0ZVNjYWxlQ29udGV4dCIsImNyZWF0ZVRpY2tDb250ZXh0IiwidGl0bGVBbGlnbiIsIl90b0xlZnRSaWdodENlbnRlciIsInRpdGxlQXJncyIsInRpdGxlWCIsInRpdGxlWSIsIl9hbGlnblN0YXJ0RW5kIiwicG9zaXRpb25BeGlzSUQiLCJTY2FsZSIsIl9tYXJnaW5zIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImxhYmVsUm90YXRpb24iLCJfcmFuZ2UiLCJfZ3JpZExpbmVJdGVtcyIsIl9sYWJlbEl0ZW1zIiwiX2xhYmVsU2l6ZXMiLCJfbG9uZ2VzdFRleHRDYWNoZSIsIl91c2VyTWF4IiwiX3VzZXJNaW4iLCJfc3VnZ2VzdGVkTWF4IiwiX3N1Z2dlc3RlZE1pbiIsIl90aWNrc0xlbmd0aCIsIl9ib3JkZXJWYWx1ZSIsIl9kYXRhTGltaXRzQ2FjaGVkIiwic2V0Q29udGV4dCIsInN1Z2dlc3RlZE1pbiIsInN1Z2dlc3RlZE1heCIsImZpbml0ZU9yRGVmYXVsdCIsIm1ldGFzIiwiZ2V0VGlja3MiLCJ4TGFiZWxzIiwieUxhYmVscyIsImdldExhYmVsSXRlbXMiLCJfY29tcHV0ZUxhYmVsSXRlbXMiLCJiZWZvcmVVcGRhdGUiLCJtYXJnaW5zIiwiZ3JhY2UiLCJzYW1wbGVTaXplIiwiYmVmb3JlU2V0RGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJhZnRlclNldERpbWVuc2lvbnMiLCJiZWZvcmVEYXRhTGltaXRzIiwiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsImFmdGVyRGF0YUxpbWl0cyIsIl9hZGRHcmFjZSIsImJlZm9yZUJ1aWxkVGlja3MiLCJidWlsZFRpY2tzIiwiYWZ0ZXJCdWlsZFRpY2tzIiwic2FtcGxpbmdFbmFibGVkIiwiX2NvbnZlcnRUaWNrc1RvTGFiZWxzIiwiYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsImNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCJhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCJzb3VyY2UiLCJhZnRlckF1dG9Ta2lwIiwiYmVmb3JlRml0IiwiZml0IiwiYWZ0ZXJGaXQiLCJhZnRlclVwZGF0ZSIsInJldmVyc2VQaXhlbHMiLCJfYWxpZ25Ub1BpeGVscyIsImFsaWduVG9QaXhlbHMiLCJfY2FsbEhvb2tzIiwibm90aWZ5UGx1Z2lucyIsImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImdlbmVyYXRlVGlja0xhYmVscyIsImNhbGxiYWNrIiwiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJudW1UaWNrcyIsIm1pblJvdGF0aW9uIiwibWF4Um90YXRpb24iLCJ0aWNrV2lkdGgiLCJtYXhMYWJlbERpYWdvbmFsIiwiX2lzVmlzaWJsZSIsImxhYmVsU2l6ZXMiLCJfZ2V0TGFiZWxTaXplcyIsIm1heExhYmVsV2lkdGgiLCJ3aWRlc3QiLCJtYXhMYWJlbEhlaWdodCIsImhpZ2hlc3QiLCJfbGltaXRWYWx1ZSIsInRpdGxlIiwidG9EZWdyZWVzIiwiYXNpbiIsInRpdGxlT3B0cyIsImdyaWRPcHRzIiwidGl0bGVIZWlnaHQiLCJ0aWNrUGFkZGluZyIsImFuZ2xlUmFkaWFucyIsImxhYmVsSGVpZ2h0IiwibWlycm9yIiwibGFiZWxXaWR0aCIsIl9jYWxjdWxhdGVQYWRkaW5nIiwiX2hhbmRsZU1hcmdpbnMiLCJpc1JvdGF0ZWQiLCJsYWJlbHNCZWxvd1RpY2tzIiwib2Zmc2V0TGVmdCIsIm9mZnNldFJpZ2h0IiwiaXNGdWxsU2l6ZSIsIl9jb21wdXRlTGFiZWxTaXplcyIsIndpZHRocyIsImhlaWdodHMiLCJ3aWRlc3RMYWJlbFNpemUiLCJoaWdoZXN0TGFiZWxTaXplIiwiamxlbiIsInRpY2tGb250IiwiZm9udFN0cmluZyIsIm5lc3RlZExhYmVsIiwiX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMiLCJzdHJpbmciLCJfbWVhc3VyZVRleHQiLCJ2YWx1ZUF0IiwiaWR4IiwicGl4ZWwiLCJkZWNpbWFsIiwiX2ludDE2UmFuZ2UiLCJfYWxpZ25QaXhlbCIsImdldERlY2ltYWxGb3JQaXhlbCIsImdldEJhc2VWYWx1ZSIsIm9wdGlvblRpY2tzIiwicm90IiwiYXV0b1NraXBQYWRkaW5nIiwiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwidGwiLCJib3JkZXJPcHRzIiwiYXhpc1dpZHRoIiwiYXhpc0hhbGZXaWR0aCIsImFsaWduQm9yZGVyVmFsdWUiLCJib3JkZXJWYWx1ZSIsImFsaWduZWRMaW5lVmFsdWUiLCJ0eDEiLCJ0eTEiLCJ0eDIiLCJ0eTIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxpbWl0Iiwic3RlcCIsIm9wdHNBdEluZGV4Iiwib3B0c0F0SW5kZXhCb3JkZXIiLCJsaW5lQ29sb3IiLCJkYXNoIiwiZGFzaE9mZnNldCIsInRpY2tDb2xvciIsInRpY2tCb3JkZXJEYXNoIiwidGlja0JvcmRlckRhc2hPZmZzZXQiLCJjcm9zc0FsaWduIiwidGlja0FuZFBhZGRpbmciLCJoVGlja0FuZFBhZGRpbmciLCJsaW5lQ291bnQiLCJ0ZXh0T2Zmc2V0IiwidGV4dEJhc2VsaW5lIiwiX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQiLCJfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCIsImxhYmVsT2Zmc2V0IiwiaGFsZkNvdW50Iiwic3Ryb2tlQ29sb3IiLCJ0ZXh0U3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsInRleHRTdHJva2VXaWR0aCIsInRpY2tUZXh0QWxpZ24iLCJzaG93TGFiZWxCYWNrZHJvcCIsImJhY2tkcm9wIiwibGFiZWxQYWRkaW5nIiwiYmFja2Ryb3BQYWRkaW5nIiwiYmFja2Ryb3BDb2xvciIsInRyYW5zbGF0aW9uIiwiX2NvbXB1dGVMYWJlbEFyZWEiLCJkcmF3QmFja2dyb3VuZCIsInNhdmUiLCJmaWxsUmVjdCIsInJlc3RvcmUiLCJkcmF3R3JpZCIsImRyYXdMaW5lIiwicDEiLCJwMiIsInNldExpbmVEYXNoIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd0JvcmRlciIsImxhc3RMaW5lV2lkdGgiLCJkcmF3TGFiZWxzIiwiY2xpcEFyZWEiLCJyZW5kZXJUZXh0T3B0aW9ucyIsInJlbmRlclRleHQiLCJ1bmNsaXBBcmVhIiwiZHJhd1RpdGxlIiwidHoiLCJneiIsImJ6IiwiX21heERpZ2l0cyIsImZvbnRTaXplIiwiVHlwZWRSZWdpc3RyeSIsInNjb3BlIiwiY3JlYXRlIiwiaXNGb3JUeXBlIiwiaXNQcm90b3R5cGVPZiIsInJlZ2lzdGVyIiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInBhcmVudFNjb3BlIiwiaXNJQ2hhcnRDb21wb25lbnQiLCJyZWdpc3RlckRlZmF1bHRzIiwidW5yZWdpc3RlciIsIml0ZW1EZWZhdWx0cyIsIm1lcmdlIiwicm91dGVEZWZhdWx0cyIsImRlc2NyaWJlIiwicm91dGVzIiwicHJvcGVydHkiLCJwcm9wZXJ0eVBhcnRzIiwic3BsaXQiLCJzb3VyY2VOYW1lIiwic291cmNlU2NvcGUiLCJqb2luIiwicGFydHMiLCJ0YXJnZXROYW1lIiwidGFyZ2V0U2NvcGUiLCJyb3V0ZSIsIlJlZ2lzdHJ5IiwiY29udHJvbGxlcnMiLCJfdHlwZWRSZWdpc3RyaWVzIiwiX2VhY2giLCJhZGRDb250cm9sbGVycyIsImFkZFBsdWdpbnMiLCJhZGRTY2FsZXMiLCJnZXRDb250cm9sbGVyIiwiX2dldCIsImdldFBsdWdpbiIsImdldFNjYWxlIiwicmVtb3ZlQ29udHJvbGxlcnMiLCJyZW1vdmVFbGVtZW50cyIsInJlbW92ZVBsdWdpbnMiLCJyZW1vdmVTY2FsZXMiLCJ0eXBlZFJlZ2lzdHJ5IiwiYXJnIiwicmVnIiwiX2dldFJlZ2lzdHJ5Rm9yVHlwZSIsIl9leGVjIiwiaXRlbVJlZyIsImNvbXBvbmVudCIsImNhbWVsTWV0aG9kIiwiX2NhcGl0YWxpemUiLCJQbHVnaW5TZXJ2aWNlIiwiX2luaXQiLCJub3RpZnkiLCJob29rIiwiX2NyZWF0ZURlc2NyaXB0b3JzIiwiX2Rlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsInBsdWdpbiIsImNhbGxDYWxsYmFjayIsImNhbmNlbGFibGUiLCJpbnZhbGlkYXRlIiwiX29sZENhY2hlIiwiX25vdGlmeVN0YXRlQ2hhbmdlcyIsImFsbFBsdWdpbnMiLCJjcmVhdGVEZXNjcmlwdG9ycyIsInByZXZpb3VzRGVzY3JpcHRvcnMiLCJzb21lIiwibG9jYWxJZHMiLCJsb2NhbCIsImdldE9wdHMiLCJwbHVnaW5PcHRzIiwicGx1Z2luU2NvcGVLZXlzIiwic2NyaXB0YWJsZSIsImluZGV4YWJsZSIsImFsbEtleXMiLCJnZXRJbmRleEF4aXMiLCJkYXRhc2V0RGVmYXVsdHMiLCJkYXRhc2V0T3B0aW9ucyIsImdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQiLCJnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzIiwiaWRNYXRjaGVzQXhpcyIsImF4aXNGcm9tUG9zaXRpb24iLCJkZXRlcm1pbmVBeGlzIiwic2NhbGVPcHRpb25zIiwidG9Mb3dlckNhc2UiLCJnZXRBeGlzRnJvbURhdGFzZXQiLCJyZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMiLCJib3VuZERzIiwiZCIsIm1lcmdlU2NhbGVDb25maWciLCJjaGFydERlZmF1bHRzIiwiY29uZmlnU2NhbGVzIiwiY2hhcnRJbmRleEF4aXMiLCJzY2FsZUNvbmYiLCJlcnJvciIsIl9wcm94eSIsImRlZmF1bHRJZCIsImRlZmF1bHRTY2FsZU9wdGlvbnMiLCJtZXJnZUlmIiwiZGVmYXVsdElEIiwiaW5pdE9wdGlvbnMiLCJpbml0RGF0YSIsImluaXRDb25maWciLCJrZXlDYWNoZSIsImtleXNDYWNoZWQiLCJTZXQiLCJjYWNoZWRLZXlzIiwiZ2VuZXJhdGUiLCJhZGRJZkZvdW5kIiwiQ29uZmlnIiwiX2NvbmZpZyIsIl9zY29wZUNhY2hlIiwiX3Jlc29sdmVyQ2FjaGUiLCJwbGF0Zm9ybSIsImNsZWFyQ2FjaGUiLCJjbGVhciIsImRhdGFzZXRUeXBlIiwiYWRkaXRpb25hbE9wdGlvblNjb3BlcyIsIl9jYWNoZWRTY29wZXMiLCJtYWluU2NvcGUiLCJyZXNldENhY2hlIiwia2V5TGlzdHMiLCJjaGFydE9wdGlvblNjb3BlcyIsInJlc29sdmVyIiwic3ViUHJlZml4ZXMiLCJnZXRSZXNvbHZlciIsIm5lZWRDb250ZXh0IiwiaXNGdW5jdGlvbiIsInN1YlJlc29sdmVyIiwiX2F0dGFjaENvbnRleHQiLCJkZXNjcmlwdG9yRGVmYXVsdHMiLCJyZXNvbHZlckNhY2hlIiwiX2NyZWF0ZVJlc29sdmVyIiwicCIsImhhc0Z1bmN0aW9uIiwiaXNTY3JpcHRhYmxlIiwiaXNJbmRleGFibGUiLCJLTk9XTl9QT1NJVElPTlMiLCJwb3NpdGlvbklzSG9yaXpvbnRhbCIsImNvbXBhcmUyTGV2ZWwiLCJsMSIsImwyIiwib25BbmltYXRpb25zQ29tcGxldGUiLCJvbkNvbXBsZXRlIiwib25BbmltYXRpb25Qcm9ncmVzcyIsIm9uUHJvZ3Jlc3MiLCJnZXRDYW52YXMiLCJnZXRFbGVtZW50QnlJZCIsImluc3RhbmNlcyIsImdldENoYXJ0IiwiYyIsIm1vdmVOdW1lcmljS2V5cyIsImludEtleSIsImRldGVybWluZUxhc3RFdmVudCIsImxhc3RFdmVudCIsImluQ2hhcnRBcmVhIiwiaXNDbGljayIsIkNoYXJ0IiwidmVyc2lvbiIsImludmFsaWRhdGVQbHVnaW5zIiwidXNlckNvbmZpZyIsImluaXRpYWxDYW52YXMiLCJleGlzdGluZ0NoYXJ0IiwidWlkIiwiX29wdGlvbnMiLCJfYXNwZWN0UmF0aW8iLCJfbWV0YXNldHMiLCJfbGFzdEV2ZW50IiwiX2xpc3RlbmVycyIsIl9yZXNwb25zaXZlTGlzdGVuZXJzIiwiX3NvcnRlZE1ldGFzZXRzIiwiX3BsdWdpbnMiLCJfaGlkZGVuSW5kaWNlcyIsImF0dGFjaGVkIiwiX2RvUmVzaXplIiwiZGVib3VuY2UiLCJyZXNpemVEZWxheSIsIl9pbml0aWFsaXplIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsInJlc3BvbnNpdmUiLCJyZXRpbmFTY2FsZSIsImJpbmRFdmVudHMiLCJjbGVhckNhbnZhcyIsIl9yZXNpemUiLCJfcmVzaXplQmVmb3JlRHJhdyIsIm5ld1NpemUiLCJuZXdSYXRpbyIsIm9uUmVzaXplIiwicmVuZGVyIiwiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsInNjYWxlc09wdGlvbnMiLCJheGlzT3B0aW9ucyIsImJ1aWxkT3JVcGRhdGVTY2FsZXMiLCJzY2FsZU9wdHMiLCJ1cGRhdGVkIiwiaXNSYWRpYWwiLCJkcG9zaXRpb24iLCJkdHlwZSIsInNjYWxlVHlwZSIsInNjYWxlQ2xhc3MiLCJoYXNVcGRhdGVkIiwiX3VwZGF0ZU1ldGFzZXRzIiwiX2Rlc3Ryb3lEYXRhc2V0TWV0YSIsIl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cyIsImJ1aWxkT3JVcGRhdGVDb250cm9sbGVycyIsIm5ld0NvbnRyb2xsZXJzIiwib3JkZXIiLCJ2aXNpYmxlIiwiQ29udHJvbGxlckNsYXNzIiwiX3Jlc2V0RWxlbWVudHMiLCJhbmltc0Rpc2FibGVkIiwiX3VwZGF0ZVNjYWxlcyIsIl9jaGVja0V2ZW50QmluZGluZ3MiLCJfdXBkYXRlSGlkZGVuSW5kaWNlcyIsIl9taW5QYWRkaW5nIiwiYXV0b1BhZGRpbmciLCJfdXBkYXRlTGF5b3V0IiwiX3VwZGF0ZURhdGFzZXRzIiwiX2V2ZW50SGFuZGxlciIsIl91cGRhdGVIb3ZlclN0eWxlcyIsImV4aXN0aW5nRXZlbnRzIiwibmV3RXZlbnRzIiwiZXZlbnRzIiwic2V0c0VxdWFsIiwidW5iaW5kRXZlbnRzIiwiY2hhbmdlcyIsIl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMiLCJkYXRhc2V0Q291bnQiLCJtYWtlU2V0IiwiY2hhbmdlU2V0Iiwibm9BcmVhIiwiX2lkeCIsIl91cGRhdGVEYXRhc2V0IiwibGF5ZXJzIiwiX2RyYXdEYXRhc2V0cyIsIl9kcmF3RGF0YXNldCIsImdldERhdGFzZXRDbGlwQXJlYSIsImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCJzZXREYXRhc2V0VmlzaWJpbGl0eSIsIl91cGRhdGVWaXNpYmlsaXR5IiwiaGlkZSIsInNob3ciLCJfc3RvcCIsImRlc3Ryb3kiLCJ0b0Jhc2U2NEltYWdlIiwidG9EYXRhVVJMIiwiYmluZFVzZXJFdmVudHMiLCJiaW5kUmVzcG9uc2l2ZUV2ZW50cyIsIl9hZGQiLCJfcmVtb3ZlIiwiZGV0YWNoZWQiLCJ1cGRhdGVIb3ZlclN0eWxlIiwicHJlZml4IiwiZ2V0QWN0aXZlRWxlbWVudHMiLCJzZXRBY3RpdmVFbGVtZW50cyIsImFjdGl2ZUVsZW1lbnRzIiwibGFzdEFjdGl2ZSIsIl9lbGVtZW50c0VxdWFsIiwicGx1Z2luSWQiLCJyZXBsYXkiLCJob3Zlck9wdGlvbnMiLCJob3ZlciIsImRlYWN0aXZhdGVkIiwiYWN0aXZhdGVkIiwiZXZlbnRGaWx0ZXIiLCJfaGFuZGxlRXZlbnQiLCJfZ2V0QWN0aXZlRWxlbWVudHMiLCJfaXNDbGlja0V2ZW50Iiwib25Ib3ZlciIsImNsaXBTZWxmIiwib3V0ZXJBbmdsZUNsaXAiLCJfbm9ybWFsaXplQW5nbGUiLCJpbm5lckFuZ2xlQ2xpcCIsImNsaXBXaWR0aCIsImNsb3NlUGF0aCIsInJlY3QiLCJjbGlwQXJjIiwicGl4ZWxNYXJnaW4iLCJhbmdsZU1hcmdpbiIsInRvUmFkaXVzQ29ybmVycyIsIl9yZWFkVmFsdWVUb1Byb3BzIiwicGFyc2VCb3JkZXJSYWRpdXMiLCJhbmdsZURlbHRhIiwibyIsImhhbGZUaGlja25lc3MiLCJpbm5lckxpbWl0IiwiY29tcHV0ZU91dGVyTGltaXQiLCJvdXRlckFyY0xpbWl0Iiwib3V0ZXJTdGFydCIsIm91dGVyRW5kIiwiaW5uZXJTdGFydCIsImlubmVyRW5kIiwiclRoZXRhVG9YWSIsInRoZXRhIiwicGF0aEFyYyIsImlubmVyUiIsInNwYWNpbmdPZmZzZXQiLCJhbHBoYSIsIm5vU3BhY2luZ0lubmVyUmFkaXVzIiwibm9TcGFjaW5nT3V0ZXJSYWRpdXMiLCJhdk5vZ1NwYWNpbmdSYWRpdXMiLCJhZGp1c3RlZEFuZ2xlIiwiYmV0YSIsImFuZ2xlT2Zmc2V0Iiwib3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzIiwib3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyIsIm91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwib3V0ZXJFbmRBZGp1c3RlZEFuZ2xlIiwiaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzIiwiaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyIsImlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwiaW5uZXJFbmRBZGp1c3RlZEFuZ2xlIiwib3V0ZXJNaWRBZGp1c3RlZEFuZ2xlIiwicENlbnRlciIsInA0IiwiaW5uZXJNaWRBZGp1c3RlZEFuZ2xlIiwicDgiLCJvdXRlclN0YXJ0WCIsIm91dGVyU3RhcnRZIiwib3V0ZXJFbmRYIiwib3V0ZXJFbmRZIiwiZHJhd0FyYyIsImZ1bGxDaXJjbGVzIiwiaW5uZXIiLCJzZWxmSm9pbiIsIkFyY0VsZW1lbnQiLCJjaGFydFgiLCJjaGFydFkiLCJyQWRqdXN0Iiwibm9uWmVyb0JldHdlZW4iLCJiZXR3ZWVuQW5nbGVzIiwid2l0aGluUmFkaXVzIiwiX2lzQmV0d2VlbiIsImhhbGZBbmdsZSIsImhhbGZSYWRpdXMiLCJ0cmFuc2xhdGUiLCJmaXgiLCJyYWRpdXNPZmZzZXQiLCJzZXRTdHlsZSIsImxpbmVDYXAiLCJib3JkZXJDYXBTdHlsZSIsInByZXZpb3VzIiwiZ2V0TGluZU1ldGhvZCIsInN0ZXBwZWQiLCJfc3RlcHBlZExpbmVUbyIsInRlbnNpb24iLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwiX2JlemllckN1cnZlVG8iLCJwYXRoVmFycyIsInBhcmFtc1N0YXJ0IiwicGFyYW1zRW5kIiwic2VnbWVudFN0YXJ0Iiwic2VnbWVudEVuZCIsIm91dHNpZGUiLCJwYXRoU2VnbWVudCIsImxpbmVNZXRob2QiLCJmYXN0UGF0aFNlZ21lbnQiLCJhdmdYIiwiY291bnRYIiwicHJldlgiLCJsYXN0WSIsInBvaW50SW5kZXgiLCJkcmF3WCIsInRydW5jWCIsIl9nZXRTZWdtZW50TWV0aG9kIiwidXNlRmFzdFBhdGgiLCJfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZCIsIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsIl9iZXppZXJJbnRlcnBvbGF0aW9uIiwiX3BvaW50SW5MaW5lIiwic3Ryb2tlUGF0aFdpdGhDYWNoZSIsInBhdGgiLCJfcGF0aCIsIlBhdGgyRCIsInN0cm9rZVBhdGhEaXJlY3QiLCJzZWdtZW50cyIsInNlZ21lbnRNZXRob2QiLCJ1c2VQYXRoMkQiLCJMaW5lRWxlbWVudCIsImNhcEJlemllclBvaW50cyIsIl9wb2ludHMiLCJfc2VnbWVudHMiLCJfcG9pbnRzVXBkYXRlZCIsIl91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIiwiX2NvbXB1dGVTZWdtZW50cyIsImludGVycG9sYXRlIiwiX2JvdW5kU2VnbWVudHMiLCJfaW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWQiLCJoaXRSYWRpdXMiLCJQb2ludEVsZW1lbnQiLCJob3ZlclJhZGl1cyIsIm1vdXNlWCIsIm1vdXNlWSIsImluWFJhbmdlIiwiaW5ZUmFuZ2UiLCJkcmF3UG9pbnQiLCJnZXRCYXJCb3VuZHMiLCJiYXIiLCJoYWxmIiwic2tpcE9yTGltaXQiLCJwYXJzZUJvcmRlcldpZHRoIiwibWF4VyIsIm1heEgiLCJ0b1RSQkwiLCJ0b1RSQkxDb3JuZXJzIiwibWF4UiIsImVuYWJsZUJvcmRlciIsInRvcExlZnQiLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsImJvdW5kaW5nUmVjdHMiLCJib3VuZHMiLCJvdXRlciIsInNraXBYIiwic2tpcFkiLCJza2lwQm90aCIsImhhc1JhZGl1cyIsImFkZE5vcm1hbFJlY3RQYXRoIiwiaW5mbGF0ZVJlY3QiLCJhbW91bnQiLCJyZWZSZWN0IiwiQmFyRWxlbWVudCIsImFkZFJlY3RQYXRoIiwiYWRkUm91bmRlZFJlY3RQYXRoIiwiQk9SREVSX0NPTE9SUyIsIkJBQ0tHUk9VTkRfQ09MT1JTIiwicmVwbGFjZSIsImdldEJvcmRlckNvbG9yIiwiZ2V0QmFja2dyb3VuZENvbG9yIiwiY29sb3JpemVEZWZhdWx0RGF0YXNldCIsImNvbG9yaXplRG91Z2hudXREYXRhc2V0IiwiY29sb3JpemVQb2xhckFyZWFEYXRhc2V0IiwiZ2V0Q29sb3JpemVyIiwiY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyIsImsiLCJjb250YWluc0NvbG9yc0RlZmluaXRpb24iLCJjb250YWluc0RlZmF1bHRDb2xvcnNEZWZlbml0aW9ucyIsInBsdWdpbl9jb2xvcnMiLCJmb3JjZU92ZXJyaWRlIiwiX2FyZ3MiLCJjaGFydE9wdGlvbnMiLCJjb250YWluc0NvbG9yRGVmZW5pdGlvbiIsImNvbG9yaXplciIsImx0dGJEZWNpbWF0aW9uIiwic2FtcGxlcyIsImRlY2ltYXRlZCIsImJ1Y2tldFdpZHRoIiwic2FtcGxlZEluZGV4IiwiZW5kSW5kZXgiLCJtYXhBcmVhUG9pbnQiLCJtYXhBcmVhIiwibmV4dEEiLCJhdmdZIiwiYXZnUmFuZ2VTdGFydCIsImF2Z1JhbmdlRW5kIiwiYXZnUmFuZ2VMZW5ndGgiLCJyYW5nZU9mZnMiLCJyYW5nZVRvIiwicG9pbnRBeCIsInBvaW50QXkiLCJtaW5NYXhEZWNpbWF0aW9uIiwibWluSW5kZXgiLCJtYXhJbmRleCIsInN0YXJ0SW5kZXgiLCJ4TWluIiwieE1heCIsImR4IiwibGFzdEluZGV4IiwiaW50ZXJtZWRpYXRlSW5kZXgxIiwiaW50ZXJtZWRpYXRlSW5kZXgyIiwiY2xlYW5EZWNpbWF0ZWREYXRhc2V0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjbGVhbkRlY2ltYXRlZERhdGEiLCJnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZCIsInBvaW50Q291bnQiLCJwbHVnaW5fZGVjaW1hdGlvbiIsImFsZ29yaXRobSIsImJlZm9yZUVsZW1lbnRzVXBkYXRlIiwieEF4aXMiLCJ0aHJlc2hvbGQiLCJ0cG9pbnRzIiwiX2ZpbmRTZWdtZW50RW5kIiwiX2dldEJvdW5kcyIsInRhcmdldFNlZ21lbnRzIiwidGd0Iiwic3ViQm91bmRzIiwiZmlsbFNvdXJjZXMiLCJfYm91bmRTZWdtZW50IiwiZmlsbFNvdXJjZSIsIl9nZXRFZGdlIiwiX3BvaW50c0Zyb21TZWdtZW50cyIsImJvdW5kYXJ5IiwibGluZVBvaW50cyIsIl9jcmVhdGVCb3VuZGFyeUxpbmUiLCJfc2hvdWxkQXBwbHlGaWxsIiwiX3Jlc29sdmVUYXJnZXQiLCJzb3VyY2VzIiwicHJvcGFnYXRlIiwidmlzaXRlZCIsIl9kZWNvZGVGaWxsIiwicGFyc2VGaWxsT3B0aW9uIiwicGFyc2VGbG9hdCIsImRlY29kZVRhcmdldEluZGV4IiwiZmlyc3RDaCIsIl9nZXRUYXJnZXRQaXhlbCIsIl9nZXRUYXJnZXRWYWx1ZSIsImZpbGxPcHRpb24iLCJfYnVpbGRTdGFja0xpbmUiLCJzb3VyY2VQb2ludHMiLCJsaW5lc0JlbG93IiwiZ2V0TGluZXNCZWxvdyIsImFkZFBvaW50c0JlbG93IiwiYmVsb3ciLCJ1bnNoaWZ0Iiwic291cmNlUG9pbnQiLCJwb3N0cG9uZWQiLCJmaW5kUG9pbnQiLCJwb2ludFZhbHVlIiwiZmlyc3RWYWx1ZSIsImxhc3RWYWx1ZSIsInNpbXBsZUFyYyIsIl9nZXRUYXJnZXQiLCJnZXRMaW5lQnlJbmRleCIsImNvbXB1dGVCb3VuZGFyeSIsImNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5IiwiY29tcHV0ZUxpbmVhckJvdW5kYXJ5IiwiX2RyYXdmaWxsIiwibGluZU9wdHMiLCJhYm92ZSIsImRvRmlsbCIsImZpbGxDb2xvciIsImNsaXBWZXJ0aWNhbCIsImNsaXBIb3Jpem9udGFsIiwiY2xpcFkiLCJsaW5lTG9vcCIsImNsaXBYIiwic3JjIiwibm90U2hhcGUiLCJjbGlwQm91bmRzIiwiaW50ZXJwb2xhdGVkTGluZVRvIiwidGFyZ2V0TG9vcCIsImludGVycG9sYXRlZFBvaW50IiwiYWZ0ZXJEYXRhc2V0c1VwZGF0ZSIsIiRmaWxsZXIiLCJiZWZvcmVEcmF3IiwiZHJhd1RpbWUiLCJiZWZvcmVEYXRhc2V0c0RyYXciLCJiZWZvcmVEYXRhc2V0RHJhdyIsImdldEJveFNpemUiLCJsYWJlbE9wdHMiLCJib3hIZWlnaHQiLCJib3hXaWR0aCIsInVzZVBvaW50U3R5bGUiLCJwb2ludFN0eWxlV2lkdGgiLCJpdGVtSGVpZ2h0IiwiaXRlbXNFcXVhbCIsIkxlZ2VuZCIsIl9hZGRlZCIsImxlZ2VuZEhpdEJveGVzIiwiX2hvdmVyZWRJdGVtIiwiZG91Z2hudXRNb2RlIiwibGVnZW5kSXRlbXMiLCJjb2x1bW5TaXplcyIsImxpbmVXaWR0aHMiLCJidWlsZExhYmVscyIsImxhYmVsRm9udCIsIl9jb21wdXRlVGl0bGVIZWlnaHQiLCJfZml0Um93cyIsIl9maXRDb2xzIiwiaGl0Ym94ZXMiLCJ0b3RhbEhlaWdodCIsInJvdyIsIml0ZW1XaWR0aCIsIm1lYXN1cmVUZXh0IiwiX2l0ZW1IZWlnaHQiLCJoZWlnaHRMaW1pdCIsInRvdGFsV2lkdGgiLCJjdXJyZW50Q29sV2lkdGgiLCJjdXJyZW50Q29sSGVpZ2h0IiwiY29sIiwiY2FsY3VsYXRlSXRlbVNpemUiLCJhZGp1c3RIaXRCb3hlcyIsInJ0bCIsInJ0bEhlbHBlciIsImdldFJ0bEFkYXB0ZXIiLCJoaXRib3giLCJsZWZ0Rm9yTHRyIiwiX2RyYXciLCJkZWZhdWx0Q29sb3IiLCJoYWxmRm9udFNpemUiLCJjdXJzb3IiLCJkcmF3TGVnZW5kQm94IiwiZHJhd09wdGlvbnMiLCJTUVJUMiIsInhQbHVzIiwiZHJhd1BvaW50TGVnZW5kIiwieUJveFRvcCIsInhCb3hMZWZ0IiwiZmlsbFRleHQiLCJzdHJpa2V0aHJvdWdoIiwib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwidGV4dERpcmVjdGlvbiIsInRleHRXaWR0aCIsInNldFdpZHRoIiwicmVhbFgiLCJfdGV4dFgiLCJmb250TGluZUhlaWdodCIsImNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQiLCJyZXN0b3JlVGV4dERpcmVjdGlvbiIsInRpdGxlRm9udCIsInRpdGxlUGFkZGluZyIsInRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplIiwiX2dldExlZ2VuZEl0ZW1BdCIsImhpdEJveCIsImxoIiwiaGFuZGxlRXZlbnQiLCJpc0xpc3RlbmVkIiwiaG92ZXJlZEl0ZW0iLCJzYW1lSXRlbSIsIm9uTGVhdmUiLCJjYWxjdWxhdGVJdGVtV2lkdGgiLCJjYWxjdWxhdGVJdGVtSGVpZ2h0IiwibGVnZW5kSXRlbVRleHQiLCJwbHVnaW5fbGVnZW5kIiwiX2VsZW1lbnQiLCJhZnRlckV2ZW50IiwiY2kiLCJUaXRsZSIsIl9wYWRkaW5nIiwidGV4dFNpemUiLCJfZHJhd0FyZ3MiLCJmb250T3B0cyIsImNyZWF0ZVRpdGxlIiwidGl0bGVCbG9jayIsInBsdWdpbl90aXRsZSIsIldlYWtNYXAiLCJwbHVnaW5fc3VidGl0bGUiLCJwb3NpdGlvbmVycyIsImF2ZXJhZ2UiLCJ4U2V0IiwieEF2ZXJhZ2UiLCJldmVudFBvc2l0aW9uIiwibmVhcmVzdEVsZW1lbnQiLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJ0cCIsInB1c2hPckNvbmNhdCIsInRvUHVzaCIsImFwcGx5Iiwic3BsaXROZXdsaW5lcyIsInN0ciIsIlN0cmluZyIsImNyZWF0ZVRvb2x0aXBJdGVtIiwiZm9ybWF0dGVkVmFsdWUiLCJnZXRUb29sdGlwU2l6ZSIsInRvb2x0aXAiLCJib2R5IiwiZm9vdGVyIiwiYm9keUZvbnQiLCJmb290ZXJGb250IiwidGl0bGVMaW5lQ291bnQiLCJmb290ZXJMaW5lQ291bnQiLCJib2R5TGluZUl0ZW1Db3VudCIsImNvbWJpbmVkQm9keUxlbmd0aCIsImJvZHlJdGVtIiwiYmVmb3JlIiwiYWZ0ZXIiLCJiZWZvcmVCb2R5IiwiYWZ0ZXJCb2R5IiwidGl0bGVTcGFjaW5nIiwidGl0bGVNYXJnaW5Cb3R0b20iLCJib2R5TGluZUhlaWdodCIsImRpc3BsYXlDb2xvcnMiLCJib2R5U3BhY2luZyIsImZvb3Rlck1hcmdpblRvcCIsImZvb3RlclNwYWNpbmciLCJ3aWR0aFBhZGRpbmciLCJtYXhMaW5lV2lkdGgiLCJkZXRlcm1pbmVZQWxpZ24iLCJkb2VzTm90Rml0V2l0aEFsaWduIiwieEFsaWduIiwiY2FyZXQiLCJjYXJldFNpemUiLCJjYXJldFBhZGRpbmciLCJkZXRlcm1pbmVYQWxpZ24iLCJ5QWxpZ24iLCJjaGFydFdpZHRoIiwiZGV0ZXJtaW5lQWxpZ25tZW50IiwiYWxpZ25YIiwiYWxpZ25ZIiwicGFkZGluZ0FuZFNpemUiLCJnZXRCYWNrZ3JvdW5kUG9pbnQiLCJhbGlnbm1lbnQiLCJjb3JuZXJSYWRpdXMiLCJnZXRBbGlnbmVkWCIsImdldEJlZm9yZUFmdGVyQm9keUxpbmVzIiwiY3JlYXRlVG9vbHRpcENvbnRleHQiLCJ0b29sdGlwSXRlbXMiLCJvdmVycmlkZUNhbGxiYWNrcyIsImRlZmF1bHRDYWxsYmFja3MiLCJiZWZvcmVUaXRsZSIsIm5vb3AiLCJsYWJlbENvdW50IiwiYWZ0ZXJUaXRsZSIsImJlZm9yZUxhYmVsIiwidG9vbHRpcEl0ZW0iLCJsYWJlbENvbG9yIiwibGFiZWxUZXh0Q29sb3IiLCJib2R5Q29sb3IiLCJsYWJlbFBvaW50U3R5bGUiLCJhZnRlckxhYmVsIiwiYmVmb3JlRm9vdGVyIiwiYWZ0ZXJGb290ZXIiLCJpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayIsIlRvb2x0aXAiLCJvcGFjaXR5IiwiX2V2ZW50UG9zaXRpb24iLCJfc2l6ZSIsIl9jYWNoZWRBbmltYXRpb25zIiwiX3Rvb2x0aXBJdGVtcyIsImRhdGFQb2ludHMiLCJjYXJldFgiLCJjYXJldFkiLCJsYWJlbENvbG9ycyIsImxhYmVsUG9pbnRTdHlsZXMiLCJsYWJlbFRleHRDb2xvcnMiLCJnZXRUaXRsZSIsImdldEJlZm9yZUJvZHkiLCJnZXRCb2R5IiwiYm9keUl0ZW1zIiwic2NvcGVkIiwiZ2V0QWZ0ZXJCb2R5IiwiZ2V0Rm9vdGVyIiwiX2NyZWF0ZUl0ZW1zIiwiaXRlbVNvcnQiLCJwb3NpdGlvbkFuZFNpemUiLCJiYWNrZ3JvdW5kUG9pbnQiLCJleHRlcm5hbCIsImRyYXdDYXJldCIsInRvb2x0aXBQb2ludCIsImNhcmV0UG9zaXRpb24iLCJnZXRDYXJldFBvc2l0aW9uIiwieDMiLCJ5MyIsInB0WCIsInB0WSIsInB0IiwidGl0bGVDb2xvciIsIl9kcmF3Q29sb3JCb3giLCJjb2xvclgiLCJydGxDb2xvclgiLCJ5T2ZmU2V0IiwiY29sb3JZIiwibXVsdGlLZXlCYWNrZ3JvdW5kIiwib3V0ZXJYIiwiaW5uZXJYIiwic3Ryb2tlUmVjdCIsImRyYXdCb2R5IiwiYm9keUFsaWduIiwieExpbmVQYWRkaW5nIiwiZmlsbExpbmVPZlRleHQiLCJib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiIsInRleHRDb2xvciIsImRyYXdGb290ZXIiLCJmb290ZXJBbGlnbiIsImZvb3RlckNvbG9yIiwidG9vbHRpcFNpemUiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiX3VwZGF0ZUFuaW1hdGlvblRhcmdldCIsImFuaW1YIiwiYW5pbVkiLCJfd2lsbFJlbmRlciIsImhhc1Rvb2x0aXBDb250ZW50IiwiZ2xvYmFsQWxwaGEiLCJwb3NpdGlvbkNoYW5nZWQiLCJfcG9zaXRpb25DaGFuZ2VkIiwiX2lnbm9yZVJlcGxheUV2ZW50cyIsInBsdWdpbl90b29sdGlwIiwiYWZ0ZXJJbml0IiwiYWZ0ZXJEcmF3IiwiX2ZhbGxiYWNrIiwiYWRkSWZTdHJpbmciLCJhZGRlZExhYmVscyIsImZpbmRPckFkZExhYmVsIiwibGFzdEluZGV4T2YiLCJfZ2V0TGFiZWxGb3JWYWx1ZSIsIkNhdGVnb3J5U2NhbGUiLCJfc3RhcnRWYWx1ZSIsIl92YWx1ZVJhbmdlIiwiX2FkZGVkTGFiZWxzIiwiYWRkZWQiLCJnZW5lcmF0ZVRpY2tzIiwiZ2VuZXJhdGlvbk9wdGlvbnMiLCJkYXRhUmFuZ2UiLCJNSU5fU1BBQ0lORyIsInByZWNpc2lvbiIsIm1heFRpY2tzIiwibWF4RGlnaXRzIiwiaW5jbHVkZUJvdW5kcyIsInVuaXQiLCJtYXhTcGFjZXMiLCJybWluIiwicm1heCIsImNvdW50RGVmaW5lZCIsIm1pblNwYWNpbmciLCJuaWNlTnVtIiwibmljZU1pbiIsIm5pY2VNYXgiLCJudW1TcGFjZXMiLCJhbG1vc3RXaG9sZSIsImFsbW9zdEVxdWFscyIsImRlY2ltYWxQbGFjZXMiLCJfZGVjaW1hbFBsYWNlcyIsInJlbGF0aXZlTGFiZWxTaXplIiwidGlja1ZhbHVlIiwicmFkIiwiTGluZWFyU2NhbGVCYXNlIiwiX2VuZFZhbHVlIiwiaGFuZGxlVGlja1JhbmdlT3B0aW9ucyIsInNldE1pbiIsInNldE1heCIsIm1pblNpZ24iLCJtYXhTaWduIiwiZ2V0VGlja0xpbWl0Iiwic3RlcFNpemUiLCJjb21wdXRlVGlja0xpbWl0IiwibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCJfc2V0TWluQW5kTWF4QnlLZXkiLCJMaW5lYXJTY2FsZSIsIlRpY2tzIiwiZm9ybWF0dGVycyIsIm51bWVyaWMiLCJsb2cxMEZsb29yIiwibG9nMTAiLCJjaGFuZ2VFeHBvbmVudCIsIm0iLCJpc01ham9yIiwidGlja1ZhbCIsInN0ZXBzIiwicmFuZ2VFeHAiLCJyYW5nZVN0ZXAiLCJzdGFydEV4cCIsIm1pbkV4cCIsImV4cCIsInNpZ25pZmljYW5kIiwibGFzdFRpY2siLCJMb2dhcml0aG1pY1NjYWxlIiwibG9nYXJpdGhtaWMiLCJfemVybyIsImdldFRpY2tCYWNrZHJvcEhlaWdodCIsIm1lYXN1cmVMYWJlbFNpemUiLCJfbG9uZ2VzdFRleHQiLCJkZXRlcm1pbmVMaW1pdHMiLCJmaXRXaXRoUG9pbnRMYWJlbHMiLCJsaW1pdHMiLCJ2YWx1ZUNvdW50IiwiX3BvaW50TGFiZWxzIiwicG9pbnRMYWJlbE9wdHMiLCJhZGRpdGlvbmFsQW5nbGUiLCJjZW50ZXJQb2ludExhYmVscyIsImdldFBvaW50TGFiZWxDb250ZXh0IiwiZ2V0UG9pbnRQb3NpdGlvbiIsImRyYXdpbmdBcmVhIiwicGxGb250IiwiaExpbWl0cyIsInZMaW1pdHMiLCJ1cGRhdGVMaW1pdHMiLCJzZXRDZW50ZXJQb2ludCIsIl9wb2ludExhYmVsSXRlbXMiLCJidWlsZFBvaW50TGFiZWxJdGVtcyIsImNyZWF0ZVBvaW50TGFiZWxJdGVtIiwiaXRlbU9wdHMiLCJvdXRlckRpc3RhbmNlIiwiZXh0cmEiLCJwb2ludExhYmVsUG9zaXRpb24iLCJ5Rm9yQW5nbGUiLCJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsImxlZnRGb3JUZXh0QWxpZ24iLCJpc05vdE92ZXJsYXBwZWQiLCJhcGV4ZXNJbkFyZWEiLCJkcmF3UG9pbnRMYWJlbEJveCIsImJhY2tkcm9wTGVmdCIsImJhY2tkcm9wVG9wIiwiYmFja2Ryb3BXaWR0aCIsImJhY2tkcm9wSGVpZ2h0IiwiZHJhd1BvaW50TGFiZWxzIiwicGF0aFJhZGl1c0xpbmUiLCJkcmF3UmFkaXVzTGluZSIsImdyaWRMaW5lT3B0cyIsImNyZWF0ZVBvaW50TGFiZWxDb250ZXh0IiwiUmFkaWFsTGluZWFyU2NhbGUiLCJhbmltYXRlIiwibGVmdE1vdmVtZW50IiwicmlnaHRNb3ZlbWVudCIsInRvcE1vdmVtZW50IiwiYm90dG9tTW92ZW1lbnQiLCJhbmdsZU11bHRpcGxpZXIiLCJzY2FsaW5nRmFjdG9yIiwiZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIiLCJzY2FsZWREaXN0YW5jZSIsInBvaW50TGFiZWwiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJnZXRCYXNlUG9zaXRpb24iLCJnZXRQb2ludExhYmVsUG9zaXRpb24iLCJyb3RhdGUiLCJJTlRFUlZBTFMiLCJtaWxsaXNlY29uZCIsImNvbW1vbiIsInNlY29uZCIsIm1pbnV0ZSIsImhvdXIiLCJkYXkiLCJ3ZWVrIiwibW9udGgiLCJxdWFydGVyIiwieWVhciIsIlVOSVRTIiwic29ydGVyIiwiaW5wdXQiLCJhZGFwdGVyIiwiX2FkYXB0ZXIiLCJwYXJzZXIiLCJpc29XZWVrZGF5IiwiX3BhcnNlT3B0cyIsImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCJtaW5Vbml0IiwiY2FwYWNpdHkiLCJpbnRlcnZhbCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsImRldGVybWluZU1ham9yVW5pdCIsImFkZFRpY2siLCJ0aW1lIiwidGltZXN0YW1wcyIsIl9sb29rdXAiLCJ0aW1lc3RhbXAiLCJzZXRNYWpvclRpY2tzIiwibWFqb3JVbml0IiwidGlja3NGcm9tVGltZXN0YW1wcyIsIlRpbWVTY2FsZSIsImRpc3BsYXlGb3JtYXRzIiwiX3VuaXQiLCJfbWFqb3JVbml0IiwiX29mZnNldHMiLCJfbm9ybWFsaXplZCIsIm5vcm1hbGl6ZWQiLCJfYXBwbHlCb3VuZHMiLCJfZ2V0TGFiZWxCb3VuZHMiLCJnZXRMYWJlbFRpbWVzdGFtcHMiLCJ0aW1lT3B0cyIsIl9nZW5lcmF0ZSIsIl9maWx0ZXJCZXR3ZWVuIiwiX2dldExhYmVsQ2FwYWNpdHkiLCJpbml0T2Zmc2V0cyIsIm9mZnNldEFmdGVyQXV0b3NraXAiLCJnZXREZWNpbWFsRm9yVmFsdWUiLCJtaW5vciIsIndlZWtkYXkiLCJoYXNXZWVrZGF5IiwiZ2V0RGF0YVRpbWVzdGFtcHMiLCJ0b29sdGlwRm9ybWF0IiwiZGF0ZXRpbWUiLCJmbXQiLCJfdGlja0Zvcm1hdEZ1bmN0aW9uIiwiZm9ybWF0dGVyIiwibWlub3JGb3JtYXQiLCJtYWpvckZvcm1hdCIsIm9mZnNldHMiLCJfZ2V0TGFiZWxTaXplIiwidGlja3NPcHRzIiwidGlja0xhYmVsV2lkdGgiLCJjb3NSb3RhdGlvbiIsInNpblJvdGF0aW9uIiwidGlja0ZvbnRTaXplIiwiZXhhbXBsZVRpbWUiLCJleGFtcGxlTGFiZWwiLCJub3JtYWxpemUiLCJ0YWJsZSIsInByZXZTb3VyY2UiLCJuZXh0U291cmNlIiwicHJldlRhcmdldCIsIm5leHRUYXJnZXQiLCJzcGFuIiwiVGltZVNlcmllc1NjYWxlIiwiX3RhYmxlIiwiX21pblBvcyIsIl90YWJsZVJhbmdlIiwiX2dldFRpbWVzdGFtcHNGb3JUYWJsZSIsImJ1aWxkTG9va3VwVGFibGUiLCJyZWdpc3RlcmFibGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/dist/chart.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chart.js/dist/chunks/helpers.dataset.js":
/*!**************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.dataset.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ unclipArea),\n/* harmony export */   A: () => (/* binding */ _rlookupByKey),\n/* harmony export */   B: () => (/* binding */ _lookupByKey),\n/* harmony export */   C: () => (/* binding */ _isPointInArea),\n/* harmony export */   D: () => (/* binding */ getAngleFromPoint),\n/* harmony export */   E: () => (/* binding */ toPadding),\n/* harmony export */   F: () => (/* binding */ each),\n/* harmony export */   G: () => (/* binding */ getMaximumSize),\n/* harmony export */   H: () => (/* binding */ HALF_PI),\n/* harmony export */   I: () => (/* binding */ _getParentNode),\n/* harmony export */   J: () => (/* binding */ readUsedSize),\n/* harmony export */   K: () => (/* binding */ supportsEventListenerOptions),\n/* harmony export */   L: () => (/* binding */ throttled),\n/* harmony export */   M: () => (/* binding */ _isDomSupported),\n/* harmony export */   N: () => (/* binding */ _factorize),\n/* harmony export */   O: () => (/* binding */ finiteOrDefault),\n/* harmony export */   P: () => (/* binding */ PI),\n/* harmony export */   Q: () => (/* binding */ callback),\n/* harmony export */   R: () => (/* binding */ _addGrace),\n/* harmony export */   S: () => (/* binding */ _limitValue),\n/* harmony export */   T: () => (/* binding */ TAU),\n/* harmony export */   U: () => (/* binding */ toDegrees),\n/* harmony export */   V: () => (/* binding */ _measureText),\n/* harmony export */   W: () => (/* binding */ _int16Range),\n/* harmony export */   X: () => (/* binding */ _alignPixel),\n/* harmony export */   Y: () => (/* binding */ clipArea),\n/* harmony export */   Z: () => (/* binding */ renderText),\n/* harmony export */   _: () => (/* binding */ _arrayUnique),\n/* harmony export */   a: () => (/* binding */ resolve),\n/* harmony export */   a$: () => (/* binding */ getStyle),\n/* harmony export */   a0: () => (/* binding */ toFont),\n/* harmony export */   a1: () => (/* binding */ _toLeftRightCenter),\n/* harmony export */   a2: () => (/* binding */ _alignStartEnd),\n/* harmony export */   a3: () => (/* binding */ overrides),\n/* harmony export */   a4: () => (/* binding */ merge),\n/* harmony export */   a5: () => (/* binding */ _capitalize),\n/* harmony export */   a6: () => (/* binding */ descriptors),\n/* harmony export */   a7: () => (/* binding */ isFunction),\n/* harmony export */   a8: () => (/* binding */ _attachContext),\n/* harmony export */   a9: () => (/* binding */ _createResolver),\n/* harmony export */   aA: () => (/* binding */ getRtlAdapter),\n/* harmony export */   aB: () => (/* binding */ overrideTextDirection),\n/* harmony export */   aC: () => (/* binding */ _textX),\n/* harmony export */   aD: () => (/* binding */ restoreTextDirection),\n/* harmony export */   aE: () => (/* binding */ drawPointLegend),\n/* harmony export */   aF: () => (/* binding */ distanceBetweenPoints),\n/* harmony export */   aG: () => (/* binding */ noop),\n/* harmony export */   aH: () => (/* binding */ _setMinAndMaxByKey),\n/* harmony export */   aI: () => (/* binding */ niceNum),\n/* harmony export */   aJ: () => (/* binding */ almostWhole),\n/* harmony export */   aK: () => (/* binding */ almostEquals),\n/* harmony export */   aL: () => (/* binding */ _decimalPlaces),\n/* harmony export */   aM: () => (/* binding */ Ticks),\n/* harmony export */   aN: () => (/* binding */ log10),\n/* harmony export */   aO: () => (/* binding */ _longestText),\n/* harmony export */   aP: () => (/* binding */ _filterBetween),\n/* harmony export */   aQ: () => (/* binding */ _lookup),\n/* harmony export */   aR: () => (/* binding */ isPatternOrGradient),\n/* harmony export */   aS: () => (/* binding */ getHoverColor),\n/* harmony export */   aT: () => (/* binding */ clone),\n/* harmony export */   aU: () => (/* binding */ _merger),\n/* harmony export */   aV: () => (/* binding */ _mergerIf),\n/* harmony export */   aW: () => (/* binding */ _deprecated),\n/* harmony export */   aX: () => (/* binding */ _splitKey),\n/* harmony export */   aY: () => (/* binding */ toFontString),\n/* harmony export */   aZ: () => (/* binding */ splineCurve),\n/* harmony export */   a_: () => (/* binding */ splineCurveMonotone),\n/* harmony export */   aa: () => (/* binding */ _descriptors),\n/* harmony export */   ab: () => (/* binding */ mergeIf),\n/* harmony export */   ac: () => (/* binding */ uid),\n/* harmony export */   ad: () => (/* binding */ debounce),\n/* harmony export */   ae: () => (/* binding */ retinaScale),\n/* harmony export */   af: () => (/* binding */ clearCanvas),\n/* harmony export */   ag: () => (/* binding */ setsEqual),\n/* harmony export */   ah: () => (/* binding */ getDatasetClipArea),\n/* harmony export */   ai: () => (/* binding */ _elementsEqual),\n/* harmony export */   aj: () => (/* binding */ _isClickEvent),\n/* harmony export */   ak: () => (/* binding */ _isBetween),\n/* harmony export */   al: () => (/* binding */ _normalizeAngle),\n/* harmony export */   am: () => (/* binding */ _readValueToProps),\n/* harmony export */   an: () => (/* binding */ _updateBezierControlPoints),\n/* harmony export */   ao: () => (/* binding */ _computeSegments),\n/* harmony export */   ap: () => (/* binding */ _boundSegments),\n/* harmony export */   aq: () => (/* binding */ _steppedInterpolation),\n/* harmony export */   ar: () => (/* binding */ _bezierInterpolation),\n/* harmony export */   as: () => (/* binding */ _pointInLine),\n/* harmony export */   at: () => (/* binding */ _steppedLineTo),\n/* harmony export */   au: () => (/* binding */ _bezierCurveTo),\n/* harmony export */   av: () => (/* binding */ drawPoint),\n/* harmony export */   aw: () => (/* binding */ addRoundedRectPath),\n/* harmony export */   ax: () => (/* binding */ toTRBL),\n/* harmony export */   ay: () => (/* binding */ toTRBLCorners),\n/* harmony export */   az: () => (/* binding */ _boundSegment),\n/* harmony export */   b: () => (/* binding */ isArray),\n/* harmony export */   b0: () => (/* binding */ fontString),\n/* harmony export */   b1: () => (/* binding */ toLineHeight),\n/* harmony export */   b2: () => (/* binding */ PITAU),\n/* harmony export */   b3: () => (/* binding */ INFINITY),\n/* harmony export */   b4: () => (/* binding */ RAD_PER_DEG),\n/* harmony export */   b5: () => (/* binding */ QUARTER_PI),\n/* harmony export */   b6: () => (/* binding */ TWO_THIRDS_PI),\n/* harmony export */   b7: () => (/* binding */ _angleDiff),\n/* harmony export */   c: () => (/* binding */ color),\n/* harmony export */   d: () => (/* binding */ defaults),\n/* harmony export */   e: () => (/* binding */ effects),\n/* harmony export */   f: () => (/* binding */ resolveObjectKey),\n/* harmony export */   g: () => (/* binding */ isNumberFinite),\n/* harmony export */   h: () => (/* binding */ defined),\n/* harmony export */   i: () => (/* binding */ isObject),\n/* harmony export */   j: () => (/* binding */ createContext),\n/* harmony export */   k: () => (/* binding */ isNullOrUndef),\n/* harmony export */   l: () => (/* binding */ listenArrayEvents),\n/* harmony export */   m: () => (/* binding */ toPercentage),\n/* harmony export */   n: () => (/* binding */ toDimension),\n/* harmony export */   o: () => (/* binding */ formatNumber),\n/* harmony export */   p: () => (/* binding */ _angleBetween),\n/* harmony export */   q: () => (/* binding */ _getStartAndCountOfVisiblePoints),\n/* harmony export */   r: () => (/* binding */ requestAnimFrame),\n/* harmony export */   s: () => (/* binding */ sign),\n/* harmony export */   t: () => (/* binding */ toRadians),\n/* harmony export */   u: () => (/* binding */ unlistenArrayEvents),\n/* harmony export */   v: () => (/* binding */ valueOrDefault),\n/* harmony export */   w: () => (/* binding */ _scaleRangesChanged),\n/* harmony export */   x: () => (/* binding */ isNumber),\n/* harmony export */   y: () => (/* binding */ _parseObjectDataRadialScale),\n/* harmony export */   z: () => (/* binding */ getRelativePosition)\n/* harmony export */ });\n/* harmony import */ var _kurkle_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kurkle/color */ \"(ssr)/./node_modules/@kurkle/color/dist/color.esm.js\");\n/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */ \n/**\n * @namespace Chart.helpers\n */ /**\n * An empty function that can be used, for example, for optional callback.\n */ function noop() {\n/* noop */ }\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */ const uid = (()=>{\n    let id = 0;\n    return ()=>id++;\n})();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isNullOrUndef(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */ function isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === \"[object\" && type.slice(-6) === \"Array]\") {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === \"[object Object]\";\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */ function isNumberFinite(value) {\n    return (typeof value === \"number\" || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */ function finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */ function valueOrDefault(value, defaultValue) {\n    return typeof value === \"undefined\" ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 : +value / dimension;\nconst toDimension = (value, dimension)=>typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 * dimension : +value;\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */ function callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === \"function\") {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */ function _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */ function clone(source) {\n    if (isArray(source)) {\n        return source.map(clone);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        \"__proto__\",\n        \"prototype\",\n        \"constructor\"\n    ].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */ function _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    let current;\n    for(let i = 0; i < ilen; ++i){\n        current = sources[i];\n        if (!isObject(current)) {\n            continue;\n        }\n        const keys = Object.keys(current);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, current, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */ function _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone(sval);\n    }\n}\n/**\n * @private\n */ function _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n    // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n    \"\": (v)=>v,\n    // default resolvers\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\n/**\n * @private\n */ function _splitKey(key) {\n    const parts = key.split(\".\");\n    const keys = [];\n    let tmp = \"\";\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith(\"\\\\\")) {\n            tmp = tmp.slice(0, -1) + \".\";\n        } else {\n            keys.push(tmp);\n            tmp = \"\";\n        }\n    }\n    return keys;\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === \"\") {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\n/**\n * @private\n */ function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== \"undefined\";\nconst isFunction = (value)=>typeof value === \"function\";\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param e - The event\n * @private\n */ function _isClickEvent(e) {\n    return e.type === \"mouseup\" || e.type === \"click\" || e.type === \"contextmenu\";\n}\n/**\n * @alias Chart.helpers.math\n * @namespace\n */ const PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */ function niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */ function _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */ function isNonPrimitive(n) {\n    return typeof n === \"symbol\" || typeof n === \"object\" && n !== null && !(Symbol.toPrimitive in n || \"toString\" in n || \"valueOf\" in n);\n}\nfunction isNumber(n) {\n    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */ function _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */ function _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */ function _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */ function _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */ function _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */ function _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */ function _isBetween(value, start, end, epsilon = 1e-6) {\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{\n        const ti = table[index][key];\n        return ti < value || ti === value && table[index + 1][key] === value;\n    } : (index)=>table[index][key] < value);\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */ function _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    \"push\",\n    \"pop\",\n    \"shift\",\n    \"splice\",\n    \"unshift\"\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, \"_chartjs\", {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = \"_onData\" + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value (...args) {\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === \"function\") {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\n/**\n * @param items\n */ function _arrayUnique(items) {\n    const set = new Set(items);\n    if (set.size === items.length) {\n        return items;\n    }\n    return Array.from(set);\n}\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + \" \" + pixelSize + \"px \" + fontFamily;\n}\n/**\n* Request animation polyfill\n*/ const requestAnimFrame = function() {\n    if (true) {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */ function throttled(fn, thisArg) {\n    let argsToUse = [];\n    let ticking = false;\n    return function(...args) {\n        // Save the args for use later\n        argsToUse = args;\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, argsToUse);\n            });\n        }\n    };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */ function debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */ const _toLeftRightCenter = (align)=>align === \"start\" ? \"left\" : align === \"end\" ? \"right\" : \"center\";\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */ const _alignStartEnd = (align, start, end)=>align === \"start\" ? start : align === \"end\" ? end : (start + end) / 2;\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */ const _textX = (align, left, right, rtl)=>{\n    const check = rtl ? \"left\" : \"right\";\n    return align === check ? right : align === \"center\" ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale, vScale, _parsed } = meta;\n        const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n        const axis = iScale.axis;\n        const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n        if (minDefined) {\n            start = Math.min(_lookupByKey(_parsed, axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n            if (spanGaps) {\n                const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                start -= Math.max(0, distanceToDefinedLo);\n            }\n            start = _limitValue(start, 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            let end = Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n            if (spanGaps) {\n                const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                end += Math.max(0, distanceToDefinedHi);\n            }\n            count = _limitValue(end, start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */ function _scaleRangesChanged(meta) {\n    const { xScale, yScale, _scaleRanges } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */ const effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === \"object\") {\n        const type = value.toString();\n        return type === \"[object CanvasPattern]\" || type === \"[object CanvasGradient]\";\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : new _kurkle_color__WEBPACK_IMPORTED_MODULE_0__.Color(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : new _kurkle_color__WEBPACK_IMPORTED_MODULE_0__.Color(value).saturate(0.5).darken(0.1).hexString();\n}\nconst numbers = [\n    \"x\",\n    \"y\",\n    \"borderWidth\",\n    \"radius\",\n    \"tension\"\n];\nconst colors = [\n    \"color\",\n    \"borderColor\",\n    \"backgroundColor\"\n];\nfunction applyAnimationsDefaults(defaults) {\n    defaults.set(\"animation\", {\n        delay: undefined,\n        duration: 1000,\n        easing: \"easeOutQuart\",\n        fn: undefined,\n        from: undefined,\n        loop: undefined,\n        to: undefined,\n        type: undefined\n    });\n    defaults.describe(\"animation\", {\n        _fallback: false,\n        _indexable: false,\n        _scriptable: (name)=>name !== \"onProgress\" && name !== \"onComplete\" && name !== \"fn\"\n    });\n    defaults.set(\"animations\", {\n        colors: {\n            type: \"color\",\n            properties: colors\n        },\n        numbers: {\n            type: \"number\",\n            properties: numbers\n        }\n    });\n    defaults.describe(\"animations\", {\n        _fallback: \"animation\"\n    });\n    defaults.set(\"transitions\", {\n        active: {\n            animation: {\n                duration: 400\n            }\n        },\n        resize: {\n            animation: {\n                duration: 0\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    from: \"transparent\"\n                },\n                visible: {\n                    type: \"boolean\",\n                    duration: 0\n                }\n            }\n        },\n        hide: {\n            animations: {\n                colors: {\n                    to: \"transparent\"\n                },\n                visible: {\n                    type: \"boolean\",\n                    easing: \"linear\",\n                    fn: (v)=>v | 0\n                }\n            }\n        }\n    });\n}\nfunction applyLayoutsDefaults(defaults) {\n    defaults.set(\"layout\", {\n        autoPadding: true,\n        padding: {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    });\n}\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\nconst formatters = {\n    values (value) {\n        return isArray(value) ? value : \"\" + value;\n    },\n    numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return \"0\";\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = \"scientific\";\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = log10(Math.abs(delta));\n        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return formatNumber(tickValue, locale, options);\n    },\n    logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return \"0\";\n        }\n        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n        if ([\n            1,\n            2,\n            3,\n            5,\n            10,\n            15\n        ].includes(remain) || index > 0.8 * ticks.length) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return \"\";\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\nvar Ticks = {\n    formatters\n};\nfunction applyScaleDefaults(defaults) {\n    defaults.set(\"scale\", {\n        display: true,\n        offset: false,\n        reverse: false,\n        beginAtZero: false,\n        bounds: \"ticks\",\n        clip: true,\n        grace: 0,\n        grid: {\n            display: true,\n            lineWidth: 1,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickLength: 8,\n            tickWidth: (_ctx, options)=>options.lineWidth,\n            tickColor: (_ctx, options)=>options.color,\n            offset: false\n        },\n        border: {\n            display: true,\n            dash: [],\n            dashOffset: 0.0,\n            width: 1\n        },\n        title: {\n            display: false,\n            text: \"\",\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            textStrokeWidth: 0,\n            textStrokeColor: \"\",\n            padding: 3,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 3,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {},\n            align: \"center\",\n            crossAlign: \"near\",\n            showLabelBackdrop: false,\n            backdropColor: \"rgba(255, 255, 255, 0.75)\",\n            backdropPadding: 2\n        }\n    });\n    defaults.route(\"scale.ticks\", \"color\", \"\", \"color\");\n    defaults.route(\"scale.grid\", \"color\", \"\", \"borderColor\");\n    defaults.route(\"scale.border\", \"color\", \"\", \"borderColor\");\n    defaults.route(\"scale.title\", \"color\", \"\", \"color\");\n    defaults.describe(\"scale\", {\n        _fallback: false,\n        _scriptable: (name)=>!name.startsWith(\"before\") && !name.startsWith(\"after\") && name !== \"callback\" && name !== \"parser\",\n        _indexable: (name)=>name !== \"borderDash\" && name !== \"tickBorderDash\" && name !== \"dash\"\n    });\n    defaults.describe(\"scales\", {\n        _fallback: \"scale\"\n    });\n    defaults.describe(\"scale.ticks\", {\n        _scriptable: (name)=>name !== \"backdropPadding\" && name !== \"callback\",\n        _indexable: (name)=>name !== \"backdropPadding\"\n    });\n}\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split(\".\");\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === \"string\") {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, \"\"), scope);\n}\nclass Defaults {\n    constructor(_descriptors, _appliers){\n        this.animation = undefined;\n        this.backgroundColor = \"rgba(0,0,0,0.1)\";\n        this.borderColor = \"rgba(0,0,0,0.1)\";\n        this.color = \"#666\";\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            \"mousemove\",\n            \"mouseout\",\n            \"click\",\n            \"touchstart\",\n            \"touchmove\"\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: \"normal\",\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = \"x\";\n        this.interaction = {\n            mode: \"nearest\",\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n        this.apply(_appliers);\n    }\n    set(scope, values) {\n        return set(this, scope, values);\n    }\n    get(scope) {\n        return getScope$1(this, scope);\n    }\n    describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n    route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = \"_\" + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n    apply(appliers) {\n        appliers.forEach((apply)=>apply(this));\n    }\n}\nvar defaults = /* #__PURE__ */ new Defaults({\n    _scriptable: (name)=>!name.startsWith(\"on\"),\n    _indexable: (name)=>name !== \"events\",\n    hover: {\n        _fallback: \"interaction\"\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n}, [\n    applyAnimationsDefaults,\n    applyLayoutsDefaults,\n    applyScaleDefaults\n]);\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */ function toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + \" \" : \"\") + (font.weight ? font.weight + \" \" : \"\") + font.size + \"px \" + font.family;\n}\n/**\n * @private\n */ function _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\n/**\n * @private\n */ // eslint-disable-next-line complexity\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        // Undefined strings and arrays should not be measured\n        if (thing !== undefined && thing !== null && !isArray(thing)) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            // if it is an array lets measure each element\n            // to do maybe simplify this function a bit so we can do this more recursively?\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                // Undefined strings and arrays should not be measured\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */ function _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n/**\n * Clears the entire canvas.\n */ function clearCanvas(canvas, ctx) {\n    if (!ctx && !canvas) {\n        return;\n    }\n    ctx = ctx || canvas.getContext(\"2d\");\n    ctx.save();\n    // canvas.width and canvas.height do not consider the canvas transform,\n    // while clearRect does\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    drawPointLegend(ctx, options, x, y, null);\n}\n// eslint-disable-next-line complexity\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === \"object\") {\n        type = style.toString();\n        if (type === \"[object HTMLImageElement]\" || type === \"[object HTMLCanvasElement]\") {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        // Default includes circle\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case \"triangle\":\n            width = w ? w / 2 : radius;\n            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case \"rectRounded\":\n            // NOTE: the rounded rect implementation changed to use `arc` instead of\n            // `quadraticCurveTo` since it generates better results when rect is\n            // almost a circle. 0.516 (instead of 0.5) produces results with visually\n            // closer proportion to the previous impl and it is inscribed in the\n            // circle with `radius`. For more details, see the following PRs:\n            // https://github.com/chartjs/Chart.js/issues/5597\n            // https://github.com/chartjs/Chart.js/issues/5858\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case \"rect\":\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        /* falls through */ case \"rectRot\":\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            ctx.closePath();\n            break;\n        case \"crossRot\":\n            rad += QUARTER_PI;\n        /* falls through */ case \"cross\":\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case \"star\":\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            rad += QUARTER_PI;\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case \"line\":\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case \"dash\":\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n            break;\n        case false:\n            ctx.closePath();\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */ function _isPointInArea(point, area, margin) {\n    margin = margin || 0.5; // margin - default is to match rounded decimals\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\n/**\n * @private\n */ function _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === \"middle\") {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === \"after\" !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\n/**\n * @private\n */ function _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */ const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction drawBackdrop(ctx, opts) {\n    const oldColor = ctx.fillStyle;\n    ctx.fillStyle = opts.color;\n    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n    ctx.fillStyle = oldColor;\n}\n/**\n * Render text onto the canvas\n */ function renderText(ctx, text, x, y, font, opts = {}) {\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== \"\";\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (opts.backdrop) {\n            drawBackdrop(ctx, opts.backdrop);\n        }\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += Number(font.lineHeight);\n    }\n    ctx.restore();\n}\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */ function addRoundedRectPath(ctx, rect) {\n    const { x, y, w, h, radius } = rect;\n    // top left arc\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n    // line from top left to bottom left\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    // bottom left arc\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    // line from bottom left to bottom right\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    // bottom right arc\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    // line from bottom right to top right\n    ctx.lineTo(x + w, y + radius.topRight);\n    // top right arc\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    // line from top right to top left\n    ctx.lineTo(x + radius.topLeft, y);\n}\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */ function toLineHeight(value, size) {\n    const matches = (\"\" + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === \"normal\") {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case \"px\":\n            return value;\n        case \"%\":\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */ function toTRBL(value) {\n    return _readValueToProps(value, {\n        top: \"y\",\n        right: \"x\",\n        bottom: \"y\",\n        left: \"x\"\n    });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */ function toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        \"topLeft\",\n        \"topRight\",\n        \"bottomLeft\",\n        \"bottomRight\"\n    ]);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */ function toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */ function toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === \"string\") {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !(\"\" + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = undefined;\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: \"\"\n    };\n    font.string = toFontString(font);\n    return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */ function resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === \"function\") {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */ function _addGrace(minmax, grace, beginAtZero) {\n    const { min, max } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */ function _createResolver(scopes, prefixes = [\n    \"\"\n], rootScopes, fallback, getTarget = ()=>scopes[0]) {\n    const finalRootScopes = rootScopes || scopes;\n    if (typeof fallback === \"undefined\") {\n        fallback = _resolve(\"_fallback\", scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: \"Object\",\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: finalRootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, finalRootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete target._keys; // remove cached keys\n            delete scopes[0][prop]; // remove from top level scope\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value; // set to top level scope + cache\n            delete target._keys; // remove cached keys\n            return true;\n        }\n    });\n}\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete proxy[prop]; // remove from proxy\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            proxy[prop] = value; // set to proxy\n            delete target[prop]; // remove from cache\n            return true;\n        }\n    });\n}\n/**\n * @private\n */ function _descriptors(proxy, defaults = {\n    scriptable: true,\n    indexable: true\n}) {\n    const { _scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== \"adapters\" && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === \"constructor\") {\n        return target[prop];\n    }\n    const value = resolve();\n    // cache the resolved value\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    let value = _proxy[prop]; // resolve from proxy\n    // resolve with context\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        // if the resolved value is an object, create a sub resolver for it\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, getValue, target, receiver) {\n    const { _proxy, _context, _subProxy, _stack } = target;\n    if (_stack.has(prop)) {\n        throw new Error(\"Recursion detected: \" + Array.from(_stack).join(\"->\") + \"->\" + prop);\n    }\n    _stack.add(prop);\n    let value = getValue(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        // When scriptable option returns an object, create a resolver on that.\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    if (typeof _context.index !== \"undefined\" && isIndexable(prop)) {\n        return value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        // Array of objects, return array or resolvers\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === \"string\" ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (typeof fallback !== \"undefined\" && fallback !== key && fallback !== parentFallback) {\n                // When we reach the descriptor that defines a new _fallback, return that.\n                // The fallback will resume to that new scope.\n                return fallback;\n            }\n        } else if (scope === false && typeof parentFallback !== \"undefined\" && key !== parentFallback) {\n            // Fallback to `false` results to `false`, when falling back to different key.\n            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (typeof fallback !== \"undefined\" && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        \"\"\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        // For array of objects, the object is used to store updated values\n        return value;\n    }\n    return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (typeof value !== \"undefined\") {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (typeof value !== \"undefined\") {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith(\"_\"))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale } = meta;\n    const { key = \"r\" } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === \"x\" ? \"y\" : \"x\";\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    // Props to Rob Spencer at scaled innovation for his post on splining between points\n    // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n    // This function must also respect \"skipped\" points\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    // If all points are the same, s01 & s02 will be inf\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01; // scaling factor for triangle Ta\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */ function monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK, indexAxis = \"x\") {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n        }\n    }\n}\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */ function splineCurveMonotone(points, indexAxis = \"x\") {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    // Calculate slopes (deltaK) and initialize tangents (mK)\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\n/**\n * @private\n */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    // Only consider points that are drawn in case the spanGaps option is used\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === \"monotone\") {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\n/**\n * @private\n */ function _isDomSupported() {\n    return  false && 0;\n}\n/**\n * @private\n */ function _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === \"[object ShadowRoot]\") {\n        parent = parent.host;\n    }\n    return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */ function parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === \"string\") {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf(\"%\") !== -1) {\n            // percentage * size in dimension\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? \"-\" + suffix : \"\";\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + \"-\" + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */ function getCanvasPosition(e, canvas) {\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX, offsetY } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */ function getRelativePosition(event, chart) {\n    if (\"native\" in event) {\n        return event;\n    }\n    const { canvas, currentDevicePixelRatio } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === \"border-box\";\n    const paddings = getPositionedStyle(style, \"padding\");\n    const borders = getPositionedStyle(style, \"border\", \"width\");\n    const { x, y, box } = getCanvasPosition(event, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width, height } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = canvas && _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect(); // this is the border box of the container\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, \"border\", \"width\");\n            const containerPadding = getPositionedStyle(containerStyle, \"padding\");\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, \"clientWidth\");\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, \"clientHeight\");\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, \"margin\");\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, \"clientWidth\") || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, \"clientHeight\") || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width, height } = containerSize;\n    if (style.boxSizing === \"content-box\") {\n        const borders = getPositionedStyle(style, \"border\", \"width\");\n        const paddings = getPositionedStyle(style, \"padding\");\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        // https://github.com/chartjs/Chart.js/issues/4659\n        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n        height = round1(width / 2);\n    }\n    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n        height = containerSize.height;\n        width = round1(Math.floor(height * aspectRatio));\n    }\n    return {\n        width,\n        height\n    };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */ function retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = round1(chart.height * pixelRatio);\n    const deviceWidth = round1(chart.width * pixelRatio);\n    chart.height = round1(chart.height);\n    chart.width = round1(chart.width);\n    const canvas = chart.canvas;\n    // If no style has been set on the canvas, the render size is used as display size,\n    // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n    // See https://github.com/chartjs/Chart.js/issues/3575\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = `${chart.height}px`;\n        canvas.style.width = `${chart.width}px`;\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */ const supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        if (_isDomSupported()) {\n            window.addEventListener(\"test\", null, options);\n            window.removeEventListener(\"test\", null, options);\n        }\n    } catch (e) {\n    // continue regardless of error\n    }\n    return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */ function readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\n/**\n * @private\n */ function _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\n/**\n * @private\n */ function _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === \"middle\" ? t < 0.5 ? p1.y : p2.y : mode === \"after\" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\n/**\n * @private\n */ function _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === \"center\") {\n                return align;\n            }\n            return align === \"right\" ? \"left\" : \"right\";\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === \"ltr\" || direction === \"rtl\") {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue(\"direction\"),\n            style.getPropertyPriority(\"direction\")\n        ];\n        style.setProperty(\"direction\", direction, \"important\");\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty(\"direction\", original[0], original[1]);\n    }\n}\nfunction propertyFn(property) {\n    if (property === \"angle\") {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment({ start, end, count, loop, style }) {\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property, start: startBound, end: endBound } = bounds;\n    const { between, normalize } = propertyFn(property);\n    const count = points.length;\n    let { start, end, loop } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\nfunction _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property, start: startBound, end: endBound } = bounds;\n    const count = points.length;\n    const { compare, between, normalize } = propertyFn(property);\n    const { start, end, loop, style } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\nfunction _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\nfunction solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: \"segment\",\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    if (!prevStyle) {\n        return false;\n    }\n    const cache = [];\n    const replacer = function(key, value) {\n        if (!isPatternOrGradient(value)) {\n            return value;\n        }\n        if (!cache.includes(value)) {\n            cache.push(value);\n        }\n        return cache.indexOf(value);\n    };\n    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\nfunction getSizeForArea(scale, chartArea, field) {\n    return scale.options.clip ? scale[field] : chartArea[field];\n}\nfunction getDatasetArea(meta, chartArea) {\n    const { xScale, yScale } = meta;\n    if (xScale && yScale) {\n        return {\n            left: getSizeForArea(xScale, chartArea, \"left\"),\n            right: getSizeForArea(xScale, chartArea, \"right\"),\n            top: getSizeForArea(yScale, chartArea, \"top\"),\n            bottom: getSizeForArea(yScale, chartArea, \"bottom\")\n        };\n    }\n    return chartArea;\n}\nfunction getDatasetClipArea(chart, meta) {\n    const clip = meta._clip;\n    if (clip.disabled) {\n        return false;\n    }\n    const area = getDatasetArea(meta, chart.chartArea);\n    return {\n        left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),\n        right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),\n        top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),\n        bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)\n    };\n}\n //# sourceMappingURL=helpers.dataset.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaHVua3MvaGVscGVycy5kYXRhc2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztJQVVPLFNBQVNBO0FBQ2Q7QUFHRjs7Q0FFQyxHQUNNLE1BQU1DLE1BQU87SUFDbEIsSUFBSUMsS0FBSztJQUNULE9BQU8sSUFBTUE7QUFDZjtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTQyxjQUFjQyxLQUFjO0lBQzFDLE9BQU9BLFVBQVUsUUFBUUEsVUFBVUM7QUFDckM7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0MsUUFBcUJGLEtBQWM7SUFDakQsSUFBSUcsTUFBTUQsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLENBQUNGLFFBQVE7UUFDekMsT0FBTzs7SUFFVCxNQUFNSSxPQUFPQyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUjtJQUM1QyxJQUFJSSxLQUFLSyxLQUFLLENBQUMsR0FBRyxPQUFPLGFBQWFMLEtBQUtLLEtBQUssQ0FBQyxDQUFDLE9BQU8sVUFBVTtRQUNqRSxPQUFPOztJQUVULE9BQU87QUFDVDtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTQyxTQUFTVixLQUFjO0lBQ3JDLE9BQU9BLFVBQVUsUUFBUUssT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1IsV0FBVztBQUNyRTtBQUVBOzs7SUFJQSxTQUFTVyxlQUFlWCxLQUFjO0lBQ3BDLE9BQVEsUUFBT0EsVUFBVSxZQUFZQSxpQkFBaUJZLE1BQUFBLEtBQVdDLFNBQVMsQ0FBQ2I7QUFDN0U7QUFLQTs7OztDQUlDLEdBQ00sU0FBU2MsZ0JBQWdCZCxLQUFjLEVBQUVlLFlBQW9CO0lB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QVEsSUFBSW9MLEtBQUtwTCxHQUFHLEdBQUl1QyxDQUFBQSxLQUFLdkMsR0FBRyxLQUFLLE9BQU8sSUFBSXVDLEtBQUt2QyxHQUFHO1FBQzFFQyxRQUFRc0MsS0FBS3RDLE1BQU0sS0FBSyxRQUFRbUIsTUFBTW9JLE1BQU0sR0FBRzRCLEtBQUtuTCxNQUFNLEdBQUlzQyxDQUFBQSxLQUFLdEMsTUFBTSxLQUFLLE9BQU8sSUFBSXNDLEtBQUt0QyxNQUFLO0lBQ3JHO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLmNvcmUudHM/NTYzYSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLm1hdGgudHM/MmU4MSIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24udHM/MTQ5MyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLmV4dHJhcy50cz81MDM5Iiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3NyYy9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLnRzPzk2ZDciLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5jb2xvci50cz8wYzFkIiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcz8xMjg3Iiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcz82MTc2Iiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50bC50cz8xYmE2Iiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3NyYy9jb3JlL2NvcmUudGlja3MuanM/ZGM1NiIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9zcmMvY29yZS9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzPzUxYzciLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vc3JjL2NvcmUvY29yZS5kZWZhdWx0cy5qcz8wN2JhIiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3NyYy9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLnRzPzc5YTIiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLnRzPzZlZDUiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5jb25maWcudHM/ZGNmNyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLmN1cnZlLnRzPzdiMjIiLCJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vLi4vc3JjL2hlbHBlcnMvaGVscGVycy5kb20udHM/ZTYwNyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24udHM/MDkxYyIsIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9zcmMvaGVscGVycy9oZWxwZXJzLnJ0bC50cz8yYWMyIiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3NyYy9oZWxwZXJzL2hlbHBlcnMuc2VnbWVudC5qcz9kYzNjIiwid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL3NyYy9oZWxwZXJzL2hlbHBlcnMuZGF0YXNldC50cz85Mjg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0FjdGl2ZURhdGFQb2ludCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG4vKipcbiAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge1xuICAvKiBub29wICovXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgdWlkID0gKCgpID0+IHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuICgpID0+IGlkKys7XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bGwgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSAoaW5jbHVkaW5nIHR5cGVkIGFycmF5cyksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5PFQgPSB1bmtub3duPih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFRbXSB7XG4gIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh0eXBlLnNsaWNlKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zbGljZSgtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBBbnlPYmplY3Qge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2VcbiAqIEBwYXJhbSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXJGaW5pdGUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG59XG5leHBvcnQge1xuICBpc051bWJlckZpbml0ZSBhcyBpc0Zpbml0ZSxcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGZpbml0ZSwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyBub3QgZmluaXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlOiB1bmtub3duLCBkZWZhdWx0VmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQ8VD4odmFsdWU6IFQgfCB1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZTogVCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuXG5leHBvcnQgY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGRpbWVuc2lvbjogbnVtYmVyKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiArdmFsdWUgLyBkaW1lbnNpb247XG5cbmV4cG9ydCBjb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBkaW1lbnNpb246IG51bWJlcikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuXG4vKipcbiAqIENhbGxzIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gYGFyZ3NgIGluIHRoZSBzY29wZSBkZWZpbmVkIGJ5IGB0aGlzQXJnYCBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG4gKiBAcGFyYW0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxiYWNrPFQgZXh0ZW5kcyAodGhpczogVEEsIC4uLnJlc3RBcmdzOiB1bmtub3duW10pID0+IFIsIFRBLCBSPihcbiAgZm46IFQgfCB1bmRlZmluZWQsXG4gIGFyZ3M6IHVua25vd25bXSxcbiAgdGhpc0FyZz86IFRBXG4pOiBSIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG4gKiBpcyB1bmtub3duIG9yIGluIG5vbmUgaW50ZW5zaXZlIGNvZGUgKG5vdCBjYWxsZWQgb2Z0ZW4gYW5kIHNtYWxsIGxvb3BhYmxlKS4gRWxzZVxuICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cbiAqIEBwYXJhbSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKiBAcGFyYW0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogc3RyaW5nKSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogVFtdLFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBudW1iZXIpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBUW10gfCBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogYW55KSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgbGVuOiBudW1iZXIsIGtleXM6IHN0cmluZ1tdO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBhMSAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTA6IEFjdGl2ZURhdGFQb2ludFtdLCBhMTogQWN0aXZlRGF0YVBvaW50W10pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2MDogQWN0aXZlRGF0YVBvaW50LCB2MTogQWN0aXZlRGF0YVBvaW50O1xuXG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcblxuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZTxUPihzb3VyY2U6IFQpOiBUIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lKSBhcyB1bmtub3duIGFzIFQ7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcblxuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cbiAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlcihrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zOiBBbnlPYmplY3QpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lcmdlT3B0aW9ucyB7XG4gIG1lcmdlcj86IChrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zPzogQW55T2JqZWN0KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuICogQHBhcmFtIFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcbiAqIEBwYXJhbSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogW10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogUzEsIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMj4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzJdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxICYgUzI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMz4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMSAmIFMyICYgUzM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMywgUzQ+KFxuICB0YXJnZXQ6IFQsXG4gIHNvdXJjZTogW1MxLCBTMiwgUzMsIFM0XSxcbiAgb3B0aW9ucz86IE1lcmdlT3B0aW9uc1xuKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IEFueU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBBbnlPYmplY3Qge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblxuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGFzIEFueU9iamVjdDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBsZXQgY3VycmVudDogQW55T2JqZWN0O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChjdXJyZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cnJlbnQpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIGN1cnJlbnQsIG9wdGlvbnMgYXMgQW55T2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cbiAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBbXSk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFMxKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMl0pOiBUICYgUzEgJiBTMjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMiwgUzM+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTM10pOiBUICYgUzEgJiBTMiAmIFMzO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyLCBTMywgUzQ+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTMywgUzRdKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICByZXR1cm4gbWVyZ2U8VD4odGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuXG4vKipcbiAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VySWYoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duLCBwcmV2aW91czogc3RyaW5nLCBjdXJyZW50OiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG4gICAgICAnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuXG4vLyByZXNvbHZlT2JqZWN0S2V5IHJlc29sdmVyIGNhY2hlXG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCByZXNvbHZlIGVtcHR5IGtleSB0byByb290IG9iamVjdFxuICAnJzogdiA9PiB2LFxuICAvLyBkZWZhdWx0IHJlc29sdmVyc1xuICB4OiBvID0+IG8ueCxcbiAgeTogbyA9PiBvLnlcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zcGxpdEtleShrZXk6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgdG1wID0gJyc7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIHRtcCArPSBwYXJ0O1xuICAgIGlmICh0bXAuZW5kc1dpdGgoJ1xcXFwnKSkge1xuICAgICAgdG1wID0gdG1wLnNsaWNlKDAsIC0xKSArICcuJztcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHRtcCk7XG4gICAgICB0bXAgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXlSZXNvbHZlcihrZXk6IHN0cmluZykge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6XG4gICAgICAgIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCBicmVhayBhdCBlbXB0eSBrZXlcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmo6IEFueU9iamVjdCwga2V5OiBzdHJpbmcpOiBhbnkge1xuICBjb25zdCByZXNvbHZlciA9IGtleVJlc29sdmVyc1trZXldIHx8IChrZXlSZXNvbHZlcnNba2V5XSA9IF9nZXRLZXlSZXNvbHZlcihrZXkpKTtcbiAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cblxuZXhwb3J0IGNvbnN0IGRlZmluZWQgPSAodmFsdWU6IHVua25vd24pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzExMjg4NTUvY29tcGFyaW5nLWVjbWE2LXNldHMtZm9yLWVxdWFsaXR5IzMxMTI5Mzg0XG5leHBvcnQgY29uc3Qgc2V0c0VxdWFsID0gPFQ+KGE6IFNldDxUPiwgYjogU2V0PFQ+KSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZSAtIFRoZSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZTogQ2hhcnRFdmVudCkge1xuICByZXR1cm4gZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jztcbn1cbiIsImltcG9ydCB0eXBlIHtQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcbmltcG9ydCB7aXNGaW5pdGUgYXMgaXNGaW5pdGVOdW1iZXJ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5tYXRoXG4gKiBAbmFtZXNwYWNlXG4gKi9cblxuZXhwb3J0IGNvbnN0IFBJID0gTWF0aC5QSTtcbmV4cG9ydCBjb25zdCBUQVUgPSAyICogUEk7XG5leHBvcnQgY29uc3QgUElUQVUgPSBUQVUgKyBQSTtcbmV4cG9ydCBjb25zdCBJTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbmV4cG9ydCBjb25zdCBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xuZXhwb3J0IGNvbnN0IEhBTEZfUEkgPSBQSSAvIDI7XG5leHBvcnQgY29uc3QgUVVBUlRFUl9QSSA9IFBJIC8gNDtcbmV4cG9ydCBjb25zdCBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcblxuZXhwb3J0IGNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcbmV4cG9ydCBjb25zdCBzaWduID0gTWF0aC5zaWduO1xuXG5leHBvcnQgZnVuY3Rpb24gYWxtb3N0RXF1YWxzKHg6IG51bWJlciwgeTogbnVtYmVyLCBlcHNpbG9uOiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIG5pY2UgbnVtYmVyIGFsZ29yaXRobSB1c2VkIGluIGRldGVybWluaW5nIHdoZXJlIGF4aXMgbGFiZWxzIHdpbGwgZ29cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5pY2VOdW0ocmFuZ2U6IG51bWJlcikge1xuICBjb25zdCByb3VuZGVkUmFuZ2UgPSBNYXRoLnJvdW5kKHJhbmdlKTtcbiAgcmFuZ2UgPSBhbG1vc3RFcXVhbHMocmFuZ2UsIHJvdW5kZWRSYW5nZSwgcmFuZ2UgLyAxMDAwKSA/IHJvdW5kZWRSYW5nZSA6IHJhbmdlO1xuICBjb25zdCBuaWNlUmFuZ2UgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChyYW5nZSkpKTtcbiAgY29uc3QgZnJhY3Rpb24gPSByYW5nZSAvIG5pY2VSYW5nZTtcbiAgY29uc3QgbmljZUZyYWN0aW9uID0gZnJhY3Rpb24gPD0gMSA/IDEgOiBmcmFjdGlvbiA8PSAyID8gMiA6IGZyYWN0aW9uIDw9IDUgPyA1IDogMTA7XG4gIHJldHVybiBuaWNlRnJhY3Rpb24gKiBuaWNlUmFuZ2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBmYWN0b3JzIHNvcnRlZCBmcm9tIDEgdG8gc3FydCh2YWx1ZSlcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZmFjdG9yaXplKHZhbHVlOiBudW1iZXIpIHtcbiAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgbGV0IGk6IG51bWJlcjtcblxuICBmb3IgKGkgPSAxOyBpIDwgc3FydDsgaSsrKSB7XG4gICAgaWYgKHZhbHVlICUgaSA9PT0gMCkge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSAvIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoc3FydCA9PT0gKHNxcnQgfCAwKSkgeyAvLyBpZiB2YWx1ZSBpcyBhIHNxdWFyZSBudW1iZXJcbiAgICByZXN1bHQucHVzaChzcXJ0KTtcbiAgfVxuXG4gIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhIC0gYikucG9wKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBhdHRlbXB0aW5nIHRvIGNvZXJjZSBuIHRvIHN0cmluZyBvciBudW1iZXIgd29uJ3QgdGhyb3cgYSBUeXBlRXJyb3IuXG4gKi9cbmZ1bmN0aW9uIGlzTm9uUHJpbWl0aXZlKG46IHVua25vd24pIHtcbiAgcmV0dXJuIHR5cGVvZiBuID09PSAnc3ltYm9sJyB8fCAodHlwZW9mIG4gPT09ICdvYmplY3QnICYmIG4gIT09IG51bGwgJiYgIShTeW1ib2wudG9QcmltaXRpdmUgaW4gbiB8fCAndG9TdHJpbmcnIGluIG4gfHwgJ3ZhbHVlT2YnIGluIG4pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG46IHVua25vd24pOiBuIGlzIG51bWJlciB7XG4gIHJldHVybiAhaXNOb25QcmltaXRpdmUobikgJiYgIWlzTmFOKHBhcnNlRmxvYXQobiBhcyBzdHJpbmcpKSAmJiBpc0Zpbml0ZShuIGFzIG51bWJlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbG1vc3RXaG9sZSh4OiBudW1iZXIsIGVwc2lsb246IG51bWJlcikge1xuICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcbiAgcmV0dXJuICgocm91bmRlZCAtIGVwc2lsb24pIDw9IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID49IHgpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc2V0TWluQW5kTWF4QnlLZXkoXG4gIGFycmF5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+W10sXG4gIHRhcmdldDogeyBtaW46IG51bWJlciwgbWF4OiBudW1iZXIgfSxcbiAgcHJvcGVydHk6IHN0cmluZ1xuKSB7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgdmFsdWU6IG51bWJlcjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJheVtpXVtwcm9wZXJ0eV07XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRhcmdldC5taW4gPSBNYXRoLm1pbih0YXJnZXQubWluLCB2YWx1ZSk7XG4gICAgICB0YXJnZXQubWF4ID0gTWF0aC5tYXgodGFyZ2V0Lm1heCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXM6IG51bWJlcikge1xuICByZXR1cm4gZGVncmVlcyAqIChQSSAvIDE4MCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFuczogbnVtYmVyKSB7XG4gIHJldHVybiByYWRpYW5zICogKDE4MCAvIFBJKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAqIGkuZS4gdGhlIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIE51bWJlci5cbiAqIEBwYXJhbSB4IC0gQSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWNpbWFsUGxhY2VzKHg6IG51bWJlcikge1xuICBpZiAoIWlzRmluaXRlTnVtYmVyKHgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gMTtcbiAgbGV0IHAgPSAwO1xuICB3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG4gICAgZSAqPSAxMDtcbiAgICBwKys7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbi8vIEdldHMgdGhlIGFuZ2xlIGZyb20gdmVydGljYWwgdXByaWdodCB0byB0aGUgcG9pbnQgYWJvdXQgYSBjZW50cmUuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW5nbGVGcm9tUG9pbnQoXG4gIGNlbnRyZVBvaW50OiBQb2ludCxcbiAgYW5nbGVQb2ludDogUG9pbnRcbikge1xuICBjb25zdCBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG4gIGNvbnN0IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcblxuICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKGRpc3RhbmNlRnJvbVlDZW50ZXIsIGRpc3RhbmNlRnJvbVhDZW50ZXIpO1xuXG4gIGlmIChhbmdsZSA8ICgtMC41ICogUEkpKSB7XG4gICAgYW5nbGUgKz0gVEFVOyAvLyBtYWtlIHN1cmUgdGhlIHJldHVybmVkIGFuZ2xlIGlzIGluIHRoZSByYW5nZSBvZiAoLVBJLzIsIDNQSS8yXVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhbmdsZSxcbiAgICBkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocHQxOiBQb2ludCwgcHQyOiBQb2ludCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xufVxuXG4vKipcbiAqIFNob3J0ZXN0IGRpc3RhbmNlIGJldHdlZW4gYW5nbGVzLCBpbiBlaXRoZXIgZGlyZWN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbmdsZURpZmYoYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgcmV0dXJuIChhIC0gYiArIFBJVEFVKSAlIFRBVSAtIFBJO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbmdsZSB0byBiZSBiZXR3ZWVuIDAgYW5kIDIqUElcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbm9ybWFsaXplQW5nbGUoYTogbnVtYmVyKSB7XG4gIHJldHVybiAoYSAlIFRBVSArIFRBVSkgJSBUQVU7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbmdsZUJldHdlZW4oYW5nbGU6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHNhbWVBbmdsZUlzRnVsbENpcmNsZT86IGJvb2xlYW4pIHtcbiAgY29uc3QgYSA9IF9ub3JtYWxpemVBbmdsZShhbmdsZSk7XG4gIGNvbnN0IHMgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICBjb25zdCBlID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIGNvbnN0IGFuZ2xlVG9TdGFydCA9IF9ub3JtYWxpemVBbmdsZShzIC0gYSk7XG4gIGNvbnN0IGFuZ2xlVG9FbmQgPSBfbm9ybWFsaXplQW5nbGUoZSAtIGEpO1xuICBjb25zdCBzdGFydFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIHMpO1xuICBjb25zdCBlbmRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBlKTtcbiAgcmV0dXJuIGEgPT09IHMgfHwgYSA9PT0gZSB8fCAoc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlICYmIHMgPT09IGUpXG4gICAgfHwgKGFuZ2xlVG9TdGFydCA+IGFuZ2xlVG9FbmQgJiYgc3RhcnRUb0FuZ2xlIDwgZW5kVG9BbmdsZSk7XG59XG5cbi8qKlxuICogTGltaXQgYHZhbHVlYCBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gbWluXG4gKiBAcGFyYW0gbWF4XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2xpbWl0VmFsdWUodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaW50MTZSYW5nZSh2YWx1ZTogbnVtYmVyKSB7XG4gIHJldHVybiBfbGltaXRWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gc3RhcnRcbiAqIEBwYXJhbSBlbmRcbiAqIEBwYXJhbSBbZXBzaWxvbl1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNCZXR3ZWVuKHZhbHVlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBlcHNpbG9uID0gMWUtNikge1xuICByZXR1cm4gdmFsdWUgPj0gTWF0aC5taW4oc3RhcnQsIGVuZCkgLSBlcHNpbG9uICYmIHZhbHVlIDw9IE1hdGgubWF4KHN0YXJ0LCBlbmQpICsgZXBzaWxvbjtcbn1cbiIsImltcG9ydCB7X2NhcGl0YWxpemV9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBCaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSBjbXBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwKFxuICB0YWJsZTogbnVtYmVyW10sXG4gIHZhbHVlOiBudW1iZXIsXG4gIGNtcD86ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cDxUPihcbiAgdGFibGU6IFRbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wOiAodmFsdWU6IG51bWJlcikgPT4gYm9vbGVhblxuKToge2xvOiBudW1iZXIsIGhpOiBudW1iZXJ9O1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiB1bmtub3duW10sXG4gIHZhbHVlOiBudW1iZXIsXG4gIGNtcD86ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pIHtcbiAgY21wID0gY21wIHx8ICgoaW5kZXgpID0+IHRhYmxlW2luZGV4XSA8IHZhbHVlKTtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IG1pZDogbnVtYmVyO1xuXG4gIHdoaWxlIChoaSAtIGxvID4gMSkge1xuICAgIG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgIGlmIChjbXAobWlkKSkge1xuICAgICAgbG8gPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7bG8sIGhpfTtcbn1cblxuLyoqXG4gKiBCaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSBrZXkgLSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgdmFsdWUgaW4gZWFjaCBlbnRyeVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGxhc3QgLSBsb29rdXAgbGFzdCBpbmRleFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9sb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXIsXG4gIGxhc3Q/OiBib29sZWFuXG4pID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBsYXN0XG4gICAgPyBpbmRleCA9PiB7XG4gICAgICBjb25zdCB0aSA9IHRhYmxlW2luZGV4XVtrZXldO1xuICAgICAgcmV0dXJuIHRpIDwgdmFsdWUgfHwgdGkgPT09IHZhbHVlICYmIHRhYmxlW2luZGV4ICsgMV1ba2V5XSA9PT0gdmFsdWU7XG4gICAgfVxuICAgIDogaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPCB2YWx1ZSk7XG5cbi8qKlxuICogUmV2ZXJzZSBiaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSBrZXkgLSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgdmFsdWUgaW4gZWFjaCBlbnRyeVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9ybG9va3VwQnlLZXkgPSAoXG4gIHRhYmxlOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+W10sXG4gIGtleTogc3RyaW5nLFxuICB2YWx1ZTogbnVtYmVyXG4pID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA+PSB2YWx1ZSk7XG5cbi8qKlxuICogUmV0dXJuIHN1YnNldCBvZiBgdmFsdWVzYCBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCBpbmNsdXNpdmUuXG4gKiBWYWx1ZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gc29ydGVkIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlcyAtIHNvcnRlZCBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSBtaW4gLSBtaW4gdmFsdWVcbiAqIEBwYXJhbSBtYXggLSBtYXggdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlczogbnVtYmVyW10sIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gdmFsdWVzLmxlbmd0aDtcblxuICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgdmFsdWVzW3N0YXJ0XSA8IG1pbikge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHZhbHVlc1tlbmQgLSAxXSA+IG1heCkge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXG4gICAgPyB2YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IHZhbHVlcztcbn1cblxuY29uc3QgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J10gYXMgY29uc3Q7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJyYXlMaXN0ZW5lcjxUPiB7XG4gIF9vbkRhdGFQdXNoPyguLi5pdGVtOiBUW10pOiB2b2lkO1xuICBfb25EYXRhUG9wPygpOiB2b2lkO1xuICBfb25EYXRhU2hpZnQ/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTcGxpY2U/KGluZGV4OiBudW1iZXIsIGRlbGV0ZUNvdW50OiBudW1iZXIsIC4uLml0ZW1zOiBUW10pOiB2b2lkO1xuICBfb25EYXRhVW5zaGlmdD8oLi4uaXRlbTogVFtdKTogdm9pZDtcbn1cblxuLyoqXG4gKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxuICogJ3Vuc2hpZnQnKSBhbmQgbm90aWZ5IHRoZSBsaXN0ZW5lciBBRlRFUiB0aGUgYXJyYXkgaGFzIGJlZW4gYWx0ZXJlZC4gTGlzdGVuZXJzIGFyZVxuICogY2FsbGVkIG9uIHRoZSAnX29uRGF0YSonIGNhbGxiYWNrcyAoZS5nLiBfb25EYXRhUHVzaCwgZXRjLikgd2l0aCBzYW1lIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzPFQ+KGFycmF5OiBUW10sIGxpc3RlbmVyOiBBcnJheUxpc3RlbmVyPFQ+KTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgaWYgKGFycmF5Ll9jaGFydGpzKSB7XG4gICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ19jaGFydGpzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZToge1xuICAgICAgbGlzdGVuZXJzOiBbbGlzdGVuZXJdXG4gICAgfVxuICB9KTtcblxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5mb3JFYWNoKChvYmplY3QpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmplY3RbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYXJyYXkgZXZlbnQgbGlzdGVuZXIgYW5kIGNsZWFudXAgZXh0cmEgYXR0YWNoZWQgcHJvcGVydGllcyAoc3VjaCBhc1xuICogdGhlIF9jaGFydGpzIHN0dWIgYW5kIG92ZXJyaWRkZW4gbWV0aG9kcykgaWYgYXJyYXkgZG9lc24ndCBoYXZlIGFueSBtb3JlIGxpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGNvbnN0IHN0dWIgPSBhcnJheS5fY2hhcnRqcztcbiAgaWYgKCFzdHViKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG4gIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBkZWxldGUgYXJyYXlba2V5XTtcbiAgfSk7XG5cbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpdGVtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gX2FycmF5VW5pcXVlPFQ+KGl0ZW1zOiBUW10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxUPihpdGVtcyk7XG5cbiAgaWYgKHNldC5zaXplID09PSBpdGVtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuIiwiaW1wb3J0IHR5cGUge0NoYXJ0TWV0YSwgUG9pbnRFbGVtZW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmltcG9ydCB7X2xpbWl0VmFsdWV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZvbnRTdHJpbmcocGl4ZWxTaXplOiBudW1iZXIsIGZvbnRTdHlsZTogc3RyaW5nLCBmb250RmFtaWx5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcbn1cblxuLyoqXG4qIFJlcXVlc3QgYW5pbWF0aW9uIHBvbHlmaWxsXG4qL1xuZXhwb3J0IGNvbnN0IHJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbn0oKSk7XG5cbi8qKlxuICogVGhyb3R0bGVzIGNhbGxpbmcgYGZuYCBvbmNlIHBlciBhbmltYXRpb24gZnJhbWVcbiAqIExhdGVzdCBhcmd1bWVudHMgYXJlIHVzZWQgb24gdGhlIGFjdHVhbCBjYWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZWQ8VEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+PihcbiAgZm46ICguLi5hcmdzOiBUQXJncykgPT4gdm9pZCxcbiAgdGhpc0FyZzogYW55LFxuKSB7XG4gIGxldCBhcmdzVG9Vc2UgPSBbXSBhcyBUQXJncztcbiAgbGV0IHRpY2tpbmcgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogVEFyZ3MpIHtcbiAgICAvLyBTYXZlIHRoZSBhcmdzIGZvciB1c2UgbGF0ZXJcbiAgICBhcmdzVG9Vc2UgPSBhcmdzO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJnc1RvVXNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBEZWJvdW5jZXMgY2FsbGluZyBgZm5gIGZvciBgZGVsYXlgIG1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZTxUQXJncyBleHRlbmRzIEFycmF5PGFueT4+KGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IHZvaWQsIGRlbGF5OiBudW1iZXIpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzOiBUQXJncykge1xuICAgIGlmIChkZWxheSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGRlbGF5LCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyAnc3RhcnQnIHRvICdsZWZ0JywgJ2VuZCcgdG8gJ3JpZ2h0JyBhbmQgb3RoZXJzIHRvICdjZW50ZXInXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduOiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJykgPT4gYWxpZ24gPT09ICdzdGFydCcgPyAnbGVmdCcgOiBhbGlnbiA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG5cbi8qKlxuICogUmV0dXJucyBgc3RhcnRgLCBgZW5kYCBvciBgKHN0YXJ0ICsgZW5kKSAvIDJgIGRlcGVuZGluZyBvbiBgYWxpZ25gLiBEZWZhdWx0cyB0byBgY2VudGVyYFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduOiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJywgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpID0+IGFsaWduID09PSAnc3RhcnQnID8gc3RhcnQgOiBhbGlnbiA9PT0gJ2VuZCcgPyBlbmQgOiAoc3RhcnQgKyBlbmQpIC8gMjtcblxuLyoqXG4gKiBSZXR1cm5zIGBsZWZ0YCwgYHJpZ2h0YCBvciBgKGxlZnQgKyByaWdodCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGxlZnRgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3RleHRYID0gKGFsaWduOiAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcicsIGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgcnRsOiBib29sZWFuKSA9PiB7XG4gIGNvbnN0IGNoZWNrID0gcnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgcmV0dXJuIGFsaWduID09PSBjaGVjayA/IHJpZ2h0IDogYWxpZ24gPT09ICdjZW50ZXInID8gKGxlZnQgKyByaWdodCkgLyAyIDogbGVmdDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHN0YXJ0IGFuZCBjb3VudCBvZiB2aXNpYmxlIHBvaW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhOiBDaGFydE1ldGE8J2xpbmUnIHwgJ3NjYXR0ZXInPiwgcG9pbnRzOiBQb2ludEVsZW1lbnRbXSwgYW5pbWF0aW9uc0Rpc2FibGVkOiBib29sZWFuKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudCA9IHBvaW50Q291bnQ7XG5cbiAgaWYgKG1ldGEuX3NvcnRlZCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3BhcnNlZH0gPSBtZXRhO1xuICAgIGNvbnN0IHNwYW5HYXBzID0gbWV0YS5kYXRhc2V0ID8gbWV0YS5kYXRhc2V0Lm9wdGlvbnMgPyBtZXRhLmRhdGFzZXQub3B0aW9ucy5zcGFuR2FwcyA6IG51bGwgOiBudWxsO1xuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcblxuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IE1hdGgubWluKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBheGlzLCBtaW4pLmxvLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gZml4IHR5cGVzIG9uIF9sb29rdXBCeUtleVxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyBwb2ludENvdW50IDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWluKSkubG8pO1xuICAgICAgaWYgKHNwYW5HYXBzKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9EZWZpbmVkTG8gPSAoX3BhcnNlZFxuICAgICAgICAgIC5zbGljZSgwLCBzdGFydCArIDEpXG4gICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIHN0YXJ0IC09IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkTG8pO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgcG9pbnRDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgbGV0IGVuZCA9IE1hdGgubWF4KFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWF4LCB0cnVlKS5oaSArIDEsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpLCB0cnVlKS5oaSArIDEpO1xuICAgICAgaWYgKHNwYW5HYXBzKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9EZWZpbmVkSGkgPSAoX3BhcnNlZFxuICAgICAgICAgIC5zbGljZShlbmQgLSAxKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIGVuZCArPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZEhpKTtcbiAgICAgIH1cbiAgICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoZW5kLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc2NhbGUgcmFuZ2VzIGhhdmUgY2hhbmdlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZSwgX3NjYWxlUmFuZ2VzfSA9IG1ldGE7XG4gIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICB4bWluOiB4U2NhbGUubWluLFxuICAgIHhtYXg6IHhTY2FsZS5tYXgsXG4gICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICB5bWF4OiB5U2NhbGUubWF4XG4gIH07XG4gIGlmICghX3NjYWxlUmFuZ2VzKSB7XG4gICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY2hhbmdlZCA9IF9zY2FsZVJhbmdlcy54bWluICE9PSB4U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXhcblx0XHR8fCBfc2NhbGVSYW5nZXMueW1pbiAhPT0geVNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWF4ICE9PSB5U2NhbGUubWF4O1xuXG4gIE9iamVjdC5hc3NpZ24oX3NjYWxlUmFuZ2VzLCBuZXdSYW5nZXMpO1xuICByZXR1cm4gY2hhbmdlZDtcbn1cbiIsImltcG9ydCB7UEksIFRBVSwgSEFMRl9QSX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG5jb25zdCBhdEVkZ2UgPSAodDogbnVtYmVyKSA9PiB0ID09PSAwIHx8IHQgPT09IDE7XG5jb25zdCBlbGFzdGljSW4gPSAodDogbnVtYmVyLCBzOiBudW1iZXIsIHA6IG51bWJlcikgPT4gLShNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSk7XG5jb25zdCBlbGFzdGljT3V0ID0gKHQ6IG51bWJlciwgczogbnVtYmVyLCBwOiBudW1iZXIpID0+IE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApICsgMTtcblxuLyoqXG4gKiBFYXNpbmcgZnVuY3Rpb25zIGFkYXB0ZWQgZnJvbSBSb2JlcnQgUGVubmVyJ3MgZWFzaW5nIGVxdWF0aW9ucy5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5lYXNpbmcuZWZmZWN0c1xuICogQHNlZSBodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nL1xuICovXG5jb25zdCBlZmZlY3RzID0ge1xuICBsaW5lYXI6ICh0OiBudW1iZXIpID0+IHQsXG5cbiAgZWFzZUluUXVhZDogKHQ6IG51bWJlcikgPT4gdCAqIHQsXG5cbiAgZWFzZU91dFF1YWQ6ICh0OiBudW1iZXIpID0+IC10ICogKHQgLSAyKSxcblxuICBlYXNlSW5PdXRRdWFkOiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdFxuICAgIDogLTAuNSAqICgoLS10KSAqICh0IC0gMikgLSAxKSxcblxuICBlYXNlSW5DdWJpYzogKHQ6IG51bWJlcikgPT4gdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRDdWJpYzogKHQ6IG51bWJlcikgPT4gKHQgLT0gMSkgKiB0ICogdCArIDEsXG5cbiAgZWFzZUluT3V0Q3ViaWM6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKSxcblxuICBlYXNlSW5RdWFydDogKHQ6IG51bWJlcikgPT4gdCAqIHQgKiB0ICogdCxcblxuICBlYXNlT3V0UXVhcnQ6ICh0OiBudW1iZXIpID0+IC0oKHQgLT0gMSkgKiB0ICogdCAqIHQgLSAxKSxcblxuICBlYXNlSW5PdXRRdWFydDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdFxuICAgIDogLTAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpLFxuXG4gIGVhc2VJblF1aW50OiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQgKiB0ICogdCxcblxuICBlYXNlT3V0UXVpbnQ6ICh0OiBudW1iZXIpID0+ICh0IC09IDEpICogdCAqIHQgKiB0ICogdCArIDEsXG5cbiAgZWFzZUluT3V0UXVpbnQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMiksXG5cbiAgZWFzZUluU2luZTogKHQ6IG51bWJlcikgPT4gLU1hdGguY29zKHQgKiBIQUxGX1BJKSArIDEsXG5cbiAgZWFzZU91dFNpbmU6ICh0OiBudW1iZXIpID0+IE1hdGguc2luKHQgKiBIQUxGX1BJKSxcblxuICBlYXNlSW5PdXRTaW5lOiAodDogbnVtYmVyKSA9PiAtMC41ICogKE1hdGguY29zKFBJICogdCkgLSAxKSxcblxuICBlYXNlSW5FeHBvOiAodDogbnVtYmVyKSA9PiAodCA9PT0gMCkgPyAwIDogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSxcblxuICBlYXNlT3V0RXhwbzogKHQ6IG51bWJlcikgPT4gKHQgPT09IDEpID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDEsXG5cbiAgZWFzZUluT3V0RXhwbzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IHQgPCAwLjVcbiAgICA/IDAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgKiAyIC0gMSkpXG4gICAgOiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqICh0ICogMiAtIDEpKSArIDIpLFxuXG4gIGVhc2VJbkNpcmM6ICh0OiBudW1iZXIpID0+ICh0ID49IDEpID8gdCA6IC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSxcblxuICBlYXNlT3V0Q2lyYzogKHQ6IG51bWJlcikgPT4gTWF0aC5zcXJ0KDEgLSAodCAtPSAxKSAqIHQpLFxuXG4gIGVhc2VJbk91dENpcmM6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKVxuICAgIDogMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpLFxuXG4gIGVhc2VJbkVsYXN0aWM6ICh0OiBudW1iZXIpID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljSW4odCwgMC4wNzUsIDAuMyksXG5cbiAgZWFzZU91dEVsYXN0aWM6ICh0OiBudW1iZXIpID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljT3V0KHQsIDAuMDc1LCAwLjMpLFxuXG4gIGVhc2VJbk91dEVsYXN0aWModDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDAuMTEyNTtcbiAgICBjb25zdCBwID0gMC40NTtcbiAgICByZXR1cm4gYXRFZGdlKHQpID8gdCA6XG4gICAgICB0IDwgMC41XG4gICAgICAgID8gMC41ICogZWxhc3RpY0luKHQgKiAyLCBzLCBwKVxuICAgICAgICA6IDAuNSArIDAuNSAqIGVsYXN0aWNPdXQodCAqIDIgLSAxLCBzLCBwKTtcbiAgfSxcblxuICBlYXNlSW5CYWNrKHQ6IG51bWJlcikge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9LFxuXG4gIGVhc2VPdXRCYWNrKHQ6IG51bWJlcikge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAodCAtPSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gIH0sXG5cbiAgZWFzZUluT3V0QmFjayh0OiBudW1iZXIpIHtcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgaWYgKCh0IC89IDAuNSkgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcbiAgfSxcblxuICBlYXNlSW5Cb3VuY2U6ICh0OiBudW1iZXIpID0+IDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpLFxuXG4gIGVhc2VPdXRCb3VuY2UodDogbnVtYmVyKSB7XG4gICAgY29uc3QgbSA9IDcuNTYyNTtcbiAgICBjb25zdCBkID0gMi43NTtcbiAgICBpZiAodCA8ICgxIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogdCAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgKDIgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMS41IC8gZCkpICogdCArIDAuNzU7XG4gICAgfVxuICAgIGlmICh0IDwgKDIuNSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgyLjI1IC8gZCkpICogdCArIDAuOTM3NTtcbiAgICB9XG4gICAgcmV0dXJuIG0gKiAodCAtPSAoMi42MjUgLyBkKSkgKiB0ICsgMC45ODQzNzU7XG4gIH0sXG5cbiAgZWFzZUluT3V0Qm91bmNlOiAodDogbnVtYmVyKSA9PiAodCA8IDAuNSlcbiAgICA/IGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNVxuICAgIDogZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjUsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBFYXNpbmdGdW5jdGlvbiA9IGtleW9mIHR5cGVvZiBlZmZlY3RzXG5cbmV4cG9ydCBkZWZhdWx0IGVmZmVjdHM7XG4iLCJpbXBvcnQge0NvbG9yfSBmcm9tICdAa3Vya2xlL2NvbG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBDYW52YXNQYXR0ZXJuIHwgQ2FudmFzR3JhZGllbnQge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBDYW52YXNQYXR0ZXJuXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNQYXR0ZXJuKTogQ2FudmFzUGF0dGVybjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcihcbiAgdmFsdWU6XG4gIHwgc3RyaW5nXG4gIHwgeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyOyBhOiBudW1iZXIgfVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG4pOiBDb2xvcjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBDb2xvcih2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IG5ldyBDb2xvcih2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cbiIsImNvbnN0IG51bWJlcnMgPSBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnLCAndGVuc2lvbiddO1xuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uc0RlZmF1bHRzKGRlZmF1bHRzKSB7XG4gIGRlZmF1bHRzLnNldCgnYW5pbWF0aW9uJywge1xuICAgIGRlbGF5OiB1bmRlZmluZWQsXG4gICAgZHVyYXRpb246IDEwMDAsXG4gICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICBmbjogdW5kZWZpbmVkLFxuICAgIGZyb206IHVuZGVmaW5lZCxcbiAgICBsb29wOiB1bmRlZmluZWQsXG4gICAgdG86IHVuZGVmaW5lZCxcbiAgICB0eXBlOiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb24nLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdvblByb2dyZXNzJyAmJiBuYW1lICE9PSAnb25Db21wbGV0ZScgJiYgbmFtZSAhPT0gJ2ZuJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICAgIGNvbG9yczoge1xuICAgICAgdHlwZTogJ2NvbG9yJyxcbiAgICAgIHByb3BlcnRpZXM6IGNvbG9yc1xuICAgIH0sXG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBudW1iZXJzXG4gICAgfSxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XG4gICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuc2V0KCd0cmFuc2l0aW9ucycsIHtcbiAgICBhY3RpdmU6IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogNDAwXG4gICAgICB9XG4gICAgfSxcbiAgICByZXNpemU6IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdzoge1xuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICBmcm9tOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZHVyYXRpb246IDAgLy8gc2hvdyBpbW1lZGlhdGVseVxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH0sXG4gICAgaGlkZToge1xuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICB0bzogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgICAgZm46IHYgPT4gdiB8IDAgLy8gZm9yIGtlZXBpbmcgdGhlIGRhdGFzZXQgdmlzaWJsZSBhbGwgdGhlIHdheSB0aHJvdWdoIHRoZSBhbmltYXRpb25cbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TGF5b3V0c0RlZmF1bHRzKGRlZmF1bHRzKSB7XG4gIGRlZmF1bHRzLnNldCgnbGF5b3V0Jywge1xuICAgIGF1dG9QYWRkaW5nOiB0cnVlLFxuICAgIHBhZGRpbmc6IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH1cbiAgfSk7XG59XG4iLCJcbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBJbnRsLk51bWJlckZvcm1hdD4oKTtcblxuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bTogbnVtYmVyLCBsb2NhbGU6IHN0cmluZywgb3B0aW9ucz86IEludGwuTnVtYmVyRm9ybWF0T3B0aW9ucykge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG59XG4iLCJpbXBvcnQge2lzQXJyYXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge2xvZzEwfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgZm9ybWF0dGVycyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHRpY2tzXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnNcbiAqL1xuY29uc3QgZm9ybWF0dGVycyA9IHtcbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgdmFsdWUgbGFiZWxzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy52YWx1ZXNcbiAgICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XG4gICAqIEByZXR1cm4ge3N0cmluZ3xzdHJpbmdbXX0gdGhlIGxhYmVsIHRvIGRpc3BsYXlcbiAgICovXG4gIHZhbHVlcyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IC8qKiBAdHlwZSB7c3RyaW5nW119ICovICh2YWx1ZSkgOiAnJyArIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIG51bWVyaWMgdGlja3NcbiAgICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG4gICAqIEBwYXJhbSB0aWNrcyB7b2JqZWN0W119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuICAgKi9cbiAgbnVtZXJpYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7IC8vIG5ldmVyIHNob3cgZGVjaW1hbCBwbGFjZXMgZm9yIDBcbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIGxldCBub3RhdGlvbjtcbiAgICBsZXQgZGVsdGEgPSB0aWNrVmFsdWU7IC8vIFRoaXMgaXMgdXNlZCB3aGVuIHRoZXJlIGFyZSBsZXNzIHRoYW4gMiB0aWNrcyBhcyB0aGUgdGljayBpbnRlcnZhbC5cblxuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBhbGwgdGlja3MgYXJlIHNtYWxsIG9yIHRoZXJlIGh1Z2UgbnVtYmVyczsgdXNlIHNjaWVudGlmaWMgbm90YXRpb25cbiAgICAgIGNvbnN0IG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXS52YWx1ZSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlKSk7XG4gICAgICBpZiAobWF4VGljayA8IDFlLTQgfHwgbWF4VGljayA+IDFlKzE1KSB7XG4gICAgICAgIG5vdGF0aW9uID0gJ3NjaWVudGlmaWMnO1xuICAgICAgfVxuXG4gICAgICBkZWx0YSA9IGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ0RlbHRhID0gbG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcblxuICAgIC8vIFdoZW4gZGF0YXNldHMgaGF2ZSB2YWx1ZXMgYXBwcm9hY2hpbmcgTnVtYmVyLk1BWF9WQUxVRSwgdGhlIHRpY2sgY2FsY3VsYXRpb25zIG1pZ2h0IHJlc3VsdCBpblxuICAgIC8vIGluZmluaXR5IGFuZCBldmVudHVhbGx5IE5hTi4gUGFzc2luZyBOYU4gZm9yIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyBvciBtYXhpbXVtRnJhY3Rpb25EaWdpdHNcbiAgICAvLyB3aWxsIG1ha2UgdGhlIG51bWJlciBmb3JtYXR0ZXIgdGhyb3cuIFNvIGluc3RlYWQgd2UgY2hlY2sgZm9yIGlzTmFOIGFuZCB1c2UgYSBmYWxsYmFjayB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIHRvRml4ZWQgaGFzIGEgbWF4IG9mIDIwIGRlY2ltYWwgcGxhY2VzXG4gICAgY29uc3QgbnVtRGVjaW1hbCA9IGlzTmFOKGxvZ0RlbHRhKSA/IDEgOiBNYXRoLm1heChNYXRoLm1pbigtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpLCAyMCksIDApO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtub3RhdGlvbiwgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWx9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG5cbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIGxvZ2FyaXRobWljIHRpY2tzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pY1xuICAgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcbiAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcbiAgICogQHBhcmFtIHRpY2tzIHtvYmplY3RbXX0gdGhlIGxpc3Qgb2YgdGlja3MgYmVpbmcgY29udmVydGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXG4gICAqL1xuICBsb2dhcml0aG1pYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tzW2luZGV4XS5zaWduaWZpY2FuZCB8fCAodGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWx1ZSkpKSkpO1xuICAgIGlmIChbMSwgMiwgMywgNSwgMTAsIDE1XS5pbmNsdWRlcyhyZW1haW4pIHx8IGluZGV4ID4gMC44ICogdGlja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5udW1lcmljLmNhbGwodGhpcywgdGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxufTtcblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKSB7XG4gIC8vIEZpZ3VyZSBvdXQgaG93IG1hbnkgZGlnaXRzIHRvIHNob3dcbiAgLy8gVGhlIHNwYWNlIGJldHdlZW4gdGhlIGZpcnN0IHR3byB0aWNrcyBtaWdodCBiZSBzbWFsbGVyIHRoYW4gbm9ybWFsIHNwYWNpbmdcbiAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuXG4gIC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcbiAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAxICYmIHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XG4gICAgLy8gbm90IGFuIGludGVnZXJcbiAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQge2Zvcm1hdHRlcnN9O1xuIiwiaW1wb3J0IFRpY2tzIGZyb20gJy4vY29yZS50aWNrcy5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVNjYWxlRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdzY2FsZScsIHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIG9mZnNldDogZmFsc2UsXG4gICAgcmV2ZXJzZTogZmFsc2UsXG4gICAgYmVnaW5BdFplcm86IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuICAgICAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuICAgICAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICovXG4gICAgYm91bmRzOiAndGlja3MnLFxuXG4gICAgY2xpcDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uIGdyYWNlIGFkZGVkIHRvIG1heCBhbmQgcmVkdWNlZCBmcm9tIG1pbiBkYXRhIHZhbHVlLlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqL1xuICAgIGdyYWNlOiAwLFxuXG4gICAgLy8gZ3JpZCBsaW5lIHNldHRpbmdzXG4gICAgZ3JpZDoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcbiAgICAgIGRyYXdUaWNrczogdHJ1ZSxcbiAgICAgIHRpY2tMZW5ndGg6IDgsXG4gICAgICB0aWNrV2lkdGg6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICAgIHRpY2tDb2xvcjogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMuY29sb3IsXG4gICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgIH0sXG5cbiAgICBib3JkZXI6IHtcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBkYXNoOiBbXSxcbiAgICAgIGRhc2hPZmZzZXQ6IDAuMCxcbiAgICAgIHdpZHRoOiAxXG4gICAgfSxcblxuICAgIC8vIHNjYWxlIHRpdGxlXG4gICAgdGl0bGU6IHtcbiAgICAgIC8vIGRpc3BsYXkgcHJvcGVydHlcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuXG4gICAgICAvLyBhY3R1YWwgbGFiZWxcbiAgICAgIHRleHQ6ICcnLFxuXG4gICAgICAvLyB0b3AvYm90dG9tIHBhZGRpbmdcbiAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgdG9wOiA0LFxuICAgICAgICBib3R0b206IDRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gbGFiZWwgc2V0dGluZ3NcbiAgICB0aWNrczoge1xuICAgICAgbWluUm90YXRpb246IDAsXG4gICAgICBtYXhSb3RhdGlvbjogNTAsXG4gICAgICBtaXJyb3I6IGZhbHNlLFxuICAgICAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICAgICAgdGV4dFN0cm9rZUNvbG9yOiAnJyxcbiAgICAgIHBhZGRpbmc6IDMsXG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgYXV0b1NraXA6IHRydWUsXG4gICAgICBhdXRvU2tpcFBhZGRpbmc6IDMsXG4gICAgICBsYWJlbE9mZnNldDogMCxcbiAgICAgIC8vIFdlIHBhc3MgdGhyb3VnaCBhcnJheXMgdG8gYmUgcmVuZGVyZWQgYXMgbXVsdGlsaW5lIGxhYmVscywgd2UgY29udmVydCBPdGhlcnMgdG8gc3RyaW5ncyBoZXJlLlxuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuICAgICAgbWlub3I6IHt9LFxuICAgICAgbWFqb3I6IHt9LFxuICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgY3Jvc3NBbGlnbjogJ25lYXInLFxuXG4gICAgICBzaG93TGFiZWxCYWNrZHJvcDogZmFsc2UsXG4gICAgICBiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KScsXG4gICAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gICAgfVxuICB9KTtcblxuICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGlja3MnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2NvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUuYm9yZGVyJywgJ2NvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGl0bGUnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlJywge1xuICAgIF9mYWxsYmFjazogZmFsc2UsXG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdiZWZvcmUnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdhZnRlcicpICYmIG5hbWUgIT09ICdjYWxsYmFjaycgJiYgbmFtZSAhPT0gJ3BhcnNlcicsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAndGlja0JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdkYXNoJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlcycsIHtcbiAgICBfZmFsbGJhY2s6ICdzY2FsZScsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZS50aWNrcycsIHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnICYmIG5hbWUgIT09ICdjYWxsYmFjaycsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnLFxuICB9KTtcbn1cbiIsImltcG9ydCB7Z2V0SG92ZXJDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcbmltcG9ydCB7aXNPYmplY3QsIG1lcmdlLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthcHBseUFuaW1hdGlvbnNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseUxheW91dHNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseVNjYWxlRGVmYXVsdHN9IGZyb20gJy4vY29yZS5zY2FsZS5kZWZhdWx0cy5qcyc7XG5cbmV4cG9ydCBjb25zdCBvdmVycmlkZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0IGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTY29wZShub2RlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZShyb290LCBzY29wZSksIHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMsIF9hcHBsaWVycykge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuY29sb3IgPSAnIzY2Nic7XG4gICAgdGhpcy5kYXRhc2V0cyA9IHt9O1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICdtb3VzZW91dCcsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgJ3RvdWNobW92ZSdcbiAgICBdO1xuICAgIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaG92ZXIgPSB7fTtcbiAgICB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuY29sb3IpO1xuICAgIHRoaXMuaW5kZXhBeGlzID0gJ3gnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdHJ1ZTtcblxuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgICB0aGlzLmFwcGx5KF9hcHBsaWVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVcblx0ICovXG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSh0aGlzLCBzY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcblx0ICogUm91dGVzIHRoZSBuYW1lZCBkZWZhdWx0cyB0byBmYWxsYmFjayB0byBhbm90aGVyIHNjb3BlL25hbWUuXG5cdCAqIFRoaXMgcm91dGluZyBpcyB1c2VmdWwgd2hlbiB0aG9zZSB0YXJnZXQgdmFsdWVzLCBsaWtlIGRlZmF1bHRzLmNvbG9yLCBhcmUgY2hhbmdlZCBydW50aW1lLlxuXHQgKiBJZiB0aGUgdmFsdWVzIHdvdWxkIGJlIGNvcGllZCwgdGhlIHJ1bnRpbWUgY2hhbmdlIHdvdWxkIG5vdCB0YWtlIGVmZmVjdC4gQnkgcm91dGluZywgdGhlXG5cdCAqIGZhbGxiYWNrIGlzIGV2YWx1YXRlZCBhdCBlYWNoIGFjY2Vzcywgc28gaXRzIGFsd2F5cyB1cCB0byBkYXRlLlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBcdGRlZmF1bHRzLnJvdXRlKCdlbGVtZW50cy5hcmMnLCAnYmFja2dyb3VuZENvbG9yJywgJycsICdjb2xvcicpXG5cdCAqICAgLSByZWFkcyB0aGUgYmFja2dyb3VuZENvbG9yIGZyb20gZGVmYXVsdHMuY29sb3Igd2hlbiB1bmRlZmluZWQgbG9jYWxseVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGUgU2NvcGUgdGhpcyByb3V0ZSBhcHBsaWVzIHRvLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIHRoYXQgc2hvdWxkIGJlIHJvdXRlZCB0byBkaWZmZXJlbnQgbmFtZXNwYWNlIHdoZW4gbm90IGRlZmluZWQgaGVyZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFNjb3BlIFRoZSBuYW1lc3BhY2Ugd2hlcmUgdGhvc2UgcHJvcGVydGllcyBzaG91bGQgYmUgcm91dGVkIHRvLlxuXHQgKiBFbXB0eSBzdHJpbmcgKCcnKSBpcyB0aGUgcm9vdCBvZiBkZWZhdWx0cy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldE5hbWUgVGhlIHRhcmdldCBuYW1lIGluIHRoZSB0YXJnZXQgc2NvcGUgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqL1xuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgLy8gQSBwcml2YXRlIHByb3BlcnR5IGlzIGRlZmluZWQgdG8gaG9sZCB0aGUgYWN0dWFsIHZhbHVlLCB3aGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IGluIGl0cyBzY29wZSAoc2V0IGluIHRoZSBzZXR0ZXIpXG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBUaGUgYWN0dWFsIHByb3BlcnR5IGlzIGRlZmluZWQgYXMgZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZG8gdGhlIHJvdXRpbmcgd2hlbiB2YWx1ZSBpcyBub3QgbG9jYWxseSBzZXQuXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5KGFwcGxpZXJzKSB7XG4gICAgYXBwbGllcnMuZm9yRWFjaCgoYXBwbHkpID0+IGFwcGx5KHRoaXMpKTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0sIFthcHBseUFuaW1hdGlvbnNEZWZhdWx0cywgYXBwbHlMYXlvdXRzRGVmYXVsdHMsIGFwcGx5U2NhbGVEZWZhdWx0c10pO1xuIiwiaW1wb3J0IHR5cGUge1xuICBDaGFydCxcbiAgUG9pbnQsXG4gIEZvbnRTcGVjLFxuICBDYW52YXNGb250U3BlYyxcbiAgUG9pbnRTdHlsZSxcbiAgUmVuZGVyVGV4dE9wdHMsXG4gIEJhY2tkcm9wT3B0aW9uc1xufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFRSQkwsXG4gIFNwbGluZVBvaW50LFxuICBSb3VuZGVkUmVjdCxcbiAgVFJCTENvcm5lcnNcbn0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNOdWxsT3JVbmRlZn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJLCBRVUFSVEVSX1BJLCBUV09fVEhJUkRTX1BJLCBSQURfUEVSX0RFR30gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBmb250IG9iamVjdCBpbnRvIGEgQ1NTIGZvbnQgc3RyaW5nLlxuICogQHBhcmFtIGZvbnQgLSBBIGZvbnQgb2JqZWN0LlxuICogQHJldHVybiBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udDogRm9udFNwZWMpIHtcbiAgaWYgKCFmb250IHx8IGlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBpc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lYXN1cmVUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgZ2M6IHN0cmluZ1tdLFxuICBsb25nZXN0OiBudW1iZXIsXG4gIHN0cmluZzogc3RyaW5nXG4pIHtcbiAgbGV0IHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcbiAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICBnYy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICBsb25nZXN0ID0gdGV4dFdpZHRoO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuXG50eXBlIFRoaW5nID0gc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbFxudHlwZSBUaGluZ3MgPSAoVGhpbmcgfCBUaGluZ1tdKVtdXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBfbG9uZ2VzdFRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBmb250OiBzdHJpbmcsXG4gIGFycmF5T2ZUaGluZ3M6IFRoaW5ncyxcbiAgY2FjaGU/OiB7ZGF0YT86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sIGdhcmJhZ2VDb2xsZWN0Pzogc3RyaW5nW10sIGZvbnQ/OiBzdHJpbmd9XG4pIHtcbiAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgbGV0IGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcbiAgbGV0IGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcblxuICBpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuICAgIGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG4gICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgIGNhY2hlLmZvbnQgPSBmb250O1xuICB9XG5cbiAgY3R4LnNhdmUoKTtcblxuICBjdHguZm9udCA9IGZvbnQ7XG4gIGxldCBsb25nZXN0ID0gMDtcbiAgY29uc3QgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xuICBsZXQgaTogbnVtYmVyLCBqOiBudW1iZXIsIGpsZW46IG51bWJlciwgdGhpbmc6IFRoaW5nIHwgVGhpbmdbXSwgbmVzdGVkVGhpbmc6IFRoaW5nIHwgVGhpbmdbXTtcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xuICAgIHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcblxuICAgIC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KHRoaW5nKSkge1xuICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHRoaW5nKSkge1xuICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuICAgICAgLy8gdG8gZG8gbWF5YmUgc2ltcGxpZnkgdGhpcyBmdW5jdGlvbiBhIGJpdCBzbyB3ZSBjYW4gZG8gdGhpcyBtb3JlIHJlY3Vyc2l2ZWx5P1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IHRoaW5nLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xuICAgICAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgaWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdHgucmVzdG9yZSgpO1xuXG4gIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgaWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgIH1cbiAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUgdG8gYXZvaWQgYW50aS1hbGlhc2luZyBibHVyXG4gKiBAcGFyYW0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0gcGl4ZWwgLSBBIHBpeGVsIHZhbHVlLlxuICogQHBhcmFtIHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50LlxuICogQHJldHVybnMgVGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FsaWduUGl4ZWwoY2hhcnQ6IENoYXJ0LCBwaXhlbDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSB7XG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAvIDIsIDAuNSkgOiAwO1xuICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuXG4vKipcbiAqIENsZWFycyB0aGUgZW50aXJlIGNhbnZhcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ2FudmFzKGNhbnZhcz86IEhUTUxDYW52YXNFbGVtZW50LCBjdHg/OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgaWYgKCFjdHggJiYgIWNhbnZhcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eCA9IGN0eCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBjdHguc2F2ZSgpO1xuICAvLyBjYW52YXMud2lkdGggYW5kIGNhbnZhcy5oZWlnaHQgZG8gbm90IGNvbnNpZGVyIHRoZSBjYW52YXMgdHJhbnNmb3JtLFxuICAvLyB3aGlsZSBjbGVhclJlY3QgZG9lc1xuICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERyYXdQb2ludE9wdGlvbnMge1xuICBwb2ludFN0eWxlOiBQb2ludFN0eWxlO1xuICByb3RhdGlvbj86IG51bWJlcjtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGJvcmRlcldpZHRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3UG9pbnQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBvcHRpb25zOiBEcmF3UG9pbnRPcHRpb25zLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlclxuKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgbnVsbCk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gZHJhd1BvaW50TGVnZW5kKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgb3B0aW9uczogRHJhd1BvaW50T3B0aW9ucyxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIHc6IG51bWJlclxuKSB7XG4gIGxldCB0eXBlOiBzdHJpbmcsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIsIGNvcm5lclJhZGl1czogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCB4T2Zmc2V0VzogbnVtYmVyLCB5T2Zmc2V0VzogbnVtYmVyO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuXG4gIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5yb3RhdGUocmFkKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgc3dpdGNoIChzdHlsZSkge1xuICAvLyBEZWZhdWx0IGluY2x1ZGVzIGNpcmNsZVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodykge1xuICAgICAgICBjdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgcmFkaXVzLCAwLCAwLCBUQVUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XG4gICAgICB9XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHJhZGl1cztcbiAgICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0Um91bmRlZCc6XG4gICAgLy8gTk9URTogdGhlIHJvdW5kZWQgcmVjdCBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIHRvIHVzZSBgYXJjYCBpbnN0ZWFkIG9mXG4gICAgLy8gYHF1YWRyYXRpY0N1cnZlVG9gIHNpbmNlIGl0IGdlbmVyYXRlcyBiZXR0ZXIgcmVzdWx0cyB3aGVuIHJlY3QgaXNcbiAgICAvLyBhbG1vc3QgYSBjaXJjbGUuIDAuNTE2IChpbnN0ZWFkIG9mIDAuNSkgcHJvZHVjZXMgcmVzdWx0cyB3aXRoIHZpc3VhbGx5XG4gICAgLy8gY2xvc2VyIHByb3BvcnRpb24gdG8gdGhlIHByZXZpb3VzIGltcGwgYW5kIGl0IGlzIGluc2NyaWJlZCBpbiB0aGVcbiAgICAvLyBjaXJjbGUgd2l0aCBgcmFkaXVzYC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBmb2xsb3dpbmcgUFJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81NTk3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU4NThcbiAgICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogKHcgPyB3IC8gMiAtIGNvcm5lclJhZGl1cyA6IHNpemUpO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICBjdHguYXJjKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgICBjdHguYXJjKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMoeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0JzpcbiAgICAgIGlmICghcm90YXRpb24pIHtcbiAgICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiBzaXplO1xuICAgICAgICBjdHgucmVjdCh4IC0gd2lkdGgsIHkgLSBzaXplLCAyICogd2lkdGgsIDIgKiBzaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSAncmVjdFJvdCc6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjcm9zc1JvdCc6XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSAnY3Jvc3MnOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3Rhcic6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgeE9mZnNldCA9IHcgPyB3IC8gMiA6IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rhc2gnOlxuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKSwgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmYWxzZTpcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgY3R4LmZpbGwoKTtcbiAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSBhcmVhIC0gVGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIG1hcmdpbiAtIGFsbG93ZWQgbWFyZ2luXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEoXG4gIHBvaW50OiBQb2ludCxcbiAgYXJlYTogVFJCTCxcbiAgbWFyZ2luPzogbnVtYmVyXG4pIHtcbiAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTsgLy8gbWFyZ2luIC0gZGVmYXVsdCBpcyB0byBtYXRjaCByb3VuZGVkIGRlY2ltYWxzXG5cbiAgcmV0dXJuICFhcmVhIHx8IChwb2ludCAmJiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gbWFyZ2luICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgbWFyZ2luICYmXG5cdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gbWFyZ2luICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIG1hcmdpbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGlwQXJlYShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgYXJlYTogVFJCTCkge1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICBjdHguY2xpcCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5jbGlwQXJlYShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3RlcHBlZExpbmVUbyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHByZXZpb3VzOiBQb2ludCxcbiAgdGFyZ2V0OiBQb2ludCxcbiAgZmxpcD86IGJvb2xlYW4sXG4gIG1vZGU/OiBzdHJpbmdcbikge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICBjb25zdCBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcHJldmlvdXM6IFNwbGluZVBvaW50LFxuICB0YXJnZXQ6IFNwbGluZVBvaW50LFxuICBmbGlwPzogYm9vbGVhblxuKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCxcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeSA6IHByZXZpb3VzLmNwMnksXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ4IDogdGFyZ2V0LmNwMXgsXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksXG4gICAgdGFyZ2V0LngsXG4gICAgdGFyZ2V0LnkpO1xufVxuXG5mdW5jdGlvbiBzZXRSZW5kZXJPcHRzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcHRzOiBSZW5kZXJUZXh0T3B0cykge1xuICBpZiAob3B0cy50cmFuc2xhdGlvbikge1xuICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XG4gIH1cblxuICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5yb3RhdGlvbikpIHtcbiAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICB9XG5cbiAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgfVxuXG4gIGlmIChvcHRzLnRleHRBbGlnbikge1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcbiAgfVxuXG4gIGlmIChvcHRzLnRleHRCYXNlbGluZSkge1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgbGluZTogc3RyaW5nLFxuICBvcHRzOiBSZW5kZXJUZXh0T3B0c1xuKSB7XG4gIGlmIChvcHRzLnN0cmlrZXRocm91Z2ggfHwgb3B0cy51bmRlcmxpbmUpIHtcbiAgICAvKipcbiAgICAgKiBOb3cgdGhhdCBJRTExIHN1cHBvcnQgaGFzIGJlZW4gZHJvcHBlZCwgd2UgY2FuIHVzZSBtb3JlXG4gICAgICogb2YgdGhlIFRleHRNZXRyaWNzIG9iamVjdC4gVGhlIGFjdHVhbCBib3VuZGluZyBib3hlc1xuICAgICAqIGFyZSB1bmZsYWdnZWQgaW4gQ2hyb21lLCBGaXJlZm94LCBFZGdlLCBhbmQgU2FmYXJpIHNvIHRoZXlcbiAgICAgKiBjYW4gYmUgc2FmZWx5IHVzZWQuXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0TWV0cmljcyNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgKi9cbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIGNvbnN0IGxlZnQgPSB4IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLmRlY29yYXRpb25XaWR0aCB8fCAyO1xuICAgIGN0eC5tb3ZlVG8obGVmdCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0JhY2tkcm9wKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcHRzOiBCYWNrZHJvcE9wdGlvbnMpIHtcbiAgY29uc3Qgb2xkQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuXG4gIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yIGFzIHN0cmluZztcbiAgY3R4LmZpbGxSZWN0KG9wdHMubGVmdCwgb3B0cy50b3AsIG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgY3R4LmZpbGxTdHlsZSA9IG9sZENvbG9yO1xufVxuXG4vKipcbiAqIFJlbmRlciB0ZXh0IG9udG8gdGhlIGNhbnZhc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHRleHQ6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgZm9udDogQ2FudmFzRm9udFNwZWMsXG4gIG9wdHM6IFJlbmRlclRleHRPcHRzID0ge31cbikge1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcbiAgbGV0IGk6IG51bWJlciwgbGluZTogc3RyaW5nO1xuXG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG5cbiAgICBpZiAob3B0cy5iYWNrZHJvcCkge1xuICAgICAgZHJhd0JhY2tkcm9wKGN0eCwgb3B0cy5iYWNrZHJvcCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0cy5zdHJva2VDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICB9XG5cbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG5cbiAgICB5ICs9IE51bWJlcihmb250LmxpbmVIZWlnaHQpO1xuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBwYXRoIG9mIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIHRvIHRoZSBjdXJyZW50IHN1Yi1wYXRoXG4gKiBAcGFyYW0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHJlY3QgLSBCb3VuZGluZyByZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICByZWN0OiBSb3VuZGVkUmVjdCAmIHsgcmFkaXVzOiBUUkJMQ29ybmVycyB9XG4pIHtcbiAgY29uc3Qge3gsIHksIHcsIGgsIHJhZGl1c30gPSByZWN0O1xuXG4gIC8vIHRvcCBsZWZ0IGFyY1xuICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgMS41ICogUEksIFBJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gdG9wIGxlZnQgdG8gYm90dG9tIGxlZnRcbiAgY3R4LmxpbmVUbyh4LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0KTtcblxuICAvLyBib3R0b20gbGVmdCBhcmNcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLmJvdHRvbUxlZnQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQsIHJhZGl1cy5ib3R0b21MZWZ0LCBQSSwgSEFMRl9QSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIGJvdHRvbSBsZWZ0IHRvIGJvdHRvbSByaWdodFxuICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG5cbiAgLy8gYm90dG9tIHJpZ2h0IGFyY1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gYm90dG9tIHJpZ2h0IHRvIHRvcCByaWdodFxuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcblxuICAvLyB0b3AgcmlnaHQgYXJjXG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSB0b3AgcmlnaHQgdG8gdG9wIGxlZnRcbiAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLnRvcExlZnQsIHkpO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzT2JqZWN0LCB0b0RpbWVuc2lvbiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9Gb250U3RyaW5nfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWEsIEZvbnRTcGVjLCBQb2ludH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1RSQkwsIFRSQkxDb3JuZXJzfSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG5jb25zdCBMSU5FX0hFSUdIVCA9IC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvO1xuY29uc3QgRk9OVF9TVFlMRSA9IC9eKG5vcm1hbHxpdGFsaWN8aW5pdGlhbHxpbmhlcml0fHVuc2V0fChvYmxpcXVlKCAtP1swLTldP1swLTldZGVnKT8pKSQvO1xuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm9wdGlvbnNcbiAqIEBuYW1lc3BhY2VcbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBmb250IHNpemUgKGluIHBpeGVscykgdXNlZCB0byByZXNvbHZlIHJlbGF0aXZlIGB2YWx1ZWAuXG4gKiBAcmV0dXJucyBUaGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGluIHBpeGVscyAoc2l6ZSAqIDEuMiBpZiB2YWx1ZSBpcyBpbnZhbGlkKS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTGluZUhlaWdodCh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKExJTkVfSEVJR0hUKTtcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XG4gICAgcmV0dXJuIHNpemUgKiAxLjI7XG4gIH1cblxuICB2YWx1ZSA9ICttYXRjaGVzWzJdO1xuXG4gIHN3aXRjaCAobWF0Y2hlc1szXSkge1xuICAgIGNhc2UgJ3B4JzpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjYXNlICclJzpcbiAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBzaXplICogdmFsdWU7XG59XG5cbmNvbnN0IG51bWJlck9yWmVybyA9ICh2OiB1bmtub3duKSA9PiArdiB8fCAwO1xuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHByb3BzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wczxLIGV4dGVuZHMgc3RyaW5nPih2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPEssIG51bWJlcj4sIHByb3BzOiBLW10pOiBSZWNvcmQ8SywgbnVtYmVyPjtcbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wczxLIGV4dGVuZHMgc3RyaW5nLCBUIGV4dGVuZHMgc3RyaW5nPih2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPEsgJiBULCBudW1iZXI+LCBwcm9wczogUmVjb3JkPFQsIEs+KTogUmVjb3JkPFQsIG51bWJlcj47XG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWU6IG51bWJlciB8IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sIHByb3BzOiBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNvbnN0IG9ialByb3BzID0gaXNPYmplY3QocHJvcHMpO1xuICBjb25zdCBrZXlzID0gb2JqUHJvcHMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcztcbiAgY29uc3QgcmVhZCA9IGlzT2JqZWN0KHZhbHVlKVxuICAgID8gb2JqUHJvcHNcbiAgICAgID8gcHJvcCA9PiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZVtwcm9wXSwgdmFsdWVbcHJvcHNbcHJvcF1dKVxuICAgICAgOiBwcm9wID0+IHZhbHVlW3Byb3BdXG4gICAgOiAoKSA9PiB2YWx1ZTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgVFJCTCBvYmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiAgeCAvIHkgYXJlIHNob3J0aGFuZHMgZm9yIHNhbWUgdmFsdWUgZm9yIGxlZnQvcmlnaHQgYW5kIHRvcC9ib3R0b20uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyB2YWx1ZXMgKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdClcbiAqIEBzaW5jZSAzLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UUkJMKHZhbHVlOiBudW1iZXIgfCBUUkJMIHwgUG9pbnQpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCB7dG9wOiAneScsIHJpZ2h0OiAneCcsIGJvdHRvbTogJ3knLCBsZWZ0OiAneCd9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIFRSQkwgY29ybmVycyBvYmplY3QgKHNpbWlsYXIgd2l0aCBjc3MgYm9yZGVyLXJhZGl1cykuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb3JuZXIgY29tcG9uZW50cyxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqIEByZXR1cm5zIFRoZSBUUkJMIGNvcm5lciB2YWx1ZXMgKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodClcbiAqIEBzaW5jZSAzLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UUkJMQ29ybmVycyh2YWx1ZTogbnVtYmVyIHwgVFJCTENvcm5lcnMpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tTGVmdCcsICdib3R0b21SaWdodCddKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIHBhZGRpbmcgb2JqZWN0IHdpdGggcHJlLWNvbXB1dGVkIHdpZHRoL2hlaWdodC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1BhZGRpbmcodmFsdWU/OiBudW1iZXIgfCBUUkJMKTogQ2hhcnRBcmVhIHtcbiAgY29uc3Qgb2JqID0gdG9UUkJMKHZhbHVlKSBhcyBDaGFydEFyZWE7XG5cbiAgb2JqLndpZHRoID0gb2JqLmxlZnQgKyBvYmoucmlnaHQ7XG4gIG9iai5oZWlnaHQgPSBvYmoudG9wICsgb2JqLmJvdHRvbTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFBhcnNlcyBmb250IG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZvbnQgb3B0aW9ucyB0byBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZhbGxiYWNrIGZvbnQgb3B0aW9ucy5cbiAqIEByZXR1cm4gVGhlIGZvbnQgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Gb250KG9wdGlvbnM6IFBhcnRpYWw8Rm9udFNwZWM+LCBmYWxsYmFjaz86IFBhcnRpYWw8Rm9udFNwZWM+KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8IGRlZmF1bHRzLmZvbnQgYXMgRm9udFNwZWM7XG5cbiAgbGV0IHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnNpemUsIGZhbGxiYWNrLnNpemUpO1xuXG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICB9XG4gIGxldCBzdHlsZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc3R5bGUsIGZhbGxiYWNrLnN0eWxlKTtcbiAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHN0eWxlICsgJ1wiJyk7XG4gICAgc3R5bGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBmb250ID0ge1xuICAgIGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mYW1pbHksIGZhbGxiYWNrLmZhbWlseSksXG4gICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxuICAgIHNpemUsXG4gICAgc3R5bGUsXG4gICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcbiAgICBzdHJpbmc6ICcnXG4gIH07XG5cbiAgZm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG4gIHJldHVybiBmb250O1xufVxuXG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gYGlucHV0c2Agc2VxdWVudGlhbGx5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlLlxuICogQHBhcmFtIGlucHV0cyAtIEFuIGFycmF5IG9mIHZhbHVlcywgZmFsbGluZyBiYWNrIHRvIHRoZSBsYXN0IHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQgLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcbiAqIGlzIGNhbGxlZCB3aXRoIGBjb250ZXh0YCBhcyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIHJlc3VsdCBiZWNvbWVzIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5kZXggLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXG4gKiBhdCBgaW5kZXhgIGJlY29tZSB0aGUgbmV3IGlucHV0LlxuICogQHBhcmFtIGluZm8gLSBvYmplY3QgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0IHJlc29sdXRpb24gaW5cbiAqIEBwYXJhbSBpbmZvLmNhY2hlYWJsZSAtIFdpbGwgYmUgc2V0IHRvIGBmYWxzZWAgaWYgb3B0aW9uIGlzIG5vdCBjYWNoZWFibGUuXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzOiBBcnJheTx1bmtub3duPiwgY29udGV4dD86IG9iamVjdCwgaW5kZXg/OiBudW1iZXIsIGluZm8/OiB7IGNhY2hlYWJsZTogYm9vbGVhbiB9KSB7XG4gIGxldCBjYWNoZWFibGUgPSB0cnVlO1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHZhbHVlOiB1bmtub3duO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSBpbnB1dHNbaV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbmZvICYmICFjYWNoZWFibGUpIHtcbiAgICAgICAgaW5mby5jYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gbWlubWF4XG4gKiBAcGFyYW0gZ3JhY2VcbiAqIEBwYXJhbSBiZWdpbkF0WmVyb1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hZGRHcmFjZShtaW5tYXg6IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyOyB9LCBncmFjZTogbnVtYmVyIHwgc3RyaW5nLCBiZWdpbkF0WmVybzogYm9vbGVhbikge1xuICBjb25zdCB7bWluLCBtYXh9ID0gbWlubWF4O1xuICBjb25zdCBjaGFuZ2UgPSB0b0RpbWVuc2lvbihncmFjZSwgKG1heCAtIG1pbikgLyAyKTtcbiAgY29uc3Qga2VlcFplcm8gPSAodmFsdWU6IG51bWJlciwgYWRkOiBudW1iZXIpID0+IGJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xuICByZXR1cm4ge1xuICAgIG1pbjoga2VlcFplcm8obWluLCAtTWF0aC5hYnMoY2hhbmdlKSksXG4gICAgbWF4OiBrZWVwWmVybyhtYXgsIGNoYW5nZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjb250ZXh0IGluaGVyaXRpbmcgcGFyZW50Q29udGV4dFxuICogQHBhcmFtIHBhcmVudENvbnRleHRcbiAqIEBwYXJhbSBjb250ZXh0XG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dDxUIGV4dGVuZHMgb2JqZWN0PihwYXJlbnRDb250ZXh0OiBudWxsLCBjb250ZXh0OiBUKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0PFQgZXh0ZW5kcyBvYmplY3QsIFAgZXh0ZW5kcyBUPihwYXJlbnRDb250ZXh0OiBQLCBjb250ZXh0OiBUKTogUCAmIFQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChwYXJlbnRDb250ZXh0OiBvYmplY3QsIGNvbnRleHQ6IG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudENvbnRleHQpLCBjb250ZXh0KTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL1xuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0TWV0YX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1xuICBSZXNvbHZlck9iamVjdEtleSxcbiAgUmVzb2x2ZXJDYWNoZSxcbiAgUmVzb2x2ZXJQcm94eSxcbiAgRGVzY3JpcHRvckRlZmF1bHRzLFxuICBEZXNjcmlwdG9yLFxuICBDb250ZXh0Q2FjaGUsXG4gIENvbnRleHRQcm94eVxufSBmcm9tICcuL2hlbHBlcnMuY29uZmlnLnR5cGVzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIHJlc29sdmVPYmplY3RLZXksIF9jYXBpdGFsaXplfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vaGVscGVycy5jb25maWcudHlwZXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm94eSBmb3IgcmVzb2x2aW5nIHJhdyB2YWx1ZXMgZm9yIG9wdGlvbnMuXG4gKiBAcGFyYW0gc2NvcGVzIC0gVGhlIG9wdGlvbiBzY29wZXMgdG8gbG9vayBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyXG4gKiBAcGFyYW0gcHJlZml4ZXMgLSBUaGUgcHJlZml4ZXMgZm9yIHZhbHVlcywgaW4gcmVzb2x1dGlvbiBvcmRlci5cbiAqIEBwYXJhbSByb290U2NvcGVzIC0gVGhlIHJvb3Qgb3B0aW9uIHNjb3Blc1xuICogQHBhcmFtIGZhbGxiYWNrIC0gUGFyZW50IHNjb3BlcyBmYWxsYmFja1xuICogQHBhcmFtIGdldFRhcmdldCAtIGNhbGxiYWNrIGZvciBnZXR0aW5nIHRoZSB0YXJnZXQgZm9yIGNoYW5nZWQgdmFsdWVzXG4gKiBAcmV0dXJucyBQcm94eVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVSZXNvbHZlcjxcbiAgVCBleHRlbmRzIEFueU9iamVjdFtdID0gQW55T2JqZWN0W10sXG4gIFIgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IFRcbj4oXG4gIHNjb3BlczogVCxcbiAgcHJlZml4ZXMgPSBbJyddLFxuICByb290U2NvcGVzPzogUixcbiAgZmFsbGJhY2s/OiBSZXNvbHZlck9iamVjdEtleSxcbiAgZ2V0VGFyZ2V0ID0gKCkgPT4gc2NvcGVzWzBdXG4pIHtcbiAgY29uc3QgZmluYWxSb290U2NvcGVzID0gcm9vdFNjb3BlcyB8fCBzY29wZXM7XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmFsbGJhY2sgPSBfcmVzb2x2ZSgnX2ZhbGxiYWNrJywgc2NvcGVzKTtcbiAgfVxuICBjb25zdCBjYWNoZTogUmVzb2x2ZXJDYWNoZTxULCBSPiA9IHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ09iamVjdCcsXG4gICAgX2NhY2hlYWJsZTogdHJ1ZSxcbiAgICBfc2NvcGVzOiBzY29wZXMsXG4gICAgX3Jvb3RTY29wZXM6IGZpbmFsUm9vdFNjb3BlcyxcbiAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICBvdmVycmlkZTogKHNjb3BlOiBBbnlPYmplY3QpID0+IF9jcmVhdGVSZXNvbHZlcihbc2NvcGUsIC4uLnNjb3Blc10sIHByZWZpeGVzLCBmaW5hbFJvb3RTY29wZXMsIGZhbGxiYWNrKSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGRlbGV0ZSBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7IC8vIHJlbW92ZSBjYWNoZWQga2V5c1xuICAgICAgZGVsZXRlIHNjb3Blc1swXVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gdG9wIGxldmVsIHNjb3BlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuX3Njb3Blc1swXSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mLlxuICAgICAqL1xuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yoc2NvcGVzWzBdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgaW4gb3BlcmF0b3IuXG4gICAgICovXG4gICAgaGFzKHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KS5pbmNsdWRlcyhwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scy5cbiAgICAgKi9cbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3Igc2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgc2V0KHRhcmdldCwgcHJvcDogc3RyaW5nLCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc3RvcmFnZVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gdG9wIGxldmVsIHNjb3BlICsgY2FjaGVcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7IC8vIHJlbW92ZSBjYWNoZWQga2V5c1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSBhcyBSZXNvbHZlclByb3h5PFQsIFI+O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gUHJveHkgZm9yIHJlc29sdmluZyBvcHRpb24gdmFsdWVzIHdpdGggY29udGV4dC5cbiAqIEBwYXJhbSBwcm94eSAtIFRoZSBQcm94eSByZXR1cm5lZCBieSBgX2NyZWF0ZVJlc29sdmVyYFxuICogQHBhcmFtIGNvbnRleHQgLSBDb250ZXh0IG9iamVjdCBmb3Igc2NyaXB0YWJsZS9pbmRleGFibGUgb3B0aW9uc1xuICogQHBhcmFtIHN1YlByb3h5IC0gVGhlIHByb3h5IHByb3ZpZGVkIGZvciBzY3JpcHRhYmxlIG9wdGlvbnNcbiAqIEBwYXJhbSBkZXNjcmlwdG9yRGVmYXVsdHMgLSBEZWZhdWx0cyBmb3IgZGVzY3JpcHRvcnNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXR0YWNoQ29udGV4dDxcbiAgVCBleHRlbmRzIEFueU9iamVjdFtdID0gQW55T2JqZWN0W10sXG4gIFIgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IFRcbj4oXG4gIHByb3h5OiBSZXNvbHZlclByb3h5PFQsIFI+LFxuICBjb250ZXh0OiBBbnlPYmplY3QsXG4gIHN1YlByb3h5PzogUmVzb2x2ZXJQcm94eTxULCBSPixcbiAgZGVzY3JpcHRvckRlZmF1bHRzPzogRGVzY3JpcHRvckRlZmF1bHRzXG4pIHtcbiAgY29uc3QgY2FjaGU6IENvbnRleHRDYWNoZTxULCBSPiA9IHtcbiAgICBfY2FjaGVhYmxlOiBmYWxzZSxcbiAgICBfcHJveHk6IHByb3h5LFxuICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgIF9zdWJQcm94eTogc3ViUHJveHksXG4gICAgX3N0YWNrOiBuZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMocHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgc2V0Q29udGV4dDogKGN0eDogQW55T2JqZWN0KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eSwgY3R4LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBvdmVycmlkZTogKHNjb3BlOiBBbnlPYmplY3QpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5Lm92ZXJyaWRlKHNjb3BlKSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGRlbGV0ZSBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICBkZWxldGUgcHJveHlbcHJvcF07IC8vIHJlbW92ZSBmcm9tIHByb3h5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuXG4gICAgICogQWxzbyB1c2VkIGJ5IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Ll9kZXNjcmlwdG9ycy5hbGxLZXlzXG4gICAgICAgID8gUmVmbGVjdC5oYXMocHJveHksIHByb3ApID8ge2VudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOiB1bmRlZmluZWRcbiAgICAgICAgOiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm94eSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mLlxuICAgICAqL1xuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJveHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqL1xuICAgIG93bktleXMoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHByb3h5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJveHlbcHJvcF0gPSB2YWx1ZTsgLy8gc2V0IHRvIHByb3h5XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSBhcyBDb250ZXh0UHJveHk8VCwgUj47XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXNjcmlwdG9ycyhcbiAgcHJveHk6IFJlc29sdmVyQ2FjaGUsXG4gIGRlZmF1bHRzOiBEZXNjcmlwdG9yRGVmYXVsdHMgPSB7c2NyaXB0YWJsZTogdHJ1ZSwgaW5kZXhhYmxlOiB0cnVlfVxuKTogRGVzY3JpcHRvciB7XG4gIGNvbnN0IHtfc2NyaXB0YWJsZSA9IGRlZmF1bHRzLnNjcmlwdGFibGUsIF9pbmRleGFibGUgPSBkZWZhdWx0cy5pbmRleGFibGUsIF9hbGxLZXlzID0gZGVmYXVsdHMuYWxsS2V5c30gPSBwcm94eTtcbiAgcmV0dXJuIHtcbiAgICBhbGxLZXlzOiBfYWxsS2V5cyxcbiAgICBzY3JpcHRhYmxlOiBfc2NyaXB0YWJsZSxcbiAgICBpbmRleGFibGU6IF9pbmRleGFibGUsXG4gICAgaXNTY3JpcHRhYmxlOiBpc0Z1bmN0aW9uKF9zY3JpcHRhYmxlKSA/IF9zY3JpcHRhYmxlIDogKCkgPT4gX3NjcmlwdGFibGUsXG4gICAgaXNJbmRleGFibGU6IGlzRnVuY3Rpb24oX2luZGV4YWJsZSkgPyBfaW5kZXhhYmxlIDogKCkgPT4gX2luZGV4YWJsZVxuICB9O1xufVxuXG5jb25zdCByZWFkS2V5ID0gKHByZWZpeDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpID0+IHByZWZpeCA/IHByZWZpeCArIF9jYXBpdGFsaXplKG5hbWUpIDogbmFtZTtcbmNvbnN0IG5lZWRzU3ViUmVzb2x2ZXIgPSAocHJvcDogc3RyaW5nLCB2YWx1ZTogdW5rbm93bikgPT4gaXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiZcbiAgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG5cbmZ1bmN0aW9uIF9jYWNoZWQoXG4gIHRhcmdldDogQW55T2JqZWN0LFxuICBwcm9wOiBzdHJpbmcsXG4gIHJlc29sdmU6ICgpID0+IHVua25vd25cbikge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkgfHwgcHJvcCA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IHJlc29sdmUoKTtcbiAgLy8gY2FjaGUgdGhlIHJlc29sdmVkIHZhbHVlXG4gIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aENvbnRleHQoXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICBwcm9wOiBzdHJpbmcsXG4gIHJlY2VpdmVyOiBBbnlPYmplY3Rcbikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgbGV0IHZhbHVlID0gX3Byb3h5W3Byb3BdOyAvLyByZXNvbHZlIGZyb20gcHJveHlcblxuICAvLyByZXNvbHZlIHdpdGggY29udGV4dFxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgJiYgZGVzY3JpcHRvcnMuaXNTY3JpcHRhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgZGVzY3JpcHRvcnMuaXNJbmRleGFibGUpO1xuICB9XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIC8vIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhbiBvYmplY3QsIGNyZWF0ZSBhIHN1YiByZXNvbHZlciBmb3IgaXRcbiAgICB2YWx1ZSA9IF9hdHRhY2hDb250ZXh0KHZhbHVlLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKFxuICBwcm9wOiBzdHJpbmcsXG4gIGdldFZhbHVlOiAoY3R4OiBBbnlPYmplY3QsIHN1YjogQW55T2JqZWN0KSA9PiB1bmtub3duLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9zdGFja30gPSB0YXJnZXQ7XG4gIGlmIChfc3RhY2suaGFzKHByb3ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpb24gZGV0ZWN0ZWQ6ICcgKyBBcnJheS5mcm9tKF9zdGFjaykuam9pbignLT4nKSArICctPicgKyBwcm9wKTtcbiAgfVxuICBfc3RhY2suYWRkKHByb3ApO1xuICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShfY29udGV4dCwgX3N1YlByb3h5IHx8IHJlY2VpdmVyKTtcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gV2hlbiBzY3JpcHRhYmxlIG9wdGlvbiByZXR1cm5zIGFuIG9iamVjdCwgY3JlYXRlIGEgcmVzb2x2ZXIgb24gdGhhdC5cbiAgICB2YWx1ZSA9IGNyZWF0ZVN1YlJlc29sdmVyKF9wcm94eS5fc2NvcGVzLCBfcHJveHksIHByb3AsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkoXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25bXSxcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIGlzSW5kZXhhYmxlOiAoa2V5OiBzdHJpbmcpID0+IGJvb2xlYW5cbikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcblxuICBpZiAodHlwZW9mIF9jb250ZXh0LmluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHJldHVybiB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVbMF0pKSB7XG4gICAgLy8gQXJyYXkgb2Ygb2JqZWN0cywgcmV0dXJuIGFycmF5IG9yIHJlc29sdmVyc1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhcbiAgZmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5IHwgKChwcm9wOiBSZXNvbHZlck9iamVjdEtleSwgdmFsdWU6IHVua25vd24pID0+IFJlc29sdmVyT2JqZWN0S2V5KSxcbiAgcHJvcDogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2socHJvcCwgdmFsdWUpIDogZmFsbGJhY2s7XG59XG5cbmNvbnN0IGdldFNjb3BlID0gKGtleTogUmVzb2x2ZXJPYmplY3RLZXksIHBhcmVudDogQW55T2JqZWN0KSA9PiBrZXkgPT09IHRydWUgPyBwYXJlbnRcbiAgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBhZGRTY29wZXMoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHBhcmVudEZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRTY29wZXMpIHtcbiAgICBjb25zdCBzY29wZSA9IGdldFNjb3BlKGtleSwgcGFyZW50KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHNldC5hZGQoc2NvcGUpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgcmVhY2ggdGhlIGRlc2NyaXB0b3IgdGhhdCBkZWZpbmVzIGEgbmV3IF9mYWxsYmFjaywgcmV0dXJuIHRoYXQuXG4gICAgICAgIC8vIFRoZSBmYWxsYmFjayB3aWxsIHJlc3VtZSB0byB0aGF0IG5ldyBzY29wZS5cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IGZhbHNlICYmIHR5cGVvZiBwYXJlbnRGYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYga2V5ICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gYGZhbHNlYCByZXN1bHRzIHRvIGBmYWxzZWAsIHdoZW4gZmFsbGluZyBiYWNrIHRvIGRpZmZlcmVudCBrZXkuXG4gICAgICAvLyBGb3IgZXhhbXBsZSBgaW50ZXJhY3Rpb25gIGZyb20gYGhvdmVyYCBvciBgcGx1Z2lucy50b29sdGlwYCBhbmQgYGFuaW1hdGlvbmAgZnJvbSBgYW5pbWF0aW9uc2BcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YlJlc29sdmVyKFxuICBwYXJlbnRTY29wZXM6IEFueU9iamVjdFtdLFxuICByZXNvbHZlcjogUmVzb2x2ZXJDYWNoZSxcbiAgcHJvcDogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8QW55T2JqZWN0PigpO1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgbGV0IGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIHByb3AsIGZhbGxiYWNrIHx8IHByb3AsIHZhbHVlKTtcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBmYWxsYmFjayAhPT0gcHJvcCkge1xuICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfY3JlYXRlUmVzb2x2ZXIoQXJyYXkuZnJvbShzZXQpLCBbJyddLCByb290U2NvcGVzLCBmYWxsYmFjayxcbiAgICAoKSA9PiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AgYXMgc3RyaW5nLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBhZGRTY29wZXNGcm9tS2V5KFxuICBzZXQ6IFNldDxBbnlPYmplY3Q+LFxuICBhbGxTY29wZXM6IEFueU9iamVjdFtdLFxuICBrZXk6IFJlc29sdmVyT2JqZWN0S2V5LFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGl0ZW06IHVua25vd25cbikge1xuICB3aGlsZSAoa2V5KSB7XG4gICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBzdWJHZXRUYXJnZXQoXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBzdHJpbmcsXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgLy8gRm9yIGFycmF5IG9mIG9iamVjdHMsIHRoZSBvYmplY3QgaXMgdXNlZCB0byBzdG9yZSB1cGRhdGVkIHZhbHVlc1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0IHx8IHt9O1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhcbiAgcHJvcDogc3RyaW5nLFxuICBwcmVmaXhlczogc3RyaW5nW10sXG4gIHNjb3BlczogQW55T2JqZWN0W10sXG4gIHByb3h5OiBSZXNvbHZlclByb3h5XG4pIHtcbiAgbGV0IHZhbHVlOiB1bmtub3duO1xuICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgIHZhbHVlID0gX3Jlc29sdmUocmVhZEtleShwcmVmaXgsIHByb3ApLCBzY29wZXMpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc29sdmUoa2V5OiBzdHJpbmcsIHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldDogUmVzb2x2ZXJDYWNoZSkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXM6IEFueU9iamVjdFtdKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjb3BlKS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCdfJykpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUoXG4gIG1ldGE6IENoYXJ0TWV0YTwnbGluZScgfCAnc2NhdHRlcic+LFxuICBkYXRhOiBBbnlPYmplY3RbXSxcbiAgc3RhcnQ6IG51bWJlcixcbiAgY291bnQ6IG51bWJlclxuKSB7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge2tleSA9ICdyJ30gPSB0aGlzLl9wYXJzaW5nO1xuICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXk8e3I6IHVua25vd259Pihjb3VudCk7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgaW5kZXg6IG51bWJlciwgaXRlbTogQW55T2JqZWN0O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICBwYXJzZWRbaV0gPSB7XG4gICAgICByOiBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCBrZXkpLCBpbmRleClcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCJpbXBvcnQge2FsbW9zdEVxdWFscywgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBzaWdufSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWF9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtTcGxpbmVQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXG50eXBlIE9wdGlvbmFsU3BsaW5lUG9pbnQgPSBTcGxpbmVQb2ludCB8IGZhbHNlXG5jb25zdCBnZXRQb2ludCA9IChwb2ludHM6IFNwbGluZVBvaW50W10sIGk6IG51bWJlcik6IE9wdGlvbmFsU3BsaW5lUG9pbnQgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXM6ICd4JyB8ICd5JykgPT4gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpbmVDdXJ2ZShcbiAgZmlyc3RQb2ludDogU3BsaW5lUG9pbnQsXG4gIG1pZGRsZVBvaW50OiBTcGxpbmVQb2ludCxcbiAgYWZ0ZXJQb2ludDogU3BsaW5lUG9pbnQsXG4gIHQ6IG51bWJlclxuKToge1xuICAgIHByZXZpb3VzOiBTcGxpbmVQb2ludFxuICAgIG5leHQ6IFNwbGluZVBvaW50XG4gIH0ge1xuICAvLyBQcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcbiAgLy8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgY29uc3QgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICBjb25zdCBkMTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMobmV4dCwgY3VycmVudCk7XG5cbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cbiAgLy8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxuICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cbiAgY29uc3QgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcbiAgY29uc3QgZmIgPSB0ICogczEyO1xuXG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHM6IFNwbGluZVBvaW50W10sIGRlbHRhSzogbnVtYmVyW10sIG1LOiBudW1iZXJbXSkge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBhbHBoYUs6IG51bWJlciwgYmV0YUs6IG51bWJlciwgdGF1SzogbnVtYmVyLCBzcXVhcmVkTWFnbml0dWRlOiBudW1iZXIsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGFscGhhSyA9IG1LW2ldIC8gZGVsdGFLW2ldO1xuICAgIGJldGFLID0gbUtbaSArIDFdIC8gZGVsdGFLW2ldO1xuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgIGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50czogU3BsaW5lUG9pbnRbXSwgbUs6IG51bWJlcltdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhOiBudW1iZXIsIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuICogYnV0IHByZXNlcnZlcyBtb25vdG9uaWNpdHkgb2YgdGhlIHByb3ZpZGVkIGRhdGEgYW5kIGVuc3VyZXMgbm8gbG9jYWwgZXh0cmVtdW1zIGFyZSBhZGRlZFxuICogYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuICogU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHM6IFNwbGluZVBvaW50W10sIGluZGV4QXhpczogJ3gnIHwgJ3knID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBkZWx0YUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSzogbnVtYmVyW10gPSBBcnJheShwb2ludHNMZW4pO1xuXG4gIC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuICBsZXQgaSwgcG9pbnRCZWZvcmU6IE9wdGlvbmFsU3BsaW5lUG9pbnQsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuXG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgICA6IChzaWduKGRlbHRhS1tpIC0gMV0pICE9PSBzaWduKGRlbHRhS1tpXSkpID8gMFxuICAgICAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuXG4gIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG5cbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuXG5mdW5jdGlvbiBjYXBCZXppZXJQb2ludHMocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKFxuICBwb2ludHM6IFNwbGluZVBvaW50W10sXG4gIG9wdGlvbnMsXG4gIGFyZWE6IENoYXJ0QXJlYSxcbiAgbG9vcDogYm9vbGVhbixcbiAgaW5kZXhBeGlzOiAneCcgfCAneSdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHBvaW50OiBTcGxpbmVQb2ludCwgY29udHJvbFBvaW50czogUmV0dXJuVHlwZTx0eXBlb2Ygc3BsaW5lQ3VydmU+O1xuXG4gIC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5jYXBCZXppZXJQb2ludHMpIHtcbiAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUge0NoYXJ0QXJlYSwgU2NhbGV9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIFByaXZhdGVDaGFydCBmcm9tICcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnQsIENoYXJ0RXZlbnR9IGZyb20gJy4uL3R5cGVzLmpzJztcbmltcG9ydCB7SU5GSU5JVFl9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzRG9tU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFBhcmVudE5vZGUoZG9tTm9kZTogSFRNTENhbnZhc0VsZW1lbnQpOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gIGxldCBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuICAgIHBhcmVudCA9IChwYXJlbnQgYXMgU2hhZG93Um9vdCkuaG9zdDtcbiAgfVxuICByZXR1cm4gcGFyZW50IGFzIEhUTUxDYW52YXNFbGVtZW50O1xufVxuXG4vKipcbiAqIGNvbnZlcnQgbWF4LXdpZHRoL21heC1oZWlnaHQgdmFsdWVzIHRoYXQgbWF5IGJlIHBlcmNlbnRhZ2VzIGludG8gYSBudW1iZXJcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VNYXhTdHlsZShzdHlsZVZhbHVlOiBzdHJpbmcgfCBudW1iZXIsIG5vZGU6IEhUTUxFbGVtZW50LCBwYXJlbnRQcm9wZXJ0eTogc3RyaW5nKSB7XG4gIGxldCB2YWx1ZUluUGl4ZWxzOiBudW1iZXI7XG4gIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuXG4gICAgaWYgKHN0eWxlVmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgLy8gcGVyY2VudGFnZSAqIHNpemUgaW4gZGltZW5zaW9uXG4gICAgICB2YWx1ZUluUGl4ZWxzID0gKHZhbHVlSW5QaXhlbHMgLyAxMDApICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWVJblBpeGVscztcbn1cblxuY29uc3QgZ2V0Q29tcHV0ZWRTdHlsZSA9IChlbGVtZW50OiBIVE1MRWxlbWVudCk6IENTU1N0eWxlRGVjbGFyYXRpb24gPT5cbiAgZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHByb3BlcnR5OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59XG5cbmNvbnN0IHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5mdW5jdGlvbiBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGVzOiBDU1NTdHlsZURlY2xhcmF0aW9uLCBzdHlsZTogc3RyaW5nLCBzdWZmaXg/OiBzdHJpbmcpOiBDaGFydEFyZWEge1xuICBjb25zdCByZXN1bHQgPSB7fSBhcyBDaGFydEFyZWE7XG4gIHN1ZmZpeCA9IHN1ZmZpeCA/ICctJyArIHN1ZmZpeCA6ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uc1tpXTtcbiAgICByZXN1bHRbcG9zXSA9IHBhcnNlRmxvYXQoc3R5bGVzW3N0eWxlICsgJy0nICsgcG9zICsgc3VmZml4XSkgfHwgMDtcbiAgfVxuICByZXN1bHQud2lkdGggPSByZXN1bHQubGVmdCArIHJlc3VsdC5yaWdodDtcbiAgcmVzdWx0LmhlaWdodCA9IHJlc3VsdC50b3AgKyByZXN1bHQuYm90dG9tO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCB1c2VPZmZzZXRQb3MgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIsIHRhcmdldDogSFRNTEVsZW1lbnQgfCBFdmVudFRhcmdldCkgPT5cbiAgKHggPiAwIHx8IHkgPiAwKSAmJiAoIXRhcmdldCB8fCAhKHRhcmdldCBhcyBIVE1MRWxlbWVudCkuc2hhZG93Um9vdCk7XG5cbi8qKlxuICogQHBhcmFtIGVcbiAqIEBwYXJhbSBjYW52YXNcbiAqIEByZXR1cm5zIENhbnZhcyBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBnZXRDYW52YXNQb3NpdGlvbihcbiAgZTogRXZlbnQgfCBUb3VjaEV2ZW50IHwgTW91c2VFdmVudCxcbiAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxuKToge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgYm94OiBib29sZWFuO1xuICB9IHtcbiAgY29uc3QgdG91Y2hlcyA9IChlIGFzIFRvdWNoRXZlbnQpLnRvdWNoZXM7XG4gIGNvbnN0IHNvdXJjZSA9ICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID8gdG91Y2hlc1swXSA6IGUpIGFzIE1vdXNlRXZlbnQ7XG4gIGNvbnN0IHtvZmZzZXRYLCBvZmZzZXRZfSA9IHNvdXJjZSBhcyBNb3VzZUV2ZW50O1xuICBsZXQgYm94ID0gZmFsc2U7XG4gIGxldCB4LCB5O1xuICBpZiAodXNlT2Zmc2V0UG9zKG9mZnNldFgsIG9mZnNldFksIGUudGFyZ2V0KSkge1xuICAgIHggPSBvZmZzZXRYO1xuICAgIHkgPSBvZmZzZXRZO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgeCA9IHNvdXJjZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIHkgPSBzb3VyY2UuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIGJveCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHt4LCB5LCBib3h9O1xufVxuXG4vKipcbiAqIEdldHMgYW4gZXZlbnQncyB4LCB5IGNvb3JkaW5hdGVzLCByZWxhdGl2ZSB0byB0aGUgY2hhcnQgYXJlYVxuICogQHBhcmFtIGV2ZW50XG4gKiBAcGFyYW0gY2hhcnRcbiAqIEByZXR1cm5zIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oXG4gIGV2ZW50OiBFdmVudCB8IENoYXJ0RXZlbnQgfCBUb3VjaEV2ZW50IHwgTW91c2VFdmVudCxcbiAgY2hhcnQ6IENoYXJ0IHwgUHJpdmF0ZUNoYXJ0XG4pOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICBpZiAoJ25hdGl2ZScgaW4gZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxuICBjb25zdCB7Y2FudmFzLCBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpb30gPSBjaGFydDtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IGJvcmRlckJveCA9IHN0eWxlLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnO1xuICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICBjb25zdCB7eCwgeSwgYm94fSA9IGdldENhbnZhc1Bvc2l0aW9uKGV2ZW50LCBjYW52YXMpO1xuICBjb25zdCB4T2Zmc2V0ID0gcGFkZGluZ3MubGVmdCArIChib3ggJiYgYm9yZGVycy5sZWZ0KTtcbiAgY29uc3QgeU9mZnNldCA9IHBhZGRpbmdzLnRvcCArIChib3ggJiYgYm9yZGVycy50b3ApO1xuXG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjaGFydDtcbiAgaWYgKGJvcmRlckJveCkge1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLnJvdW5kKCh4IC0geE9mZnNldCkgLyB3aWR0aCAqIGNhbnZhcy53aWR0aCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKSxcbiAgICB5OiBNYXRoLnJvdW5kKCh5IC0geU9mZnNldCkgLyBoZWlnaHQgKiBjYW52YXMuaGVpZ2h0IC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lclNpemUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBQYXJ0aWFsPFNjYWxlPiB7XG4gIGxldCBtYXhXaWR0aDogbnVtYmVyLCBtYXhIZWlnaHQ6IG51bWJlcjtcblxuICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcyAmJiBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHRoaXMgaXMgdGhlIGJvcmRlciBib3ggb2YgdGhlIGNvbnRhaW5lclxuICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICBjb25zdCBjb250YWluZXJCb3JkZXIgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGggLSBjb250YWluZXJQYWRkaW5nLndpZHRoIC0gY29udGFpbmVyQm9yZGVyLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBjb250YWluZXJQYWRkaW5nLmhlaWdodCAtIGNvbnRhaW5lckJvcmRlci5oZWlnaHQ7XG4gICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XG4gICAgICBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCwgY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1heFdpZHRoOiBtYXhXaWR0aCB8fCBJTkZJTklUWSxcbiAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCB8fCBJTkZJTklUWVxuICB9O1xufVxuXG5jb25zdCByb3VuZDEgPSAodjogbnVtYmVyKSA9PiBNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXhpbXVtU2l6ZShcbiAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcbiAgYmJXaWR0aD86IG51bWJlcixcbiAgYmJIZWlnaHQ/OiBudW1iZXIsXG4gIGFzcGVjdFJhdGlvPzogbnVtYmVyXG4pOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0ge1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgbWFyZ2lucyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ21hcmdpbicpO1xuICBjb25zdCBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4V2lkdGgsIGNhbnZhcywgJ2NsaWVudFdpZHRoJykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4SGVpZ2h0LCBjYW52YXMsICdjbGllbnRIZWlnaHQnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGdldENvbnRhaW5lclNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjb250YWluZXJTaXplO1xuXG4gIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcbiAgICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gbWFyZ2lucy53aWR0aCk7XG4gIGhlaWdodCA9IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gd2lkdGggLyBhc3BlY3RSYXRpbyA6IGhlaWdodCAtIG1hcmdpbnMuaGVpZ2h0KTtcbiAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XG4gIGhlaWdodCA9IHJvdW5kMShNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCwgY29udGFpbmVyU2l6ZS5tYXhIZWlnaHQpKTtcbiAgaWYgKHdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDY1OVxuICAgIC8vIElmIHRoZSBjYW52YXMgaGFzIHdpZHRoLCBidXQgbm8gaGVpZ2h0LCBkZWZhdWx0IHRvIGFzcGVjdFJhdGlvIG9mIDIgKGNhbnZhcyBkZWZhdWx0KVxuICAgIGhlaWdodCA9IHJvdW5kMSh3aWR0aCAvIDIpO1xuICB9XG5cbiAgY29uc3QgbWFpbnRhaW5IZWlnaHQgPSBiYldpZHRoICE9PSB1bmRlZmluZWQgfHwgYmJIZWlnaHQgIT09IHVuZGVmaW5lZDtcblxuICBpZiAobWFpbnRhaW5IZWlnaHQgJiYgYXNwZWN0UmF0aW8gJiYgY29udGFpbmVyU2l6ZS5oZWlnaHQgJiYgaGVpZ2h0ID4gY29udGFpbmVyU2l6ZS5oZWlnaHQpIHtcbiAgICBoZWlnaHQgPSBjb250YWluZXJTaXplLmhlaWdodDtcbiAgICB3aWR0aCA9IHJvdW5kMShNYXRoLmZsb29yKGhlaWdodCAqIGFzcGVjdFJhdGlvKSk7XG4gIH1cblxuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSBjaGFydFxuICogQHBhcmFtIGZvcmNlUmF0aW9cbiAqIEBwYXJhbSBmb3JjZVN0eWxlXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjYW52YXMgY29udGV4dCBzaXplIG9yIHRyYW5zZm9ybWF0aW9uIGhhcyBjaGFuZ2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0aW5hU2NhbGUoXG4gIGNoYXJ0OiBDaGFydCB8IFByaXZhdGVDaGFydCxcbiAgZm9yY2VSYXRpbzogbnVtYmVyLFxuICBmb3JjZVN0eWxlPzogYm9vbGVhblxuKTogYm9vbGVhbiB8IHZvaWQge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAxO1xuICBjb25zdCBkZXZpY2VIZWlnaHQgPSByb3VuZDEoY2hhcnQuaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVdpZHRoID0gcm91bmQxKGNoYXJ0LndpZHRoICogcGl4ZWxSYXRpbyk7XG5cbiAgKGNoYXJ0IGFzIFByaXZhdGVDaGFydCkuaGVpZ2h0ID0gcm91bmQxKGNoYXJ0LmhlaWdodCk7XG4gIChjaGFydCBhcyBQcml2YXRlQ2hhcnQpLndpZHRoID0gcm91bmQxKGNoYXJ0LndpZHRoKTtcblxuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cbiAgLy8gSWYgbm8gc3R5bGUgaGFzIGJlZW4gc2V0IG9uIHRoZSBjYW52YXMsIHRoZSByZW5kZXIgc2l6ZSBpcyB1c2VkIGFzIGRpc3BsYXkgc2l6ZSxcbiAgLy8gbWFraW5nIHRoZSBjaGFydCB2aXN1YWxseSBiaWdnZXIsIHNvIGxldCdzIGVuZm9yY2UgaXQgdG8gdGhlIFwiY29ycmVjdFwiIHZhbHVlcy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNTc1XG4gIGlmIChjYW52YXMuc3R5bGUgJiYgKGZvcmNlU3R5bGUgfHwgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpKSkge1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydC5oZWlnaHR9cHhgO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NoYXJ0LndpZHRofXB4YDtcbiAgfVxuXG4gIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGl4ZWxSYXRpb1xuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XG4gICAgICB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgKGNoYXJ0IGFzIFByaXZhdGVDaGFydCkuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogRGV0ZWN0cyBzdXBwb3J0IGZvciBvcHRpb25zIG9iamVjdCBhcmd1bWVudCBpbiBhZGRFdmVudExpc3RlbmVyLlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBwYXNzaXZlKCkgeyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgYXR0ZW1wdHMgdG8gYWNjZXNzIHRoZSBwYXNzaXZlIHByb3BlcnR5LlxuICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gYXMgRXZlbnRMaXN0ZW5lck9wdGlvbnM7XG5cbiAgICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgfVxuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn0oKSk7XG5cbi8qKlxuICogVGhlIFwidXNlZFwiIHNpemUgaXMgdGhlIGZpbmFsIHZhbHVlIG9mIGEgZGltZW5zaW9uIHByb3BlcnR5IGFmdGVyIGFsbCBjYWxjdWxhdGlvbnMgaGF2ZVxuICogYmVlbiBwZXJmb3JtZWQuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIGBlbGVtZW50YCBidXQgcmV0dXJucyB1bmRlZmluZWRcbiAqIGlmIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBub3QgZXhwcmVzc2VkIGluIHBpeGVscy4gVGhhdCBjYW4gaGFwcGVuIGluIHNvbWUgY2FzZXMgd2hlcmVcbiAqIGBlbGVtZW50YCBoYXMgYSBzaXplIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgYW5kIHRoaXMgbGFzdCBvbmUgaXMgbm90IHlldCBkaXNwbGF5ZWQsXG4gKiBmb3IgZXhhbXBsZSBiZWNhdXNlIG9mIGBkaXNwbGF5OiBub25lYCBvbiBhIHBhcmVudCBub2RlLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdXNlZF92YWx1ZVxuICogQHJldHVybnMgU2l6ZSBpbiBwaXhlbHMgb3IgdW5kZWZpbmVkIGlmIHVua25vd24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQsXG4gIHByb3BlcnR5OiAnd2lkdGgnIHwgJ2hlaWdodCdcbik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG4gIHJldHVybiBtYXRjaGVzID8gK21hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgdHlwZSB7UG9pbnQsIFNwbGluZVBvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcG9pbnRJbkxpbmUocDE6IFBvaW50LCBwMjogUG9pbnQsIHQ6IG51bWJlciwgbW9kZT8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogcDEueSArIHQgKiAocDIueSAtIHAxLnkpXG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGVwcGVkSW50ZXJwb2xhdGlvbihcbiAgcDE6IFBvaW50LFxuICBwMjogUG9pbnQsXG4gIHQ6IG51bWJlciwgbW9kZTogJ21pZGRsZScgfCAnYWZ0ZXInIHwgdW5rbm93blxuKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IG1vZGUgPT09ICdtaWRkbGUnID8gdCA8IDAuNSA/IHAxLnkgOiBwMi55XG4gICAgICA6IG1vZGUgPT09ICdhZnRlcicgPyB0IDwgMSA/IHAxLnkgOiBwMi55XG4gICAgICAgIDogdCA+IDAgPyBwMi55IDogcDEueVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYmV6aWVySW50ZXJwb2xhdGlvbihwMTogU3BsaW5lUG9pbnQsIHAyOiBTcGxpbmVQb2ludCwgdDogbnVtYmVyLCBtb2RlPykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIFJUTEFkYXB0ZXIge1xuICB4KHg6IG51bWJlcik6IG51bWJlcjtcbiAgc2V0V2lkdGgodzogbnVtYmVyKTogdm9pZDtcbiAgdGV4dEFsaWduKGFsaWduOiAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCcpOiAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCc7XG4gIHhQbHVzKHg6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IG51bWJlcjtcbiAgbGVmdEZvckx0cih4OiBudW1iZXIsIGl0ZW1XaWR0aDogbnVtYmVyKTogbnVtYmVyO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKTogUlRMQWRhcHRlciB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4gcmVjdFggKyByZWN0WCArIHdpZHRoIC0geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICAgIHdpZHRoID0gdztcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4IC0gdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIGl0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHggLSBpdGVtV2lkdGg7XG4gICAgfSxcbiAgfTtcbn07XG5cbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCk6IFJUTEFkYXB0ZXIge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4ICsgdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIF9pdGVtV2lkdGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnRsQWRhcHRlcihydGw6IGJvb2xlYW4sIHJlY3RYOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGRpcmVjdGlvbjogJ2x0cicgfCAncnRsJykge1xuICBsZXQgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24sIG9yaWdpbmFsOiBbc3RyaW5nLCBzdHJpbmddO1xuICBpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgc3R5bGUgPSBjdHguY2FudmFzLnN0eWxlO1xuICAgIG9yaWdpbmFsID0gW1xuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdkaXJlY3Rpb24nKSxcbiAgICBdO1xuXG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIGRpcmVjdGlvbiwgJ2ltcG9ydGFudCcpO1xuICAgIChjdHggYXMgeyBwcmV2VGV4dERpcmVjdGlvbj86IFtzdHJpbmcsIHN0cmluZ10gfSkucHJldlRleHREaXJlY3Rpb24gPSBvcmlnaW5hbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9yaWdpbmFsPzogW3N0cmluZywgc3RyaW5nXSkge1xuICBpZiAob3JpZ2luYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSAoY3R4IGFzIHsgcHJldlRleHREaXJlY3Rpb24/OiBbc3RyaW5nLCBzdHJpbmddIH0pLnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cbiIsImltcG9ydCB7X2FuZ2xlQmV0d2VlbiwgX2FuZ2xlRGlmZiwgX2lzQmV0d2VlbiwgX25vcm1hbGl6ZUFuZ2xlfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHR9IGZyb20gJy4vaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7aXNQYXR0ZXJuT3JHcmFkaWVudH0gZnJvbSAnLi9oZWxwZXJzLmNvbG9yLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJykuZGVmYXVsdCB9IExpbmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqIEB0eXBlZGVmIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIGxvb3A6IGJvb2xlYW4sIHN0eWxlPzogYW55fX0gU2VnbWVudFxuICovXG5cbmZ1bmN0aW9uIHByb3BlcnR5Rm4ocHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJldHdlZW46IF9hbmdsZUJldHdlZW4sXG4gICAgICBjb21wYXJlOiBfYW5nbGVEaWZmLFxuICAgICAgbm9ybWFsaXplOiBfbm9ybWFsaXplQW5nbGUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJldHdlZW46IF9pc0JldHdlZW4sXG4gICAgY29tcGFyZTogKGEsIGIpID0+IGEgLSBiLFxuICAgIG5vcm1hbGl6ZTogeCA9PiB4XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCB7YmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtzdGFydCwgZW5kLCBsb29wfSA9IHNlZ21lbnQ7XG4gIGxldCBpLCBpbGVuO1xuXG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICBlbmQgKz0gY291bnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZTogc2VnbWVudC5zdHlsZX07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3ViLXNlZ21lbnQocykgb2YgYSBsaW5lIHNlZ21lbnQgdGhhdCBmYWxsIGluIHRoZSBnaXZlbiBib3VuZHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3BcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudC5zdHlsZV0gLSBzZWdtZW50IHN0eWxlXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHMgLSB0aGUgcG9pbnRzIHRoYXQgdGhpcyBzZWdtZW50IHJlZmVycyB0b1xuICogQHBhcmFtIHtvYmplY3R9IFtib3VuZHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gYm91bmRzLnByb3BlcnR5IC0gdGhlIHByb3BlcnR5IG9mIGEgYFBvaW50RWxlbWVudGAgd2UgYXJlIGJvdW5kaW5nLiBgeGAsIGB5YCBvciBgYW5nbGVgLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5zdGFydCAtIHN0YXJ0IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5lbmQgLSBlbmQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4gW3NlZ21lbnRdO1xuICB9XG5cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gIGxldCBzdWJTdGFydCA9IG51bGw7XG4gIGxldCB2YWx1ZSwgcG9pbnQsIHByZXZWYWx1ZTtcblxuICBjb25zdCBzdGFydElzQmVmb3JlID0gKCkgPT4gYmV0d2VlbihzdGFydEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKSAmJiBjb21wYXJlKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSkgIT09IDA7XG4gIGNvbnN0IGVuZElzQmVmb3JlID0gKCkgPT4gY29tcGFyZShlbmRCb3VuZCwgdmFsdWUpID09PSAwIHx8IGJldHdlZW4oZW5kQm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpO1xuICBjb25zdCBzaG91bGRTdGFydCA9ICgpID0+IGluc2lkZSB8fCBzdGFydElzQmVmb3JlKCk7XG4gIGNvbnN0IHNob3VsZFN0b3AgPSAoKSA9PiAhaW5zaWRlIHx8IGVuZElzQmVmb3JlKCk7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhbHVlID0gbm9ybWFsaXplKHBvaW50W3Byb3BlcnR5XSk7XG5cbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaW5zaWRlID0gYmV0d2Vlbih2YWx1ZSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpO1xuXG4gICAgaWYgKHN1YlN0YXJ0ID09PSBudWxsICYmIHNob3VsZFN0YXJ0KCkpIHtcbiAgICAgIHN1YlN0YXJ0ID0gY29tcGFyZSh2YWx1ZSwgc3RhcnRCb3VuZCkgPT09IDAgPyBpIDogcHJldjtcbiAgICB9XG5cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGlmIChzdWJTdGFydCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2VnbWVudHMgb2YgdGhlIGxpbmUgdGhhdCBhcmUgaW5zaWRlIGdpdmVuIGJvdW5kc1xuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IFtib3VuZHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gYm91bmRzLnByb3BlcnR5IC0gdGhlIHByb3BlcnR5IHdlIGFyZSBib3VuZGluZyB3aXRoLiBgeGAsIGB5YCBvciBgYW5nbGVgLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5zdGFydCAtIHN0YXJ0IHZhbHVlIG9mIHRoZSBgcHJvcGVydHlgXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLmVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgYHByb3BlcnR5YFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ib3VuZFNlZ21lbnRzKGxpbmUsIGJvdW5kcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdWIgPSBfYm91bmRTZWdtZW50KHNlZ21lbnRzW2ldLCBsaW5lLnBvaW50cywgYm91bmRzKTtcbiAgICBpZiAoc3ViLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goLi4uc3ViKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGaW5kIHN0YXJ0IGFuZCBlbmQgaW5kZXggb2YgYSBsaW5lLlxuICovXG5mdW5jdGlvbiBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGNvdW50IC0gMTtcblxuICBpZiAobG9vcCAmJiAhc3BhbkdhcHMpIHtcbiAgICAvLyBsb29wIGFuZCBub3Qgc3Bhbm5pbmcgZ2FwcywgZmlyc3QgZmluZCBhIGdhcCB0byBzdGFydCBmcm9tXG4gICAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgIXBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIGZpcnN0IG5vbiBza2lwcGVkIHBvaW50IChhZnRlciB0aGUgZmlyc3QgZ2FwIHBvc3NpYmx5KVxuICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiBwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICBzdGFydCsrO1xuICB9XG5cbiAgLy8gaWYgd2UgbG9vcGVkIHRvIGNvdW50LCBzdGFydCBuZWVkcyB0byBiZSAwXG4gIHN0YXJ0ICU9IGNvdW50O1xuXG4gIGlmIChsb29wKSB7XG4gICAgLy8gbG9vcCB3aWxsIGdvIHBhc3QgY291bnQsIGlmIHN0YXJ0ID4gMFxuICAgIGVuZCArPSBzdGFydDtcbiAgfVxuXG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuXG4gIC8vIGVuZCBjb3VsZCBiZSBtb3JlIHRoYW4gY291bnQsIG5vcm1hbGl6ZVxuICBlbmQgJT0gY291bnQ7XG5cbiAgcmV0dXJuIHtzdGFydCwgZW5kfTtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHNvbGlkIHNlZ21lbnRzIGZyb20gUG9pbnRzLCB3aGVuIHNwYW5HYXBzID09PSBmYWxzZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzIC0gdGhlIHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBtYXggaW5kZXggKGNhbiBnbyBwYXN0IGNvdW50IG9uIGEgbG9vcClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcCAtIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoaXMgd291bGQgYmUgYSBsb29wIGlmIG5vIGdhcHMgYXJlIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBsb29wKSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBsYXN0ID0gc3RhcnQ7XG4gIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0XTtcbiAgbGV0IGVuZDtcblxuICBmb3IgKGVuZCA9IHN0YXJ0ICsgMTsgZW5kIDw9IG1heDsgKytlbmQpIHtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbZW5kICUgY291bnRdO1xuICAgIGlmIChjdXIuc2tpcCB8fCBjdXIuc3RvcCkge1xuICAgICAgaWYgKCFwcmV2LnNraXApIHtcbiAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogKGVuZCAtIDEpICUgY291bnQsIGxvb3B9KTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG5cbiAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogbGFzdCAlIGNvdW50LCBsb29wfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNvbnRpbnVvdXMgc2VnbWVudHMgdGhhdCBkZWZpbmUgdGhlIHdob2xlIGxpbmVcbiAqIFRoZXJlIGNhbiBiZSBza2lwcGVkIHBvaW50cyB3aXRoaW4gYSBzZWdtZW50LCBpZiBzcGFuR2FwcyBpcyB0cnVlLlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsb29wID0gISFsaW5lLl9sb29wO1xuICBjb25zdCB7c3RhcnQsIGVuZH0gPSBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpO1xuXG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IG1heCA9IGVuZCA8IHN0YXJ0ID8gZW5kICsgY291bnQgOiBlbmQ7XG4gIGNvbnN0IGNvbXBsZXRlTG9vcCA9ICEhbGluZS5fZnVsbExvb3AgJiYgc3RhcnQgPT09IDAgJiYgZW5kID09PSBjb3VudCAtIDE7XG4gIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBjb21wbGV0ZUxvb3ApLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqL1xuZnVuY3Rpb24gc3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBpZiAoIXNlZ21lbnRPcHRpb25zIHx8ICFzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0IHx8ICFwb2ludHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cbiAgcmV0dXJuIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtTZWdtZW50W119IHNlZ21lbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudE9wdGlvbnNdXG4gKiBAcmV0dXJuIHtTZWdtZW50W119XG4gKi9cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gIGNvbnN0IGJhc2VTdHlsZSA9IHJlYWRTdHlsZShsaW5lLm9wdGlvbnMpO1xuICBjb25zdCB7X2RhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LCBvcHRpb25zOiB7c3BhbkdhcHN9fSA9IGxpbmU7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuXG4gIGZ1bmN0aW9uIGFkZFN0eWxlKHMsIGUsIGwsIHN0KSB7XG4gICAgY29uc3QgZGlyID0gc3BhbkdhcHMgPyAtMSA6IDE7XG4gICAgaWYgKHMgPT09IGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU3R5bGUgY2FuIG5vdCBzdGFydC9lbmQgb24gYSBza2lwcGVkIHBvaW50LCBhZGp1c3QgaW5kaWNlcyBhY2NvcmRpbmdseVxuICAgIHMgKz0gY291bnQ7XG4gICAgd2hpbGUgKHBvaW50c1tzICUgY291bnRdLnNraXApIHtcbiAgICAgIHMgLT0gZGlyO1xuICAgIH1cbiAgICB3aGlsZSAocG9pbnRzW2UgJSBjb3VudF0uc2tpcCkge1xuICAgICAgZSArPSBkaXI7XG4gICAgfVxuICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcbiAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc3RhcnQgPSBzcGFuR2FwcyA/IHN0YXJ0IDogc2VnbWVudC5zdGFydDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1tzdGFydCAlIGNvdW50XTtcbiAgICBsZXQgc3R5bGU7XG4gICAgZm9yIChpID0gc3RhcnQgKyAxOyBpIDw9IHNlZ21lbnQuZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IHB0ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgICBzdHlsZSA9IHJlYWRTdHlsZShzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0KGNyZWF0ZUNvbnRleHQoY2hhcnRDb250ZXh0LCB7XG4gICAgICAgIHR5cGU6ICdzZWdtZW50JyxcbiAgICAgICAgcDA6IHByZXYsXG4gICAgICAgIHAxOiBwdCxcbiAgICAgICAgcDBEYXRhSW5kZXg6IChpIC0gMSkgJSBjb3VudCxcbiAgICAgICAgcDFEYXRhSW5kZXg6IGkgJSBjb3VudCxcbiAgICAgICAgZGF0YXNldEluZGV4XG4gICAgICB9KSkpO1xuICAgICAgaWYgKHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSkge1xuICAgICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByZXYgPSBwdDtcbiAgICAgIHByZXZTdHlsZSA9IHN0eWxlO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCBpIC0gMSkge1xuICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkge1xuICBpZiAoIXByZXZTdHlsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjYWNoZSA9IFtdO1xuICBjb25zdCByZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICghY2FjaGUuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICBjYWNoZS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmluZGV4T2YodmFsdWUpO1xuICB9O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3R5bGUsIHJlcGxhY2VyKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldlN0eWxlLCByZXBsYWNlcik7XG59XG4iLCJpbXBvcnQgdHlwZSB7Q2hhcnQsIENoYXJ0QXJlYSwgQ2hhcnRNZXRhLCBTY2FsZSwgVFJCTH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBnZXRTaXplRm9yQXJlYShzY2FsZTogU2NhbGUsIGNoYXJ0QXJlYTogQ2hhcnRBcmVhLCBmaWVsZDoga2V5b2YgQ2hhcnRBcmVhKSB7XG4gIHJldHVybiBzY2FsZS5vcHRpb25zLmNsaXAgPyBzY2FsZVtmaWVsZF0gOiBjaGFydEFyZWFbZmllbGRdO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhc2V0QXJlYShtZXRhOiBDaGFydE1ldGEsIGNoYXJ0QXJlYTogQ2hhcnRBcmVhKTogVFJCTCB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICBpZiAoeFNjYWxlICYmIHlTY2FsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ2xlZnQnKSxcbiAgICAgIHJpZ2h0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ3JpZ2h0JyksXG4gICAgICB0b3A6IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAndG9wJyksXG4gICAgICBib3R0b206IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAnYm90dG9tJylcbiAgICB9O1xuICB9XG4gIHJldHVybiBjaGFydEFyZWE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhc2V0Q2xpcEFyZWEoY2hhcnQ6IENoYXJ0LCBtZXRhOiBDaGFydE1ldGEpOiBUUkJMIHwgZmFsc2Uge1xuICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgaWYgKGNsaXAuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYXJlYSA9IGdldERhdGFzZXRBcmVhKG1ldGEsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIChjbGlwLmxlZnQgPT09IHRydWUgPyAwIDogY2xpcC5sZWZ0KSxcbiAgICByaWdodDogY2xpcC5yaWdodCA9PT0gZmFsc2UgPyBjaGFydC53aWR0aCA6IGFyZWEucmlnaHQgKyAoY2xpcC5yaWdodCA9PT0gdHJ1ZSA/IDAgOiBjbGlwLnJpZ2h0KSxcbiAgICB0b3A6IGNsaXAudG9wID09PSBmYWxzZSA/IDAgOiBhcmVhLnRvcCAtIChjbGlwLnRvcCA9PT0gdHJ1ZSA/IDAgOiBjbGlwLnRvcCksXG4gICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyBjaGFydC5oZWlnaHQgOiBhcmVhLmJvdHRvbSArIChjbGlwLmJvdHRvbSA9PT0gdHJ1ZSA/IDAgOiBjbGlwLmJvdHRvbSlcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJub29wIiwidWlkIiwiaWQiLCJpc051bGxPclVuZGVmIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJpc0FycmF5IiwiQXJyYXkiLCJ0eXBlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJpc09iamVjdCIsImlzTnVtYmVyRmluaXRlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJmaW5pdGVPckRlZmF1bHQiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZU9yRGVmYXVsdCIsInRvUGVyY2VudGFnZSIsImRpbWVuc2lvbiIsImVuZHNXaXRoIiwicGFyc2VGbG9hdCIsInRvRGltZW5zaW9uIiwiY2FsbGJhY2siLCJmbiIsImFyZ3MiLCJ0aGlzQXJnIiwiYXBwbHkiLCJlYWNoIiwibG9vcGFibGUiLCJyZXZlcnNlIiwiaSIsImxlbiIsImtleXMiLCJsZW5ndGgiLCJfZWxlbWVudHNFcXVhbCIsImEwIiwiYTEiLCJpbGVuIiwidjAiLCJ2MSIsImRhdGFzZXRJbmRleCIsImluZGV4IiwiY2xvbmUiLCJzb3VyY2UiLCJtYXAiLCJ0YXJnZXQiLCJjcmVhdGUiLCJrbGVuIiwiayIsImlzVmFsaWRLZXkiLCJrZXkiLCJpbmRleE9mIiwiX21lcmdlciIsIm9wdGlvbnMiLCJ0dmFsIiwic3ZhbCIsIm1lcmdlIiwic291cmNlcyIsIm1lcmdlciIsImN1cnJlbnQiLCJtZXJnZUlmIiwiX21lcmdlcklmIiwiaGFzT3duUHJvcGVydHkiLCJfZGVwcmVjYXRlZCIsInNjb3BlIiwicHJldmlvdXMiLCJjb25zb2xlIiwid2FybiIsImtleVJlc29sdmVycyIsInYiLCJ4IiwibyIsInkiLCJfc3BsaXRLZXkiLCJwYXJ0cyIsInNwbGl0IiwidG1wIiwicGFydCIsInB1c2giLCJfZ2V0S2V5UmVzb2x2ZXIiLCJvYmoiLCJyZXNvbHZlT2JqZWN0S2V5IiwicmVzb2x2ZXIiLCJfY2FwaXRhbGl6ZSIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiZGVmaW5lZCIsImlzRnVuY3Rpb24iLCJzZXRzRXF1YWwiLCJhIiwiYiIsInNpemUiLCJpdGVtIiwiaGFzIiwiX2lzQ2xpY2tFdmVudCIsImUiLCJQSSIsIk1hdGgiLCJUQVUiLCJQSVRBVSIsIklORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJSQURfUEVSX0RFRyIsIkhBTEZfUEkiLCJRVUFSVEVSX1BJIiwiVFdPX1RISVJEU19QSSIsImxvZzEwIiwic2lnbiIsImFsbW9zdEVxdWFscyIsImVwc2lsb24iLCJhYnMiLCJuaWNlTnVtIiwicmFuZ2UiLCJyb3VuZGVkUmFuZ2UiLCJyb3VuZCIsIm5pY2VSYW5nZSIsInBvdyIsImZsb29yIiwiZnJhY3Rpb24iLCJuaWNlRnJhY3Rpb24iLCJfZmFjdG9yaXplIiwicmVzdWx0Iiwic3FydCIsInNvcnQiLCJwb3AiLCJpc05vblByaW1pdGl2ZSIsIm4iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsImlzTnVtYmVyIiwiaXNOYU4iLCJhbG1vc3RXaG9sZSIsInJvdW5kZWQiLCJfc2V0TWluQW5kTWF4QnlLZXkiLCJhcnJheSIsInByb3BlcnR5IiwibWluIiwibWF4IiwidG9SYWRpYW5zIiwiZGVncmVlcyIsInRvRGVncmVlcyIsInJhZGlhbnMiLCJfZGVjaW1hbFBsYWNlcyIsImlzRmluaXRlTnVtYmVyIiwicCIsImdldEFuZ2xlRnJvbVBvaW50IiwiY2VudHJlUG9pbnQiLCJhbmdsZVBvaW50IiwiZGlzdGFuY2VGcm9tWENlbnRlciIsImRpc3RhbmNlRnJvbVlDZW50ZXIiLCJyYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCJhbmdsZSIsImF0YW4yIiwiZGlzdGFuY2UiLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJwdDEiLCJwdDIiLCJfYW5nbGVEaWZmIiwiX25vcm1hbGl6ZUFuZ2xlIiwiX2FuZ2xlQmV0d2VlbiIsInN0YXJ0IiwiZW5kIiwic2FtZUFuZ2xlSXNGdWxsQ2lyY2xlIiwicyIsImFuZ2xlVG9TdGFydCIsImFuZ2xlVG9FbmQiLCJzdGFydFRvQW5nbGUiLCJlbmRUb0FuZ2xlIiwiX2xpbWl0VmFsdWUiLCJfaW50MTZSYW5nZSIsIl9pc0JldHdlZW4iLCJfbG9va3VwIiwidGFibGUiLCJjbXAiLCJoaSIsImxvIiwibWlkIiwiX2xvb2t1cEJ5S2V5IiwibGFzdCIsInRpIiwiX3Jsb29rdXBCeUtleSIsIl9maWx0ZXJCZXR3ZWVuIiwidmFsdWVzIiwiYXJyYXlFdmVudHMiLCJsaXN0ZW5BcnJheUV2ZW50cyIsImxpc3RlbmVyIiwiX2NoYXJ0anMiLCJsaXN0ZW5lcnMiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJmb3JFYWNoIiwibWV0aG9kIiwiYmFzZSIsInJlcyIsIm9iamVjdCIsInVubGlzdGVuQXJyYXlFdmVudHMiLCJzdHViIiwic3BsaWNlIiwiX2FycmF5VW5pcXVlIiwiaXRlbXMiLCJzZXQiLCJTZXQiLCJmcm9tIiwiZm9udFN0cmluZyIsInBpeGVsU2l6ZSIsImZvbnRTdHlsZSIsImZvbnRGYW1pbHkiLCJyZXF1ZXN0QW5pbUZyYW1lIiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGhyb3R0bGVkIiwiYXJnc1RvVXNlIiwidGlja2luZyIsImRlYm91bmNlIiwiZGVsYXkiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIl90b0xlZnRSaWdodENlbnRlciIsImFsaWduIiwiX2FsaWduU3RhcnRFbmQiLCJfdGV4dFgiLCJsZWZ0IiwicmlnaHQiLCJydGwiLCJjaGVjayIsIl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIiwibWV0YSIsInBvaW50cyIsImFuaW1hdGlvbnNEaXNhYmxlZCIsInBvaW50Q291bnQiLCJjb3VudCIsIl9zb3J0ZWQiLCJpU2NhbGUiLCJ2U2NhbGUiLCJfcGFyc2VkIiwic3BhbkdhcHMiLCJkYXRhc2V0IiwiYXhpcyIsIm1pbkRlZmluZWQiLCJtYXhEZWZpbmVkIiwiZ2V0VXNlckJvdW5kcyIsImdldFBpeGVsRm9yVmFsdWUiLCJkaXN0YW5jZVRvRGVmaW5lZExvIiwiZmluZEluZGV4IiwicG9pbnQiLCJkaXN0YW5jZVRvRGVmaW5lZEhpIiwiX3NjYWxlUmFuZ2VzQ2hhbmdlZCIsInhTY2FsZSIsInlTY2FsZSIsIl9zY2FsZVJhbmdlcyIsIm5ld1JhbmdlcyIsInhtaW4iLCJ4bWF4IiwieW1pbiIsInltYXgiLCJjaGFuZ2VkIiwiYXNzaWduIiwiYXRFZGdlIiwidCIsImVsYXN0aWNJbiIsInNpbiIsImVsYXN0aWNPdXQiLCJlZmZlY3RzIiwibGluZWFyIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJjb3MiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJlYXNlT3V0RWxhc3RpYyIsImVhc2VJbk91dEVsYXN0aWMiLCJlYXNlSW5CYWNrIiwiZWFzZU91dEJhY2siLCJlYXNlSW5PdXRCYWNrIiwiZWFzZUluQm91bmNlIiwiZWFzZU91dEJvdW5jZSIsIm0iLCJkIiwiZWFzZUluT3V0Qm91bmNlIiwiaXNQYXR0ZXJuT3JHcmFkaWVudCIsImNvbG9yIiwiQ29sb3IiLCJnZXRIb3ZlckNvbG9yIiwic2F0dXJhdGUiLCJkYXJrZW4iLCJoZXhTdHJpbmciLCJudW1iZXJzIiwiY29sb3JzIiwiYXBwbHlBbmltYXRpb25zRGVmYXVsdHMiLCJkZWZhdWx0cyIsImR1cmF0aW9uIiwiZWFzaW5nIiwibG9vcCIsInRvIiwiZGVzY3JpYmUiLCJfZmFsbGJhY2siLCJfaW5kZXhhYmxlIiwiX3NjcmlwdGFibGUiLCJuYW1lIiwicHJvcGVydGllcyIsImFjdGl2ZSIsImFuaW1hdGlvbiIsInJlc2l6ZSIsInNob3ciLCJhbmltYXRpb25zIiwidmlzaWJsZSIsImhpZGUiLCJhcHBseUxheW91dHNEZWZhdWx0cyIsImF1dG9QYWRkaW5nIiwicGFkZGluZyIsInRvcCIsImJvdHRvbSIsImludGxDYWNoZSIsIk1hcCIsImdldE51bWJlckZvcm1hdCIsImxvY2FsZSIsImNhY2hlS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImZvcm1hdHRlciIsImdldCIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJmb3JtYXROdW1iZXIiLCJudW0iLCJmb3JtYXQiLCJmb3JtYXR0ZXJzIiwibnVtZXJpYyIsInRpY2tWYWx1ZSIsInRpY2tzIiwiY2hhcnQiLCJub3RhdGlvbiIsImRlbHRhIiwibWF4VGljayIsImNhbGN1bGF0ZURlbHRhIiwibG9nRGVsdGEiLCJudW1EZWNpbWFsIiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwibG9nYXJpdGhtaWMiLCJyZW1haW4iLCJzaWduaWZpY2FuZCIsImluY2x1ZGVzIiwiVGlja3MiLCJhcHBseVNjYWxlRGVmYXVsdHMiLCJkaXNwbGF5Iiwib2Zmc2V0IiwiYmVnaW5BdFplcm8iLCJib3VuZHMiLCJjbGlwIiwiZ3JhY2UiLCJncmlkIiwibGluZVdpZHRoIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd1RpY2tzIiwidGlja0xlbmd0aCIsInRpY2tXaWR0aCIsIl9jdHgiLCJ0aWNrQ29sb3IiLCJib3JkZXIiLCJkYXNoIiwiZGFzaE9mZnNldCIsIndpZHRoIiwidGl0bGUiLCJ0ZXh0IiwibWluUm90YXRpb24iLCJtYXhSb3RhdGlvbiIsIm1pcnJvciIsInRleHRTdHJva2VXaWR0aCIsInRleHRTdHJva2VDb2xvciIsImF1dG9Ta2lwIiwiYXV0b1NraXBQYWRkaW5nIiwibGFiZWxPZmZzZXQiLCJtaW5vciIsIm1ham9yIiwiY3Jvc3NBbGlnbiIsInNob3dMYWJlbEJhY2tkcm9wIiwiYmFja2Ryb3BDb2xvciIsImJhY2tkcm9wUGFkZGluZyIsInJvdXRlIiwic3RhcnRzV2l0aCIsIm92ZXJyaWRlcyIsImRlc2NyaXB0b3JzIiwiZ2V0U2NvcGUiLCJub2RlIiwicm9vdCIsIkRlZmF1bHRzIiwiY29uc3RydWN0b3IiLCJfZGVzY3JpcHRvcnMiLCJfYXBwbGllcnMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImRhdGFzZXRzIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNvbnRleHQiLCJwbGF0Zm9ybSIsImdldERldmljZVBpeGVsUmF0aW8iLCJlbGVtZW50cyIsImV2ZW50cyIsImZvbnQiLCJmYW1pbHkiLCJzdHlsZSIsImxpbmVIZWlnaHQiLCJ3ZWlnaHQiLCJob3ZlciIsImhvdmVyQmFja2dyb3VuZENvbG9yIiwiY3R4IiwiaG92ZXJCb3JkZXJDb2xvciIsImhvdmVyQ29sb3IiLCJpbmRleEF4aXMiLCJpbnRlcmFjdGlvbiIsIm1vZGUiLCJpbnRlcnNlY3QiLCJpbmNsdWRlSW52aXNpYmxlIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsIm9uSG92ZXIiLCJvbkNsaWNrIiwicGFyc2luZyIsInBsdWdpbnMiLCJyZXNwb25zaXZlIiwic2NhbGUiLCJzY2FsZXMiLCJzaG93TGluZSIsImRyYXdBY3RpdmVFbGVtZW50c09uVG9wIiwib3ZlcnJpZGUiLCJ0YXJnZXRTY29wZSIsInRhcmdldE5hbWUiLCJzY29wZU9iamVjdCIsInRhcmdldFNjb3BlT2JqZWN0IiwicHJpdmF0ZU5hbWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwid3JpdGFibGUiLCJsb2NhbCIsImFwcGxpZXJzIiwidG9Gb250U3RyaW5nIiwiX21lYXN1cmVUZXh0IiwiZGF0YSIsImdjIiwibG9uZ2VzdCIsInN0cmluZyIsInRleHRXaWR0aCIsIm1lYXN1cmVUZXh0IiwiX2xvbmdlc3RUZXh0IiwiYXJyYXlPZlRoaW5ncyIsImNhY2hlIiwiZ2FyYmFnZUNvbGxlY3QiLCJzYXZlIiwiaiIsImpsZW4iLCJ0aGluZyIsIm5lc3RlZFRoaW5nIiwicmVzdG9yZSIsImdjTGVuIiwiX2FsaWduUGl4ZWwiLCJwaXhlbCIsImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwiaGFsZldpZHRoIiwiY2xlYXJDYW52YXMiLCJjYW52YXMiLCJnZXRDb250ZXh0IiwicmVzZXRUcmFuc2Zvcm0iLCJjbGVhclJlY3QiLCJoZWlnaHQiLCJkcmF3UG9pbnQiLCJkcmF3UG9pbnRMZWdlbmQiLCJ3IiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXJSYWRpdXMiLCJ4T2Zmc2V0VyIsInlPZmZzZXRXIiwicG9pbnRTdHlsZSIsInJvdGF0aW9uIiwicmFkaXVzIiwicmFkIiwidHJhbnNsYXRlIiwicm90YXRlIiwiZHJhd0ltYWdlIiwiYmVnaW5QYXRoIiwiZWxsaXBzZSIsImFyYyIsImNsb3NlUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsIlNRUlQxXzIiLCJyZWN0IiwiZmlsbCIsImJvcmRlcldpZHRoIiwic3Ryb2tlIiwiX2lzUG9pbnRJbkFyZWEiLCJhcmVhIiwibWFyZ2luIiwiY2xpcEFyZWEiLCJ1bmNsaXBBcmVhIiwiX3N0ZXBwZWRMaW5lVG8iLCJmbGlwIiwibWlkcG9pbnQiLCJfYmV6aWVyQ3VydmVUbyIsImJlemllckN1cnZlVG8iLCJjcDF4IiwiY3AyeCIsImNwMXkiLCJjcDJ5Iiwic2V0UmVuZGVyT3B0cyIsIm9wdHMiLCJ0cmFuc2xhdGlvbiIsImZpbGxTdHlsZSIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImRlY29yYXRlVGV4dCIsImxpbmUiLCJzdHJpa2V0aHJvdWdoIiwidW5kZXJsaW5lIiwibWV0cmljcyIsImFjdHVhbEJvdW5kaW5nQm94TGVmdCIsImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsImFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCIsInlEZWNvcmF0aW9uIiwic3Ryb2tlU3R5bGUiLCJkZWNvcmF0aW9uV2lkdGgiLCJkcmF3QmFja2Ryb3AiLCJvbGRDb2xvciIsImZpbGxSZWN0IiwicmVuZGVyVGV4dCIsImxpbmVzIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VDb2xvciIsImJhY2tkcm9wIiwic3Ryb2tlVGV4dCIsIm1heFdpZHRoIiwiZmlsbFRleHQiLCJhZGRSb3VuZGVkUmVjdFBhdGgiLCJoIiwidG9wTGVmdCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsInRvcFJpZ2h0IiwiTElORV9IRUlHSFQiLCJGT05UX1NUWUxFIiwidG9MaW5lSGVpZ2h0IiwibWF0Y2hlcyIsIm1hdGNoIiwibnVtYmVyT3JaZXJvIiwiX3JlYWRWYWx1ZVRvUHJvcHMiLCJwcm9wcyIsInJldCIsIm9ialByb3BzIiwicmVhZCIsInByb3AiLCJ0b1RSQkwiLCJ0b1RSQkxDb3JuZXJzIiwidG9QYWRkaW5nIiwidG9Gb250IiwiZmFsbGJhY2siLCJwYXJzZUludCIsInJlc29sdmUiLCJpbnB1dHMiLCJpbmZvIiwiY2FjaGVhYmxlIiwiX2FkZEdyYWNlIiwibWlubWF4IiwiY2hhbmdlIiwia2VlcFplcm8iLCJhZGQiLCJjcmVhdGVDb250ZXh0IiwicGFyZW50Q29udGV4dCIsIl9jcmVhdGVSZXNvbHZlciIsInNjb3BlcyIsInByZWZpeGVzIiwicm9vdFNjb3BlcyIsImdldFRhcmdldCIsImZpbmFsUm9vdFNjb3BlcyIsIl9yZXNvbHZlIiwidG9TdHJpbmdUYWciLCJfY2FjaGVhYmxlIiwiX3Njb3BlcyIsIl9yb290U2NvcGVzIiwiX2dldFRhcmdldCIsIlByb3h5IiwiZGVsZXRlUHJvcGVydHkiLCJfa2V5cyIsIl9jYWNoZWQiLCJfcmVzb2x2ZVdpdGhQcmVmaXhlcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIlJlZmxlY3QiLCJnZXRQcm90b3R5cGVPZiIsImdldEtleXNGcm9tQWxsU2NvcGVzIiwib3duS2V5cyIsInN0b3JhZ2UiLCJfc3RvcmFnZSIsIl9hdHRhY2hDb250ZXh0IiwicHJveHkiLCJzdWJQcm94eSIsImRlc2NyaXB0b3JEZWZhdWx0cyIsIl9wcm94eSIsIl9jb250ZXh0IiwiX3N1YlByb3h5IiwiX3N0YWNrIiwic2V0Q29udGV4dCIsInJlY2VpdmVyIiwiX3Jlc29sdmVXaXRoQ29udGV4dCIsImFsbEtleXMiLCJzY3JpcHRhYmxlIiwiaW5kZXhhYmxlIiwiX2FsbEtleXMiLCJpc1NjcmlwdGFibGUiLCJpc0luZGV4YWJsZSIsInJlYWRLZXkiLCJwcmVmaXgiLCJuZWVkc1N1YlJlc29sdmVyIiwiX3Jlc29sdmVTY3JpcHRhYmxlIiwiX3Jlc29sdmVBcnJheSIsImdldFZhbHVlIiwiRXJyb3IiLCJqb2luIiwiZGVsZXRlIiwiY3JlYXRlU3ViUmVzb2x2ZXIiLCJhcnIiLCJmaWx0ZXIiLCJyZXNvbHZlRmFsbGJhY2siLCJwYXJlbnQiLCJhZGRTY29wZXMiLCJwYXJlbnRTY29wZXMiLCJwYXJlbnRGYWxsYmFjayIsImFsbFNjb3BlcyIsImFkZFNjb3Blc0Zyb21LZXkiLCJzdWJHZXRUYXJnZXQiLCJyZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMiLCJfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUiLCJfcGFyc2luZyIsInBhcnNlZCIsInIiLCJwYXJzZSIsIkVQU0lMT04iLCJnZXRQb2ludCIsInNraXAiLCJnZXRWYWx1ZUF4aXMiLCJzcGxpbmVDdXJ2ZSIsImZpcnN0UG9pbnQiLCJtaWRkbGVQb2ludCIsImFmdGVyUG9pbnQiLCJuZXh0IiwiZDAxIiwiZDEyIiwiczAxIiwiczEyIiwiZmEiLCJmYiIsIm1vbm90b25lQWRqdXN0IiwiZGVsdGFLIiwibUsiLCJwb2ludHNMZW4iLCJhbHBoYUsiLCJiZXRhSyIsInRhdUsiLCJzcXVhcmVkTWFnbml0dWRlIiwicG9pbnRDdXJyZW50IiwicG9pbnRBZnRlciIsIm1vbm90b25lQ29tcHV0ZSIsInZhbHVlQXhpcyIsInBvaW50QmVmb3JlIiwiaVBpeGVsIiwidlBpeGVsIiwic3BsaW5lQ3VydmVNb25vdG9uZSIsInNsb3BlRGVsdGEiLCJjYXBDb250cm9sUG9pbnQiLCJwdCIsImNhcEJlemllclBvaW50cyIsImluQXJlYSIsImluQXJlYVByZXYiLCJpbkFyZWFOZXh0IiwiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCJjb250cm9sUG9pbnRzIiwiY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSIsInByZXYiLCJ0ZW5zaW9uIiwiX2lzRG9tU3VwcG9ydGVkIiwiZG9jdW1lbnQiLCJfZ2V0UGFyZW50Tm9kZSIsImRvbU5vZGUiLCJwYXJlbnROb2RlIiwiaG9zdCIsInBhcnNlTWF4U3R5bGUiLCJzdHlsZVZhbHVlIiwicGFyZW50UHJvcGVydHkiLCJ2YWx1ZUluUGl4ZWxzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImVsZW1lbnQiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJnZXRTdHlsZSIsImVsIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInBvc2l0aW9ucyIsImdldFBvc2l0aW9uZWRTdHlsZSIsInN0eWxlcyIsInN1ZmZpeCIsInBvcyIsInVzZU9mZnNldFBvcyIsInNoYWRvd1Jvb3QiLCJnZXRDYW52YXNQb3NpdGlvbiIsInRvdWNoZXMiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJjbGllbnRZIiwiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsImV2ZW50IiwiYm9yZGVyQm94IiwiYm94U2l6aW5nIiwicGFkZGluZ3MiLCJib3JkZXJzIiwiZ2V0Q29udGFpbmVyU2l6ZSIsIm1heEhlaWdodCIsImNvbnRhaW5lciIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiY29udGFpbmVyU3R5bGUiLCJjb250YWluZXJCb3JkZXIiLCJjb250YWluZXJQYWRkaW5nIiwicm91bmQxIiwiZ2V0TWF4aW11bVNpemUiLCJiYldpZHRoIiwiYmJIZWlnaHQiLCJhc3BlY3RSYXRpbyIsIm1hcmdpbnMiLCJjb250YWluZXJTaXplIiwibWFpbnRhaW5IZWlnaHQiLCJyZXRpbmFTY2FsZSIsImZvcmNlUmF0aW8iLCJmb3JjZVN0eWxlIiwicGl4ZWxSYXRpbyIsImRldmljZUhlaWdodCIsImRldmljZVdpZHRoIiwic2V0VHJhbnNmb3JtIiwic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsInBhc3NpdmVTdXBwb3J0ZWQiLCJwYXNzaXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWFkVXNlZFNpemUiLCJfcG9pbnRJbkxpbmUiLCJwMSIsInAyIiwiX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIiwiX2JlemllckludGVycG9sYXRpb24iLCJjcDEiLCJjcDIiLCJjIiwiZ2V0UmlnaHRUb0xlZnRBZGFwdGVyIiwicmVjdFgiLCJzZXRXaWR0aCIsInhQbHVzIiwibGVmdEZvckx0ciIsIml0ZW1XaWR0aCIsImdldExlZnRUb1JpZ2h0QWRhcHRlciIsIl9pdGVtV2lkdGgiLCJnZXRSdGxBZGFwdGVyIiwib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwib3JpZ2luYWwiLCJnZXRQcm9wZXJ0eVByaW9yaXR5Iiwic2V0UHJvcGVydHkiLCJwcmV2VGV4dERpcmVjdGlvbiIsInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwicHJvcGVydHlGbiIsImJldHdlZW4iLCJjb21wYXJlIiwibm9ybWFsaXplIiwibm9ybWFsaXplU2VnbWVudCIsImdldFNlZ21lbnQiLCJzZWdtZW50Iiwic3RhcnRCb3VuZCIsImVuZEJvdW5kIiwiX2JvdW5kU2VnbWVudCIsImluc2lkZSIsInN1YlN0YXJ0IiwicHJldlZhbHVlIiwic3RhcnRJc0JlZm9yZSIsImVuZElzQmVmb3JlIiwic2hvdWxkU3RhcnQiLCJzaG91bGRTdG9wIiwiX2JvdW5kU2VnbWVudHMiLCJzZWdtZW50cyIsInN1YiIsImZpbmRTdGFydEFuZEVuZCIsInNvbGlkU2VnbWVudHMiLCJjdXIiLCJzdG9wIiwiX2NvbXB1dGVTZWdtZW50cyIsInNlZ21lbnRPcHRpb25zIiwiX2xvb3AiLCJzcGxpdEJ5U3R5bGVzIiwiY29tcGxldGVMb29wIiwiX2Z1bGxMb29wIiwiZG9TcGxpdEJ5U3R5bGVzIiwiY2hhcnRDb250ZXh0IiwiX2NoYXJ0IiwiYmFzZVN0eWxlIiwicmVhZFN0eWxlIiwiX2RhdGFzZXRJbmRleCIsInByZXZTdHlsZSIsImFkZFN0eWxlIiwibCIsInN0IiwiZGlyIiwicDAiLCJwMERhdGFJbmRleCIsInAxRGF0YUluZGV4Iiwic3R5bGVDaGFuZ2VkIiwiYm9yZGVyQ2FwU3R5bGUiLCJib3JkZXJEYXNoIiwiYm9yZGVyRGFzaE9mZnNldCIsImJvcmRlckpvaW5TdHlsZSIsInJlcGxhY2VyIiwiZ2V0U2l6ZUZvckFyZWEiLCJjaGFydEFyZWEiLCJmaWVsZCIsImdldERhdGFzZXRBcmVhIiwiZ2V0RGF0YXNldENsaXBBcmVhIiwiX2NsaXAiLCJkaXNhYmxlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/dist/chunks/helpers.dataset.js\n");

/***/ })

};
;